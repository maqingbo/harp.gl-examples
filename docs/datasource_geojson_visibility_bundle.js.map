{"version":3,"sources":["webpack://@here/harp-examples/../harp-vectortile-datasource/lib/adapters/omv/proto/vector_tile.js","webpack://@here/harp-examples/./src/datasource_geojson_visibility.ts","webpack://@here/harp-examples/../harp-geometry/lib/ClipLineString.ts","webpack://@here/harp-examples/../harp-geometry/lib/ClipPolygon.ts","webpack://@here/harp-examples/../harp-mapview-decoder/index-worker.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/GeoJsonTiler.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/ThemedTileDecoder.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/TileDecoderService.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/TilerService.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/WorkerService.ts","webpack://@here/harp-examples/../harp-mapview-decoder/lib/WorkerServiceManager.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/index-worker.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/DataAdapter.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/DecodeInfo.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/GeoJsonTilerService.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/OmvPoliticalViewFeatureModifier.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/OmvUtils.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/Ring.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/StyleSetDataFilter.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/VectorTileDataEmitter.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/VectorTileDecoder.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/adapters/geojson-vt/GeoJsonVtDataAdapter.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/adapters/geojson/GeoJsonDataAdapter.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/adapters/omv/OmvData.ts","webpack://@here/harp-examples/../harp-vectortile-datasource/lib/adapters/omv/OmvDataAdapter.ts","webpack://@here/harp-examples/external \"THREE\"","webpack://@here/harp-examples/webpack/bootstrap","webpack://@here/harp-examples/webpack/runtime/define property getters","webpack://@here/harp-examples/webpack/runtime/global","webpack://@here/harp-examples/webpack/runtime/hasOwnProperty shorthand","webpack://@here/harp-examples/webpack/runtime/make namespace object","webpack://@here/harp-examples/webpack/runtime/jsonp chunk loading","webpack://@here/harp-examples/webpack/startup"],"names":[],"mappings":";;;;;;;;;;AAAA;AACa;;AAEb,gBAAgB,mBAAO,CAAC,oEAAoB;;AAE5C;AACA;;AAEA;AACA,0EAA0E;;AAE1E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,uCAAuC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD,2BAA2B,OAAO;AAClC,6BAA6B,mBAAmB;AAChD,4BAA4B,MAAM;AAClC,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD,6BAA6B,mBAAmB;AAChD,4BAA4B,MAAM;AAClC,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C,2BAA2B,6BAA6B;AACxD,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C,kCAAkC,YAAY;AAC9C,kCAAkC,YAAY;AAC9C,kCAAkC,iBAAiB;AACnD,kCAAkC,iBAAiB;AACnD,kCAAkC,iBAAiB;AACnD,kCAAkC,aAAa;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,+BAA+B,OAAO;AACtC,iCAAiC,yBAAyB;AAC1D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,iCAAiC,yBAAyB;AAC1D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD,+BAA+B,6BAA6B;AAC5D,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,kCAAkC,oBAAoB;AACtD,kCAAkC,iCAAiC;AACnE,kCAAkC,oBAAoB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,+BAA+B,OAAO;AACtC,iCAAiC,2BAA2B;AAC5D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,iCAAiC,2BAA2B;AAC5D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D,+BAA+B,6BAA6B;AAC5D,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC,kCAAkC,OAAO;AACzC,kCAAkC,yCAAyC;AAC3E,kCAAkC,oBAAoB;AACtD,kCAAkC,uCAAuC;AACzE,kCAAkC,YAAY;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,+BAA+B,OAAO;AACtC,iCAAiC,yBAAyB;AAC1D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,oBAAoB;AACzG;AACA,kFAAkF,oBAAoB;AACtG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D,iCAAiC,yBAAyB;AAC1D,gCAAgC,MAAM;AACtC,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AA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","file":"datasource_geojson_visibility_bundle.js","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.com = (function() {\n\n    /**\n     * Namespace com.\n     * @exports com\n     * @namespace\n     */\n    var com = {};\n\n    com.mapbox = (function() {\n\n        /**\n         * Namespace mapbox.\n         * @memberof com\n         * @namespace\n         */\n        var mapbox = {};\n\n        mapbox.pb = (function() {\n\n            /**\n             * Namespace pb.\n             * @memberof com.mapbox\n             * @namespace\n             */\n            var pb = {};\n\n            pb.Tile = (function() {\n\n                /**\n                 * Properties of a Tile.\n                 * @memberof com.mapbox.pb\n                 * @interface ITile\n                 * @property {Array.<com.mapbox.pb.Tile.ILayer>|null} [layers] Tile layers\n                 */\n\n                /**\n                 * Constructs a new Tile.\n                 * @memberof com.mapbox.pb\n                 * @classdesc Represents a Tile.\n                 * @implements ITile\n                 * @constructor\n                 * @param {com.mapbox.pb.ITile=} [properties] Properties to set\n                 */\n                function Tile(properties) {\n                    this.layers = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Tile layers.\n                 * @member {Array.<com.mapbox.pb.Tile.ILayer>} layers\n                 * @memberof com.mapbox.pb.Tile\n                 * @instance\n                 */\n                Tile.prototype.layers = $util.emptyArray;\n\n                /**\n                 * Decodes a Tile message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Tile.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 3:\n                            if (!(message.layers && message.layers.length))\n                                message.layers = [];\n                            message.layers.push($root.com.mapbox.pb.Tile.Layer.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Tile message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Tile.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Creates a Tile message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {com.mapbox.pb.Tile} Tile\n                 */\n                Tile.fromObject = function fromObject(object) {\n                    if (object instanceof $root.com.mapbox.pb.Tile)\n                        return object;\n                    var message = new $root.com.mapbox.pb.Tile();\n                    if (object.layers) {\n                        if (!Array.isArray(object.layers))\n                            throw TypeError(\".com.mapbox.pb.Tile.layers: array expected\");\n                        message.layers = [];\n                        for (var i = 0; i < object.layers.length; ++i) {\n                            if (typeof object.layers[i] !== \"object\")\n                                throw TypeError(\".com.mapbox.pb.Tile.layers: object expected\");\n                            message.layers[i] = $root.com.mapbox.pb.Tile.Layer.fromObject(object.layers[i]);\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Creates a plain object from a Tile message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof com.mapbox.pb.Tile\n                 * @static\n                 * @param {com.mapbox.pb.Tile} message Tile\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                Tile.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.arrays || options.defaults)\n                        object.layers = [];\n                    if (message.layers && message.layers.length) {\n                        object.layers = [];\n                        for (var j = 0; j < message.layers.length; ++j)\n                            object.layers[j] = $root.com.mapbox.pb.Tile.Layer.toObject(message.layers[j], options);\n                    }\n                    return object;\n                };\n\n                /**\n                 * Converts this Tile to JSON.\n                 * @function toJSON\n                 * @memberof com.mapbox.pb.Tile\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                Tile.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n\n                /**\n                 * GeomType enum.\n                 * @name com.mapbox.pb.Tile.GeomType\n                 * @enum {number}\n                 * @property {number} UNKNOWN=0 UNKNOWN value\n                 * @property {number} POINT=1 POINT value\n                 * @property {number} LINESTRING=2 LINESTRING value\n                 * @property {number} POLYGON=3 POLYGON value\n                 */\n                Tile.GeomType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"UNKNOWN\"] = 0;\n                    values[valuesById[1] = \"POINT\"] = 1;\n                    values[valuesById[2] = \"LINESTRING\"] = 2;\n                    values[valuesById[3] = \"POLYGON\"] = 3;\n                    return values;\n                })();\n\n                Tile.Value = (function() {\n\n                    /**\n                     * Properties of a Value.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface IValue\n                     * @property {string|null} [stringValue] Value stringValue\n                     * @property {number|null} [floatValue] Value floatValue\n                     * @property {number|null} [doubleValue] Value doubleValue\n                     * @property {number|Long|null} [intValue] Value intValue\n                     * @property {number|Long|null} [uintValue] Value uintValue\n                     * @property {number|Long|null} [sintValue] Value sintValue\n                     * @property {boolean|null} [boolValue] Value boolValue\n                     */\n\n                    /**\n                     * Constructs a new Value.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Value.\n                     * @implements IValue\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.IValue=} [properties] Properties to set\n                     */\n                    function Value(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Value stringValue.\n                     * @member {string} stringValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.stringValue = \"\";\n\n                    /**\n                     * Value floatValue.\n                     * @member {number} floatValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.floatValue = 0;\n\n                    /**\n                     * Value doubleValue.\n                     * @member {number} doubleValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.doubleValue = 0;\n\n                    /**\n                     * Value intValue.\n                     * @member {number|Long} intValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.intValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                    /**\n                     * Value uintValue.\n                     * @member {number|Long} uintValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.uintValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                    /**\n                     * Value sintValue.\n                     * @member {number|Long} sintValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.sintValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                    /**\n                     * Value boolValue.\n                     * @member {boolean} boolValue\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     */\n                    Value.prototype.boolValue = false;\n\n                    /**\n                     * Decodes a Value message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Value.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Value();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.stringValue = reader.string();\n                                break;\n                            case 2:\n                                message.floatValue = reader.float();\n                                break;\n                            case 3:\n                                message.doubleValue = reader.double();\n                                break;\n                            case 4:\n                                message.intValue = reader.int64();\n                                break;\n                            case 5:\n                                message.uintValue = reader.uint64();\n                                break;\n                            case 6:\n                                message.sintValue = reader.sint64();\n                                break;\n                            case 7:\n                                message.boolValue = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Value message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Value.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Value message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Value} Value\n                     */\n                    Value.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Value)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Value();\n                        if (object.stringValue != null)\n                            message.stringValue = String(object.stringValue);\n                        if (object.floatValue != null)\n                            message.floatValue = Number(object.floatValue);\n                        if (object.doubleValue != null)\n                            message.doubleValue = Number(object.doubleValue);\n                        if (object.intValue != null)\n                            if ($util.Long)\n                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;\n                            else if (typeof object.intValue === \"string\")\n                                message.intValue = parseInt(object.intValue, 10);\n                            else if (typeof object.intValue === \"number\")\n                                message.intValue = object.intValue;\n                            else if (typeof object.intValue === \"object\")\n                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();\n                        if (object.uintValue != null)\n                            if ($util.Long)\n                                (message.uintValue = $util.Long.fromValue(object.uintValue)).unsigned = true;\n                            else if (typeof object.uintValue === \"string\")\n                                message.uintValue = parseInt(object.uintValue, 10);\n                            else if (typeof object.uintValue === \"number\")\n                                message.uintValue = object.uintValue;\n                            else if (typeof object.uintValue === \"object\")\n                                message.uintValue = new $util.LongBits(object.uintValue.low >>> 0, object.uintValue.high >>> 0).toNumber(true);\n                        if (object.sintValue != null)\n                            if ($util.Long)\n                                (message.sintValue = $util.Long.fromValue(object.sintValue)).unsigned = false;\n                            else if (typeof object.sintValue === \"string\")\n                                message.sintValue = parseInt(object.sintValue, 10);\n                            else if (typeof object.sintValue === \"number\")\n                                message.sintValue = object.sintValue;\n                            else if (typeof object.sintValue === \"object\")\n                                message.sintValue = new $util.LongBits(object.sintValue.low >>> 0, object.sintValue.high >>> 0).toNumber();\n                        if (object.boolValue != null)\n                            message.boolValue = Boolean(object.boolValue);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Value message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Value} message Value\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Value.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.stringValue = \"\";\n                            object.floatValue = 0;\n                            object.doubleValue = 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.intValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.intValue = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, true);\n                                object.uintValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.uintValue = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.sintValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.sintValue = options.longs === String ? \"0\" : 0;\n                            object.boolValue = false;\n                        }\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\"))\n                            object.stringValue = message.stringValue;\n                        if (message.floatValue != null && message.hasOwnProperty(\"floatValue\"))\n                            object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\"))\n                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\"))\n                            if (typeof message.intValue === \"number\")\n                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;\n                            else\n                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;\n                        if (message.uintValue != null && message.hasOwnProperty(\"uintValue\"))\n                            if (typeof message.uintValue === \"number\")\n                                object.uintValue = options.longs === String ? String(message.uintValue) : message.uintValue;\n                            else\n                                object.uintValue = options.longs === String ? $util.Long.prototype.toString.call(message.uintValue) : options.longs === Number ? new $util.LongBits(message.uintValue.low >>> 0, message.uintValue.high >>> 0).toNumber(true) : message.uintValue;\n                        if (message.sintValue != null && message.hasOwnProperty(\"sintValue\"))\n                            if (typeof message.sintValue === \"number\")\n                                object.sintValue = options.longs === String ? String(message.sintValue) : message.sintValue;\n                            else\n                                object.sintValue = options.longs === String ? $util.Long.prototype.toString.call(message.sintValue) : options.longs === Number ? new $util.LongBits(message.sintValue.low >>> 0, message.sintValue.high >>> 0).toNumber() : message.sintValue;\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\"))\n                            object.boolValue = message.boolValue;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Value to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Value\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Value.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Value;\n                })();\n\n                Tile.Feature = (function() {\n\n                    /**\n                     * Properties of a Feature.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface IFeature\n                     * @property {number|Long|null} [id] Feature id\n                     * @property {Array.<number>|null} [tags] Feature tags\n                     * @property {com.mapbox.pb.Tile.GeomType|null} [type] Feature type\n                     * @property {Array.<number>|null} [geometry] Feature geometry\n                     */\n\n                    /**\n                     * Constructs a new Feature.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Feature.\n                     * @implements IFeature\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.IFeature=} [properties] Properties to set\n                     */\n                    function Feature(properties) {\n                        this.tags = [];\n                        this.geometry = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Feature id.\n                     * @member {number|Long} id\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                    /**\n                     * Feature tags.\n                     * @member {Array.<number>} tags\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.tags = $util.emptyArray;\n\n                    /**\n                     * Feature type.\n                     * @member {com.mapbox.pb.Tile.GeomType} type\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.type = 0;\n\n                    /**\n                     * Feature geometry.\n                     * @member {Array.<number>} geometry\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     */\n                    Feature.prototype.geometry = $util.emptyArray;\n\n                    /**\n                     * Decodes a Feature message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Feature.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Feature();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.uint64();\n                                break;\n                            case 2:\n                                if (!(message.tags && message.tags.length))\n                                    message.tags = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.tags.push(reader.uint32());\n                                } else\n                                    message.tags.push(reader.uint32());\n                                break;\n                            case 3:\n                                message.type = reader.int32();\n                                break;\n                            case 4:\n                                if (!(message.geometry && message.geometry.length))\n                                    message.geometry = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.geometry.push(reader.uint32());\n                                } else\n                                    message.geometry.push(reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Feature message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Feature.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Feature message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Feature} Feature\n                     */\n                    Feature.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Feature)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Feature();\n                        if (object.id != null)\n                            if ($util.Long)\n                                (message.id = $util.Long.fromValue(object.id)).unsigned = true;\n                            else if (typeof object.id === \"string\")\n                                message.id = parseInt(object.id, 10);\n                            else if (typeof object.id === \"number\")\n                                message.id = object.id;\n                            else if (typeof object.id === \"object\")\n                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);\n                        if (object.tags) {\n                            if (!Array.isArray(object.tags))\n                                throw TypeError(\".com.mapbox.pb.Tile.Feature.tags: array expected\");\n                            message.tags = [];\n                            for (var i = 0; i < object.tags.length; ++i)\n                                message.tags[i] = object.tags[i] >>> 0;\n                        }\n                        switch (object.type) {\n                        case \"UNKNOWN\":\n                        case 0:\n                            message.type = 0;\n                            break;\n                        case \"POINT\":\n                        case 1:\n                            message.type = 1;\n                            break;\n                        case \"LINESTRING\":\n                        case 2:\n                            message.type = 2;\n                            break;\n                        case \"POLYGON\":\n                        case 3:\n                            message.type = 3;\n                            break;\n                        }\n                        if (object.geometry) {\n                            if (!Array.isArray(object.geometry))\n                                throw TypeError(\".com.mapbox.pb.Tile.Feature.geometry: array expected\");\n                            message.geometry = [];\n                            for (var i = 0; i < object.geometry.length; ++i)\n                                message.geometry[i] = object.geometry[i] >>> 0;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Feature message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Feature} message Feature\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Feature.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.tags = [];\n                            object.geometry = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, true);\n                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.id = options.longs === String ? \"0\" : 0;\n                            object.type = options.enums === String ? \"UNKNOWN\" : 0;\n                        }\n                        if (message.id != null && message.hasOwnProperty(\"id\"))\n                            if (typeof message.id === \"number\")\n                                object.id = options.longs === String ? String(message.id) : message.id;\n                            else\n                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;\n                        if (message.tags && message.tags.length) {\n                            object.tags = [];\n                            for (var j = 0; j < message.tags.length; ++j)\n                                object.tags[j] = message.tags[j];\n                        }\n                        if (message.type != null && message.hasOwnProperty(\"type\"))\n                            object.type = options.enums === String ? $root.com.mapbox.pb.Tile.GeomType[message.type] : message.type;\n                        if (message.geometry && message.geometry.length) {\n                            object.geometry = [];\n                            for (var j = 0; j < message.geometry.length; ++j)\n                                object.geometry[j] = message.geometry[j];\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Feature to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Feature\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Feature.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Feature;\n                })();\n\n                Tile.Layer = (function() {\n\n                    /**\n                     * Properties of a Layer.\n                     * @memberof com.mapbox.pb.Tile\n                     * @interface ILayer\n                     * @property {number} version Layer version\n                     * @property {string} name Layer name\n                     * @property {Array.<com.mapbox.pb.Tile.IFeature>|null} [features] Layer features\n                     * @property {Array.<string>|null} [keys] Layer keys\n                     * @property {Array.<com.mapbox.pb.Tile.IValue>|null} [values] Layer values\n                     * @property {number|null} [extent] Layer extent\n                     */\n\n                    /**\n                     * Constructs a new Layer.\n                     * @memberof com.mapbox.pb.Tile\n                     * @classdesc Represents a Layer.\n                     * @implements ILayer\n                     * @constructor\n                     * @param {com.mapbox.pb.Tile.ILayer=} [properties] Properties to set\n                     */\n                    function Layer(properties) {\n                        this.features = [];\n                        this.keys = [];\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Layer version.\n                     * @member {number} version\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.version = 1;\n\n                    /**\n                     * Layer name.\n                     * @member {string} name\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.name = \"\";\n\n                    /**\n                     * Layer features.\n                     * @member {Array.<com.mapbox.pb.Tile.IFeature>} features\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.features = $util.emptyArray;\n\n                    /**\n                     * Layer keys.\n                     * @member {Array.<string>} keys\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.keys = $util.emptyArray;\n\n                    /**\n                     * Layer values.\n                     * @member {Array.<com.mapbox.pb.Tile.IValue>} values\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Layer extent.\n                     * @member {number} extent\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     */\n                    Layer.prototype.extent = 4096;\n\n                    /**\n                     * Decodes a Layer message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Layer.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.com.mapbox.pb.Tile.Layer();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 15:\n                                message.version = reader.uint32();\n                                break;\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                if (!(message.features && message.features.length))\n                                    message.features = [];\n                                message.features.push($root.com.mapbox.pb.Tile.Feature.decode(reader, reader.uint32()));\n                                break;\n                            case 3:\n                                if (!(message.keys && message.keys.length))\n                                    message.keys = [];\n                                message.keys.push(reader.string());\n                                break;\n                            case 4:\n                                if (!(message.values && message.values.length))\n                                    message.values = [];\n                                message.values.push($root.com.mapbox.pb.Tile.Value.decode(reader, reader.uint32()));\n                                break;\n                            case 5:\n                                message.extent = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        if (!message.hasOwnProperty(\"version\"))\n                            throw $util.ProtocolError(\"missing required 'version'\", { instance: message });\n                        if (!message.hasOwnProperty(\"name\"))\n                            throw $util.ProtocolError(\"missing required 'name'\", { instance: message });\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Layer message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Layer.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Creates a Layer message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {com.mapbox.pb.Tile.Layer} Layer\n                     */\n                    Layer.fromObject = function fromObject(object) {\n                        if (object instanceof $root.com.mapbox.pb.Tile.Layer)\n                            return object;\n                        var message = new $root.com.mapbox.pb.Tile.Layer();\n                        if (object.version != null)\n                            message.version = object.version >>> 0;\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.features) {\n                            if (!Array.isArray(object.features))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.features: array expected\");\n                            message.features = [];\n                            for (var i = 0; i < object.features.length; ++i) {\n                                if (typeof object.features[i] !== \"object\")\n                                    throw TypeError(\".com.mapbox.pb.Tile.Layer.features: object expected\");\n                                message.features[i] = $root.com.mapbox.pb.Tile.Feature.fromObject(object.features[i]);\n                            }\n                        }\n                        if (object.keys) {\n                            if (!Array.isArray(object.keys))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.keys: array expected\");\n                            message.keys = [];\n                            for (var i = 0; i < object.keys.length; ++i)\n                                message.keys[i] = String(object.keys[i]);\n                        }\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".com.mapbox.pb.Tile.Layer.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".com.mapbox.pb.Tile.Layer.values: object expected\");\n                                message.values[i] = $root.com.mapbox.pb.Tile.Value.fromObject(object.values[i]);\n                            }\n                        }\n                        if (object.extent != null)\n                            message.extent = object.extent >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Layer message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @static\n                     * @param {com.mapbox.pb.Tile.Layer} message Layer\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Layer.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.features = [];\n                            object.keys = [];\n                            object.values = [];\n                        }\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.extent = 4096;\n                            object.version = 1;\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.features && message.features.length) {\n                            object.features = [];\n                            for (var j = 0; j < message.features.length; ++j)\n                                object.features[j] = $root.com.mapbox.pb.Tile.Feature.toObject(message.features[j], options);\n                        }\n                        if (message.keys && message.keys.length) {\n                            object.keys = [];\n                            for (var j = 0; j < message.keys.length; ++j)\n                                object.keys[j] = message.keys[j];\n                        }\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.com.mapbox.pb.Tile.Value.toObject(message.values[j], options);\n                        }\n                        if (message.extent != null && message.hasOwnProperty(\"extent\"))\n                            object.extent = message.extent;\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            object.version = message.version;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Layer to JSON.\n                     * @function toJSON\n                     * @memberof com.mapbox.pb.Tile.Layer\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Layer.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    return Layer;\n                })();\n\n                return Tile;\n            })();\n\n            return pb;\n        })();\n\n        return mapbox;\n    })();\n\n    return com;\n})();\n\nmodule.exports = $root;\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FeatureCollection } from \"@here/harp-datasource-protocol\";\nimport { GeoPointLike } from \"@here/harp-geoutils\";\nimport { MapControls, MapControlsUI } from \"@here/harp-map-controls\";\nimport { CopyrightElementHandler, MapView } from \"@here/harp-mapview\";\nimport { GeoJsonTiler } from \"@here/harp-mapview-decoder/lib/GeoJsonTiler\";\nimport { GeoJsonDataProvider, VectorTileDataSource } from \"@here/harp-vectortile-datasource\";\nimport { VectorTileDecoder } from \"@here/harp-vectortile-datasource/index-worker\";\nimport * as turf from \"@turf/turf\";\n\nimport { apikey } from \"../config\";\n\nexport namespace GeoJsonVisibilityExample {\n    async function main(id: string): Promise<MapView> {\n        const canvas = document.getElementById(id) as HTMLCanvasElement;\n        const NY = [-74.01, 40.707];\n        const mapView = new MapView({\n            canvas,\n            theme: \"resources/berlin_tilezen_base.json\",\n            target: NY as GeoPointLike,\n            zoomLevel: 15.1\n        });\n\n        CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n\n        const mapControls = new MapControls(mapView);\n        mapControls.maxTiltAngle = 50;\n\n        const ui = new MapControlsUI(mapControls, { zoomLevel: \"input\" });\n        canvas.parentElement!.appendChild(ui.domElement);\n\n        mapView.resize(window.innerWidth, window.innerHeight);\n\n        window.addEventListener(\"resize\", () => {\n            mapView.resize(window.innerWidth, window.innerHeight);\n        });\n\n        const omvDataSource = new VectorTileDataSource({\n            baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n            authenticationCode: apikey\n        });\n\n        mapView.addDataSource(omvDataSource);\n\n        omvDataSource.dataSourceOrder = 0;\n\n        const circle = turf.circle(NY, 1000, {\n            units: \"meters\"\n        });\n\n        const points = turf.randomPoint(100, {\n            bbox: turf.bbox(circle)\n        });\n\n        points.features = points.features.filter(\n            feature => turf.distance(NY, feature.geometry!.coordinates, { units: \"meters\" }) < 1000\n        );\n\n        const dataProvider = new GeoJsonDataProvider(\n            \"geojson\",\n            turf.featureCollection([circle, ...points.features]) as FeatureCollection,\n            { tiler: new GeoJsonTiler() }\n        );\n\n        const featuresDataSource = new VectorTileDataSource({\n            decoder: new VectorTileDecoder(),\n            styleSetName: \"geojson\",\n            dataProvider,\n            addGroundPlane: false\n        });\n\n        featuresDataSource.dataSourceOrder = 1;\n\n        await mapView.addDataSource(featuresDataSource);\n\n        await featuresDataSource.setTheme({\n            styles: [\n                {\n                    styleSet: \"geojson\",\n                    when: [\"==\", [\"geometry-type\"], \"Polygon\"],\n                    technique: \"fill\",\n                    color: \"rgba(200,94,202,0.5)\",\n                    minZoomLevel: 15,\n                    maxZoomLevel: 17\n                },\n                {\n                    styleSet: \"geojson\",\n                    when: [\"==\", [\"geometry-type\"], \"Point\"],\n                    technique: \"circles\",\n                    color: \"rgba(94,0,202,1)\",\n                    size: 30,\n                    minZoomLevel: 15,\n                    maxZoomLevel: 17\n                }\n            ]\n        });\n\n        dataProvider.onDidInvalidate(() => {\n            mapView.update();\n        });\n\n        const animate = () => {\n            turf.transformRotate(points, 5, {\n                pivot: NY,\n                mutate: true\n            });\n\n            dataProvider.updateInput(\n                turf.featureCollection([circle, ...points.features]) as FeatureCollection\n            );\n        };\n\n        setInterval(animate, 100);\n\n        return mapView;\n    }\n\n    // eslint-disable-next-line no-console\n    main(\"mapCanvas\").catch(console.error);\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { EarthConstants, GeoCoordinates, webMercatorProjection } from \"@here/harp-geoutils\";\nimport { Math2D } from \"@here/harp-utils\";\nimport { Vector2, Vector3 } from \"three\";\n\n/**\n * A clipping edge.\n *\n * @remarks\n * Clip lines using the Sutherland-Hodgman algorithm.\n *\n * @internal\n */\nclass ClipEdge {\n    readonly p0: Vector2;\n    readonly p1: Vector2;\n\n    /**\n     * Creates a clipping edge.\n     *\n     * @param x1 - The x coordinate of the first point of this ClipEdge.\n     * @param y1 - The y coordinate of the first point of this ClipEdge.\n     * @param x2 - The x coordinate of the second point of this ClipEdge.\n     * @param y2 - The y coordinate of the second point of this ClipEdge.\n     * @param isInside - The function used to test points against this ClipEdge.\n     */\n    constructor(\n        x1: number,\n        y1: number,\n        x2: number,\n        y2: number,\n        private readonly isInside: (p: Vector2) => boolean\n    ) {\n        this.p0 = new Vector2(x1, y1);\n        this.p1 = new Vector2(x2, y2);\n    }\n\n    /**\n     * Tests if the given point is inside this clipping edge.\n     */\n    inside(point: Vector2): boolean {\n        return this.isInside(point);\n    }\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection}.\n     */\n    computeIntersection(a: Vector2, b: Vector2): Vector2 {\n        const result = new Vector2();\n        Math2D.intersectLines(\n            a.x,\n            a.y,\n            b.x,\n            b.y,\n            this.p0.x,\n            this.p0.y,\n            this.p1.x,\n            this.p1.y,\n            result\n        );\n        return result;\n    }\n\n    /**\n     * Clip the input line against this edge.\n     */\n    clipLine(lineString: Vector2[]): Vector2[][] {\n        const inputList = lineString;\n\n        const result: Vector2[][] = [];\n\n        lineString = [];\n        result.push(lineString);\n\n        const pushPoint = (point: Vector2) => {\n            if (lineString.length === 0 || !lineString[lineString.length - 1].equals(point)) {\n                lineString.push(point);\n            }\n        };\n\n        for (let i = 0; i < inputList.length; ++i) {\n            const currentPoint = inputList[i];\n            const prevPoint = i > 0 ? inputList[i - 1] : undefined;\n\n            if (this.inside(currentPoint)) {\n                if (prevPoint !== undefined && !this.inside(prevPoint)) {\n                    if (lineString.length > 0) {\n                        lineString = [];\n                        result.push(lineString);\n                    }\n                    pushPoint(this.computeIntersection(prevPoint, currentPoint));\n                }\n                pushPoint(currentPoint);\n            } else if (prevPoint !== undefined && this.inside(prevPoint)) {\n                pushPoint(this.computeIntersection(prevPoint, currentPoint));\n            }\n        }\n\n        if (result[result.length - 1].length === 0) {\n            result.length = result.length - 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Clip the input lines against this edge.\n     */\n    clipLines(lineStrings: Vector2[][]) {\n        const reuslt: Vector2[][] = [];\n        lineStrings.forEach(lineString => {\n            this.clipLine(lineString).forEach(clippedLine => {\n                reuslt.push(clippedLine);\n            });\n        });\n        return reuslt;\n    }\n}\n\n/**\n * Clip the input line against the given bounds.\n *\n * @param lineString - The line to clip.\n * @param minX - The minimum x coordinate.\n * @param minY - The minimum y coordinate.\n * @param maxX - The maxumum x coordinate.\n * @param maxY - The maxumum y coordinate.\n */\nexport function clipLineString(\n    lineString: Vector2[],\n    minX: number,\n    minY: number,\n    maxX: number,\n    maxY: number\n): Vector2[][] {\n    const clipEdge0 = new ClipEdge(minX, minY, minX, maxY, p => p.x > minX); // left\n    const clipEdge1 = new ClipEdge(minX, maxY, maxX, maxY, p => p.y < maxY); // bottom\n    const clipEdge2 = new ClipEdge(maxX, maxY, maxX, minY, p => p.x < maxX); // right\n    const clipEdge3 = new ClipEdge(maxX, minY, minX, minY, p => p.y > minY); // top\n\n    let lines = clipEdge0.clipLine(lineString);\n    lines = clipEdge1.clipLines(lines);\n    lines = clipEdge2.clipLines(lines);\n    lines = clipEdge3.clipLines(lines);\n\n    return lines;\n}\n\n/**\n * The result of wrapping a line string.\n */\ninterface WrappedLineString {\n    left: GeoCoordinates[][];\n    middle: GeoCoordinates[][];\n    right: GeoCoordinates[][];\n}\n\n/**\n * Helper function to wrap a line string projected in web mercator.\n *\n * @param multiLineString The input to wrap\n * @param edges The clipping edges used to wrap the input.\n * @param offset The x-offset used to displace the result\n *\n * @internal\n */\nfunction wrapMultiLineStringHelper(\n    multiLineString: Vector2[][],\n    edges: ClipEdge[],\n    offset: number\n): GeoCoordinates[][] | undefined {\n    for (const clip of edges) {\n        multiLineString = clip.clipLines(multiLineString);\n    }\n\n    const worldP = new Vector3();\n\n    const coordinates: GeoCoordinates[][] = [];\n\n    multiLineString.forEach(lineString => {\n        if (lineString.length === 0) {\n            return;\n        }\n\n        const coords = lineString.map(({ x, y }) => {\n            worldP.set(x, y, 0);\n            const geoPoint = webMercatorProjection.unprojectPoint(worldP);\n            geoPoint.longitude += offset;\n            return geoPoint;\n        });\n\n        coordinates.push(coords);\n    });\n\n    return coordinates.length > 0 ? coordinates : undefined;\n}\n\n/**\n * Wrap the given line string.\n *\n * @remarks\n * This function splits this input line string in three parts.\n *\n * The `left` member of the result contains the part of the line string with longitude less than `-180`.\n *\n * The `middle` member contains the part of the line string with longitude in the range `[-180, 180]`.\n *\n * The `right` member contains the part of the line string with longitude greater than `180`.\n *\n * @param coordinates The coordinates of the line string to wrap.\n */\nexport function wrapLineString(coordinates: GeoCoordinates[]): Partial<WrappedLineString> {\n    const worldP = new Vector3();\n\n    const lineString = coordinates.map(g => {\n        const { x, y } = webMercatorProjection.projectPoint(g, worldP);\n        return new Vector2(x, y);\n    });\n\n    const multiLineString = [lineString];\n\n    return {\n        left: wrapMultiLineStringHelper(multiLineString, WRAP_LEFT_CLIP_EDGES, 360),\n        middle: wrapMultiLineStringHelper(multiLineString, WRAP_MIDDLE_CLIP_EDGES, 0),\n        right: wrapMultiLineStringHelper(multiLineString, WRAP_RIGHT_CLIP_EDGES, -360)\n    };\n}\n\nconst ec = EarthConstants.EQUATORIAL_CIRCUMFERENCE;\nconst border = 0;\n\nconst WRAP_MIDDLE_CLIP_EDGES = [\n    new ClipEdge(0 - border, ec, 0 - border, 0, p => p.x > 0 - border),\n    new ClipEdge(ec + border, 0, ec + border, ec, p => p.x < ec + border)\n];\n\nconst WRAP_LEFT_CLIP_EDGES = [\n    new ClipEdge(-ec - border, ec, -ec - border, 0, p => p.x > -ec - border),\n    new ClipEdge(0 + border, 0, 0 + border, ec, p => p.x < 0 + border)\n];\n\nconst WRAP_RIGHT_CLIP_EDGES = [\n    new ClipEdge(ec - border, ec, ec - border, 0, p => p.x > ec - border),\n    new ClipEdge(ec * 2 + border, 0, ec * 2 + border, ec, p => p.x < ec * 2 + border)\n];\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector2 } from \"three\";\n\ninterface ClipInfo {\n    /**\n     * `true` if this vertex was clipped.\n     */\n    isClipped?: boolean;\n}\n\nexport type ClippedVertex = Vector2 & ClipInfo;\n\n/**\n * Abstract helper class used to implement the Sutherland-Hodgman clipping algorithm.\n *\n * @remarks\n * Concrete implementation of this class are used to clip a polygon\n * against one edge of a bounding box.\n *\n * @internal\n */\nexport abstract class ClippingEdge {\n    /**\n     * Tests if the given point is inside this clipping edge.\n     *\n     * @param point A point of the polygon.\n     * @param extent The extent of the bounding box.\n     */\n    abstract inside(point: Vector2, extent: number): boolean;\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Specialization of {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection}.\n     *\n     * @param a A point of the segment to clip.\n     * @param b A point of the segment to clip.\n     * @param extent The extent of the bounding box.\n     */\n    abstract computeIntersection(a: Vector2, b: Vector2, extent: number): ClippedVertex;\n\n    /**\n     * Clip the polygon against this clipping edge.\n     *\n     * @param polygon Clip the polygon against this edge.\n     * @param extent The extent of the bounding box.\n     *\n     * @return The clipped polygon.\n     */\n    clipPolygon(polygon: Vector2[], extent: number): Vector2[] {\n        const inputList = polygon;\n\n        polygon = [];\n\n        const pushPoint = (point: ClippedVertex) => {\n            const lastAddedPoint: ClippedVertex = polygon[polygon.length - 1];\n\n            if (\n                !lastAddedPoint?.equals(point) ||\n                (point.isClipped === true && !lastAddedPoint?.isClipped) ||\n                (!point.isClipped && lastAddedPoint?.isClipped === true)\n            ) {\n                polygon.push(point);\n            }\n        };\n\n        for (let i = 0; i < inputList.length; ++i) {\n            const currentPoint = inputList[i];\n            const prevPoint = inputList[(i + inputList.length - 1) % inputList.length];\n            if (this.inside(currentPoint, extent)) {\n                if (!this.inside(prevPoint, extent)) {\n                    const p = this.computeIntersection(prevPoint, currentPoint, extent);\n                    p.isClipped = true;\n                    pushPoint(p);\n                }\n                pushPoint(currentPoint);\n            } else if (this.inside(prevPoint, extent)) {\n                const p = this.computeIntersection(prevPoint, currentPoint, extent);\n                p.isClipped = true;\n                pushPoint(p);\n            }\n        }\n\n        return polygon;\n    }\n}\n\nclass TopClippingEdge extends ClippingEdge {\n    /** @override */\n    inside(point: Vector2): boolean {\n        return point.y >= 0;\n    }\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(0, 0)` and `(0, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a: Vector2, b: Vector2): Vector2 {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v: Vector2 = new Vector2((x1 * y2 - y1 * x2) / -(y1 - y2), 0).round();\n        return v;\n    }\n}\n\nclass RightClippingEdge extends ClippingEdge {\n    /**\n     * @override\n     *\n     * See: HARP-14633, this should potentially be changed to < as it was previously.\n     * However further investigation is needed to confirm this.\n     */\n    inside(point: Vector2, extent: number): boolean {\n        return point.x <= extent;\n    }\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(extent, 0)` and `(extent, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a: Vector2, b: Vector2, extent: number): Vector2 {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v: Vector2 = new Vector2(\n            extent,\n            (x1 * y2 - y1 * x2 - (y1 - y2) * -extent) / (x1 - x2)\n        ).round();\n        return v;\n    }\n}\n\nclass BottomClipEdge extends ClippingEdge {\n    /** @override */\n    inside(point: Vector2, extent: number): boolean {\n        return point.y <= extent;\n    }\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(extent, extent)` and `(0, extent)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a: Vector2, b: Vector2, extent: number): Vector2 {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v: Vector2 = new Vector2(\n            (x1 * y2 - y1 * x2 - (x1 - x2) * extent) / -(y1 - y2),\n            extent\n        ).round();\n        return v;\n    }\n}\n\nclass LeftClippingEdge extends ClippingEdge {\n    /** @override */\n    inside(point: Vector2) {\n        return point.x >= 0;\n    }\n\n    /**\n     * Computes the intersection of a line and this clipping edge.\n     *\n     * @remarks\n     * Find the intersection point between the line defined by the points `a` and `b`\n     * and the edge defined by the points `(0, extent)` and `(0, 0)`.\n     *\n     * @override\n     *\n     */\n    computeIntersection(a: Vector2, b: Vector2): Vector2 {\n        const { x: x1, y: y1 } = a;\n        const { x: x2, y: y2 } = b;\n        const v: Vector2 = new Vector2(0, (x1 * y2 - y1 * x2) / (x1 - x2)).round();\n        return v;\n    }\n}\n\nconst clipEdges = [\n    new TopClippingEdge(),\n    new RightClippingEdge(),\n    new BottomClipEdge(),\n    new LeftClippingEdge()\n];\n\n/**\n * Clip the given polygon against a rectangle using the Sutherland-Hodgman algorithm.\n *\n * @remarks\n * The coordinates of the polygon must be integer numbers.\n *\n * @param polygon The vertices of the polygon to clip.\n * @param extent The extents of the rectangle to clip against.\n */\nexport function clipPolygon(polygon: Vector2[], extent: number): Vector2[] {\n    if (polygon.length === 0) {\n        return polygon;\n    }\n\n    if (!polygon[0].equals(polygon[polygon.length - 1])) {\n        // close the polygon if needed.\n        polygon = [...polygon, polygon[0]];\n    }\n\n    for (const clip of clipEdges) {\n        polygon = clip.clipPolygon(polygon, extent);\n    }\n\n    if (polygon.length < 3) {\n        return [];\n    }\n\n    return polygon;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/ThemedTileDecoder\";\nexport * from \"./lib/TileDecoderService\";\nexport * from \"./lib/TilerService\";\nexport * from \"./lib/WorkerService\";\nexport * from \"./lib/WorkerServiceManager\";\nexport * from \"./lib/GeoJsonTiler\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoJson, isFeatureGeometry, ITiler } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\n// @ts-ignore\nimport * as geojsonvtExport from \"geojson-vt\";\n\n// to be able to run tests on nodejs\nconst geojsonvt = geojsonvtExport.default ?? geojsonvtExport;\n\nconst EXTENT = 4096;\n\n// the factor used to compute the size of the buffer.\nconst BUFFER_FACTOR = 0.05;\n\n// align the buffer to the next integer multiple of 2.\nconst BUFFER = -(-Math.ceil(EXTENT * BUFFER_FACTOR) & -2);\n\ninterface GeoJsonVtIndex {\n    geojson: GeoJson;\n    getTile(level: number, column: number, row: number): any;\n}\n\nexport class GeoJsonTiler implements ITiler {\n    indexes: Map<string, GeoJsonVtIndex>;\n\n    constructor() {\n        this.indexes = new Map();\n    }\n\n    dispose() {\n        /* */\n    }\n\n    async connect(): Promise<void> {\n        return await Promise.resolve();\n    }\n\n    async registerIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        if (this.indexes.has(indexId)) {\n            return;\n        }\n        return await this.updateIndex(indexId, input);\n    }\n\n    async updateIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        if (input instanceof URL) {\n            const response = await fetch(input.href);\n            if (!response.ok) {\n                throw new Error(\n                    `GeoJsonTiler: Unable to fetch ${input.href}: ${response.statusText}`\n                );\n            }\n            input = (await response.json()) as GeoJson;\n        } else {\n            input = input as GeoJson;\n        }\n\n        // Generate ids only if input doesn't have them.\n        const generateId =\n            isFeatureGeometry(input) ||\n            input.type === \"GeometryCollection\" ||\n            (input.type === \"Feature\" && input.id === undefined) ||\n            (input.type === \"FeatureCollection\" &&\n                input.features.length > 0 &&\n                input.features[0].id === undefined);\n        const index = geojsonvt(input, {\n            maxZoom: 20, // max zoom to preserve detail on\n            indexMaxZoom: 5, // max zoom in the tile index\n            indexMaxPoints: 100000, // max number of points per tile in the tile index\n            tolerance: 3, // simplification tolerance (higher means simpler)\n            extent: EXTENT, // tile extent\n            buffer: BUFFER, // tile buffer on each side\n            lineMetrics: false, // whether to calculate line metrics\n            promoteId: null, // name of a feature property to be promoted to feature.id\n            generateId, // whether to generate feature ids. Cannot be used with promoteId\n            debug: 0 // logging level (0, 1 or 2)\n        });\n        index.geojson = input;\n\n        this.indexes.set(indexId, index);\n    }\n\n    async getTile(indexId: string, tileKey: TileKey): Promise<{}> {\n        const index = this.indexes.get(indexId);\n        if (index === undefined) {\n            throw new Error(\"Tile not found\");\n        }\n        const tile = index.getTile(tileKey.level, tileKey.column, tileKey.row);\n        if (tile !== null) {\n            tile.layer = indexId;\n        }\n        return tile || {};\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    DecoderOptions,\n    ITileDecoder,\n    OptionsMap,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { StyleSetEvaluator, StyleSetOptions } from \"@here/harp-datasource-protocol/index-decoder\";\nimport { Projection, TileKey } from \"@here/harp-geoutils\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"ThemedTileDecoder\");\n\n/**\n * `ThemedTileDecoder` implements an [[ITileDecoder]] which uses a [[Theme]] to apply styles to the\n * objects displayed in the map.\n *\n * By default, decoders are executed in web workers (using [[TileDecoderService]]) for performance\n * reasons.\n */\nexport abstract class ThemedTileDecoder implements ITileDecoder {\n    languages?: string[];\n    m_storageLevelOffset: number = 0;\n\n    protected m_styleSetEvaluator?: StyleSetEvaluator;\n    abstract connect(): Promise<void>;\n\n    dispose() {\n        // implemented in subclasses\n    }\n\n    decodeTile(\n        data: ArrayBufferLike | {},\n        tileKey: TileKey,\n        projection: Projection\n    ): Promise<DecodedTile | undefined> {\n        if (this.m_styleSetEvaluator === undefined) {\n            logger.info(\"cannot decode tile, as there is not style available\");\n            return Promise.resolve(undefined);\n        }\n\n        return this.decodeThemedTile(data, tileKey, this.m_styleSetEvaluator, projection);\n    }\n\n    getTileInfo(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection\n    ): Promise<TileInfo | undefined> {\n        return Promise.resolve(undefined);\n    }\n\n    configure(options?: DecoderOptions, customOptions?: OptionsMap): void {\n        if (options?.styleSet !== undefined) {\n            this.m_styleSetEvaluator = new StyleSetEvaluator(options as StyleSetOptions);\n        }\n        if (options?.languages !== undefined) {\n            this.languages = options.languages;\n        }\n        if (customOptions !== undefined && customOptions.storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = customOptions.storageLevelOffset;\n        }\n    }\n\n    /**\n     * Create a [[DecodedTile]] from binary tile data and a theme description in form of a\n     * [[StyleSetEvaluator]].\n     *\n     * @param data - Binary data in form of [[ArrayBufferLike]], or any object.\n     * @param tileKey - Quadtree address of tile.\n     * @param styleSetEvaluator - Processor of [[Theme]], identifies styling techniques applicable\n     *                            to individual objects.\n     * @param projection - Projection used by the individual data sources.\n     */\n    abstract decodeThemedTile(\n        data: ArrayBufferLike | {},\n        tileKey: TileKey,\n        styleSetEvaluator: StyleSetEvaluator,\n        projection: Projection\n    ): Promise<DecodedTile>;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    addBuffersToTransferList,\n    BufferAttribute,\n    getProjection,\n    InterleavedBufferAttribute,\n    ITileDecoder,\n    WorkerDecoderProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { WorkerService, WorkerServiceResponse } from \"./WorkerService\";\n\nconst logger = LoggerManager.instance.create(\"TileDecoderService\");\n\n/**\n * An extension to [[WorkerService]], the `TileDecoderService` implements an asynchronous\n * (message based) service to decode tile content in web workers. The `TileDecoderService` itself\n * lives in the web worker, and communicates with messages by means of a [[ConcurrentWorkerSet]]\n * with the application.\n *\n * The `TileDecoderService` handles a [[DecodeTileRequest]], which contains a tile and its freshly\n * loaded binary data, decodes the content with the [[ITileDecoder]] that the service is configured\n * to use, and sends the data back in form of a [[WorkerServiceResponse]].\n */\nexport class TileDecoderService extends WorkerService {\n    /**\n     * Start a [[TileDecoderService]] with a given decoder.\n     *\n     * @param serviceId - Service id. Must be unique.\n     * @param decoder -   [[TileDecoder]] instance.\n     */\n    static start(serviceId: string, decoder: ITileDecoder) {\n        return new TileDecoderService(serviceId, decoder);\n    }\n\n    /**\n     * Set up the `TileDecoderService`. The name of the service must be unique\n     *\n     * @param serviceId - Service id. Must be unique.\n     * @param m_decoder - Decoder to handle the decoding and info requests.\n     */\n    constructor(readonly serviceId: string, private readonly m_decoder: ITileDecoder) {\n        super(serviceId);\n        this.m_decoder.connect();\n    }\n\n    /**\n     * Handle incoming request messages. Identifies message type and processes the request.\n     *\n     * @param request - Message that is either a DecodeTileRequest or a TileInfoRequest.\n     * @returns A promise which resolves to a [[WorkerServiceResponse]].\n     * @override\n     */\n    protected handleRequest(request: any): Promise<WorkerServiceResponse> {\n        if (WorkerDecoderProtocol.isDecodeTileRequest(request)) {\n            return this.handleDecodeTileRequest(request);\n        } else if (WorkerDecoderProtocol.isTileInfoRequest(request)) {\n            return this.handleTileInfoRequest(request);\n        } else {\n            return super.handleRequest(request);\n        }\n    }\n\n    /**\n     * Handle incoming configuration message. Configuration message is passed on to decoder.\n     *\n     * @param request - Message of type [[ConfigurationMessage]].\n     * @override\n     */\n    protected handleMessage(message: any) {\n        if (WorkerDecoderProtocol.isConfigurationMessage(message)) {\n            this.handleConfigurationMessage(message);\n        } else {\n            logger.error(`[${this.serviceId}]: invalid message ${message.type}`);\n        }\n    }\n\n    private async handleDecodeTileRequest(\n        request: WorkerDecoderProtocol.DecodeTileRequest\n    ): Promise<WorkerServiceResponse> {\n        const tileKey = TileKey.fromMortonCode(request.tileKey);\n        const projection = getProjection(request.projection);\n\n        const decodedTile = await this.m_decoder.decodeTile(request.data, tileKey, projection);\n\n        const transferList: ArrayBufferLike[] = [];\n\n        const transferBufferAttribute = (\n            attribute?: BufferAttribute | InterleavedBufferAttribute\n        ) => {\n            if (\n                attribute !== undefined &&\n                attribute.buffer.byteLength > 0 &&\n                !transferList.includes(attribute.buffer)\n            ) {\n                transferList.push(attribute.buffer);\n            }\n        };\n\n        decodedTile?.geometries.forEach(geom => {\n            geom.vertexAttributes?.forEach(attr => transferBufferAttribute(attr));\n            geom.interleavedVertexAttributes?.forEach(attr => transferBufferAttribute(attr));\n            transferBufferAttribute(geom.index);\n            transferBufferAttribute(geom.edgeIndex);\n\n            if (\n                Array.isArray(geom.objInfos) &&\n                geom.objInfos.length === 1 &&\n                typeof geom.objInfos[0] === \"object\" &&\n                geom.objInfos[0]?.hasOwnProperty(\"displacementMap\")\n            ) {\n                const obj = geom.objInfos[0] as any;\n                transferBufferAttribute(obj.displacementMap);\n            }\n\n            if (Array.isArray(geom.attachments)) {\n                geom.attachments.forEach(attachment => {\n                    transferBufferAttribute(attachment.index);\n                    transferBufferAttribute(attachment.edgeIndex);\n                });\n            }\n        });\n\n        decodedTile?.techniques.forEach(technique => {\n            addBuffersToTransferList(technique, transferList);\n        });\n\n        return {\n            response: decodedTile,\n            transferList\n        };\n    }\n\n    private handleTileInfoRequest(\n        request: WorkerDecoderProtocol.TileInfoRequest\n    ): Promise<WorkerServiceResponse> {\n        const tileKey = TileKey.fromMortonCode(request.tileKey);\n        const projection = getProjection(request.projection);\n\n        return this.m_decoder.getTileInfo(request.data, tileKey, projection).then(tileInfo => {\n            const transferList: ArrayBuffer[] =\n                tileInfo !== undefined && tileInfo.transferList !== undefined\n                    ? tileInfo.transferList\n                    : [];\n            return {\n                response: tileInfo,\n                transferList\n            };\n        });\n    }\n\n    private handleConfigurationMessage(message: WorkerDecoderProtocol.ConfigurationMessage) {\n        this.m_decoder.configure(message, message.options);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITiler, WorkerTilerProtocol } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\n\nimport { GeoJsonTiler } from \"./GeoJsonTiler\";\nimport { WorkerService, WorkerServiceResponse } from \"./WorkerService\";\n\n/**\n * An extension to {@link WorkerService}, the `TilerService`\n * implements an asynchronous (message based)\n * service to tile untiled payloads in web workers.\n *\n * @remarks\n * The `TilerService` itself lives in the web\n * worker, and communicates with messages by means of a `ConcurrentWorkerSet` with the\n * application.\n *\n * The `TilerService` registers tile indices (parent tile to be subdivided) by handling a\n * `RegisterIndexRequest`, and can later retrieve tiled payloads from through the `TileRequest`.\n * The data is sent back in form of a {@link WorkerServiceResponse}.\n */\nexport class TilerService extends WorkerService {\n    /**\n     * Start a `TilerService`.\n     *\n     * @param serviceId - Service id. Must be unique.\n     */\n    static start(serviceId: string) {\n        return new TilerService(serviceId);\n    }\n\n    tiler: ITiler = new GeoJsonTiler();\n\n    /**\n     * Set up the `TilerService`. The name of the service must be unique\n     *\n     * @param serviceId - Service id. Must be unique.\n     */\n    constructor(readonly serviceId: string) {\n        super(serviceId);\n    }\n\n    /**\n     * Handle incoming request messages. Identifies message type and processes the request.\n     *\n     * @param request - {@link WorkerTilerProtocol} request.\n     * @returns A promise which resolves to a {@link WorkerServiceResponse}.\n     * @override\n     */\n    protected handleRequest(request: any): Promise<WorkerServiceResponse> {\n        if (WorkerTilerProtocol.isRegisterIndexRequest(request)) {\n            return this.handleRegisterIndexRequest(request);\n        } else if (WorkerTilerProtocol.isUpdateIndexRequest(request)) {\n            return this.handleUpdateIndexRequest(request);\n        } else if (WorkerTilerProtocol.isTileRequest(request)) {\n            return this.handleTileRequest(request);\n        } else {\n            return super.handleRequest(request);\n        }\n    }\n\n    private async handleTileRequest(\n        request: WorkerTilerProtocol.TileRequest\n    ): Promise<WorkerServiceResponse> {\n        const tileKey = TileKey.fromMortonCode(request.tileKey);\n        const tile = await this.tiler.getTile(request.index, tileKey);\n\n        return { response: tile || {} };\n    }\n\n    private async handleRegisterIndexRequest(\n        message: WorkerTilerProtocol.RegisterIndexRequest\n    ): Promise<WorkerServiceResponse> {\n        const input = typeof message.input === \"string\" ? new URL(message.input) : message.input;\n        await this.tiler.registerIndex(message.id, input);\n\n        return { response: {} };\n    }\n\n    private async handleUpdateIndexRequest(\n        message: WorkerTilerProtocol.UpdateIndexRequest\n    ): Promise<WorkerServiceResponse> {\n        const input = typeof message.input === \"string\" ? new URL(message.input) : message.input;\n\n        this.tiler.updateIndex(message.id, input);\n\n        return { response: {} };\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"WorkerService\", { enabled: true });\n\ndeclare let self: Worker;\n\n/**\n * Response for {@link WorkerService} procession results.\n */\nexport interface WorkerServiceResponse {\n    /**\n     * Response object.\n     */\n    response: any;\n\n    /**\n     * Transfer list containing a list of `ArrayBuffer` which transfer ownership from web worker\n     * to UI thread.\n     */\n    transferList?: ArrayBuffer[];\n}\n\n/**\n * Header information for a [[RequestMessage]].\n */\ninterface RequestEntry {\n    /**\n     * ID of service.\n     */\n    service: string;\n\n    /**\n     * Unique ID of message.\n     */\n    messageId: number;\n\n    /**\n     * Contains `true` if message has been processed, and response has been sent.\n     */\n    responseSent: boolean;\n}\n\n/**\n * Worker Service communication helper.\n *\n * @remarks\n * Listens to Web Worker messages from `entWorkerSet` and implements:\n *  - worker service initialization\n *  - request/response scheme\n *  - error handling.\n *\n * This class should be subclassed to provide concrete like `TileDecoderService`.\n *\n * Communication peer for `ConcurrentWorkerSet`.\n */\nexport abstract class WorkerService {\n    private readonly m_pendingRequests: Map<number, RequestEntry> = new Map();\n\n    /**\n     * Sets up the `WorkerService` with the specified name, and starts processing messages.\n     *\n     * @param serviceId - The service id.\n     */\n    constructor(readonly serviceId: string) {\n        self.addEventListener(\"message\", this.onMessage);\n\n        const isInitializedMessage: WorkerServiceProtocol.InitializedMessage = {\n            service: serviceId,\n            type: WorkerServiceProtocol.ServiceMessageName.Initialized\n        };\n        self.postMessage(isInitializedMessage);\n    }\n\n    /**\n     * Destroy the `WorkerService`. Cancels all pending requests ad removes itself from the message\n     * queue.\n     */\n    destroy() {\n        this.cancelAllPendingRequests();\n\n        self.removeEventListener(\"message\", this.onMessage);\n    }\n\n    /**\n     * Message handler to be overridden by implementation.\n     *\n     * @param message - `MessageEvent.data` as received by `WorkerService`.\n     */\n    protected handleMessage(message: any): void {\n        logger.error(`[${this.serviceId}]: Invalid message ${message.type}`);\n    }\n\n    /**\n     * Call request handler to be overridden by implementation.\n     *\n     * @param request - `RequestMessage.request` as received by `WorkerService`.\n     */\n    protected handleRequest(request: any): Promise<WorkerServiceResponse> {\n        throw new Error(`ServiceAdapter[${this.serviceId}]: Invalid request '${request.type}'`);\n    }\n\n    /**\n     * Central message handler for this service.\n     *\n     * Responsible for filtering message target and managing request/response sequence.\n     *\n     * @param message - Message to be dispatched.\n     */\n    private readonly onMessage = (message: MessageEvent) => {\n        if (typeof message.data.service !== \"string\" || message.data.service !== this.serviceId) {\n            return;\n        }\n\n        try {\n            if (WorkerServiceProtocol.isRequestMessage(message.data)) {\n                const request = message.data;\n                const requestEntry = {\n                    service: request.service,\n                    messageId: request.messageId,\n                    responseSent: false\n                };\n                this.m_pendingRequests.set(request.messageId, requestEntry);\n                this.tryHandleRequest(request.request)\n                    .then(response => {\n                        this.doSendResponse(\n                            requestEntry,\n                            {\n                                service: this.serviceId,\n                                type: WorkerServiceProtocol.ServiceMessageName.Response,\n                                messageId: request.messageId,\n                                response: response.response\n                            },\n                            response.transferList\n                        );\n                    })\n                    .catch(error => {\n                        this.doSendResponse(requestEntry, {\n                            service: this.serviceId,\n                            type: WorkerServiceProtocol.ServiceMessageName.Response,\n                            messageId: request.messageId,\n                            errorMessage: error.toString(),\n                            errorStack: error.stack\n                        });\n                    });\n            } else {\n                this.tryHandleMessage(message.data);\n            }\n        } catch (err) {\n            logger.error(`[${this.serviceId}]: Unhandled exception when handling ${message.type}`);\n        }\n    };\n\n    /**\n     * Safety belt over `handleMessage` for correct exception handling & logging.\n     */\n    private tryHandleMessage(message: any): void {\n        try {\n            this.handleMessage(message);\n        } catch (error) {\n            logger.error(`[${this.serviceId}]: Failed, handling message ${message.type}`);\n        }\n    }\n\n    /**\n     * Safety belt over `handleRequest` for correct exception handling in promise chain.\n     */\n    private tryHandleRequest(request: any): Promise<WorkerServiceResponse> {\n        try {\n            return this.handleRequest(request);\n        } catch (error) {\n            // we don't log exceptions here as they are propagated to client as responses\n            logger.error(`[${this.serviceId}]: Failure`, error);\n            return Promise.reject(error);\n        }\n    }\n\n    private doSendResponse(\n        requestEntry: RequestEntry,\n        response: WorkerServiceProtocol.ResponseMessage,\n        transferList?: ArrayBuffer[]\n    ) {\n        if (requestEntry.responseSent) {\n            return;\n        }\n\n        if (transferList !== undefined) {\n            self.postMessage(response, transferList);\n        } else {\n            self.postMessage(response);\n        }\n\n        requestEntry.responseSent = true;\n        this.m_pendingRequests.delete(requestEntry.messageId);\n    }\n\n    private cancelAllPendingRequests() {\n        this.m_pendingRequests.forEach(requestEntry => {\n            this.doSendResponse(requestEntry, {\n                service: this.serviceId,\n                type: WorkerServiceProtocol.ServiceMessageName.Response,\n                messageId: requestEntry.messageId,\n                errorMessage: \"cancelled\"\n            });\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\n\nimport { WorkerService, WorkerServiceResponse } from \"./WorkerService\";\n\n/**\n * Factory function that creates [[WorkerService]].\n */\nexport type WorkerServiceFactory = (serviceId: string) => WorkerService;\n\n/**\n * Worker service class definition as needed by [[WorkerServiceManager.register]].\n */\nexport interface WorkerServiceDescriptor {\n    serviceType: string;\n    factory: WorkerServiceFactory;\n}\n\n/**\n * Manages dynamic worker services in Web Worker context.\n *\n * Handles `CreateService` and `DestroyService` messages sent to Web Worker. Singleton (in scope of\n * one worker runtime!), starts automatically with first [[getInstance]] call.\n */\nexport class WorkerServiceManager extends WorkerService {\n    /**\n     * Gets the default instance of `WorkerServiceManager`. Starts the service when first called.\n     */\n    static getInstance() {\n        if (this.m_service === undefined) {\n            this.m_service = new WorkerServiceManager(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID\n            );\n        }\n        return this.m_service;\n    }\n\n    /**\n     * Default instance of `WorkerServiceManager`.\n     */\n    private static m_service: WorkerServiceManager;\n\n    /**\n     * Contains all registered service factories indexed by `serviceType`.\n     */\n    private readonly m_factories = new Map<string, WorkerServiceFactory>();\n\n    /**\n     * Contains all managed worker services indexed by their `serviceId`.\n     */\n    private readonly m_services = new Map<string, WorkerService>();\n\n    private constructor(\n        serviceId: string = WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID\n    ) {\n        super(serviceId);\n    }\n\n    /**\n     * Register [[WorkerService]] class to this manager.\n     *\n     * @param workerServiceDescriptor - service type and factory\n     */\n    register(workerServiceDescriptor: WorkerServiceDescriptor): void {\n        this.m_factories.set(workerServiceDescriptor.serviceType, workerServiceDescriptor.factory);\n    }\n\n    /** @override */\n    protected handleRequest(request: any): Promise<WorkerServiceResponse> {\n        if (request.type === WorkerServiceProtocol.Requests.CreateService) {\n            const existingService = this.m_services.get(request.targetServiceId);\n            if (existingService !== undefined) {\n                throw Error(\n                    `error - service with targetServiceId='${request.targetServiceId}' already running, ignoring CreateService request`\n                );\n            }\n\n            const factory = this.m_factories.get(request.targetServiceType);\n\n            if (factory === undefined) {\n                throw Error(`unknown targetServiceType requested: '${request.targetServiceType}'`);\n            }\n\n            const service = factory(request.targetServiceId);\n            this.m_services.set(request.targetServiceId, service);\n        }\n        if (request.type === WorkerServiceProtocol.Requests.DestroyService) {\n            const service = this.m_services.get(request.targetServiceId);\n            if (service === undefined) {\n                throw Error(`unknown targetServiceId '${request.targetServiceId}'`);\n            }\n            service.destroy();\n            this.m_services.delete(request.targetServiceId);\n        }\n\n        return Promise.resolve({\n            response: {}\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/VectorTileDecoder\";\nexport * from \"./lib/GeoJsonTilerService\";\nexport * from \"./lib/OmvDecoderDefs\";\nexport * from \"./lib/DataAdapter\";\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DecodeInfo } from \"./DecodeInfo\";\nimport { IGeometryProcessor } from \"./IGeometryProcessor\";\n\n/**\n * The class `DataAdapter` prepares vector data so it\n * can be processed by the vector tile decoder.\n */\nexport interface DataAdapter {\n    /**\n     * Checks if the given data can be processed by this `DataAdapter`.\n     *\n     * @param data - The raw data to adapt.\n     */\n    canProcess(data: ArrayBufferLike | {}): boolean;\n\n    /**\n     * Process the given raw data.\n     *\n     * @param data - The raw data to process.\n     * @param decodeInfo - The `DecodeInfo` of the tile to process.\n     * @param geometryProcessor - Must be called for every feature providing its geometry\n     * (point,line or polygon) and properties. @see {@link IGeometryProcessor} for more details.\n     */\n    process(\n        data: ArrayBufferLike | {},\n        decodeInfo: DecodeInfo,\n        geometryProcessor: IGeometryProcessor\n    ): void;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeoBox,\n    OrientedBox3,\n    Projection,\n    TileKey,\n    TilingScheme,\n    webMercatorTilingScheme\n} from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { WorldTileProjectionCookie } from \"./OmvUtils\";\n\nexport class DecodeInfo {\n    /**\n     * The [[GeoBox]] of the Tile to decode.\n     */\n    readonly geoBox: GeoBox;\n\n    readonly projectedBoundingBox = new OrientedBox3();\n\n    /**\n     * The tile bounds in the OMV tile space [[webMercatorTilingScheme]].\n     */\n    readonly tileBounds = new THREE.Box3();\n\n    /**\n     * The tile size in the OMV tile space [[webMercatorTilingScheme]].\n     */\n    readonly tileSize = new THREE.Vector3();\n\n    /**\n     * The center of the Tile in the target [[Projection]] space.\n     * Geometries generated by decoding the OMV tile must be relative\n     * to this position.\n     */\n    readonly center = new THREE.Vector3();\n\n    /**\n     * @internal\n     */\n    worldTileProjectionCookie?: WorldTileProjectionCookie;\n\n    /**\n     * Estimated tile size in pixels.\n     */\n    readonly tileSizeOnScreen: number;\n\n    /**\n     * The maximum number of columns.\n     */\n    readonly columnCount: number;\n\n    /**\n     * The maximum number of rows.\n     */\n    readonly rowCount: number;\n\n    /**\n     * Constructs a new [[DecodeInfo]].\n     *\n     * @param targetProjection - The [[Projection]]\n     * @param tileKey - The [[TileKey]] of the Tile to decode.\n     * @param storageLevelOffset - The storage level offset.\n     */\n    constructor(\n        readonly targetProjection: Projection,\n        readonly tileKey: TileKey,\n        readonly storageLevelOffset: number = 0\n    ) {\n        this.geoBox = this.tilingScheme.getGeoBox(tileKey);\n        this.targetProjection.projectBox(this.geoBox, this.projectedBoundingBox);\n        this.projectedBoundingBox.getCenter(this.center);\n        this.tilingScheme.getWorldBox(tileKey, this.tileBounds);\n        this.tileBounds.getSize(this.tileSize);\n        this.tileSizeOnScreen = 256 * Math.pow(2, -this.storageLevelOffset);\n\n        this.columnCount = webMercatorTilingScheme.subdivisionScheme.getLevelDimensionX(\n            this.tileKey.level\n        );\n\n        this.rowCount = webMercatorTilingScheme.subdivisionScheme.getLevelDimensionY(\n            this.tileKey.level\n        );\n    }\n\n    /**\n     * The [[TilingScheme]] of the OMV data, currenly it is defined\n     * to be [[webMercatorTilingScheme]].\n     */\n    get tilingScheme(): TilingScheme {\n        return webMercatorTilingScheme;\n    }\n\n    /**\n     * The [[Projection]] of OMV tiled data, currenly it is defined\n     * to be [[webMercatorProjection]].\n     */\n    get sourceProjection(): Projection {\n        return this.tilingScheme.projection;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TilerService, WorkerServiceManager } from \"@here/harp-mapview-decoder/index-worker\";\n\nimport { GEOJSON_TILER_SERVICE_TYPE } from \"./OmvDecoderDefs\";\n\n/**\n * GeoJson tiler service.\n *\n * @remarks\n * This services instantiates the geojson-vt based tiler\n * service that is responsible to create small tiles from\n * large GeoJson datasets.\n *\n * @example\n * ```typescript\n * // decoder.ts\n * GeoJsonTilerService.start();\n * ```\n */\nexport class GeoJsonTilerService {\n    /**\n     * Register a vector data tiler service with\n     * {@link @here/harp-mapview-decoder#WorkerServiceManager}.\n     *\n     * @remarks\n     * Has to be called during initialization of decoder bundle.\n     */\n    static start() {\n        WorkerServiceManager.getInstance().register({\n            serviceType: GEOJSON_TILER_SERVICE_TYPE,\n            factory: (serviceId: string) => TilerService.start(serviceId)\n        });\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MapEnv } from \"@here/harp-datasource-protocol/index-decoder\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { OmvFeatureModifier } from \"./OmvDataFilter\";\n\nconst logger = LoggerManager.instance.create(\"OmvPoliticalViewFeatureModifier\");\n\n/**\n * Modifies the MapEnv of the Vector Tiles in Tilezen format with different POV.\n *\n * This feature modifier updates feature properties according to different political\n * point of view.\n * Political views (or alternate point of views) are supported in Tilezen by adding\n * country posix (lower-case ISO 3166-1 alpha-2 compliant) to __default__ property name.\n * For example country borders (__boundaries__ layer) may have both __kind__ property for\n * default (commonly accepted point of view) and __kind:xx__ for alternate points of view.\n * This way disputed borders may be visible or not for certain regions and different\n * users (clients).\n *\n * @hidden\n */\nexport class OmvPoliticalViewFeatureModifier implements OmvFeatureModifier {\n    private readonly m_countryCode: string;\n\n    /**\n     * C-tor.\n     *\n     * @param pov - The code of the country (in lower-case ISO 3166-1 alpha-2 format) which\n     * point of view should be taken into account.\n     */\n    constructor(pov: string) {\n        this.m_countryCode = pov;\n    }\n\n    /**\n     * Simply passes all points to rendering, points features does not support PoliticalView.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of point feature.\n     * @param level - Level of tile.\n     * @returns always `true` to pass feature.\n     */\n    doProcessPointFeature(layer: string, env: MapEnv, level: number): boolean {\n        return true;\n    }\n\n    /**\n     * Implements line features processing changing \"kind\" attribute depending on point of view.\n     *\n     * Currently only line features support different point of view.\n     * @param layer - The name of the layer.\n     * @param env - The environment to use.\n     * @returns always `true` to pass lines for rendering.\n     */\n    doProcessLineFeature(layer: string, env: MapEnv, level: number): boolean {\n        this.rewriteEnvironment(layer, env);\n        return true;\n    }\n\n    /**\n     * Simply pass all polygons to rendering, this feature does not support PoliticalView yet.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of polygon feature.\n     * @param level - Level of tile.\n     * @returns `true` to pass feature.\n     */\n    doProcessPolygonFeature(layer: string, env: MapEnv, level: number): boolean {\n        return true;\n    }\n\n    /**\n     * Rewrites the Environment to match the different points of view.\n     *\n     * @param layer - The layer name.\n     * @param env - The environment to use.\n     */\n    private rewriteEnvironment(layer: string, env: MapEnv) {\n        // For now we need to rewrite \"boundaries\" layer only.\n        if (this.isPoliticalViewLayer(layer)) {\n            this.updateEnvironment(env, this.m_countryCode, \"kind\");\n        }\n    }\n\n    private updateEnvironment(env: MapEnv, countryCode: string, propName: string): void {\n        const value = this.getAlternativePov(env, countryCode, propName);\n        if (value !== undefined) {\n            env.entries[propName] = value;\n        }\n    }\n\n    private getAlternativePov(env: MapEnv, countryCode: string, propName: string) {\n        logger.log(\"Get alternate POV: \", JSON.stringify(env));\n        const cc = countryCode;\n        const value = env.lookup(`${propName}:${cc}`);\n        logger.log(\"Lookup POV: \", `${propName}:${cc}`, value);\n        if (typeof value === \"string\" && value.length > 0) {\n            logger.log(\"Found POV: \", `${propName}:${cc}`, value);\n            return value;\n        } else {\n            return undefined;\n        }\n    }\n\n    private isPoliticalViewLayer(layer: string): boolean {\n        return layer === \"boundaries\";\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    EarthConstants,\n    isVector3Like,\n    Vector2Like,\n    Vector3Like,\n    webMercatorProjection\n} from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { DecodeInfo } from \"./DecodeInfo\";\n\n/**\n * @hidden\n */\nexport function isArrayBufferLike(data: any): data is ArrayBufferLike {\n    if (typeof SharedArrayBuffer !== \"undefined\") {\n        return data instanceof ArrayBuffer || data instanceof SharedArrayBuffer;\n    } else {\n        return data instanceof ArrayBuffer;\n    }\n}\n\n/**\n * @hidden\n */\nexport function lat2tile(lat: number, zoom: number): number {\n    return Math.round(\n        ((1 -\n            Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) /\n                Math.PI) /\n            2) *\n            Math.pow(2, zoom)\n    );\n}\n\n/**\n * @hidden\n */\nexport function tile2lat(y: number, level: number): number {\n    const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, level);\n    return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n}\n\nexport interface WorldTileProjectionCookie {\n    extents: number;\n    top: number;\n    left: number;\n    scale: number;\n}\n\nexport function createWorldTileTransformationCookie(extents: number, decodeInfo: DecodeInfo) {\n    const { north, west } = decodeInfo.geoBox;\n    const N = Math.log2(extents);\n    const scale = Math.pow(2, decodeInfo.tileKey.level + N);\n    return {\n        extents,\n        scale,\n        top: lat2tile(north, decodeInfo.tileKey.level + N),\n        left: Math.round(((west + 180) / 360) * scale)\n    };\n}\n\n/**\n * @hidden\n */\nexport function tile2world<VectorType extends Vector3Like>(\n    extents: number,\n    decodeInfo: DecodeInfo,\n    position: Vector2Like,\n    flipY: boolean = false,\n    target: VectorType\n): VectorType {\n    if (\n        decodeInfo.worldTileProjectionCookie === undefined ||\n        decodeInfo.worldTileProjectionCookie.extents !== extents\n    ) {\n        decodeInfo.worldTileProjectionCookie = createWorldTileTransformationCookie(\n            extents,\n            decodeInfo\n        );\n    }\n\n    const { top, left, scale } = decodeInfo.worldTileProjectionCookie;\n    const R = EarthConstants.EQUATORIAL_CIRCUMFERENCE;\n\n    target.x = ((left + position.x) / scale) * R;\n    target.y = ((top + (flipY ? -position.y : position.y)) / scale) * R;\n    target.z = isVector3Like(position) ? position.z : 0;\n\n    return target;\n}\n\n/**\n * @hidden\n */\nexport function world2tile<VectorType extends Vector2Like>(\n    extents: number,\n    decodeInfo: DecodeInfo,\n    position: Vector3Like,\n    flipY: boolean = false,\n    target: VectorType\n): VectorType {\n    if (\n        decodeInfo.worldTileProjectionCookie === undefined ||\n        decodeInfo.worldTileProjectionCookie.extents !== extents\n    ) {\n        decodeInfo.worldTileProjectionCookie = createWorldTileTransformationCookie(\n            extents,\n            decodeInfo\n        );\n    }\n    const { top, left, scale } = decodeInfo.worldTileProjectionCookie;\n    const R = EarthConstants.EQUATORIAL_CIRCUMFERENCE;\n\n    target.x = Math.round((position.x / R) * scale - left);\n    target.y = Math.round((flipY ? -1 : 1) * ((position.y / R) * scale - top));\n    if (isVector3Like(target)) {\n        target.z = position.z;\n    }\n    return target;\n}\n\nexport function webMercatorTile2TargetWorld(\n    extents: number,\n    decodeInfo: DecodeInfo,\n    position: THREE.Vector2 | THREE.Vector3,\n    target: THREE.Vector3,\n    scaleHeight: boolean,\n    flipY: boolean = false\n) {\n    tile2world(extents, decodeInfo, position, flipY, target);\n    decodeInfo.targetProjection.reprojectPoint(webMercatorProjection, target, target);\n    if (position instanceof THREE.Vector3 && scaleHeight) {\n        target.z *= decodeInfo.targetProjection.getScaleFactor(target);\n    }\n}\n\nexport function webMercatorTile2TargetTile(\n    extents: number,\n    decodeInfo: DecodeInfo,\n    position: THREE.Vector2 | THREE.Vector3,\n    target: THREE.Vector3,\n    scaleHeight: boolean,\n    flipY: boolean = false\n) {\n    webMercatorTile2TargetWorld(extents, decodeInfo, position, target, scaleHeight, flipY);\n    target.sub(decodeInfo.center);\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ClippedVertex } from \"@here/harp-geometry/lib/ClipPolygon\";\nimport { ShapeUtils, Vector2 } from \"three\";\n\n/**\n * A class representing a ring of a polygon geometry.\n */\nexport class Ring {\n    /**\n     * The signed area of this `Ring`.\n     *\n     * @remarks\n     * The sign of the area depends on the projection and the axis orientation\n     * of the ring coordinates.\n     * For example, given a ring with `CW winding`: `area > 0` with Y-axis that grows downwards and `area < 0` otherwise.\n     */\n    readonly area: number;\n\n    /**\n     * The winding of this `Ring`.\n     *\n     * @remarks\n     * Derived from the sign of the `area` of this Ring.\n     */\n    readonly winding: boolean;\n\n    /**\n     * The vertex stride.\n     */\n    readonly vertexStride: number;\n\n    /**\n     * Creates a new `Ring`.\n     *\n     * @param points The coordinates of the rings.\n     * @param textureCoords The optional `Array` of texture coordinates.\n     * @param extents The extents of the tile bounds.\n     * @param hasClipInfo A flag indicating that vertices of this `Ring` may be clipped.\n     */\n    constructor(\n        readonly points: Vector2[],\n        readonly textureCoords?: Vector2[],\n        readonly extents: number = 4 * 1024,\n        readonly hasClipInfo: boolean = false\n    ) {\n        if (textureCoords !== undefined && textureCoords.length !== points.length) {\n            throw new Error(\n                `the array of texture coordinates must have the same number of elements of the array of points`\n            );\n        }\n\n        this.vertexStride = 2;\n\n        if (textureCoords !== undefined) {\n            this.vertexStride = this.vertexStride + 2;\n        }\n\n        this.area = ShapeUtils.area(this.points);\n        this.winding = this.area < 0;\n    }\n\n    /**\n     * Returns a flattened `Array` containing the position and texture coordinates of this `Ring`.\n     *\n     * @param array The target `Array`.\n     * @param offset Optional offset into the array.\n     */\n    toArray(array: number[] = [], offset: number = 0): number[] {\n        this.points.forEach((p, i) => p.toArray(array, offset + this.vertexStride * i));\n        this.textureCoords?.forEach((p, i) => p.toArray(array, offset + this.vertexStride * i + 2));\n        return array;\n    }\n\n    /**\n     * Tests if the edge connecting the vertex at `index` with\n     * the vertex at `index+1` should be connected by a line\n     * when stroking the polygon.\n     *\n     * @param index The index of the first vertex of the outline edge.\n     */\n    isProperEdge(index: number): boolean {\n        const extents = this.extents;\n        const nextIdx = (index + 1) % this.points.length;\n        const curr: ClippedVertex = this.points[index];\n        const next: ClippedVertex = this.points[nextIdx];\n\n        if (this.hasClipInfo) {\n            if (curr.x !== next.x && curr.y !== next.y) {\n                // `curr` and `next` must be connected with a line\n                // because they don't form a vertical or horizontal lines.\n                return true;\n            }\n\n            const currAtEdge = curr.x % this.extents === 0 || curr.y % this.extents === 0;\n\n            if (!currAtEdge) {\n                // the points are connected with a line\n                // because at least one of the points is not on\n                // the tile boundary.\n                return true;\n            }\n\n            const nextAtEdge = next.x % this.extents === 0 || next.y % this.extents === 0;\n\n            if (!nextAtEdge) {\n                // the points are connected with a line\n                // because at least one of the points is not on\n                // the tile boundary.\n                return true;\n            }\n\n            const currWasClipped = curr.isClipped === true;\n            const nextWasClipped = next.isClipped === true;\n\n            return !currWasClipped && !nextWasClipped;\n        }\n\n        return !(\n            (curr.x <= 0 && next.x <= 0) ||\n            (curr.x >= extents && next.x >= extents) ||\n            (curr.y <= 0 && next.y <= 0) ||\n            (curr.y >= extents && next.y >= extents)\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { StyleSetEvaluator } from \"@here/harp-datasource-protocol/index-decoder\";\n\nimport { OmvFeatureFilter } from \"./OmvDataFilter\";\n\n/**\n * An [[OmvFeatureFilter]] implementation that queries [[StyleSetEvaluator]]\n * if given layers/features should be processed.\n *\n * Used in [[OmvDecoder]] to skip processing of layers/features that doesn't\n * have associated rules in style.\n *\n * @see [[StyleSetEvaluator.wantsFeature]]\n * @see [[StyleSetEvaluator.wantsLayer]]\n */\nexport class StyleSetDataFilter implements OmvFeatureFilter {\n    hasKindFilter: boolean = false;\n\n    constructor(readonly styleSetEvaluator: StyleSetEvaluator) {}\n\n    wantsLayer(layer: string, level: number): boolean {\n        return this.styleSetEvaluator.wantsLayer(layer);\n    }\n\n    wantsPointFeature(layer: string): boolean {\n        return this.styleSetEvaluator.wantsFeature(layer, \"point\");\n    }\n\n    wantsLineFeature(layer: string): boolean {\n        return this.styleSetEvaluator.wantsFeature(layer, \"line\");\n    }\n\n    wantsPolygonFeature(layer: string): boolean {\n        return this.styleSetEvaluator.wantsFeature(layer, \"polygon\");\n    }\n\n    wantsKind(): boolean {\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    AttributeMap,\n    BufferAttribute,\n    composeTechniqueTextureName,\n    DecodedTile,\n    ExtrudedPolygonTechnique,\n    FillTechnique,\n    Geometry,\n    GeometryType,\n    getFeatureId,\n    getFeatureText,\n    Group,\n    IndexedTechnique,\n    InterleavedBufferAttribute,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isLabelRejectionLineTechnique,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isShaderTechnique,\n    isSolidLineTechnique,\n    isSpecialDashesLineTechnique,\n    isStandardTechnique,\n    isTextTechnique,\n    LineMarkerTechnique,\n    PathGeometry,\n    PoiGeometry,\n    PoiTechnique,\n    scaleHeight,\n    StyleColor,\n    Technique,\n    TextGeometry,\n    TextPathGeometry,\n    TextTechnique,\n    TextureCoordinateType,\n    textureCoordinateType\n} from \"@here/harp-datasource-protocol\";\nimport {\n    Env,\n    IMeshBuffers,\n    StyleSetEvaluator,\n    Value\n} from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    AttrEvaluationContext,\n    evaluateTechniqueAttr\n} from \"@here/harp-datasource-protocol/lib/TechniqueAttr\";\nimport { clipPolygon } from \"@here/harp-geometry/lib/ClipPolygon\";\nimport {\n    EdgeLengthGeometrySubdivisionModifier,\n    SubdivisionMode\n} from \"@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier\";\nimport { SphericalGeometrySubdivisionModifier } from \"@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier\";\nimport {\n    GeoBox,\n    GeoCoordinates,\n    normalizedEquirectangularProjection,\n    ProjectionType,\n    Vector3Like,\n    webMercatorProjection\n} from \"@here/harp-geoutils\";\nimport { LineGroup } from \"@here/harp-lines/lib/Lines\";\nimport { triangulateLine } from \"@here/harp-lines/lib/TriangulateLines\";\nimport { ExtrusionFeatureDefs } from \"@here/harp-materials/lib/MapMeshMaterialsDefs\";\nimport { assert, getOptionValue, LoggerManager, Math2D } from \"@here/harp-utils\";\nimport earcut from \"earcut\";\nimport * as THREE from \"three\";\n\nimport { DecodeInfo } from \"./DecodeInfo\";\nimport { ILineGeometry, IPolygonGeometry } from \"./IGeometryProcessor\";\nimport {\n    tile2world,\n    webMercatorTile2TargetTile,\n    webMercatorTile2TargetWorld,\n    world2tile\n} from \"./OmvUtils\";\nimport { Ring } from \"./Ring\";\n\nconst logger = LoggerManager.instance.create(\"OmvDecodedTileEmitter\");\n\nconst tempTileOrigin = new THREE.Vector3();\nconst tempVertNormal = new THREE.Vector3();\nconst tempFootDisp = new THREE.Vector3();\nconst tempRoofDisp = new THREE.Vector3();\n\nconst tmpV2 = new THREE.Vector2();\nconst tmpV2r = new THREE.Vector2();\nconst tmpV3 = new THREE.Vector3();\nconst tmpV3r = new THREE.Vector3();\nconst tmpV4 = new THREE.Vector3();\n\nconst tempP0 = new THREE.Vector2();\nconst tempP1 = new THREE.Vector2();\nconst tempPreviousTangent = new THREE.Vector2();\n\nconst tmpPointA = new THREE.Vector3();\nconst tmpPointB = new THREE.Vector3();\nconst tmpPointC = new THREE.Vector3();\nconst tmpPointD = new THREE.Vector3();\nconst tmpPointE = new THREE.Vector3();\nconst tmpLine = new THREE.Line3();\n\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text. Based on the estimated screen size of a tile.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n\n/**\n * Estimation \"fudge factor\", tweaking the size estimation to\n *\n * a) allow room for zooming in to the tile, and\n *\n * b) allow for some tilting, where the edge of a tile closer to the camera has more space.\n *\n * Useful values are between 0 (allow all labels), 0.5 (allow labels at twice the default display\n * size of the tile) and 1.0 (skip labels that would normally not be displayed at default tile\n * size).\n */\nconst SIZE_ESTIMATION_FACTOR = 0.5;\n\n/**\n * Maximum allowed corner angle inside a label path.\n */\nconst MAX_CORNER_ANGLE = Math.PI / 8;\n\n/**\n * Used to identify an invalid (or better: unused) array index.\n */\nconst INVALID_ARRAY_INDEX = -1;\n\nfunction createIndexBufferAttribute(\n    elements: ArrayLike<number>,\n    maxValue: number,\n    name: string = \"index\"\n): BufferAttribute {\n    const type = maxValue > 65535 ? \"uint32\" : \"uint16\";\n    const storage = type === \"uint32\" ? new Uint32Array(elements) : new Uint16Array(elements);\n    const buffer = storage.buffer;\n    return {\n        itemCount: 1,\n        name,\n        buffer,\n        type\n    };\n}\n\ninterface LinesGeometry {\n    type: GeometryType;\n    lines: LineGroup;\n    technique: number;\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n\n    /**\n     * Optional list of feature start indices. The indices point into the index attribute.\n     */\n    featureStarts?: number[];\n}\n\n// for tilezen by default extrude all buildings even those without height data\nclass MeshBuffers implements IMeshBuffers {\n    readonly positions: number[] = [];\n    readonly normals: number[] = [];\n    readonly textureCoordinates: number[] = [];\n    readonly colors: number[] = [];\n    readonly extrusionAxis: number[] = [];\n    readonly indices: number[] = [];\n    readonly edgeIndices: number[] = [];\n    readonly groups: Group[] = [];\n    readonly texts: number[] = [];\n    readonly pathLengths: number[] = [];\n    readonly stringCatalog: Array<string | undefined> = [];\n    readonly imageTextures: number[] = [];\n\n    /**\n     * Optional list of feature start indices. The indices point into the index attribute.\n     */\n    readonly featureStarts: number[] = [];\n\n    /**\n     * Optional list of edge feature start indices. The indices point into the edge index attribute.\n     */\n    readonly edgeFeatureStarts: number[] = [];\n\n    /**\n     * An optional list of additional data that can be used as additional data for the object\n     * picking.\n     */\n    readonly objInfos: AttributeMap[] = [];\n\n    /**\n     * Angle in degrees from north clockwise which represents the direction the icons can be\n     * shifted.\n     */\n    readonly offsetDirections: number[] = [];\n\n    constructor(readonly type: GeometryType) {}\n\n    addText(text: string) {\n        let index = this.stringCatalog.indexOf(text);\n\n        if (index < 0) {\n            index = this.stringCatalog.length;\n            this.stringCatalog.push(text);\n        }\n        return index;\n    }\n}\n\nenum LineType {\n    Simple,\n    Complex\n}\n\ntype TexCoordsFunction = (tilePos: THREE.Vector2, tileExtents: number) => THREE.Vector2;\nconst tmpColor = new THREE.Color();\n\n/**\n * Options for VectorTileDataEmitter, see {@link DecoderOptions} and {@link OmvDecoderOptions}.\n * @internal\n */\nexport interface VectorTileDataEmitterOptions {\n    gatherFeatureAttributes?: boolean;\n    skipShortLabels?: boolean;\n    enableElevationOverlay?: boolean;\n    languages?: string[];\n}\n\nexport class VectorTileDataEmitter {\n    // mapping from style index to mesh buffers\n    private readonly m_meshBuffers = new Map<number, MeshBuffers>();\n\n    private readonly m_geometries: Geometry[] = [];\n    private readonly m_textGeometries: TextGeometry[] = [];\n    private readonly m_textPathGeometries: TextPathGeometry[] = [];\n    private readonly m_pathGeometries: PathGeometry[] = [];\n    private readonly m_poiGeometries: PoiGeometry[] = [];\n    private readonly m_simpleLines: LinesGeometry[] = [];\n    private readonly m_solidLines: LinesGeometry[] = [];\n\n    private readonly m_sources: string[] = [];\n    private m_maxGeometryHeight: number = 0;\n    private m_minGeometryHeight: number = 0;\n\n    constructor(\n        private readonly m_decodeInfo: DecodeInfo,\n        private readonly m_styleSetEvaluator: StyleSetEvaluator,\n        private readonly m_options: VectorTileDataEmitterOptions = {}\n    ) {\n        this.m_options.gatherFeatureAttributes = m_options.gatherFeatureAttributes ?? false;\n        this.m_options.skipShortLabels = m_options.skipShortLabels ?? true;\n        this.m_options.enableElevationOverlay = m_options.enableElevationOverlay ?? false;\n    }\n\n    get projection() {\n        return this.m_decodeInfo.targetProjection;\n    }\n\n    get center() {\n        return this.m_decodeInfo.center;\n    }\n\n    /**\n     * Creates the Point of Interest geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The feature geometry in local webMercator coordinates.\n     * @param env - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     */\n    processPointFeature(\n        layer: string,\n        extents: number,\n        geometry: THREE.Vector3[],\n        context: AttrEvaluationContext,\n        techniques: IndexedTechnique[]\n    ): void {\n        const env = context.env;\n        this.processFeatureCommon(env);\n\n        const { tileKey, columnCount, rowCount } = this.m_decodeInfo;\n\n        // adjust the extents to ensure that points on the right and bottom edges\n        // of the tile are discarded.\n        const xExtent = tileKey.column + 1 < columnCount ? extents - 1 : extents;\n        const yExtent = tileKey.row + 1 < rowCount ? extents - 1 : extents;\n\n        // get the point positions (in tile space) that are inside the tile bounds.\n        const tilePositions = geometry.filter(p => {\n            return p.x >= 0 && p.x <= xExtent && p.y >= 0 && p.y <= yExtent;\n        });\n\n        if (tilePositions.length === 0) {\n            // nothing to do, no geometry within the tile bound.\n            return;\n        }\n\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n\n            const techniqueIndex = technique._index;\n            const meshBuffers = this.findOrCreateMeshBuffers(techniqueIndex, GeometryType.Point);\n\n            if (meshBuffers === undefined) {\n                continue;\n            }\n\n            const { positions, texts, imageTextures, objInfos, offsetDirections } = meshBuffers;\n\n            const shouldCreateTextGeometries =\n                isTextTechnique(technique) || isPoiTechnique(technique);\n\n            let imageTexture: string | undefined;\n            const wantsPoi = isPoiTechnique(technique);\n\n            if (wantsPoi) {\n                const poiTechnique = technique as PoiTechnique;\n                imageTexture = evaluateTechniqueAttr(context, poiTechnique.imageTexture);\n\n                // TODO: Move to decoder independent parts of code.\n                if (poiTechnique.poiName !== undefined) {\n                    imageTexture = evaluateTechniqueAttr(context, poiTechnique.poiName);\n                } else if (typeof poiTechnique.poiNameField === \"string\") {\n                    const poiNameFieldValue = env.lookup(poiTechnique.poiNameField) as string;\n                    imageTexture = poiNameFieldValue;\n                } else if (typeof poiTechnique.imageTextureField === \"string\") {\n                    const imageTextureValue = env.lookup(poiTechnique.imageTextureField) as string;\n                    imageTexture = composeTechniqueTextureName(imageTextureValue, poiTechnique);\n                }\n            }\n\n            const scaleHeights = scaleHeight(context, technique, this.m_decodeInfo.tileKey.level);\n            const featureId = getFeatureId(env.entries);\n            for (const pos of tilePositions) {\n                if (shouldCreateTextGeometries) {\n                    const textTechnique = technique as TextTechnique;\n                    const text = getFeatureText(context, textTechnique, this.m_options.languages);\n\n                    if (text !== undefined && text.length > 0) {\n                        texts.push(meshBuffers.addText(text));\n                    } else {\n                        texts.push(INVALID_ARRAY_INDEX);\n                    }\n                }\n\n                // Always store the position, otherwise the following POIs will be\n                // misplaced.\n                if (shouldCreateTextGeometries) {\n                    webMercatorTile2TargetWorld(\n                        extents,\n                        this.m_decodeInfo,\n                        pos,\n                        tmpV3,\n                        scaleHeights\n                    );\n                } else {\n                    webMercatorTile2TargetTile(\n                        extents,\n                        this.m_decodeInfo,\n                        pos,\n                        tmpV3,\n                        scaleHeights\n                    );\n                }\n\n                // For planar projection the world z coordinate (potentially scaled) is taken,\n                // for spherical projection the z coordinate in the source projection (no scaling needed) is taken:\n                const height = this.projection.type === ProjectionType.Planar ? tmpV3.z : pos.z;\n                if (height > this.m_maxGeometryHeight) {\n                    this.m_maxGeometryHeight = height;\n                } else if (height < this.m_minGeometryHeight) {\n                    this.m_minGeometryHeight = height;\n                }\n\n                positions.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                objInfos.push(this.m_options.gatherFeatureAttributes ? env.entries : featureId);\n                offsetDirections.push((env.lookup(\"offset_direction\") as number) ?? 0);\n\n                if (wantsPoi) {\n                    if (imageTexture === undefined) {\n                        imageTextures.push(INVALID_ARRAY_INDEX);\n                    } else {\n                        imageTextures.push(meshBuffers.addText(imageTexture));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * Creates the line geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The current feature containing the main geometry.\n     * @param env - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     */\n    processLineFeature(\n        layer: string,\n        extents: number,\n        geometry: ILineGeometry[],\n        context: AttrEvaluationContext,\n        techniques: IndexedTechnique[]\n    ): void {\n        const env = context.env;\n        this.processFeatureCommon(env);\n\n        const localLines: number[][] = []; // lines in target tile space.\n        const worldLines: number[][] = []; // lines in world space.\n        const uvs: number[][] = [];\n        const offsets: number[][] = [];\n        const projectedBoundingBox = this.m_decodeInfo.projectedBoundingBox;\n\n        let localLineSegments: number[][]; // lines in target tile space for special dashes.\n\n        const tileWidth = projectedBoundingBox.extents.x * 2;\n        const tileHeight = projectedBoundingBox.extents.y * 2;\n        const tileSizeWorld = Math.max(tileWidth, tileHeight);\n\n        let computeTexCoords: TexCoordsFunction | undefined;\n        let texCoordinateType: TextureCoordinateType | undefined;\n\n        const hasUntiledLines = geometry[0].untiledPositions !== undefined;\n        const scaleHeights = false; // No need to scale height, source data is 2D.\n\n        // If true, special handling for dashes is required (round and diamond shaped dashes).\n        let hasIndividualLineSegments = false;\n        let hasContinuousLineSegments = false;\n\n        // Check if any of the techniques needs texture coordinates\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n            if (!computeTexCoords) {\n                computeTexCoords = this.getComputeTexCoordsFunc(technique);\n                texCoordinateType = this.getTextureCoordinateType(technique);\n            } else {\n                // Support generation of only one type of texture coordinates.\n                const otherTexCoordType = this.getTextureCoordinateType(technique);\n                assert(otherTexCoordType === undefined || texCoordinateType === otherTexCoordType);\n            }\n\n            hasIndividualLineSegments =\n                hasIndividualLineSegments || isSpecialDashesLineTechnique(technique);\n\n            hasContinuousLineSegments = hasContinuousLineSegments || !hasIndividualLineSegments;\n        }\n\n        for (const polyline of geometry) {\n            // Compute the world position of the untiled line and its distance to the origin of the\n            // line to properly join lines.\n            const untiledLine: number[] = [];\n            let lineDist = 0;\n            if (hasUntiledLines) {\n                this.m_decodeInfo.targetProjection.projectPoint(\n                    polyline.untiledPositions![0],\n                    tmpV3r\n                );\n                polyline.untiledPositions!.forEach(pos => {\n                    // Calculate the distance to the next un-normalized point.\n                    this.m_decodeInfo.targetProjection.projectPoint(pos, tmpV3);\n                    lineDist += tmpV3.distanceTo(tmpV3r);\n                    tmpV3r.copy(tmpV3);\n\n                    // Pushed the normalized point for line matching.\n                    this.m_decodeInfo.targetProjection.projectPoint(pos.normalized(), tmpV3);\n                    untiledLine.push(tmpV3.x, tmpV3.y, tmpV3.z, lineDist);\n                });\n            }\n\n            // Add continuous line as individual segments to improve special dashes by overlapping\n            // their connecting vertices. The technique/style should defined round or rectangular\n            // caps.\n            if (hasIndividualLineSegments) {\n                localLineSegments = [];\n\n                // Compute length of whole line and offsets of individual segments.\n                let lineLength = 0;\n                const pointCount = polyline.positions.length;\n                if (pointCount > 1) {\n                    let lastSegmentOffset = 0;\n\n                    for (let i = 0; i < pointCount - 1; i++) {\n                        const localLine: number[] = [];\n                        const worldLine: number[] = [];\n                        const lineUvs: number[] = [];\n                        const segmentOffsets: number[] = [];\n\n                        const pos1 = polyline.positions[i];\n                        const pos2 = polyline.positions[i + 1];\n                        webMercatorTile2TargetWorld(\n                            extents,\n                            this.m_decodeInfo,\n                            pos1,\n                            tmpV3,\n                            scaleHeights\n                        );\n                        worldLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                        webMercatorTile2TargetWorld(\n                            extents,\n                            this.m_decodeInfo,\n                            pos2,\n                            tmpV4,\n                            scaleHeights\n                        );\n                        worldLine.push(tmpV4.x, tmpV4.y, tmpV4.z);\n\n                        if (computeTexCoords) {\n                            computeTexCoords(pos1, extents).toArray(lineUvs, lineUvs.length);\n                            computeTexCoords(pos2, extents).toArray(lineUvs, lineUvs.length);\n                        }\n                        if (hasUntiledLines) {\n                            // Find where in the [0...1] range relative to the line our current\n                            // vertex lies.\n                            let offset =\n                                this.findRelativePositionInLine(tmpV3, untiledLine) / lineDist;\n                            segmentOffsets.push(offset);\n                            offset = this.findRelativePositionInLine(tmpV4, untiledLine) / lineDist;\n                            segmentOffsets.push(offset);\n                        } else {\n                            segmentOffsets.push(lastSegmentOffset);\n\n                            // Compute length of segment and whole line to scale down later.\n                            const segmentLength = tmpV3.distanceTo(tmpV4);\n                            lineLength += segmentLength;\n                            lastSegmentOffset += segmentLength;\n                            segmentOffsets.push(lastSegmentOffset);\n                        }\n\n                        tmpV3.sub(this.m_decodeInfo.center);\n                        localLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                        tmpV4.sub(this.m_decodeInfo.center);\n                        localLine.push(tmpV4.x, tmpV4.y, tmpV4.z);\n\n                        localLineSegments!.push(localLine);\n                        worldLines.push(worldLine);\n                        uvs.push(lineUvs);\n                        offsets.push(segmentOffsets);\n                    }\n                }\n\n                if (!hasUntiledLines && lineLength > 0) {\n                    // Scale down each individual segment to range [0..1] for whole line.\n                    for (const segOffsets of offsets) {\n                        segOffsets.forEach((offs, index) => {\n                            segOffsets[index] = offs / lineLength;\n                        });\n                    }\n                }\n            }\n\n            // Add continuous lines\n            if (hasContinuousLineSegments) {\n                const localLine: number[] = [];\n                const worldLine: number[] = [];\n                const lineUvs: number[] = [];\n                const lineOffsets: number[] = [];\n                polyline.positions.forEach(pos => {\n                    webMercatorTile2TargetWorld(\n                        extents,\n                        this.m_decodeInfo,\n                        pos,\n                        tmpV3,\n                        scaleHeights\n                    );\n                    worldLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n\n                    if (computeTexCoords) {\n                        computeTexCoords(pos, extents).toArray(lineUvs, lineUvs.length);\n                    }\n                    if (hasUntiledLines) {\n                        // Find where in the [0...1] range relative to the line our current vertex\n                        // lines.\n                        const offset =\n                            this.findRelativePositionInLine(tmpV3, untiledLine) / lineDist;\n                        lineOffsets.push(offset);\n                    }\n                    tmpV3.sub(this.m_decodeInfo.center);\n                    localLine.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                });\n                localLines.push(localLine);\n                worldLines.push(worldLine);\n                uvs.push(lineUvs);\n                offsets.push(lineOffsets);\n            }\n        }\n\n        const wantCircle = this.m_decodeInfo.tileKey.level >= 11;\n\n        for (const technique of techniques) {\n            if (technique === undefined) {\n                continue;\n            }\n            const techniqueIndex = technique._index;\n            const techniqueName = technique.name;\n\n            if (isLineTechnique(technique) || isSolidLineTechnique(technique)) {\n                const lineGeometry = isLineTechnique(technique)\n                    ? this.m_simpleLines\n                    : this.m_solidLines;\n\n                const lineType = isLineTechnique(technique) ? LineType.Simple : LineType.Complex;\n\n                if (hasIndividualLineSegments) {\n                    assert(\n                        localLineSegments! !== undefined,\n                        \"OmvDecodedTileEmitter#processLineFeature: \" +\n                            \"Internal error - No localLineSegments\"\n                    );\n\n                    this.applyLineTechnique(\n                        lineGeometry,\n                        technique,\n                        techniqueIndex,\n                        lineType,\n                        env.entries,\n                        localLineSegments!,\n                        context,\n                        this.getTextureCoordinateType(technique) ? uvs : undefined,\n                        offsets\n                    );\n                }\n                if (localLines.length > 0) {\n                    this.applyLineTechnique(\n                        lineGeometry,\n                        technique,\n                        techniqueIndex,\n                        lineType,\n                        env.entries,\n                        localLines,\n                        context,\n                        this.getTextureCoordinateType(technique) ? uvs : undefined,\n                        hasUntiledLines ? offsets : undefined\n                    );\n                }\n            } else if (\n                isTextTechnique(technique) ||\n                isPoiTechnique(technique) ||\n                isLineMarkerTechnique(technique)\n            ) {\n                const textTechnique = technique as TextTechnique;\n                const text = getFeatureText(context, textTechnique, this.m_options.languages);\n\n                if (text === undefined || text.length === 0) {\n                    continue;\n                }\n                let validLines: number[][] = [];\n\n                if (this.m_options.skipShortLabels) {\n                    // Filter the lines, keep only those that are long enough for labelling. Also,\n                    // split jagged label paths to keep processing and rendering only those that\n                    // have no sharp corners, which would not be rendered anyway.\n\n                    const worldUnitsPerPixel = tileSizeWorld / this.m_decodeInfo.tileSizeOnScreen;\n                    const minEstimatedLabelLength =\n                        MIN_AVERAGE_CHAR_WIDTH *\n                        text.length *\n                        worldUnitsPerPixel *\n                        SIZE_ESTIMATION_FACTOR;\n                    const minEstimatedLabelLengthSqr =\n                        minEstimatedLabelLength * minEstimatedLabelLength;\n\n                    validLines = this.splitJaggyLines(\n                        worldLines,\n                        minEstimatedLabelLengthSqr,\n                        MAX_CORNER_ANGLE\n                    );\n                } else {\n                    validLines = worldLines;\n                }\n\n                if (validLines.length === 0) {\n                    continue;\n                }\n\n                if (isTextTechnique(technique)) {\n                    if (text === undefined) {\n                        continue;\n                    }\n                    for (const path of validLines) {\n                        const pathLengthSqr = Math2D.computeSquaredLineLength(path);\n                        this.m_textPathGeometries.push({\n                            technique: techniqueIndex,\n                            path,\n                            pathLengthSqr,\n                            text: String(text),\n                            objInfos: this.m_options.gatherFeatureAttributes\n                                ? env.entries\n                                : getFeatureId(env.entries)\n                        });\n                    }\n                } else {\n                    const lineMarkerTechnique = technique as LineMarkerTechnique;\n\n                    let imageTexture = evaluateTechniqueAttr(\n                        context,\n                        lineMarkerTechnique.imageTexture\n                    );\n\n                    // TODO: `imageTextureField` and `imageTexturePrefix` and `imageTexturePostfix`\n                    // are now deprecated\n\n                    // TODO: Move to decoder independent parts of code.\n                    if (typeof lineMarkerTechnique.imageTextureField === \"string\") {\n                        const imageTextureValue = env.lookup(lineMarkerTechnique.imageTextureField);\n                        imageTexture = imageTextureValue as string;\n                        if (typeof lineMarkerTechnique.imageTexturePrefix === \"string\") {\n                            imageTexture = lineMarkerTechnique.imageTexturePrefix + imageTexture;\n                        }\n                        if (typeof lineMarkerTechnique.imageTexturePostfix === \"string\") {\n                            imageTexture = imageTexture + lineMarkerTechnique.imageTexturePostfix;\n                        }\n                    }\n\n                    for (const aLine of validLines) {\n                        this.m_poiGeometries.push({\n                            technique: techniqueIndex,\n                            positions: {\n                                name: \"position\",\n                                type: \"float\",\n                                buffer: new Float64Array(aLine).buffer,\n                                itemCount: 3\n                            },\n                            texts: [0],\n                            stringCatalog: [text, imageTexture],\n                            imageTextures: [1],\n                            objInfos: this.m_options.gatherFeatureAttributes\n                                ? [env.entries]\n                                : [getFeatureId(env.entries)]\n                        });\n                    }\n                }\n            } else if (isLabelRejectionLineTechnique(technique)) {\n                for (const path of worldLines) {\n                    const worldPath: Vector3Like[] = [];\n                    for (let i = 0; i < path.length; i += 3) {\n                        worldPath.push(new THREE.Vector3().fromArray(path, i) as Vector3Like);\n                    }\n                    this.m_pathGeometries.push({\n                        path: worldPath\n                    });\n                }\n            } else if (isExtrudedLineTechnique(technique)) {\n                const meshBuffers = this.findOrCreateMeshBuffers(\n                    techniqueIndex,\n                    GeometryType.ExtrudedLine\n                );\n                if (meshBuffers === undefined) {\n                    continue;\n                }\n                const { positions, indices, groups, featureStarts, objInfos } = meshBuffers;\n                const start = indices.length;\n\n                const lineWidth = evaluateTechniqueAttr<number>(context, technique.lineWidth);\n\n                if (lineWidth === undefined) {\n                    continue;\n                }\n\n                const techniqueCaps = evaluateTechniqueAttr<string>(\n                    context,\n                    technique.caps,\n                    \"Circle\"\n                );\n\n                const addCircle = wantCircle && techniqueCaps === \"Circle\";\n\n                localLines.forEach(aLine => {\n                    triangulateLine(aLine, lineWidth, positions, indices, addCircle);\n                    featureStarts.push(start);\n                    objInfos.push(\n                        this.m_options.gatherFeatureAttributes\n                            ? env.entries\n                            : getFeatureId(env.entries)\n                    );\n                });\n\n                const count = indices.length - start;\n                groups.push({ start, count, technique: techniqueIndex });\n            } else {\n                logger.warn(\n                    `OmvDecodedTileEmitter#processLineFeature: Invalid line technique\n                     ${techniqueName} for layer: ${env.entries.$layer} `\n                );\n            }\n        }\n    }\n\n    /**\n     * Creates the polygons geometries for the given feature.\n     *\n     * @param layer - Tile's layer to be processed.\n     * @param extents - Tile's layer extents.\n     * @param geometry - The current feature containing the main geometry.\n     * @param feature - The [[MapEnv]] containing the environment information for the map.\n     * @param techniques - The array of [[Technique]] that will be applied to the geometry.\n     */\n    processPolygonFeature(\n        layer: string,\n        extents: number,\n        geometry: IPolygonGeometry[],\n        context: AttrEvaluationContext,\n        techniques: IndexedTechnique[]\n    ): void {\n        const env = context.env;\n        this.processFeatureCommon(env);\n\n        const scaleHeights = false; // No need to scale height, source data is 2D.\n\n        techniques.forEach(technique => {\n            if (technique === undefined) {\n                return;\n            }\n\n            const techniqueIndex = technique._index;\n\n            if (techniqueIndex === undefined) {\n                throw new Error(\n                    \"OmvDecodedTileEmitter#processPolygonFeature: \" +\n                        \"Internal error - No technique index\"\n                );\n            }\n\n            let objectBounds: THREE.Box3 | undefined;\n\n            const bbox = env.lookup(\"bbox\");\n            if (Array.isArray(bbox)) {\n                const [west, south, east, north] = bbox;\n                const geoBox = new GeoBox(\n                    new GeoCoordinates(south, west),\n                    new GeoCoordinates(north, east)\n                );\n                objectBounds = new THREE.Box3();\n                webMercatorProjection.projectBox(geoBox, objectBounds);\n            }\n\n            const polygons: Ring[][] = [];\n\n            const isExtruded = isExtrudedPolygonTechnique(technique);\n            const isFilled = isFillTechnique(technique);\n            const isStandard = isStandardTechnique(technique);\n\n            const isPolygon =\n                isExtruded ||\n                isFilled ||\n                isStandard ||\n                (isShaderTechnique(technique) && technique.primitive === \"mesh\");\n\n            const computeTexCoords = this.getComputeTexCoordsFunc(technique, objectBounds);\n\n            const shouldClipPolygons = isPolygon && !isExtruded;\n\n            for (const polygon of geometry) {\n                const rings: Ring[] = [];\n                for (let i = 0; i < polygon.rings.length; i++) {\n                    const isExterior = i === 0;\n                    let ringCoords: THREE.Vector2[] = polygon.rings[i];\n\n                    // Disable clipping for the polygon geometries\n                    // rendered using the extruded-polygon technique.\n                    // We can't clip these polygons for now because\n                    // otherwise we could break the current assumptions\n                    // used to add oultines around the extruded geometries.\n                    if (shouldClipPolygons) {\n                        // Quick test to avoid clipping if all the coords\n                        // of the current polygon are inside the tile bounds.\n                        const hasCoordsOutsideTileBounds = ringCoords.some(\n                            p => p.x < 0 || p.x > extents || p.y < 0 || p.y > extents\n                        );\n                        if (hasCoordsOutsideTileBounds) {\n                            ringCoords = clipPolygon(ringCoords, extents);\n                        }\n                    }\n\n                    const area = THREE.ShapeUtils.area(ringCoords);\n\n                    // According to MVT spec, the rings defining a polygon follow this layout:\n                    // [[ext-ring], seq([int-ring])]\n                    //\n                    // For example:\n                    // ┌───────ext1───────┐\n                    // │                  │\n                    // │  ┌────hole────┐  │\n                    // │  │            │  │\n                    // │  │            │  │    w:CW     w:CCW\n                    // │  │            │  │   [[ext1], [hole]]\n                    // │  │            │  │\n                    // │  │            │  │\n                    // │  │            │  │\n                    // │  └──────>─────┘  │\n                    // │                  │\n                    // └─────────<────────┘\n                    // So, if one exterior ring get clipped to a zero-area polygon we\n                    // can imply that all the inner rings collapsed as well.\n                    // As per spec, all the inner rings must enclosed within the exterior ring.\n                    // Using this assumption, we can skip the whole polygon.\n                    if (isExterior && area === 0) {\n                        break;\n                    }\n\n                    // For holes, push the current ring only if it has a non-zero area\n                    if (area !== 0) {\n                        let textureCoords: THREE.Vector2[] | undefined;\n\n                        if (computeTexCoords !== undefined) {\n                            textureCoords = ringCoords.map(coord =>\n                                computeTexCoords(coord, extents)\n                            );\n                        }\n\n                        rings.push(\n                            new Ring(ringCoords, textureCoords, extents, shouldClipPolygons)\n                        );\n                    }\n                }\n\n                if (rings.length > 0) {\n                    polygons.push(rings);\n                }\n            }\n\n            const isLine = isSolidLineTechnique(technique) || isLineTechnique(technique);\n            if (isPolygon) {\n                this.applyPolygonTechnique(polygons, technique, techniqueIndex, context, extents);\n            } else if (isLine) {\n                const lineGeometry =\n                    technique.name === \"line\" ? this.m_simpleLines : this.m_solidLines;\n\n                const lineType = technique.name === \"line\" ? LineType.Simple : LineType.Complex;\n\n                // Use individual line segments instead of a continuous line in special cases (round\n                // and diamond shaped dashes).\n                const needIndividualLineSegments = isSpecialDashesLineTechnique(technique);\n\n                polygons.forEach(rings => {\n                    const lines: number[][] = [];\n                    const offsets: number[][] | undefined = needIndividualLineSegments\n                        ? []\n                        : undefined;\n                    rings.forEach(ring => {\n                        const length = ring.points.length;\n                        let line: number[] = [];\n\n                        // Compute length of whole line and offsets of individual segments.\n                        let ringLength = 0;\n                        let lastSegmentOffset = 0;\n                        let segmentOffsets: number[] | undefined = needIndividualLineSegments\n                            ? []\n                            : undefined;\n\n                        for (let i = 0; i < length; ++i) {\n                            if (needIndividualLineSegments && line.length > 0) {\n                                // Allocate a line for every segment.\n                                line = [];\n                                segmentOffsets = [];\n                            }\n\n                            const nextIdx = (i + 1) % length;\n                            const curr = ring.points[i];\n                            const next = ring.points[nextIdx];\n\n                            const properEdge = ring.isProperEdge(i);\n\n                            if (!properEdge && line.length !== 0) {\n                                lines.push(line);\n                                line = [];\n                            } else if (properEdge && line.length === 0) {\n                                webMercatorTile2TargetTile(\n                                    extents,\n                                    this.m_decodeInfo,\n                                    tmpV2.copy(curr),\n                                    tmpV3,\n                                    scaleHeights\n                                );\n                                line.push(tmpV3.x, tmpV3.y, tmpV3.z);\n\n                                if (needIndividualLineSegments) {\n                                    // Add next point as the end point of this line segment.\n                                    webMercatorTile2TargetTile(\n                                        extents,\n                                        this.m_decodeInfo,\n                                        tmpV2.copy(next),\n                                        tmpV4,\n                                        scaleHeights\n                                    );\n                                    line.push(tmpV4.x, tmpV4.y, tmpV4.z);\n\n                                    segmentOffsets!.push(lastSegmentOffset);\n\n                                    // Compute length of segment and whole line to scale down later.\n                                    const segmentLength = tmpV3.distanceTo(tmpV4);\n                                    ringLength += segmentLength;\n                                    lastSegmentOffset += segmentLength;\n                                    segmentOffsets!.push(lastSegmentOffset);\n                                }\n                            }\n                            if (properEdge && !needIndividualLineSegments) {\n                                webMercatorTile2TargetTile(\n                                    extents,\n                                    this.m_decodeInfo,\n                                    tmpV2.copy(next),\n                                    tmpV3,\n                                    scaleHeights\n                                );\n                                line.push(tmpV3.x, tmpV3.y, tmpV3.z);\n                            }\n\n                            if (needIndividualLineSegments && line.length > 0 && ringLength > 0) {\n                                // Scale down each individual segment to range [0..1] for the whole\n                                // line.\n                                segmentOffsets!.forEach((offs, index) => {\n                                    segmentOffsets![index] = offs / ringLength;\n                                });\n\n                                // Close the line segment as a single line.\n                                lines.push(line);\n                                offsets!.push(segmentOffsets!);\n                            }\n                        }\n\n                        if (!needIndividualLineSegments && line.length > 0) {\n                            lines.push(line);\n                        }\n                    });\n\n                    if (lines.length === 0) {\n                        return;\n                    }\n\n                    this.applyLineTechnique(\n                        lineGeometry,\n                        technique,\n                        techniqueIndex,\n                        lineType,\n                        env.entries,\n                        lines,\n                        context,\n                        undefined,\n                        offsets!\n                    );\n                });\n            }\n        });\n    }\n\n    /**\n     * Creates the geometries that belongs to the [[Tile].\n     *\n     * @returns The [[DecodedTile]]\n     */\n    getDecodedTile(): DecodedTile {\n        this.createGeometries();\n        this.processSimpleLines(this.m_simpleLines);\n        this.processLines(this.m_solidLines);\n\n        const decodedTile: DecodedTile = {\n            techniques: this.m_styleSetEvaluator.decodedTechniques,\n            geometries: this.m_geometries,\n            decodeTime: undefined\n        };\n        if (this.m_textGeometries.length > 0) {\n            decodedTile.textGeometries = this.m_textGeometries;\n        }\n        if (this.m_poiGeometries.length > 0) {\n            decodedTile.poiGeometries = this.m_poiGeometries;\n        }\n        if (this.m_textPathGeometries.length > 0) {\n            decodedTile.textPathGeometries = this.m_textPathGeometries;\n        }\n        if (this.m_pathGeometries.length > 0) {\n            decodedTile.pathGeometries = this.m_pathGeometries;\n        }\n        if (this.m_sources.length !== 0) {\n            decodedTile.copyrightHolderIds = this.m_sources;\n        }\n        decodedTile.maxGeometryHeight = this.m_maxGeometryHeight;\n        decodedTile.minGeometryHeight = this.m_minGeometryHeight;\n        return decodedTile;\n    }\n\n    /**\n     * Split the lines array into multiple parts if there are sharp corners. Reject parts that are\n     * too short to display the label text.\n     *\n     * @param {number[][]} lines Array containing the points of the paths.\n     * @param {number} minEstimatedLabelLengthSqr Minimum label size squared.\n     * @param {number} maxCornerAngle Maximum angle between consecutive path segments in radians.\n     * @returns The split and filtered lines array.\n     */\n    protected splitJaggyLines(\n        lines: number[][],\n        minEstimatedLabelLengthSqr: number,\n        maxCornerAngle: number\n    ): number[][] {\n        const validLines: number[][] = [];\n\n        const computeBoundingBoxSizeSqr = (\n            aLine: number[],\n            startIndex: number,\n            endIndex: number\n        ): number => {\n            let minX = Number.MAX_SAFE_INTEGER;\n            let maxX = Number.MIN_SAFE_INTEGER;\n            let minY = Number.MAX_SAFE_INTEGER;\n            let maxY = Number.MIN_SAFE_INTEGER;\n            for (let i = startIndex; i < endIndex; i += 3) {\n                const x = aLine[i];\n                const y = aLine[i + 1];\n                if (x < minX) {\n                    minX = x;\n                }\n                if (x > maxX) {\n                    maxX = x;\n                }\n                if (y < minY) {\n                    minY = y;\n                }\n                if (y > maxY) {\n                    maxY = y;\n                }\n            }\n\n            return (maxX - minX) * (maxX - minX) + (maxY - minY) * (maxY - minY);\n        };\n\n        // Work on a copy of the path.\n        const pathsToCheck = lines.slice();\n\n        while (pathsToCheck.length > 0) {\n            const path = pathsToCheck.pop();\n\n            if (path === undefined || path.length < 6) {\n                continue;\n            }\n\n            let splitIndex = -1;\n\n            for (let i = 0; i < path.length - 3; i += 3) {\n                tempP0.set(path[i], path[i + 1]);\n                tempP1.set(path[i + 3], path[i + 4]);\n                const tangent = tempP1.sub(tempP0).normalize();\n\n                if (i > 0) {\n                    const theta = Math.atan2(\n                        tempPreviousTangent.x * tangent.y - tangent.x * tempPreviousTangent.y,\n                        tangent.dot(tempPreviousTangent)\n                    );\n\n                    if (Math.abs(theta) > maxCornerAngle) {\n                        splitIndex = i;\n                        break;\n                    }\n                }\n                tempPreviousTangent.set(tangent.x, tangent.y);\n            }\n\n            if (splitIndex > 0) {\n                // Estimate if the first part of the path is long enough for the label.\n                const firstPathLengthSqr = computeBoundingBoxSizeSqr(path, 0, splitIndex + 3);\n                // Estimate if the second part of the path is long enough for the label.\n                const secondPathLengthSqr = computeBoundingBoxSizeSqr(\n                    path,\n                    splitIndex,\n                    path.length\n                );\n\n                if (firstPathLengthSqr > minEstimatedLabelLengthSqr) {\n                    // Split off the valid first path points with a clone of the path.\n                    validLines.push(path.slice(0, splitIndex + 3));\n                }\n\n                if (secondPathLengthSqr > minEstimatedLabelLengthSqr) {\n                    // Now process the second part of the path, it may have to be split\n                    // again.\n                    pathsToCheck.push(path.slice(splitIndex));\n                }\n            } else {\n                // Estimate if the path is long enough for the label, otherwise ignore\n                // it for rendering text. First, compute the bounding box in world\n                // coordinates.\n                const pathLengthSqr = computeBoundingBoxSizeSqr(path, 0, path.length);\n\n                if (pathLengthSqr > minEstimatedLabelLengthSqr) {\n                    validLines.push(path);\n                }\n            }\n        }\n\n        return validLines;\n    }\n\n    private getTextureCoordinateType(technique: Technique): TextureCoordinateType | undefined {\n        // Set TileSpace coordinate type to generate texture coordinates for the displacement map\n        // used in elevation overlay.\n        if (\n            (isFillTechnique(technique) ||\n                isSolidLineTechnique(technique) ||\n                isExtrudedPolygonTechnique(technique)) &&\n            this.m_options.enableElevationOverlay\n        ) {\n            return TextureCoordinateType.TileSpace;\n        }\n\n        return textureCoordinateType(technique);\n    }\n\n    private getComputeTexCoordsFunc(\n        technique: Technique,\n        objectBounds?: THREE.Box3\n    ): TexCoordsFunction | undefined {\n        const texCoordType = this.getTextureCoordinateType(technique);\n\n        switch (texCoordType) {\n            case TextureCoordinateType.TileSpace:\n                return (tilePos: THREE.Vector2, tileExtents: number): THREE.Vector2 => {\n                    const uv = tilePos.clone().divideScalar(tileExtents);\n                    uv.y = 1 - uv.y;\n                    return uv;\n                };\n\n            case TextureCoordinateType.EquirectangularSpace:\n                return (tilePos: THREE.Vector2, extents: number): THREE.Vector2 => {\n                    const worldPos = tile2world(extents, this.m_decodeInfo, tilePos, false, tmpV3r);\n                    const uv = normalizedEquirectangularProjection.reprojectPoint(\n                        webMercatorProjection,\n                        worldPos\n                    );\n                    return new THREE.Vector2(uv.x, uv.y);\n                };\n\n            case TextureCoordinateType.FeatureSpace:\n                if (!objectBounds) {\n                    return undefined;\n                }\n                return (tilePos: THREE.Vector2, extents: number): THREE.Vector2 => {\n                    const worldPos = tile2world(extents, this.m_decodeInfo, tilePos, false, tmpV3r);\n                    const uv = new THREE.Vector2(worldPos.x, worldPos.y);\n                    if (objectBounds) {\n                        uv.x -= objectBounds.min.x;\n                        uv.y -= objectBounds.min.y;\n                        uv.x /= objectBounds.max.x - objectBounds.min.x;\n                        uv.y /= objectBounds.max.y - objectBounds.min.y;\n                    }\n                    uv.y = 1 - uv.y;\n                    return uv;\n                };\n\n            default:\n                return undefined;\n        }\n    }\n\n    private applyLineTechnique(\n        linesGeometry: LinesGeometry[],\n        technique: IndexedTechnique,\n        techniqueIndex: number,\n        lineType = LineType.Complex,\n        featureAttributes: AttributeMap,\n        lines: number[][],\n        context: AttrEvaluationContext,\n        uvs?: number[][],\n        offsets?: number[][]\n    ): void {\n        let lineGroup: LineGroup;\n        const lineGroupGeometries = linesGeometry.find(aLine => aLine.technique === techniqueIndex);\n        const hasNormalsAndUvs = uvs !== undefined;\n        if (lineGroupGeometries === undefined) {\n            lineGroup = new LineGroup(hasNormalsAndUvs, undefined, lineType === LineType.Simple);\n            const aLine: LinesGeometry = {\n                type: lineType === LineType.Complex ? GeometryType.SolidLine : GeometryType.Line,\n                technique: techniqueIndex,\n                lines: lineGroup\n            };\n\n            if (this.m_options.gatherFeatureAttributes) {\n                aLine.objInfos = [featureAttributes];\n                aLine.featureStarts = [0];\n            }\n\n            linesGeometry.push(aLine);\n        } else {\n            lineGroup = lineGroupGeometries.lines;\n\n            if (\n                this.m_options.gatherFeatureAttributes &&\n                lineGroupGeometries.objInfos &&\n                lineGroupGeometries.featureStarts\n            ) {\n                // Add ID to tag the geometry, also provide the current length of the index\n                // attribute\n                lineGroupGeometries.objInfos.push(featureAttributes);\n                lineGroupGeometries.featureStarts.push(lineGroup.indices.length);\n            }\n        }\n        let i = 0;\n        lines.forEach(aLine => {\n            lineGroup.add(\n                this.m_decodeInfo.center,\n                aLine,\n                this.projection,\n                offsets ? offsets[i] : undefined,\n                uvs ? uvs[i] : undefined\n            );\n            i++;\n        });\n    }\n\n    private applyPolygonTechnique(\n        polygons: Ring[][],\n        technique: Technique,\n        techniqueIndex: number,\n        context: AttrEvaluationContext,\n        extents: number\n    ): void {\n        if (polygons.length === 0) {\n            return;\n        }\n\n        const isExtruded = isExtrudedPolygonTechnique(technique);\n\n        const geometryType = isExtruded ? GeometryType.ExtrudedPolygon : GeometryType.Polygon;\n        const meshBuffers = this.findOrCreateMeshBuffers(techniqueIndex, geometryType);\n\n        if (meshBuffers === undefined) {\n            return;\n        }\n\n        const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n        const fillTechnique = technique as FillTechnique;\n        const boundaryWalls = extrudedPolygonTechnique.boundaryWalls === true;\n\n        const isFilled = isFillTechnique(technique);\n        const texCoordType = this.getTextureCoordinateType(technique);\n\n        let height = evaluateTechniqueAttr<number>(context, extrudedPolygonTechnique.height);\n\n        let floorHeight = evaluateTechniqueAttr<number>(\n            context,\n            extrudedPolygonTechnique.floorHeight\n        );\n\n        if (height === undefined) {\n            // Get the height values for the footprint and extrusion.\n            const featureHeight = context.env.lookup(\"height\") as number;\n            const styleSetDefaultHeight = evaluateTechniqueAttr<number>(\n                context,\n                extrudedPolygonTechnique.defaultHeight\n            );\n            height =\n                featureHeight !== undefined\n                    ? featureHeight\n                    : styleSetDefaultHeight !== undefined\n                    ? styleSetDefaultHeight\n                    : 0;\n        }\n\n        if (floorHeight === undefined) {\n            const featureMinHeight = context.env.lookup(\"min_height\") as number;\n            floorHeight = featureMinHeight !== undefined && !isFilled ? featureMinHeight : 0;\n        }\n\n        // Prevent that extruded buildings are completely flat (can introduce errors in normal\n        // computation and extrusion).\n        height = Math.max(floorHeight + ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT, height);\n\n        const tileLevel = this.m_decodeInfo.tileKey.level;\n\n        const scaleHeights =\n            isExtruded && scaleHeight(context, extrudedPolygonTechnique, tileLevel);\n\n        this.m_decodeInfo.tileBounds.getCenter(tempTileOrigin);\n\n        const {\n            positions,\n            normals,\n            textureCoordinates,\n            colors,\n            extrusionAxis,\n            indices,\n            edgeIndices,\n            groups\n        } = meshBuffers;\n\n        const isSpherical = this.m_decodeInfo.targetProjection.type === ProjectionType.Spherical;\n\n        const edgeWidth = isExtruded\n            ? extrudedPolygonTechnique.lineWidth ?? 0.0\n            : isFilled\n            ? fillTechnique.lineWidth ?? 0.0\n            : 0.0;\n        const hasEdges = typeof edgeWidth === \"number\" ? edgeWidth > 0.0 : true;\n\n        let color: THREE.Color | undefined;\n        if (isExtrudedPolygonTechnique(technique)) {\n            if (getOptionValue(technique.vertexColors, false)) {\n                let colorValue = evaluateTechniqueAttr<StyleColor>(context, technique.color);\n                if (colorValue === undefined) {\n                    const featureColor = context.env.lookup(\"color\");\n                    if (this.isColorStringValid(featureColor)) {\n                        colorValue = String(featureColor);\n                    }\n                }\n                if (colorValue === undefined) {\n                    colorValue = evaluateTechniqueAttr<number | string>(\n                        context,\n                        technique.defaultColor,\n                        0x000000\n                    );\n                }\n\n                if (colorValue === undefined) {\n                    colorValue = 0x000000;\n                }\n                tmpColor.set(colorValue as any);\n\n                color = tmpColor;\n            }\n        }\n\n        for (const polygon of polygons) {\n            const startIndexCount = indices.length;\n            const edgeStartIndexCount = edgeIndices.length;\n\n            // Iterate over the exterior ring of the current polygon\n            const vertices: number[] = [];\n            const polygonBaseVertex = positions.length / 3;\n            const exteriorRing = polygon[0];\n\n            const featureStride = exteriorRing.vertexStride;\n            const vertexStride = featureStride + 2;\n\n            // The exterior ring is always the first\n            for (let i = 0; i < exteriorRing.points.length; ++i) {\n                const point = exteriorRing.points[i];\n\n                // Invert the Y component to preserve the correct winding without transforming\n                // from webMercator's local to global space.\n                vertices.push(point.x, -point.y);\n\n                if (exteriorRing.textureCoords !== undefined) {\n                    vertices.push(exteriorRing.textureCoords[i].x, exteriorRing.textureCoords[i].y);\n                }\n\n                const nextIdx = (i + 1) % exteriorRing.points.length;\n\n                const properEdge = exteriorRing.isProperEdge(i);\n\n                // Calculate nextEdge and nextWall.\n                vertices.push(\n                    properEdge ? nextIdx : -1,\n                    boundaryWalls || properEdge ? nextIdx : -1\n                );\n            }\n\n            // Iterate over the inner rings - if any\n            const holes: number[] = [];\n            let ringIndex = 1;\n            while (ringIndex < polygon.length) {\n                const vertexOffset = vertices.length / vertexStride;\n                holes.push(vertexOffset);\n\n                const hole = polygon[ringIndex++];\n                for (let i = 0; i < hole.points.length; ++i) {\n                    const nextIdx = (i + 1) % hole.points.length;\n                    const point = hole.points[i];\n\n                    // Invert the Y component to preserve the correct winding without\n                    // transforming from webMercator's local to global space.\n                    vertices.push(point.x, -point.y);\n\n                    if (hole.textureCoords !== undefined) {\n                        vertices.push(hole.textureCoords[i].x, hole.textureCoords[i].y);\n                    }\n\n                    // Calculate nextEdge and nextWall.\n                    const insideExtents = hole.isProperEdge(i);\n\n                    vertices.push(\n                        insideExtents ? vertexOffset + nextIdx : -1,\n                        boundaryWalls || insideExtents ? vertexOffset + nextIdx : -1\n                    );\n                }\n            }\n\n            try {\n                // Triangulate the footprint polyline.\n                const triangles = earcut(vertices, holes, vertexStride);\n                const originalVertexCount = vertices.length / vertexStride;\n\n                // Subdivide for spherical projections if needed.\n                if (isSpherical) {\n                    const geom = new THREE.BufferGeometry();\n\n                    const positionArray = [];\n                    const uvArray = [];\n                    const edgeArray = [];\n                    const wallArray = [];\n\n                    // Transform to global webMercator coordinates to be able to reproject to\n                    // sphere.\n                    for (let i = 0; i < vertices.length; i += vertexStride) {\n                        const worldPos = tile2world(\n                            extents,\n                            this.m_decodeInfo,\n                            tmpV2.set(vertices[i], vertices[i + 1]),\n                            true,\n                            tmpV3r\n                        );\n                        positionArray.push(worldPos.x, worldPos.y, 0);\n                        if (texCoordType !== undefined) {\n                            uvArray.push(vertices[i + 2], vertices[i + 3]);\n                        }\n                        edgeArray.push(vertices[i + featureStride]);\n                        wallArray.push(vertices[i + featureStride + 1]);\n                    }\n\n                    // Create the temporary geometry used for subdivision.\n                    const posAttr = new THREE.BufferAttribute(new Float32Array(positionArray), 3);\n                    geom.setAttribute(\"position\", posAttr);\n                    let uvAttr: THREE.BufferAttribute | undefined;\n                    if (texCoordType !== undefined) {\n                        uvAttr = new THREE.BufferAttribute(new Float32Array(uvArray), 2);\n                        geom.setAttribute(\"uv\", uvAttr);\n                    }\n                    const edgeAttr = new THREE.BufferAttribute(new Float32Array(edgeArray), 1);\n                    geom.setAttribute(\"edge\", edgeAttr);\n                    const wallAttr = new THREE.BufferAttribute(new Float32Array(wallArray), 1);\n                    geom.setAttribute(\"wall\", edgeAttr);\n                    const index = createIndexBufferAttribute(triangles, posAttr.count - 1);\n                    const indexAttr =\n                        index.type === \"uint32\"\n                            ? new THREE.Uint32BufferAttribute(index.buffer, 1)\n                            : new THREE.Uint16BufferAttribute(index.buffer, 1);\n                    geom.setIndex(indexAttr);\n\n                    // Increase tesselation of polygons for certain zoom levels\n                    // to remove mixed LOD cracks\n                    const zoomLevel = this.m_decodeInfo.tileKey.level;\n                    if (zoomLevel >= 3 && zoomLevel < 9) {\n                        const subdivision = Math.pow(2, 9 - zoomLevel);\n                        const { geoBox } = this.m_decodeInfo;\n                        const edgeModifier = new EdgeLengthGeometrySubdivisionModifier(\n                            subdivision,\n                            geoBox,\n                            SubdivisionMode.NoDiagonals,\n                            webMercatorProjection\n                        );\n                        edgeModifier.modify(geom);\n                    }\n\n                    // FIXME(HARP-5700): Subdivision modifier ignores texture coordinates.\n                    const modifier = new SphericalGeometrySubdivisionModifier(\n                        THREE.MathUtils.degToRad(10),\n                        webMercatorProjection\n                    );\n                    modifier.modify(geom);\n\n                    // Reassemble the vertex buffer, transforming the subdivided global\n                    // webMercator points back to local space.\n                    vertices.length = 0;\n                    triangles.length = 0;\n                    for (let i = 0; i < posAttr.array.length; i += 3) {\n                        const tilePos = world2tile(\n                            extents,\n                            this.m_decodeInfo,\n                            tmpV3.set(posAttr.array[i], posAttr.array[i + 1], 0),\n                            true,\n                            tmpV2r\n                        );\n                        vertices.push(tilePos.x, tilePos.y);\n                        if (texCoordType !== undefined) {\n                            vertices.push(uvAttr!.array[(i / 3) * 2]);\n                            vertices.push(uvAttr!.array[(i / 3) * 2 + 1]);\n                        }\n                        vertices.push(edgeAttr.array[i / 3]);\n                        vertices.push(wallAttr.array[i / 3]);\n                    }\n\n                    const geomIndex = geom.getIndex();\n                    if (geomIndex !== null) {\n                        triangles.push(...(geomIndex.array as Float32Array));\n                    }\n                }\n\n                // Add the footprint/roof vertices to the position buffer.\n                tempVertNormal.set(0, 0, 1);\n\n                // Assemble the vertex buffer.\n                for (let i = 0; i < vertices.length; i += vertexStride) {\n                    webMercatorTile2TargetWorld(\n                        extents,\n                        this.m_decodeInfo,\n                        tmpV2.set(vertices[i], vertices[i + 1]),\n                        tmpV3,\n                        false, // no need to scale height (source data is 2D).\n                        true\n                    );\n\n                    const scaleFactor = scaleHeights\n                        ? this.m_decodeInfo.targetProjection.getScaleFactor(tmpV3)\n                        : 1.0;\n                    this.m_maxGeometryHeight = Math.max(\n                        this.m_maxGeometryHeight,\n                        scaleFactor * height\n                    );\n                    this.m_minGeometryHeight = Math.min(\n                        this.m_minGeometryHeight,\n                        scaleFactor * height\n                    );\n\n                    if (isSpherical) {\n                        tempVertNormal.set(tmpV3.x, tmpV3.y, tmpV3.z).normalize();\n                    }\n                    tmpV3.sub(this.center);\n\n                    tempFootDisp.copy(tempVertNormal).multiplyScalar(floorHeight * scaleFactor);\n                    positions.push(\n                        tmpV3.x + tempFootDisp.x,\n                        tmpV3.y + tempFootDisp.y,\n                        tmpV3.z + tempFootDisp.z\n                    );\n                    if (texCoordType !== undefined) {\n                        textureCoordinates.push(vertices[i + 2], vertices[i + 3]);\n                    }\n                    if (this.m_options.enableElevationOverlay) {\n                        normals.push(...tempVertNormal.toArray());\n                    }\n                    if (isExtruded) {\n                        tempRoofDisp.copy(tempVertNormal).multiplyScalar(height * scaleFactor);\n                        positions.push(\n                            tmpV3.x + tempRoofDisp.x,\n                            tmpV3.y + tempRoofDisp.y,\n                            tmpV3.z + tempRoofDisp.z\n                        );\n                        extrusionAxis.push(\n                            0.0,\n                            0.0,\n                            0.0,\n                            0.0,\n                            tempRoofDisp.x - tempFootDisp.x,\n                            tempRoofDisp.y - tempFootDisp.y,\n                            tempRoofDisp.z - tempFootDisp.z,\n                            1.0\n                        );\n                        if (texCoordType !== undefined) {\n                            textureCoordinates.push(vertices[i + 2], vertices[i + 3]);\n                        }\n                        if (this.m_options.enableElevationOverlay) {\n                            normals.push(...tempVertNormal.toArray());\n                        }\n                        if (color !== undefined) {\n                            colors.push(color.r, color.g, color.b, color.r, color.g, color.b);\n                        }\n                    }\n                }\n\n                // Add the footprint/roof indices to the index buffer.\n                for (let i = 0; i < triangles.length; i += 3) {\n                    if (isExtruded) {\n                        // When extruding we duplicate the vertices, so that all even vertices\n                        // belong to the bottom and all odd vertices belong to the top.\n                        const i0 = polygonBaseVertex + triangles[i + 0] * 2 + 1;\n                        const i1 = polygonBaseVertex + triangles[i + 1] * 2 + 1;\n                        const i2 = polygonBaseVertex + triangles[i + 2] * 2 + 1;\n                        indices.push(i0, i1, i2);\n                    } else {\n                        const i0 = polygonBaseVertex + triangles[i + 0];\n                        const i1 = polygonBaseVertex + triangles[i + 1];\n                        const i2 = polygonBaseVertex + triangles[i + 2];\n                        indices.push(i0, i1, i2);\n                    }\n                }\n\n                // Assemble the index buffer for edges (follow vertices as linked list).\n                if (hasEdges) {\n                    this.addEdges(\n                        polygonBaseVertex,\n                        originalVertexCount,\n                        vertexStride,\n                        featureStride,\n                        positions,\n                        vertices,\n                        edgeIndices,\n                        isExtruded,\n                        extrudedPolygonTechnique.footprint,\n                        extrudedPolygonTechnique.maxSlope\n                    );\n                }\n                if (isExtruded) {\n                    this.addWalls(\n                        polygonBaseVertex,\n                        originalVertexCount,\n                        vertexStride,\n                        featureStride,\n                        vertices,\n                        indices\n                    );\n                }\n            } catch (err) {\n                logger.error(`cannot triangulate geometry`, err);\n            }\n\n            if (this.m_options.gatherFeatureAttributes) {\n                meshBuffers.objInfos.push(context.env.entries);\n                meshBuffers.featureStarts.push(startIndexCount);\n                meshBuffers.edgeFeatureStarts.push(edgeStartIndexCount);\n            }\n\n            const count = indices.length - startIndexCount;\n            if (count > 0) {\n                groups.push({\n                    start: startIndexCount,\n                    count,\n                    technique: techniqueIndex\n                });\n            }\n        }\n    }\n\n    private createGeometries() {\n        this.m_meshBuffers.forEach((meshBuffers, techniqueIdx) => {\n            if (meshBuffers.positions.length === 0) {\n                return;\n            } // nothing to do\n\n            if (\n                !this.m_styleSetEvaluator.techniques ||\n                this.m_styleSetEvaluator.techniques.length <= techniqueIdx\n            ) {\n                throw new Error(\"Invalid technique index\");\n            }\n\n            const technique = this.m_styleSetEvaluator.techniques[techniqueIdx];\n            if (technique === undefined) {\n                return;\n            }\n            if (meshBuffers.texts.length > 0) {\n                const geometry: TextGeometry = {\n                    positions: {\n                        name: \"position\",\n                        type: \"float\",\n                        buffer: new Float64Array(meshBuffers.positions).buffer,\n                        itemCount: 3\n                    },\n                    texts: meshBuffers.texts,\n                    technique: techniqueIdx,\n                    stringCatalog: meshBuffers.stringCatalog,\n                    objInfos: meshBuffers.objInfos\n                };\n\n                if (isTextTechnique(technique)) {\n                    this.m_textGeometries.push(geometry);\n                } else {\n                    assert(isPoiTechnique(technique));\n                    const poiGeometry = geometry as PoiGeometry;\n                    poiGeometry.imageTextures = meshBuffers.imageTextures;\n                    poiGeometry.offsetDirections = meshBuffers.offsetDirections;\n                    this.m_poiGeometries.push(poiGeometry);\n                }\n                return;\n            }\n\n            const positionElements = new Float32Array(meshBuffers.positions);\n\n            if (meshBuffers.groups.length === 0) {\n                // create a default group containing all the vertices in the position attribute.\n\n                meshBuffers.groups.push({\n                    start: 0,\n                    count: positionElements.length / 3,\n                    technique: techniqueIdx\n                });\n            }\n\n            const vertexAttributes: BufferAttribute[] = [\n                {\n                    name: \"position\",\n                    buffer: positionElements.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                }\n            ];\n\n            const geometry: Geometry = {\n                type: meshBuffers.type,\n                vertexAttributes,\n                groups: meshBuffers.groups\n            };\n\n            if (meshBuffers.normals.length > 0) {\n                const normals = new Float32Array(meshBuffers.normals);\n                assert(\n                    normals.length === positionElements.length,\n                    \"length of normals buffer is different than the length of the \" +\n                        \"position buffer\"\n                );\n\n                vertexAttributes.push({\n                    name: \"normal\",\n                    buffer: normals.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                });\n            }\n\n            if (meshBuffers.colors.length > 0) {\n                const colors = new Float32Array(meshBuffers.colors);\n                assert(\n                    colors.length === positionElements.length,\n                    \"length of colors buffer is different than the length of the \" +\n                        \"position buffer\"\n                );\n\n                vertexAttributes.push({\n                    name: \"color\",\n                    buffer: colors.buffer,\n                    itemCount: 3,\n                    type: \"float\"\n                });\n            }\n\n            const positionCount = meshBuffers.positions.length / 3;\n\n            if (meshBuffers.textureCoordinates.length > 0) {\n                const texCoordCount = meshBuffers.textureCoordinates.length / 2;\n                assert(\n                    texCoordCount === positionCount,\n                    \"length of textureCoordinates buffer is different than the length of the\" +\n                        \"position buffer\"\n                );\n\n                const textureCoordinates = new Float32Array(meshBuffers.textureCoordinates);\n                vertexAttributes.push({\n                    name: \"uv\",\n                    buffer: textureCoordinates.buffer as ArrayBuffer,\n                    itemCount: 2,\n                    type: \"float\"\n                });\n            }\n\n            if (meshBuffers.extrusionAxis.length > 0) {\n                const extrusionAxis = new Float32Array(meshBuffers.extrusionAxis);\n                assert(\n                    extrusionAxis.length / 4 === positionElements.length / 3,\n                    \"length of extrusionAxis buffer is different than the length of the \" +\n                        \"position buffer\"\n                );\n\n                vertexAttributes.push({\n                    name: \"extrusionAxis\",\n                    buffer: extrusionAxis.buffer as ArrayBuffer,\n                    itemCount: 4,\n                    type: \"float\"\n                });\n            }\n\n            if (meshBuffers.indices.length > 0) {\n                geometry.index = createIndexBufferAttribute(meshBuffers.indices, positionCount - 1);\n            }\n\n            if (meshBuffers.edgeIndices.length > 0) {\n                geometry.edgeIndex = createIndexBufferAttribute(\n                    meshBuffers.edgeIndices,\n                    positionCount - 1,\n                    \"edgeIndex\"\n                );\n            }\n\n            geometry.featureStarts = meshBuffers.featureStarts;\n            geometry.edgeFeatureStarts = meshBuffers.edgeFeatureStarts;\n            geometry.objInfos = meshBuffers.objInfos;\n\n            this.m_geometries.push(geometry);\n        });\n    }\n\n    private processLines(linesArray: LinesGeometry[]) {\n        linesArray.forEach(linesGeometry => {\n            const { vertices, indices } = linesGeometry.lines;\n            const technique = linesGeometry.technique;\n            const buffer = new Float32Array(vertices).buffer as ArrayBuffer;\n            const index = createIndexBufferAttribute(\n                indices,\n                vertices.length / linesGeometry.lines.stride - 1\n            );\n            const attr: InterleavedBufferAttribute = {\n                type: \"float\",\n                stride: linesGeometry.lines.stride,\n                buffer,\n                attributes: linesGeometry.lines.vertexAttributes\n            };\n            const geometry: Geometry = {\n                type: GeometryType.SolidLine,\n                index,\n                interleavedVertexAttributes: [attr],\n                groups: [{ start: 0, count: indices.length, technique }],\n                vertexAttributes: [],\n                featureStarts: linesGeometry.featureStarts,\n                objInfos: linesGeometry.objInfos\n            };\n\n            this.m_geometries.push(geometry);\n        });\n    }\n\n    private processSimpleLines(linesArray: LinesGeometry[]) {\n        linesArray.forEach(linesGeometry => {\n            const { vertices, indices } = linesGeometry.lines;\n            const technique = linesGeometry.technique;\n            const buffer = new Float32Array(vertices).buffer as ArrayBuffer;\n            const attr: BufferAttribute = {\n                buffer,\n                itemCount: 3,\n                type: \"float\",\n                name: \"position\"\n            };\n            const geometry: Geometry = {\n                type: GeometryType.Line,\n                index: createIndexBufferAttribute(indices, vertices.length / attr.itemCount - 1),\n                vertexAttributes: [attr],\n                groups: [{ start: 0, count: indices.length, technique }],\n                featureStarts: linesGeometry.featureStarts,\n                objInfos: linesGeometry.objInfos\n            };\n\n            this.m_geometries.push(geometry);\n        });\n    }\n\n    private findOrCreateMeshBuffers(index: number, type: GeometryType): MeshBuffers | undefined {\n        let buffers = this.m_meshBuffers.get(index);\n\n        if (buffers !== undefined) {\n            if (buffers.type !== type) {\n                logger.error(`MeshBuffer has been created with wrong type \"${GeometryType[type]}\"\n                instead of \"${GeometryType[buffers.type]}\"`);\n                return undefined;\n            }\n            return buffers;\n        }\n        buffers = new MeshBuffers(type);\n        this.m_meshBuffers.set(index, buffers);\n        return buffers;\n    }\n\n    private processFeatureCommon(env: Env) {\n        const source = env.lookup(\"source\");\n        if (typeof source === \"string\" && source !== \"\") {\n            if (!this.m_sources.includes(source)) {\n                this.m_sources.push(source);\n            }\n        }\n    }\n\n    private isColorStringValid(color: Value | undefined): color is string {\n        return typeof color === \"string\" && color.length > 0;\n    }\n\n    private addEdges(\n        featureBaseVertex: number,\n        featureVertexCount: number,\n        vertexStride: number,\n        featureStride: number,\n        positions: number[],\n        vertices: number[],\n        indices: number[],\n        isExtruded: boolean,\n        hasFootprint?: boolean,\n        maxSlope?: number\n    ) {\n        const tmpEdgeA = new THREE.Vector3();\n        const tmpEdgeB = new THREE.Vector3();\n        let firstRingVertex: number | undefined;\n        let prevRingVertex: number | undefined;\n        let currRingVertex = 0;\n        let maxRingVertex = 0;\n\n        while (currRingVertex < featureVertexCount) {\n            while (currRingVertex !== firstRingVertex) {\n                if (firstRingVertex === undefined) {\n                    firstRingVertex = currRingVertex;\n                }\n                if (currRingVertex < featureVertexCount) {\n                    maxRingVertex = Math.max(maxRingVertex, currRingVertex);\n                }\n\n                const nextRingVertex = vertices[currRingVertex * vertexStride + featureStride];\n                if (nextRingVertex < 0) {\n                    break;\n                } else {\n                    if (!isExtruded) {\n                        indices.push(\n                            featureBaseVertex + currRingVertex,\n                            featureBaseVertex + nextRingVertex\n                        );\n                    } else {\n                        if (hasFootprint === true) {\n                            indices.push(\n                                featureBaseVertex + currRingVertex * 2,\n                                featureBaseVertex + nextRingVertex * 2\n                            );\n                        }\n                        indices.push(\n                            featureBaseVertex + currRingVertex * 2 + 1,\n                            featureBaseVertex + nextRingVertex * 2 + 1\n                        );\n\n                        if (maxSlope !== undefined) {\n                            if (prevRingVertex !== undefined) {\n                                const prevPos = (featureBaseVertex + prevRingVertex * 2) * 3;\n                                const currPos = (featureBaseVertex + currRingVertex * 2) * 3;\n                                const nextPos = (featureBaseVertex + nextRingVertex * 2) * 3;\n                                tmpEdgeA\n                                    .set(\n                                        positions[currPos] - positions[prevPos],\n                                        positions[currPos + 1] - positions[prevPos + 1],\n                                        positions[currPos + 2] - positions[prevPos + 2]\n                                    )\n                                    .normalize();\n                                tmpEdgeB\n                                    .set(\n                                        positions[nextPos] - positions[currPos],\n                                        positions[nextPos + 1] - positions[currPos + 1],\n                                        positions[nextPos + 2] - positions[currPos + 2]\n                                    )\n                                    .normalize();\n                                if (tmpEdgeA.dot(tmpEdgeB) <= maxSlope) {\n                                    indices.push(\n                                        featureBaseVertex + currRingVertex * 2,\n                                        featureBaseVertex + currRingVertex * 2 + 1\n                                    );\n                                }\n                            }\n                        } else {\n                            indices.push(\n                                featureBaseVertex + currRingVertex * 2,\n                                featureBaseVertex + currRingVertex * 2 + 1\n                            );\n                        }\n                    }\n                    prevRingVertex = currRingVertex;\n                    currRingVertex = nextRingVertex;\n                }\n            }\n            currRingVertex = maxRingVertex + 1;\n            firstRingVertex = undefined;\n            prevRingVertex = undefined;\n        }\n    }\n\n    private addWalls(\n        featureBaseVertex: number,\n        featureVertexCount: number,\n        vertexStride: number,\n        featureStride: number,\n        vertices: number[],\n        indices: number[]\n    ) {\n        let firstRingVertex: number | undefined;\n        let currRingVertex = 0;\n        let maxRingVertex = 0;\n\n        while (currRingVertex < featureVertexCount) {\n            while (currRingVertex !== firstRingVertex) {\n                if (firstRingVertex === undefined) {\n                    firstRingVertex = currRingVertex;\n                }\n                if (currRingVertex < featureVertexCount) {\n                    maxRingVertex = Math.max(maxRingVertex, currRingVertex);\n                }\n\n                const nextRingVertex = vertices[currRingVertex * vertexStride + featureStride + 1];\n                if (nextRingVertex < 0) {\n                    break;\n                } else {\n                    indices.push(\n                        featureBaseVertex + currRingVertex * 2,\n                        featureBaseVertex + currRingVertex * 2 + 1,\n                        featureBaseVertex + nextRingVertex * 2 + 1,\n                        featureBaseVertex + nextRingVertex * 2 + 1,\n                        featureBaseVertex + nextRingVertex * 2,\n                        featureBaseVertex + currRingVertex * 2\n                    );\n                }\n                currRingVertex = nextRingVertex;\n            }\n            currRingVertex = maxRingVertex + 1;\n            firstRingVertex = undefined;\n        }\n    }\n\n    private findRelativePositionInLine(p: THREE.Vector3, line: number[]): number {\n        let lineDist = Infinity;\n        let lineOffset = 0;\n        for (let i = 0; i < line.length; i += 4) {\n            // Find the closest point C in segment AB to point P.\n            tmpLine.set(\n                tmpPointA.set(line[i], line[i + 1], line[i + 2]),\n                tmpPointB.set(line[i + 4], line[i + 5], line[i + 6])\n            );\n            tmpLine.closestPointToPoint(p, true, tmpPointC);\n\n            // If P is in AB (or really close), save A as anchor point and C (to estimate distance\n            // from segment origin).\n            const dist = tmpPointC.distanceTo(p);\n            if (dist < lineDist) {\n                tmpPointD.copy(tmpPointC);\n                tmpPointE.copy(tmpPointA);\n                lineDist = dist;\n                lineOffset = line[i + 3];\n            }\n        }\n        // Return the relative position of P inside the line.\n        return lineOffset + tmpPointD.distanceTo(tmpPointE);\n    }\n}\n","/*\n * Copyright (C) 2019-2022 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    DecoderOptions,\n    GeometryKind,\n    IndexedTechnique,\n    OptionsMap,\n    ValueMap\n} from \"@here/harp-datasource-protocol\";\nimport { MapEnv, StyleSetEvaluator } from \"@here/harp-datasource-protocol/index-decoder\";\nimport { AttrEvaluationContext } from \"@here/harp-datasource-protocol/lib/TechniqueAttr\";\nimport { Projection, TileKey } from \"@here/harp-geoutils\";\nimport {\n    ThemedTileDecoder,\n    TileDecoderService,\n    WorkerServiceManager\n} from \"@here/harp-mapview-decoder/index-worker\";\nimport { assert, LoggerManager, PerformanceTimer } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { GeoJsonDataAdapter } from \"./adapters/geojson/GeoJsonDataAdapter\";\nimport { GeoJsonVtDataAdapter } from \"./adapters/geojson-vt/GeoJsonVtDataAdapter\";\nimport { OmvDataAdapter } from \"./adapters/omv/OmvDataAdapter\";\nimport { DataAdapter } from \"./DataAdapter\";\nimport { DecodeInfo } from \"./DecodeInfo\";\nimport { IGeometryProcessor, ILineGeometry, IPolygonGeometry } from \"./IGeometryProcessor\";\nimport { OmvFeatureFilter } from \"./OmvDataFilter\";\nimport { OmvDecoderOptions, VECTOR_TILE_DECODER_SERVICE_TYPE } from \"./OmvDecoderDefs\";\nimport { VectorTileDataEmitter, VectorTileDataEmitterOptions } from \"./VectorTileDataEmitter\";\n\nconst logger = LoggerManager.instance.create(\"VectorTileDecoder\", { enabled: false });\n\n/**\n * Options for VectorTileDataProcessor, @see {@link OmvDecoderOptions}.\n * @internal\n */\nexport interface VectorTileDataProcessorOptions extends VectorTileDataEmitterOptions {\n    storageLevelOffset?: number;\n    showMissingTechniques?: boolean;\n}\n\n/**\n * Geometry processor for vector tiles.\n * @internal\n */\nexport class VectorTileDataProcessor implements IGeometryProcessor {\n    private m_decodedTileEmitter: VectorTileDataEmitter | undefined;\n\n    constructor(\n        private readonly m_tileKey: TileKey,\n        private readonly m_projection: Projection,\n        private readonly m_styleSetEvaluator: StyleSetEvaluator,\n        private readonly m_dataAdapter: DataAdapter,\n        private readonly m_options: VectorTileDataProcessorOptions = {},\n        private readonly m_dataFilter?: OmvFeatureFilter\n    ) {\n        m_options.storageLevelOffset = m_options.storageLevelOffset ?? 0;\n        m_options.showMissingTechniques = m_options.showMissingTechniques ?? false;\n    }\n\n    /**\n     * Decodes the given tile data.\n     *\n     * @param data - The tile data to decode.\n     * @returns A [[DecodedTile]]\n     */\n    getDecodedTile(data: ArrayBufferLike | {}): DecodedTile {\n        this.m_styleSetEvaluator.resetTechniques();\n\n        const decodeInfo = new DecodeInfo(\n            this.m_projection,\n            this.m_tileKey,\n            this.m_options.storageLevelOffset!\n        );\n\n        this.m_decodedTileEmitter = new VectorTileDataEmitter(\n            decodeInfo,\n            this.m_styleSetEvaluator,\n            this.m_options\n        );\n\n        this.m_dataAdapter.process(data, decodeInfo, this);\n        return this.m_decodedTileEmitter.getDecodedTile();\n    }\n\n    /** @override */\n    processPointFeature(\n        layer: string,\n        extents: number,\n        geometry: THREE.Vector3[],\n        properties: ValueMap,\n        featureId: string | number | undefined\n    ): void {\n        assert(this.m_decodedTileEmitter !== undefined);\n        this.processFeature(\n            layer,\n            extents,\n            geometry,\n            \"point\",\n            properties,\n            featureId,\n            this.m_decodedTileEmitter!.processPointFeature,\n            GeometryKind.Label\n        );\n    }\n\n    /** @override */\n    processLineFeature(\n        layer: string,\n        extents: number,\n        geometry: ILineGeometry[],\n        properties: ValueMap,\n        featureId: string | number | undefined\n    ): void {\n        assert(this.m_decodedTileEmitter !== undefined);\n        this.processFeature(\n            layer,\n            extents,\n            geometry,\n            \"line\",\n            properties,\n            featureId,\n            this.m_decodedTileEmitter!.processLineFeature,\n            GeometryKind.Line\n        );\n    }\n\n    /** @override */\n    processPolygonFeature(\n        layer: string,\n        extents: number,\n        geometry: IPolygonGeometry[],\n        properties: ValueMap,\n        featureId: string | number | undefined\n    ): void {\n        assert(this.m_decodedTileEmitter !== undefined);\n        this.processFeature(\n            layer,\n            extents,\n            geometry,\n            \"polygon\",\n            properties,\n            featureId,\n            this.m_decodedTileEmitter!.processPolygonFeature,\n            GeometryKind.Area\n        );\n    }\n\n    private processFeature(\n        layer: string,\n        extents: number,\n        geometry: THREE.Vector3[] | ILineGeometry[] | IPolygonGeometry[],\n        geometryType: string,\n        properties: ValueMap,\n        featureId: string | number | undefined,\n        emitterFunc: (...args: any[]) => void,\n        geometryKind: GeometryKind\n    ) {\n        const env = this.createMapEnv(properties, featureId, layer, geometryType);\n        const techniques = this.applyKindFilter(\n            this.m_styleSetEvaluator.getMatchingTechniques(env, layer, geometryType),\n            geometryKind\n        );\n\n        if (techniques.length === 0) {\n            if (this.m_options.showMissingTechniques) {\n                logger.log(\n                    \"VectorTileDataProcessor#processFeature: no techniques for object:\",\n                    JSON.stringify(env.unmap())\n                );\n            }\n            return;\n        }\n        const context: AttrEvaluationContext = {\n            env,\n            cachedExprResults: new Map()\n        };\n\n        if (this.m_decodedTileEmitter) {\n            emitterFunc.apply(this.m_decodedTileEmitter, [\n                layer,\n                extents,\n                geometry,\n                context,\n                techniques\n            ]);\n        }\n    }\n\n    private createMapEnv(\n        properties: ValueMap,\n        featureId: string | number | undefined,\n        layer: string,\n        geometryType: string\n    ): MapEnv {\n        const level = this.m_tileKey.level;\n        return new MapEnv({\n            $layer: layer,\n            $id: featureId ?? null,\n            $level: level,\n            $zoom: Math.max(0, level - this.m_options.storageLevelOffset!),\n            $geometryType: geometryType,\n            ...properties\n        });\n    }\n\n    private applyKindFilter(\n        techniques: IndexedTechnique[],\n        defaultKind: GeometryKind\n    ): IndexedTechnique[] {\n        if (this.m_dataFilter !== undefined && this.m_dataFilter.hasKindFilter) {\n            techniques = techniques.filter(technique => {\n                const kind =\n                    technique.kind === undefined ? defaultKind : (technique.kind as GeometryKind);\n                return this.m_dataFilter!.wantsKind(kind);\n            });\n        }\n        return techniques;\n    }\n}\n\n/**\n * The vector tile decoder.\n */\nexport class VectorTileDecoder extends ThemedTileDecoder {\n    private m_featureFilter?: OmvFeatureFilter;\n    private readonly m_roundUpCoordinatesIfNeeded: boolean = false;\n    private m_dataAdapter?: DataAdapter;\n    private m_options: { map: OptionsMap; changed: boolean } = { map: {}, changed: false };\n    private readonly m_defaultDataAdapters: DataAdapter[] = [];\n\n    constructor() {\n        super();\n        this.m_defaultDataAdapters.push(\n            new OmvDataAdapter(),\n            new GeoJsonVtDataAdapter(),\n            new GeoJsonDataAdapter()\n        );\n    }\n\n    /** @override */\n    connect(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /** @override */\n    decodeThemedTile(\n        data: ArrayBufferLike | {},\n        tileKey: TileKey,\n        styleSetEvaluator: StyleSetEvaluator,\n        projection: Projection\n    ): Promise<DecodedTile> {\n        const startTime = PerformanceTimer.now();\n        if (!this.m_dataAdapter) {\n            this.m_dataAdapter = this.getDataAdapter(data);\n            if (!this.m_dataAdapter) {\n                return Promise.reject(new Error(\"Unsupported data format.\"));\n            }\n        }\n        const dataAdapter = this.m_dataAdapter!;\n        assert(dataAdapter.canProcess(data));\n        if (this.m_options.changed) {\n            if (dataAdapter instanceof OmvDataAdapter) {\n                const omvOptions = this.m_options.map as OmvDecoderOptions;\n                dataAdapter.configure(omvOptions, styleSetEvaluator);\n                this.m_featureFilter = dataAdapter.dataFilter;\n            }\n            this.m_options.changed = false;\n        }\n\n        const decoder = new VectorTileDataProcessor(\n            tileKey,\n            projection,\n            styleSetEvaluator,\n            dataAdapter,\n            this.m_options.map as VectorTileDataProcessorOptions,\n            this.m_featureFilter\n        );\n        const decodedTile = decoder.getDecodedTile(data);\n\n        decodedTile.decodeTime = PerformanceTimer.now() - startTime;\n\n        return Promise.resolve(decodedTile);\n    }\n\n    /** @override */\n    configure(options?: DecoderOptions, customOptions?: OptionsMap): void {\n        super.configure(options, customOptions);\n        this.m_options.map = {\n            ...this.m_options.map,\n            ...options,\n            ...customOptions\n        };\n        this.m_options.changed = true;\n    }\n\n    /**\n     * Returns the appropiate data adapter to convert the given data into the format expected by\n     * VectorTileDecoder.\n     * @note Default adapters are available for GeoJson and OMV formats.\n     * Child classes may override this function to support additional formats.\n     *\n     * @param data - The input data to be coverted.\n     * @returns The DataAdapter to convert the data, or undefined if there's no adapter for that\n     * data format.\n     */\n    protected getDataAdapter(data: ArrayBufferLike | {}): DataAdapter | undefined {\n        for (const adapter of this.m_defaultDataAdapters) {\n            if (adapter.canProcess(data)) {\n                return adapter;\n            }\n        }\n        return undefined;\n    }\n}\n\n/**\n * Vector Tile Decoder Service.\n */\nexport class VectorTileDecoderService {\n    /**\n     * Register a vector tile decoder service.\n     *\n     * @remarks\n     * Has to be called during initialization of decoder bundle.\n     */\n    static start() {\n        WorkerServiceManager.getInstance().register({\n            serviceType: VECTOR_TILE_DECODER_SERVICE_TYPE,\n            factory: (serviceId: string) =>\n                TileDecoderService.start(serviceId, new VectorTileDecoder())\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ValueMap } from \"@here/harp-datasource-protocol/index-decoder\";\nimport { webMercatorProjection } from \"@here/harp-geoutils\";\nimport { ShapeUtils, Vector2, Vector3 } from \"three\";\n\nimport { DataAdapter } from \"../../DataAdapter\";\nimport { DecodeInfo } from \"../../DecodeInfo\";\nimport { IGeometryProcessor, ILineGeometry, IPolygonGeometry } from \"../../IGeometryProcessor\";\nimport { isArrayBufferLike, tile2world } from \"../../OmvUtils\";\n\nconst VT_JSON_EXTENTS = 4096;\n\ntype VTJsonPosition = [number, number];\n\nenum VTJsonGeometryType {\n    Unknown,\n    Point,\n    LineString,\n    Polygon\n}\n\ninterface VTJsonFeatureInterface {\n    geometry: VTJsonPosition[] | VTJsonPosition[][];\n    id: string;\n    tags: ValueMap;\n    type: VTJsonGeometryType;\n}\n\ninterface VTJsonSourceInterface {\n    geometry: number[];\n    length: number;\n    id: string;\n    maxX: number;\n    maxY: number;\n    minX: number;\n    minY: number;\n    tags: ValueMap;\n    type: string;\n}\n\ninterface VTJsonTileInterface {\n    features: VTJsonFeatureInterface[];\n    maxX: number;\n    maxY: number;\n    minX: number;\n    minY: number;\n    numFeatures: number;\n    numPoints: number;\n    numSimplified: number;\n    source: VTJsonSourceInterface[];\n    transformed: boolean;\n    x: number;\n    y: number;\n    z: number;\n    layer: string;\n}\n\nconst worldPos = new Vector3();\n\n/**\n * The class `GeoJsonVtDataAdapter` converts VT-json data to geometries for the given\n * {@link IGeometryProcessor}.\n */\nexport class GeoJsonVtDataAdapter implements DataAdapter {\n    /**\n     * @override\n     */\n    canProcess(data: ArrayBufferLike | {}): boolean {\n        if (isArrayBufferLike(data)) {\n            return false;\n        }\n\n        const tile = data as VTJsonTileInterface;\n        if (\n            tile.features === undefined ||\n            tile.source === undefined ||\n            tile.x === undefined ||\n            tile.y === undefined ||\n            tile.z === undefined\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @override\n     */\n    process(\n        tile: VTJsonTileInterface,\n        decodeInfo: DecodeInfo,\n        geometryProcessor: IGeometryProcessor\n    ) {\n        for (const feature of tile.features) {\n            switch (feature.type) {\n                case VTJsonGeometryType.Point: {\n                    for (const pointGeometry of feature.geometry) {\n                        const x = (pointGeometry as VTJsonPosition)[0];\n                        const y = (pointGeometry as VTJsonPosition)[1];\n\n                        const position = new Vector3(x, y, 0);\n\n                        geometryProcessor.processPointFeature(\n                            tile.layer,\n                            VT_JSON_EXTENTS,\n                            [position],\n                            feature.tags,\n                            feature.id\n                        );\n                    }\n                    break;\n                }\n                case VTJsonGeometryType.LineString: {\n                    const lineGeometries = feature.geometry as VTJsonPosition[][];\n\n                    let lastLine: ILineGeometry | undefined;\n                    const lines: ILineGeometry[] = [];\n\n                    lineGeometries.forEach(lineGeometry => {\n                        const lastPos = lastLine?.positions[lastLine.positions.length - 1];\n                        const [startx, starty] = lineGeometry[0];\n                        if (lastPos?.x === startx && lastPos?.y === starty) {\n                            // continue the last line\n                            for (let i = 1; i < lineGeometry.length; ++i) {\n                                const [x, y] = lineGeometry[i];\n                                lastLine?.positions.push(new Vector2(x, y));\n                            }\n                        } else {\n                            // start a new line\n                            const positions = lineGeometry.map(([x, y]) => new Vector2(x, y));\n                            lines.push({ positions });\n\n                            lastLine = lines[lines.length - 1];\n                        }\n                    });\n\n                    lines.forEach(line => {\n                        (line as any).untiledPositions = line.positions.map(tilePos => {\n                            tile2world(VT_JSON_EXTENTS, decodeInfo, tilePos, false, worldPos);\n                            return webMercatorProjection.unprojectPoint(worldPos);\n                        });\n                    });\n\n                    geometryProcessor.processLineFeature(\n                        tile.layer,\n                        VT_JSON_EXTENTS,\n                        lines,\n                        feature.tags,\n                        feature.id\n                    );\n\n                    break;\n                }\n                case VTJsonGeometryType.Polygon: {\n                    const polygons: IPolygonGeometry[] = [];\n                    let polygon: IPolygonGeometry | undefined;\n                    for (const outline of feature.geometry as VTJsonPosition[][]) {\n                        const ring: Vector2[] = [];\n                        for (const [currX, currY] of outline) {\n                            const position = new Vector2(currX, currY);\n                            ring.push(position);\n                        }\n                        // MVT spec defines that each exterior ring signals the beginning of a new polygon.\n                        // See https://github.com/mapbox/vector-tile-spec/tree/master/2.1\n                        if (ShapeUtils.area(ring) > 0) {\n                            // Create a new polygon and push it into the collection of polygons\n                            polygon = { rings: [] };\n                            polygons.push(polygon);\n                        }\n                        // Push the ring into the current polygon\n                        polygon?.rings.push(ring);\n                    }\n\n                    geometryProcessor.processPolygonFeature(\n                        tile.layer,\n                        VT_JSON_EXTENTS,\n                        polygons,\n                        feature.tags,\n                        feature.id\n                    );\n\n                    break;\n                }\n                case VTJsonGeometryType.Unknown: {\n                    break;\n                }\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ValueMap } from \"@here/harp-datasource-protocol/lib/Env\";\nimport { clipLineString } from \"@here/harp-geometry/lib/ClipLineString\";\nimport { GeoCoordinates, GeoPointLike, webMercatorProjection } from \"@here/harp-geoutils\";\nimport { Vector2Like } from \"@here/harp-geoutils/lib/math/Vector2Like\";\nimport { ShapeUtils, Vector2, Vector3 } from \"three\";\n\nimport { DataAdapter } from \"../../DataAdapter\";\nimport { DecodeInfo } from \"../../DecodeInfo\";\nimport { IGeometryProcessor, ILineGeometry, IPolygonGeometry } from \"../../IGeometryProcessor\";\nimport { world2tile } from \"../../OmvUtils\";\n\nconst DEFAULT_EXTENTS = 4 * 1024;\n\ntype GeoJsonGeometry =\n    | GeoJsonLineStringGeometry\n    | GeoJsonMultiLineStringGeometry\n    | GeoJsonPolygonGeometry\n    | GeoJsonMultiPolygonGeometry\n    | GeoJsonPointGeometry\n    | GeoJsonMultiPointGeometry;\n\ninterface GeoJsonLineStringGeometry {\n    type: \"LineString\";\n    coordinates: GeoPointLike[];\n}\n\ninterface GeoJsonMultiLineStringGeometry {\n    type: \"MultiLineString\";\n    coordinates: GeoPointLike[][];\n}\n\ninterface GeoJsonPointGeometry {\n    type: \"Point\";\n    coordinates: GeoPointLike;\n}\n\ninterface GeoJsonMultiPointGeometry {\n    type: \"MultiPoint\";\n    coordinates: GeoPointLike[];\n}\n\ninterface GeoJsonPolygonGeometry {\n    type: \"Polygon\";\n    coordinates: GeoPointLike[][];\n}\n\ninterface GeoJsonMultiPolygonGeometry {\n    type: \"MultiPolygon\";\n    coordinates: GeoPointLike[][][];\n}\n\ninterface GeoJsonFeature {\n    id?: string;\n    type: \"Feature\";\n    properties: ValueMap;\n    geometry: GeoJsonGeometry;\n}\n\nexport interface GeoJsonFeatureCollection {\n    type: \"FeatureCollection\";\n    features: GeoJsonFeature[];\n}\n\nconst worldP = new Vector3();\n\n/**\n * Converts a `geoPoint` to local tile space.\n *\n * @param geoPoint - The input [[GeoPointLike]].\n * @param decodeInfo - The [[DecodeInfo]].\n * @param target - A [[VectorLike]] used as target of the converted coordinates.\n * @return A [[VectorLike]] with the converted point.\n * @hidden\n */\nfunction convertPoint<VectorType extends Vector2Like>(\n    geoPoint: GeoPointLike,\n    decodeInfo: DecodeInfo,\n    target: VectorType\n): VectorType {\n    webMercatorProjection.projectPoint(GeoCoordinates.fromGeoPoint(geoPoint), worldP);\n    return world2tile(DEFAULT_EXTENTS, decodeInfo, worldP, false, target);\n}\n\nfunction convertLineStringGeometry(\n    coordinates: GeoPointLike[],\n    decodeInfo: DecodeInfo\n): ILineGeometry {\n    const untiledPositions = coordinates.map(geoPoint => {\n        return GeoCoordinates.fromGeoPoint(geoPoint);\n    });\n\n    const positions = coordinates.map(geoPoint =>\n        convertPoint(geoPoint, decodeInfo, new Vector2())\n    );\n\n    return { untiledPositions, positions };\n}\n\nfunction convertLineGeometry(\n    geometry: GeoJsonLineStringGeometry | GeoJsonMultiLineStringGeometry,\n    decodeInfo: DecodeInfo\n): ILineGeometry[] {\n    if (geometry.type === \"LineString\") {\n        return [convertLineStringGeometry(geometry.coordinates, decodeInfo)];\n    }\n\n    return geometry.coordinates.map(lineString =>\n        convertLineStringGeometry(lineString, decodeInfo)\n    );\n}\nfunction convertRings(coordinates: GeoPointLike[][], decodeInfo: DecodeInfo): IPolygonGeometry {\n    const rings = coordinates.map((ring, i) => {\n        const isOuterRing = i === 0;\n        const { positions } = convertLineStringGeometry(ring, decodeInfo);\n        const isClockWise = ShapeUtils.area(positions) > 0;\n        if ((isOuterRing && !isClockWise) || (!isOuterRing && isClockWise)) {\n            positions.reverse();\n        }\n        return positions;\n    });\n    return { rings };\n}\n\nfunction convertPolygonGeometry(\n    geometry: GeoJsonPolygonGeometry | GeoJsonMultiPolygonGeometry,\n    decodeInfo: DecodeInfo\n): IPolygonGeometry[] {\n    if (geometry.type === \"Polygon\") {\n        return [convertRings(geometry.coordinates, decodeInfo)];\n    }\n\n    return geometry.coordinates.map(polygon => convertRings(polygon, decodeInfo));\n}\n\nfunction convertPointGeometry(\n    geometry: GeoJsonPointGeometry | GeoJsonMultiPointGeometry,\n    decodeInfo: DecodeInfo\n): Vector3[] {\n    if (geometry.type === \"Point\") {\n        return [convertPoint(geometry.coordinates, decodeInfo, new Vector3())];\n    }\n\n    return geometry.coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new Vector3()));\n}\n\nexport class GeoJsonDataAdapter implements DataAdapter {\n    /**\n     * @override\n     */\n    canProcess(featureCollection: Partial<GeoJsonFeatureCollection>): boolean {\n        return (\n            featureCollection &&\n            featureCollection.type === \"FeatureCollection\" &&\n            Array.isArray(featureCollection.features)\n        );\n    }\n\n    /** @override */\n    process(\n        featureCollection: GeoJsonFeatureCollection,\n        decodeInfo: DecodeInfo,\n        geometryProcessor: IGeometryProcessor,\n        layer: string = \"geojson\"\n    ): void {\n        if (!Array.isArray(featureCollection.features) || featureCollection.features.length === 0) {\n            return;\n        }\n\n        for (const feature of featureCollection.features) {\n            switch (feature.geometry.type) {\n                case \"LineString\":\n                case \"MultiLineString\": {\n                    let geometry = convertLineGeometry(feature.geometry, decodeInfo);\n\n                    const clippedGeometries: ILineGeometry[] = [];\n\n                    const DEFAULT_BORDER = 100;\n\n                    geometry.forEach(g => {\n                        const clipped = clipLineString(\n                            g.positions,\n                            -DEFAULT_BORDER,\n                            -DEFAULT_BORDER,\n                            DEFAULT_EXTENTS + DEFAULT_BORDER,\n                            DEFAULT_EXTENTS + DEFAULT_BORDER\n                        );\n                        clipped.forEach(positions => {\n                            clippedGeometries.push({ positions });\n                        });\n                    });\n\n                    geometry = clippedGeometries;\n\n                    if (geometry.length > 0) {\n                        geometryProcessor.processLineFeature(\n                            layer,\n                            DEFAULT_EXTENTS,\n                            clippedGeometries,\n                            feature.properties,\n                            feature.id\n                        );\n                    }\n                    break;\n                }\n                case \"Polygon\":\n                case \"MultiPolygon\": {\n                    const geometry = convertPolygonGeometry(feature.geometry, decodeInfo);\n                    geometryProcessor.processPolygonFeature(\n                        layer,\n                        DEFAULT_EXTENTS,\n                        geometry,\n                        feature.properties,\n                        feature.id\n                    );\n                    break;\n                }\n                case \"Point\":\n                case \"MultiPoint\": {\n                    const geometry = convertPointGeometry(feature.geometry, decodeInfo);\n                    geometryProcessor.processPointFeature(\n                        layer,\n                        DEFAULT_EXTENTS,\n                        geometry,\n                        feature.properties,\n                        feature.id\n                    );\n                    break;\n                }\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector2 } from \"three\";\n\nimport { com } from \"./proto/vector_tile\";\n\n/**\n * @hidden\n */\nexport enum CommandKind {\n    MoveTo = 1,\n    LineTo = 2,\n    ClosePath = 7\n}\n\n/**\n * @hidden\n */\nexport interface BaseCommand {\n    kind: CommandKind;\n}\n\n/**\n * @hidden\n */\nexport interface PositionCommand extends BaseCommand {\n    position: Vector2;\n}\n\n/**\n * @hidden\n */\nexport type GeometryCommand = BaseCommand | PositionCommand;\n\n/**\n * @hidden\n */\nexport function isMoveToCommand(command: GeometryCommand): command is PositionCommand {\n    return command.kind === CommandKind.MoveTo;\n}\n\n/**\n * @hidden\n */\nexport function isLineToCommand(command: GeometryCommand): command is PositionCommand {\n    return command.kind === CommandKind.LineTo;\n}\n\n/**\n * @hidden\n */\nexport function isClosePathCommand(command: GeometryCommand): command is PositionCommand {\n    return command.kind === CommandKind.ClosePath;\n}\n\n/**\n * @hidden\n */\nexport interface OmvVisitor {\n    visitLayer?(layer: com.mapbox.pb.Tile.ILayer): boolean;\n    endVisitLayer?(layer: com.mapbox.pb.Tile.ILayer): void;\n    visitPointFeature?(feature: com.mapbox.pb.Tile.IFeature): void;\n    visitLineFeature?(feature: com.mapbox.pb.Tile.IFeature): void;\n    visitPolygonFeature?(feature: com.mapbox.pb.Tile.IFeature): void;\n}\n\n/**\n * @hidden\n */\nexport function visitOmv(vectorTile: com.mapbox.pb.Tile, visitor: OmvVisitor) {\n    if (!vectorTile.layers) {\n        return;\n    }\n\n    for (const layer of vectorTile.layers) {\n        if (!visitor.visitLayer || visitor.visitLayer(layer)) {\n            visitOmvLayer(layer, visitor);\n        }\n        if (visitor.endVisitLayer) {\n            visitor.endVisitLayer(layer);\n        }\n    }\n}\n\n/**\n * @hidden\n */\nexport function visitOmvLayer(layer: com.mapbox.pb.Tile.ILayer, visitor: OmvVisitor) {\n    if (!visitor.visitLayer || visitor.visitLayer(layer)) {\n        if (layer.features) {\n            for (const feature of layer.features) {\n                switch (feature.type) {\n                    case com.mapbox.pb.Tile.GeomType.UNKNOWN:\n                        break;\n\n                    case com.mapbox.pb.Tile.GeomType.POINT:\n                        if (visitor.visitPointFeature) {\n                            visitor.visitPointFeature(feature);\n                        }\n                        break;\n\n                    case com.mapbox.pb.Tile.GeomType.LINESTRING:\n                        if (visitor.visitLineFeature) {\n                            visitor.visitLineFeature(feature);\n                        }\n                        break;\n\n                    case com.mapbox.pb.Tile.GeomType.POLYGON:\n                        if (visitor.visitPolygonFeature) {\n                            visitor.visitPolygonFeature(feature);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    if (visitor.endVisitLayer) {\n        visitor.endVisitLayer(layer);\n    }\n}\n\n/**\n * @hidden\n */\nexport interface FeatureAttributesVisitor {\n    visitAttribute(name: string, value: com.mapbox.pb.Tile.IValue): boolean;\n}\n\n/**\n * @hidden\n */\nexport class FeatureAttributes {\n    accept(\n        layer: com.mapbox.pb.Tile.ILayer,\n        feature: com.mapbox.pb.Tile.IFeature,\n        visitor: FeatureAttributesVisitor\n    ): void {\n        const { keys, values } = layer;\n        const tags = feature.tags;\n\n        if (!tags || !keys || !values) {\n            return;\n        }\n\n        for (let i = 0; i < tags.length; i += 2) {\n            const key = keys[tags[i]];\n            const value = values[tags[i + 1]];\n            if (!visitor.visitAttribute(key, value)) {\n                break;\n            }\n        }\n    }\n}\n\n/**\n * @hidden\n */\nexport interface GeometryCommandsVisitor {\n    type: \"Point\" | \"Line\" | \"Polygon\";\n    visitCommand(command: GeometryCommand): void;\n}\n\n/**\n * @hidden\n */\nexport class GeometryCommands {\n    accept(geometry: number[] | null, visitor: GeometryCommandsVisitor) {\n        if (!geometry) {\n            return;\n        }\n\n        const geometryCount = geometry.length;\n\n        let currX = 0;\n        let currY = 0;\n\n        const xCoords: number[] = [];\n        const yCoords: number[] = [];\n        const commands: GeometryCommand[] = [];\n        for (let cmdIndex = 0; cmdIndex < geometryCount; ) {\n            const kind = (geometry[cmdIndex] & 0x7) as CommandKind;\n            const count = geometry[cmdIndex] >> 0x3;\n            ++cmdIndex;\n\n            if (kind === CommandKind.MoveTo || kind === CommandKind.LineTo) {\n                for (let n = 0; n < count; ++n) {\n                    const xx = geometry[cmdIndex++];\n                    const yy = geometry[cmdIndex++];\n\n                    currX += (xx >> 1) ^ -(xx & 1);\n                    currY += (yy >> 1) ^ -(yy & 1);\n                    if (visitor.type === \"Polygon\") {\n                        xCoords.push(currX);\n                        yCoords.push(currY);\n                    }\n\n                    const position = new Vector2(currX, currY);\n                    commands.push({ kind, position });\n                }\n            } else {\n                for (const command of commands) {\n                    visitor.visitCommand(command);\n                }\n                visitor.visitCommand({ kind });\n                xCoords.length = 0;\n                yCoords.length = 0;\n                commands.length = 0;\n            }\n        }\n\n        if (commands.length > 0) {\n            for (const command of commands) {\n                visitor.visitCommand(command);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    MapEnv,\n    StyleSetEvaluator,\n    Value,\n    ValueMap\n} from \"@here/harp-datasource-protocol/index-decoder\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert, ILogger, LoggerManager } from \"@here/harp-utils\";\nimport * as Long from \"long\";\nimport { ShapeUtils, Vector2, Vector3 } from \"three\";\n\nimport { DataAdapter } from \"../../DataAdapter\";\nimport { DecodeInfo } from \"../../DecodeInfo\";\nimport { IGeometryProcessor, ILineGeometry, IPolygonGeometry } from \"../../IGeometryProcessor\";\nimport {\n    ComposedDataFilter,\n    OmvFeatureFilter,\n    OmvFeatureModifier,\n    OmvGenericFeatureFilter,\n    OmvGenericFeatureModifier\n} from \"../../OmvDataFilter\";\nimport {\n    FeatureModifierId,\n    OmvDecoderOptions,\n    OmvFeatureFilterDescription,\n    OmvGeometryType\n} from \"../../OmvDecoderDefs\";\nimport { OmvPoliticalViewFeatureModifier } from \"../../OmvPoliticalViewFeatureModifier\";\nimport { isArrayBufferLike } from \"../../OmvUtils\";\nimport { StyleSetDataFilter } from \"../../StyleSetDataFilter\";\nimport {\n    FeatureAttributes,\n    GeometryCommands,\n    isClosePathCommand,\n    isLineToCommand,\n    isMoveToCommand,\n    OmvVisitor,\n    visitOmv\n} from \"./OmvData\";\nimport { com } from \"./proto/vector_tile\";\n\nconst propertyCategories = [\n    \"stringValue\",\n    \"floatValue\",\n    \"doubleValue\",\n    \"intValue\",\n    \"uintValue\",\n    \"sintValue\",\n    \"boolValue\"\n];\n\nconst logger = LoggerManager.instance.create(\"OmvDataAdapter\", { enabled: false });\n\nfunction simplifiedValue(value: com.mapbox.pb.Tile.IValue): Value {\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    for (const category of propertyCategories) {\n        if (hasOwnProperty.call(value, category)) {\n            const v = value[category as keyof com.mapbox.pb.Tile.IValue];\n\n            if (v === undefined) {\n                throw new Error(\"unpexted undefined value\");\n            }\n\n            return Long.isLong(v) ? (v as any).toNumber() : v;\n        }\n    }\n\n    throw new Error(\"not happening\");\n}\n\nfunction decodeFeatureId(\n    feature: com.mapbox.pb.Tile.IFeature,\n    properties: ValueMap,\n    logger?: ILogger\n): number | string | undefined {\n    if (properties.id !== undefined && properties.id !== null) {\n        return properties.id as number | string;\n    }\n    if (feature.hasOwnProperty(\"id\")) {\n        const id = feature.id;\n        if (typeof id === \"number\") {\n            return id;\n        } else if (id) {\n            if (logger !== undefined && id.greaterThan(Number.MAX_SAFE_INTEGER)) {\n                logger.error(\n                    \"Invalid ID: Larger than largest available Number in feature: \",\n                    feature\n                );\n            }\n            return id.toNumber();\n        }\n    }\n\n    return undefined;\n}\n\nfunction readAttributes(\n    layer: com.mapbox.pb.Tile.ILayer,\n    feature: com.mapbox.pb.Tile.IFeature\n): ValueMap {\n    const attrs = new FeatureAttributes();\n\n    const attributes: ValueMap = {};\n\n    attrs.accept(layer, feature, {\n        visitAttribute: (name, value) => {\n            attributes[name] = simplifiedValue(value);\n            return true;\n        }\n    });\n\n    return attributes;\n}\n\nexport function asGeometryType(feature: com.mapbox.pb.Tile.IFeature | undefined): OmvGeometryType {\n    if (feature === undefined) {\n        return OmvGeometryType.UNKNOWN;\n    }\n\n    switch (feature.type) {\n        case com.mapbox.pb.Tile.GeomType.UNKNOWN:\n            return OmvGeometryType.UNKNOWN;\n        case com.mapbox.pb.Tile.GeomType.POINT:\n            return OmvGeometryType.POINT;\n        case com.mapbox.pb.Tile.GeomType.LINESTRING:\n            return OmvGeometryType.LINESTRING;\n        case com.mapbox.pb.Tile.GeomType.POLYGON:\n            return OmvGeometryType.POLYGON;\n        default:\n            return OmvGeometryType.UNKNOWN;\n    } // switch\n}\n\n// Ensures ring winding follows Mapbox Vector Tile specification: outer rings must be clockwise,\n// inner rings counter-clockwise.\n// See https://docs.mapbox.com/vector-tiles/specification/\nfunction checkWinding(multipolygon: IPolygonGeometry[]) {\n    const firstPolygon = multipolygon[0];\n\n    if (firstPolygon === undefined || firstPolygon.rings.length === 0) {\n        return;\n    }\n\n    // Opposite sign to ShapeUtils.isClockWise, since webMercator tile space has top-left origin.\n    // For example:\n    // Given the ring = [(1,2), (2,2), (2,1), (1,1)]\n    // ShapeUtils.area(ring) > 0    -> false\n    // ShapeUtils.isClockWise(ring) -> true\n    // ^\n    // |  1,2 -> 2,2\n    // |          |\n    // |  1,1 <- 2,1\n    // |_______________>\n    //\n    // Tile space axis\n    //  ______________>\n    // |  1,1 <- 2,1\n    // |          |\n    // |  1,2 ->  2,2\n    // V\n    const isOuterRingClockWise = ShapeUtils.area(firstPolygon.rings[0]) > 0;\n\n    if (!isOuterRingClockWise) {\n        for (const polygon of multipolygon) {\n            for (const ring of polygon.rings) {\n                ring.reverse();\n            }\n        }\n    }\n}\n\nfunction roundUpCoordinates(coordinates: Vector2[], layerExtents: number) {\n    coordinates.forEach(p => {\n        if (p.x === layerExtents - 1) {\n            p.x = layerExtents;\n        }\n    });\n}\n\nfunction roundUpPolygonCoordinates(geometry: IPolygonGeometry[], layerExtents: number) {\n    geometry.forEach(polygon => polygon.rings.forEach(r => roundUpCoordinates(r, layerExtents)));\n}\n\nfunction roundUpLineCoordinates(geometry: ILineGeometry[], layerExtents: number) {\n    geometry.forEach(line => roundUpCoordinates(line.positions, layerExtents));\n}\nfunction createFeatureModifier(\n    filterDescription: OmvFeatureFilterDescription,\n    featureModifierId?: FeatureModifierId\n): OmvFeatureModifier {\n    switch (featureModifierId) {\n        case FeatureModifierId.default:\n            return new OmvGenericFeatureModifier(filterDescription);\n        default:\n            assert(!\"Unrecognized feature modifier id, using default!\");\n            return new OmvGenericFeatureModifier(filterDescription);\n    }\n}\n\n/**\n * The class `OmvDataAdapter` converts OMV protobuf geo data\n * to geometries for the given `IGeometryProcessor`.\n */\n\nexport class OmvDataAdapter implements DataAdapter, OmvVisitor {\n    private readonly m_geometryCommands = new GeometryCommands();\n\n    private m_tileKey!: TileKey;\n    private m_layer!: com.mapbox.pb.Tile.ILayer;\n    private m_dataFilter?: OmvFeatureFilter;\n    private m_featureModifiers?: OmvFeatureModifier[];\n    private m_processor!: IGeometryProcessor;\n    private m_roundUpCoordinatesIfNeeded: boolean = false;\n\n    /**\n     * The [[OmvFeatureFilter]] used to filter features.\n     */\n    get dataFilter(): OmvFeatureFilter | undefined {\n        return this.m_dataFilter;\n    }\n\n    /**\n     * Configures the OMV adapter.\n     *\n     * @param options - Configuration options.\n     * @param styleSetEvaluator - Style set evaluator instance, used for filtering.\n     */\n    configure(options: OmvDecoderOptions, styleSetEvaluator: StyleSetEvaluator) {\n        if (options.filterDescription !== undefined) {\n            if (options.filterDescription !== null) {\n                // TODO: Feature modifier is always used only with feature filter.\n                // At best the filtering feature should be excluded from other feature\n                // modifiers and be performed solely via OmvGenericFeature modifier or filter.\n                const filterDescription = options.filterDescription;\n                const featureModifiersIds = options.featureModifiers;\n\n                // Create new filter from description.\n                this.m_dataFilter = new OmvGenericFeatureFilter(filterDescription);\n                // Create feature modifiers.\n                const featureModifiers: OmvFeatureModifier[] = [];\n                if (featureModifiersIds !== undefined) {\n                    featureModifiersIds.forEach(fmId => {\n                        featureModifiers.push(createFeatureModifier(filterDescription, fmId));\n                    });\n                } else {\n                    featureModifiers.push(\n                        createFeatureModifier(filterDescription, FeatureModifierId.default)\n                    );\n                }\n                this.m_featureModifiers = featureModifiers;\n            } else {\n                // null is the signal to clear the filter/modifier\n                this.m_dataFilter = undefined;\n                this.m_featureModifiers = undefined;\n            }\n            const styleSetDataFilter = new StyleSetDataFilter(styleSetEvaluator);\n            this.m_dataFilter = this.m_dataFilter\n                ? new ComposedDataFilter([styleSetDataFilter, this.m_dataFilter])\n                : styleSetDataFilter;\n        }\n\n        if (options.politicalView !== undefined) {\n            const politicalView = options.politicalView;\n            let featureModifiers = this.m_featureModifiers;\n            // Remove existing political view modifiers, this actually setups default,\n            // commonly accepted point of view - without feature modifier.\n            if (featureModifiers) {\n                featureModifiers = featureModifiers.filter(\n                    fm => !(fm instanceof OmvPoliticalViewFeatureModifier)\n                );\n            }\n            // If political view is indeed requested append feature modifier at the end of list.\n            if (politicalView.length !== 0) {\n                assert(\n                    politicalView.length === 2,\n                    \"The political view must be specified as two letters ISO 3166-1 standard!\"\n                );\n                const povFeatureModifier = new OmvPoliticalViewFeatureModifier(politicalView);\n                if (featureModifiers) {\n                    featureModifiers.push(povFeatureModifier);\n                } else {\n                    featureModifiers = [povFeatureModifier];\n                }\n            }\n            // Reset modifiers if nothing was added.\n            this.m_featureModifiers =\n                featureModifiers && featureModifiers.length > 0 ? featureModifiers : undefined;\n        }\n        this.m_roundUpCoordinatesIfNeeded = options.roundUpCoordinatesIfNeeded ?? false;\n    }\n\n    /**\n     * @override\n     */\n    canProcess(data: ArrayBufferLike | {}): boolean {\n        return isArrayBufferLike(data);\n    }\n\n    /**\n     * @override\n     */\n    process(data: ArrayBufferLike, decodeInfo: DecodeInfo, geometryProcessor: IGeometryProcessor) {\n        const { tileKey } = decodeInfo;\n        const payload = new Uint8Array(data);\n        const proto = com.mapbox.pb.Tile.decode(payload);\n\n        this.m_tileKey = tileKey;\n        this.m_processor = geometryProcessor;\n\n        visitOmv(proto, this);\n    }\n\n    /**\n     * Visits the OMV layer.\n     *\n     * @param layer - The OMV layer to process.\n     */\n    visitLayer(layer: com.mapbox.pb.Tile.ILayer): boolean {\n        this.m_layer = layer;\n\n        const storageLevel = this.m_tileKey.level;\n        const layerName = layer.name;\n\n        if (\n            this.m_dataFilter !== undefined &&\n            !this.m_dataFilter.wantsLayer(layerName, storageLevel)\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Visits point features.\n     *\n     * @param feature - The OMV point features to process.\n     */\n    visitPointFeature(feature: com.mapbox.pb.Tile.IFeature): void {\n        if (feature.geometry === undefined) {\n            return;\n        }\n\n        // Pass feature modifier method to processFeature if there's any modifier. Get it from any\n        // modifier, processFeature will later apply it to all using Function.apply().\n        const modifierFunc = this.m_featureModifiers?.[0].doProcessPointFeature;\n\n        const properties = this.filterAndModifyFeature(\n            feature,\n            this.m_dataFilter?.wantsPointFeature,\n            modifierFunc\n        );\n        if (!properties) {\n            return;\n        }\n\n        const layerName = this.m_layer.name;\n        const layerExtents = this.m_layer.extent ?? 4096;\n\n        const geometry: Vector3[] = [];\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Point\",\n            visitCommand: command => {\n                if (isMoveToCommand(command)) {\n                    geometry.push(new Vector3(command.position.x, command.position.y, 0));\n                }\n            }\n        });\n\n        if (geometry.length === 0) {\n            return;\n        }\n\n        this.m_processor.processPointFeature(\n            layerName,\n            layerExtents,\n            geometry,\n            properties,\n            decodeFeatureId(feature, properties, logger)\n        );\n    }\n\n    /**\n     * Visits the line features.\n     *\n     * @param feature - The line features to process.\n     */\n    visitLineFeature(feature: com.mapbox.pb.Tile.IFeature): void {\n        if (feature.geometry === undefined) {\n            return;\n        }\n\n        // Pass feature modifier method to processFeature if there's any modifier. Get it from any\n        // modifier, processFeature will later apply it to all using Function.apply().\n        const modifierFunc = this.m_featureModifiers?.[0].doProcessLineFeature;\n\n        const properties = this.filterAndModifyFeature(\n            feature,\n            this.m_dataFilter?.wantsLineFeature,\n            modifierFunc\n        );\n        if (!properties) {\n            return;\n        }\n\n        const layerName = this.m_layer.name;\n        const layerExtents = this.m_layer.extent ?? 4096;\n\n        const geometry: ILineGeometry[] = [];\n        let positions: Vector2[];\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Line\",\n            visitCommand: command => {\n                if (isMoveToCommand(command)) {\n                    positions = [command.position];\n                    geometry.push({ positions });\n                } else if (isLineToCommand(command)) {\n                    positions.push(command.position);\n                }\n            }\n        });\n\n        if (geometry.length === 0) {\n            return;\n        }\n\n        if (this.mustRoundUpCoordinates) {\n            roundUpLineCoordinates(geometry, layerExtents);\n        }\n        this.m_processor.processLineFeature(\n            layerName,\n            layerExtents,\n            geometry,\n            properties,\n            decodeFeatureId(feature, properties, logger)\n        );\n    }\n\n    /**\n     * Visits the polygon features.\n     *\n     * @param feature - The polygon features to process.\n     */\n    visitPolygonFeature(feature: com.mapbox.pb.Tile.IFeature): void {\n        if (feature.geometry === undefined) {\n            return;\n        }\n\n        // Pass feature modifier method to processFeature if there's any modifier. Get it from any\n        // modifier, processFeature will later apply it to all using Function.apply().\n        const modifierFunc = this.m_featureModifiers?.[0].doProcessPolygonFeature;\n\n        const properties = this.filterAndModifyFeature(\n            feature,\n            this.m_dataFilter?.wantsPolygonFeature,\n            modifierFunc\n        );\n        if (!properties) {\n            return;\n        }\n\n        const layerName = this.m_layer.name;\n        const layerExtents = this.m_layer.extent ?? 4096;\n\n        const geometry: IPolygonGeometry[] = [];\n        let currentPolygon: IPolygonGeometry | undefined;\n        let currentRing: Vector2[];\n        let exteriorWinding: number | undefined;\n        this.m_geometryCommands.accept(feature.geometry, {\n            type: \"Polygon\",\n            visitCommand: command => {\n                if (isMoveToCommand(command)) {\n                    currentRing = [command.position];\n                } else if (isLineToCommand(command)) {\n                    currentRing.push(command.position);\n                } else if (isClosePathCommand(command)) {\n                    if (currentRing !== undefined && currentRing.length > 0) {\n                        const currentRingWinding = Math.sign(ShapeUtils.area(currentRing));\n                        // Winding order from XYZ spaces might be not MVT spec compliant, see HARP-11151.\n                        // We take the winding of the very first ring as reference.\n                        if (exteriorWinding === undefined) {\n                            exteriorWinding = currentRingWinding;\n                        }\n                        // MVT spec defines that each exterior ring signals the beginning of a new polygon.\n                        // see https://github.com/mapbox/vector-tile-spec/tree/master/2.1\n                        if (currentRingWinding === exteriorWinding) {\n                            // Create a new polygon and push it into the collection of polygons\n                            currentPolygon = { rings: [] };\n                            geometry.push(currentPolygon);\n                        }\n                        // Push the ring into the current polygon\n                        currentRing.push(currentRing[0].clone());\n                        currentPolygon?.rings.push(currentRing);\n                    }\n                }\n            }\n        });\n        if (geometry.length === 0) {\n            return;\n        }\n\n        if (this.mustRoundUpCoordinates) {\n            roundUpPolygonCoordinates(geometry, layerExtents);\n        }\n\n        checkWinding(geometry);\n\n        this.m_processor.processPolygonFeature(\n            layerName,\n            layerExtents,\n            geometry,\n            properties,\n            decodeFeatureId(feature, properties, logger)\n        );\n    }\n\n    /**\n     * Applies any filter and modifiers to a given feature.\n     *\n     * @param feature - The feature to filter and modify.\n     * @param filterFunc - The filtering function.\n     * @param modifierFunc - The modifier function.\n     * @returns The modified feature properties or `undefined` if feature is filtered out.\n     */\n    private filterAndModifyFeature(\n        feature: com.mapbox.pb.Tile.IFeature,\n        filterFunc?: (...args: any[]) => boolean,\n        modifierFunc?: (...args: any[]) => boolean\n    ): ValueMap | undefined {\n        const storageLevel = this.m_tileKey.level;\n        const layerName = this.m_layer.name;\n        const geometryType = asGeometryType(feature);\n\n        if (\n            this.m_dataFilter &&\n            filterFunc!.apply(this.m_dataFilter, [layerName, geometryType, storageLevel]) === false\n        ) {\n            return undefined;\n        }\n\n        const properties = readAttributes(this.m_layer, feature);\n        const env = new MapEnv(properties);\n        if (\n            this.m_featureModifiers?.find(fm => {\n                // TODO: The logic of feature ignore should be actually in the feature filtering\n                // mechanism - see OmvFeatureFilter.\n                assert(modifierFunc !== undefined);\n                return !modifierFunc!.apply(fm, [layerName, env, this.m_tileKey.level]);\n            }) !== undefined\n        ) {\n            return undefined;\n        }\n\n        return properties;\n    }\n\n    private get mustRoundUpCoordinates(): boolean {\n        return (\n            this.m_roundUpCoordinatesIfNeeded &&\n            this.m_tileKey.level < 5 &&\n            this.m_tileKey.column === this.m_tileKey.columnCount() - 1\n        );\n    }\n}\n","module.exports = THREE;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n// It's empty as some runtime module handles the default behavior\n__webpack_require__.x = x => {}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// Promise = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"datasource_geojson_visibility\": 0\n};\n\nvar deferredModules = [\n\t[\"./src/datasource_geojson_visibility.ts\",\"common\"]\n];\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\nvar checkDeferredModules = x => {};\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime, executeModules] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0, resolves = [];\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tresolves.push(installedChunks[chunkId][0]);\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\twhile(resolves.length) {\n\t\tresolves.shift()();\n\t}\n\n\t// add entry modules from loaded chunk to deferred list\n\tif(executeModules) deferredModules.push.apply(deferredModules, executeModules);\n\n\t// run deferred modules when all chunks ready\n\treturn checkDeferredModules();\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk_here_harp_examples\"] = self[\"webpackChunk_here_harp_examples\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));\n\nfunction checkDeferredModulesImpl() {\n\tvar result;\n\tfor(var i = 0; i < deferredModules.length; i++) {\n\t\tvar deferredModule = deferredModules[i];\n\t\tvar fulfilled = true;\n\t\tfor(var j = 1; j < deferredModule.length; j++) {\n\t\t\tvar depId = deferredModule[j];\n\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferredModules.splice(i--, 1);\n\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n\t\t}\n\t}\n\tif(deferredModules.length === 0) {\n\t\t__webpack_require__.x();\n\t\t__webpack_require__.x = x => {};\n\t}\n\treturn result;\n}\nvar startup = __webpack_require__.x;\n__webpack_require__.x = () => {\n\t// reset startup function so it can be called again when more startup code is added\n\t__webpack_require__.x = startup || (x => {});\n\treturn (checkDeferredModules = checkDeferredModulesImpl)();\n};","// run startup\nreturn __webpack_require__.x();\n"],"sourceRoot":""}