var harp;harp =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../harp-mapview/node_modules/rbush/rbush.min.js":
/*!*******************************************************!*\
  !*** ../harp-mapview/node_modules/rbush/rbush.min.js ***!
  \*******************************************************/
/***/ (function(module) {

!function(t,i){ true?module.exports=i():0}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});


/***/ }),

/***/ "../../node_modules/csscolorparser/csscolorparser.js":
/*!***********************************************************!*\
  !*** ../../node_modules/csscolorparser/csscolorparser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "rebeccapurple": [102,51,153,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }


/***/ }),

/***/ "../harp-datasource-protocol/index-decoder.ts":
/*!****************************************************!*\
  !*** ../harp-datasource-protocol/index-decoder.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./lib/StyleSetEvaluator */ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/IMeshBuffers */ "../harp-datasource-protocol/lib/IMeshBuffers.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Outliner */ "../harp-datasource-protocol/lib/Outliner.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThreeBufferUtils */ "../harp-datasource-protocol/lib/ThreeBufferUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ "../harp-datasource-protocol/lib/GeoJsonDataType.ts"), exports);


/***/ }),

/***/ "../harp-datasource-protocol/index.ts":
/*!********************************************!*\
  !*** ../harp-datasource-protocol/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Components used for the decoding and styling of data that is used by the Datasources.
 *
 * @remarks
 * The DataSource Protocol package contains components used for the decoding and styling
 * of data that is used by the Datasources.
 * This code is shared between the ui-thread and the web-workers which are
 * used to parallelise the decoding of the data.
 * This module contains interfaces for choosing techniques form the techniques
 * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Expr */ "../harp-datasource-protocol/lib/Expr.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Techniques */ "../harp-datasource-protocol/lib/Techniques.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/PostEffects */ "../harp-datasource-protocol/lib/PostEffects.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/PropertyValue */ "../harp-datasource-protocol/lib/PropertyValue.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerServiceProtocol */ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerTilerProtocol */ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerDecoderProtocol */ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ITileDecoder */ "../harp-datasource-protocol/lib/ITileDecoder.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ITiler */ "../harp-datasource-protocol/lib/ITiler.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DecodedTile */ "../harp-datasource-protocol/lib/DecodedTile.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileInfo */ "../harp-datasource-protocol/lib/TileInfo.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataType */ "../harp-datasource-protocol/lib/GeoJsonDataType.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThemeVisitor */ "../harp-datasource-protocol/lib/ThemeVisitor.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts"), exports);


/***/ }),

/***/ "../harp-datasource-protocol/lib/ColorUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/ColorUtils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorUtils = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "../harp-datasource-protocol/lib/RGBA.ts");
const SHIFT_TRANSPARENCY = 24;
const SHIFT_RED = 16;
const SHIFT_GREEN = 8;
const SHIFT_BLUE = 0;
//    Allow bitwise operations for colors decoding
const HEX_FULL_CHANNEL = 0xff;
const HEX_RGB_MASK = 0xffffff;
const HEX_TRGB_MASK = 0xffffffff;
const tmpColor = new THREE.Color();
/**
 * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.
 *
 * The functions provided allows for conversion from and to our custom number based color format,
 * which contains transparency, red, green and blue color channels in a way that each channel
 * occupies 8 bits of resulting number (color format 0xTTRRGGBB).
 * In order to preserve compatibility with THREE.Color class and its hexadecimal color
 * representation, we do not store __alpha__ channel in encoded color's number, but replace it
 * with __transparency__ channel, which is simply opposite to alpha:
 * ```transparency = 0xFF - alpha```
 * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,
 * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],
 * [[THREE.Color.setHex]]).
 * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.
 */
var ColorUtils;
(function (ColorUtils) {
    /**
     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).
     *
     * We do not use direct alpha channel mapping to hex in order to preserve compatibility
     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency
     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].
     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and
     * color defining transparency (alpha < 255) is always recognizable by the oldest
     * bit set:
     * ```typescript
     * (color >> SHIFT_TRANSPARENCY) !== 0.
     * ```
     * @note All input components are floating points in <0, 1> range (inclusively).
     * @note Although method encodes transparency channel in single number value, it is still
     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to
     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.
     */
    function getHexFromRgba(r, g, b, a) {
        harp_utils_1.assert(a >= 0 && a <= 1);
        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);
        return ((t << SHIFT_TRANSPARENCY) ^
            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgba = getHexFromRgba;
    /**
     * Encodes RGB all color channels in single number with format 0xRRGGBB.
     *
     * All input channels should be in <0, 1> range (inclusively).
     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.
     *
     * @note This method is fully compatible with THREE.js color encoding, so
     * you may pass this value directly to THREE.Color c-tor.
     */
    function getHexFromRgb(r, g, b) {
        harp_utils_1.assert(r >= 0 && r <= 1);
        harp_utils_1.assert(g >= 0 && g <= 1);
        harp_utils_1.assert(b >= 0 && b <= 1);
        return (((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^
            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^
            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE));
    }
    ColorUtils.getHexFromRgb = getHexFromRgb;
    /**
     * Encode and convert HSL value to number coded color format (0xRRGGBB).
     *
     * @see getHexFromRgb.
     * @param h - Hue component value between 0 and 1.
     * @param s - Saturation value between 0 and 1.
     * @param l - Lightness channel between 0 and 1.
     */
    function getHexFromHsl(h, s, l) {
        harp_utils_1.assert(h >= 0 && h <= 1);
        harp_utils_1.assert(s >= 0 && s <= 1);
        harp_utils_1.assert(l >= 0 && l <= 1);
        return tmpColor.setHSL(h, s, l).getHex();
    }
    ColorUtils.getHexFromHsl = getHexFromHsl;
    /**
     * Retrieve RGBA channels separately from number encoded custom color format.
     *
     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color
     * format.
     *
     * @see getHexFromRgba.
     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating
     * point from 0 to 1 inclusively.
     */
    function getRgbaFromHex(hex, target = new RGBA_1.RGBA()) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;
        target.a =
            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /
                HEX_FULL_CHANNEL;
        return target;
    }
    ColorUtils.getRgbaFromHex = getRgbaFromHex;
    /**
     * Determines if number encoded color contains alpha (opacity) defined and different then 255.
     *
     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns True if color has transparency defined.
     */
    function hasAlphaInHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex >> SHIFT_TRANSPARENCY !== 0;
    }
    ColorUtils.hasAlphaInHex = hasAlphaInHex;
    /**
     * Retrieves alpha color channel from hex encoded color value.
     *
     * @see getHexFromRgba.
     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns The floating point alpha component in <0, 1> range.
     */
    function getAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return (((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL);
    }
    ColorUtils.getAlphaFromHex = getAlphaFromHex;
    /**
     * Remove transparency info from the number coded color, makes it compatible with external libs.
     *
     * @see getAlphaFromHex.
     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).
     * @returns number coded color value representable as 0xRRGGBB in hex.
     */
    function removeAlphaFromHex(hex) {
        harp_utils_1.assert((hex & ~HEX_TRGB_MASK) === 0, "Wrong hex format");
        return hex & HEX_RGB_MASK;
    }
    ColorUtils.removeAlphaFromHex = removeAlphaFromHex;
})(ColorUtils = exports.ColorUtils || (exports.ColorUtils = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/DecodedTile.ts":
/*!******************************************************!*\
  !*** ../harp-datasource-protocol/lib/DecodedTile.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scaleHeight = exports.getFeatureText = exports.getFeatureName = exports.getFeatureId = exports.getProjectionName = exports.getProjection = exports.GeometryType = exports.getArrayConstructor = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const TechniqueAttr_1 = __webpack_require__(/*! ./TechniqueAttr */ "../harp-datasource-protocol/lib/TechniqueAttr.ts");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "../harp-datasource-protocol/lib/Techniques.ts");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr - specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName - string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection - `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;
/**
 * @returns Feature id from the provided attribute map.
 * @internal
 */
function getFeatureId(attributeMap) {
    if (attributeMap === undefined) {
        return 0;
    }
    if (typeof attributeMap === "string" || typeof attributeMap === "number") {
        return attributeMap;
    }
    else if (attributeMap.hasOwnProperty("$id")) {
        const id = attributeMap.$id;
        if (typeof id === "string" || typeof id === "number") {
            return id;
        }
    }
    return 0;
}
exports.getFeatureId = getFeatureId;
/**
 * Determine the name of (OMV) feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param env - Environment containing the tags from the (OMV) feature.
 * @param useAbbreviation - `true` to use the abbreviation if available.
 * @param useIsoCode - `true` to use the tag "iso_code".
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureName(env, basePropName, useAbbreviation, useIsoCode, languages) {
    var _a;
    let name;
    if (basePropName === undefined) {
        basePropName = "name";
    }
    if (useAbbreviation) {
        const abbreviation = env.lookup(`${basePropName}:short`);
        if (typeof abbreviation === "string" && abbreviation.length > 0) {
            return abbreviation;
        }
    }
    if (useIsoCode) {
        const isoCode = env.lookup(`iso_code`);
        if (typeof isoCode === "string" && isoCode.length > 0) {
            return isoCode;
        }
    }
    if (languages !== undefined) {
        for (const lang of languages) {
            name = (_a = env.lookup(`${basePropName}:${lang}`)) !== null && _a !== void 0 ? _a : env.lookup(`${basePropName}_${lang}`);
            if (typeof name === "string" && name.length > 0) {
                return name;
            }
        }
    }
    name = env.lookup(basePropName);
    if (typeof name === "string") {
        return name;
    }
    return undefined;
}
exports.getFeatureName = getFeatureName;
/**
 * Determine the text string of the map feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param feature - Feature, including properties from the (OMV) feature.
 * @param technique - technique defining how text should be created from feature
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureText(context, technique, languages) {
    let useAbbreviation;
    let useIsoCode;
    const env = context instanceof Expr_1.Env ? context : context.env;
    let propName = "name";
    if (Techniques_1.isTextTechnique(technique) ||
        Techniques_1.isPoiTechnique(technique) ||
        Techniques_1.isLineMarkerTechnique(technique)) {
        if (technique.text !== undefined) {
            return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);
        }
        if (technique.label !== undefined) {
            propName = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.label);
            if (typeof propName !== "string") {
                return undefined;
            }
        }
        useAbbreviation = technique.useAbbreviation;
        useIsoCode = technique.useIsoCode;
    }
    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);
}
exports.getFeatureText = getFeatureText;
/**
 * Determine whether to scale heights by the projection scale factor for geometry
 * using the given technique.
 * @remarks Unless explicitly defined, the scale factor to convert meters to world space units
 * won't be applied if the tile's level is less than a fixed storage level.
 * @param context - Context for evaluation of technique attributes.
 * @param technique - Technique to be evaluated.
 * @param tileLevel - The level of the tile where the geometry is stored.
 * @returns `true` if height must be scaled, `false` otherwise.
 */
function scaleHeight(context, technique, tileLevel) {
    const SCALED_HEIGHT_MIN_STORAGE_LEVEL = 12;
    const useConstantHeight = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.constantHeight, tileLevel < SCALED_HEIGHT_MIN_STORAGE_LEVEL);
    return !useConstantHeight;
}
exports.scaleHeight = scaleHeight;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Env.ts":
/*!**********************************************!*\
  !*** ../harp-datasource-protocol/lib/Env.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapEnv = exports.Env = void 0;
/**
 * A class used to lookup properties by name.
 *
 * @remarks
 * Concrete implementation of `Env` like {@link MapEnv} are used
 * to resolve the property names used in {@link Expr | style expressions}.
 *
 * @example
 * ```typescript
 * const env = new MapEnv({
 *     kind: "landuse",
 * });
 *
 * const expr = Expr.fromJson(["get", "kind"]);
 *
 * const value = expr.evaluate(env);
 *
 * console.log(`kind is '${value}`);
 * ```
 */
class Env {
    /**
     * Returns `true` if the given object is an instance of {@link Env}.
     *
     * @param object - The object to test.
     */
    static isEnv(object) {
        return object instanceof Env;
    }
    /**
     * Returns property in {@link Env} by name.
     *
     * @param name - Name of property.
     */
    lookup(name) {
        return undefined;
    }
    /**
     * Return an object containing all properties of this environment. (Here: empty object).
     */
    unmap() {
        return {};
    }
}
exports.Env = Env;
/**
 * `MapEnv` is a concrete implementation of {@link Env} that
 * creates a lookup environment from a set of properties.
 *
 * @example
 * ```typescript
 * const baseEnv = new MapEnv({
 *     $zoom: 14,
 * });
 *
 * // extends baseEnv with a the new binding (kind, "landuse").
 * const env = new MapEnv({ kind: "landuse" }, baseEnv);
 *
 * const zoom = env.lookup("$zoom"); // zoom is 14
 * const kind = env.lookup("kind"); // kind is is "landuse"
 *
 * const expr = Expr.fromJson(["get", "kind"]);
 * const value = expr.evaluate(env); // value is "landuse"
 * ```
 */
class MapEnv extends Env {
    constructor(entries, parent) {
        super();
        this.entries = entries;
        this.parent = parent;
    }
    /**
     * Returns property in {@link Env} by name.
     *
     * @param name - Name of property.
     * @override
     */
    lookup(name) {
        if (this.entries.hasOwnProperty(name)) {
            const value = this.entries[name];
            if (value !== undefined) {
                return value;
            }
        }
        return this.parent ? this.parent.lookup(name) : undefined;
    }
    /**
     * Return an object containing all properties of this environment, takes care of the parent
     * object.
     * @override
     */
    unmap() {
        const obj = this.parent ? this.parent.unmap() : {};
        for (const key in this.entries) {
            if (this.entries.hasOwnProperty(key)) {
                obj[key] = this.entries[key];
            }
        }
        return obj;
    }
}
exports.MapEnv = MapEnv;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Expr.ts":
/*!***********************************************!*\
  !*** ../harp-datasource-protocol/lib/Expr.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterpolateExpr = exports.StepExpr = exports.CaseExpr = exports.MatchExpr = exports.LookupExpr = exports.CallExpr = exports.HasAttributeExpr = exports.ObjectLiteralExpr = exports.StringLiteralExpr = exports.NumberLiteralExpr = exports.BooleanLiteralExpr = exports.NullLiteralExpr = exports.LiteralExpr = exports.VarExpr = exports.Expr = exports.ExprScope = exports.isJsonExpr = exports.ExprDependencies = void 0;
/*
 * Copyright (C) 2019-2022 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const ExprEvaluator_1 = __webpack_require__(/*! ./ExprEvaluator */ "../harp-datasource-protocol/lib/ExprEvaluator.ts");
const ExprInstantiator_1 = __webpack_require__(/*! ./ExprInstantiator */ "../harp-datasource-protocol/lib/ExprInstantiator.ts");
const ExprParser_1 = __webpack_require__(/*! ./ExprParser */ "../harp-datasource-protocol/lib/ExprParser.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "../harp-datasource-protocol/lib/Pixels.ts");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "../harp-datasource-protocol/lib/RGBA.ts");
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
__exportStar(__webpack_require__(/*! ./Env */ "../harp-datasource-protocol/lib/Env.ts"), exports);
const exprEvaluator = new ExprEvaluator_1.ExprEvaluator();
const exprInstantiator = new ExprInstantiator_1.ExprInstantiator();
/**
 * The dependencies of an {@link Expr}.
 * @internal
 */
class ExprDependencies {
    constructor() {
        /**
         * The properties needed to evaluate the {@link Expr}.
         */
        this.properties = new Set();
    }
}
exports.ExprDependencies = ExprDependencies;
class ComputeExprDependencies {
    /**
     * Gets the dependencies of an {@link Expr}.
     *
     * @param expr - The {@link Expr} to process.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param dependencies - The output [[Set]] of dependency names.
     */
    static of(expr) {
        const dependencies = new ExprDependencies();
        expr.accept(this.instance, dependencies);
        return dependencies;
    }
    visitNullLiteralExpr(expr, context) {
        // nothing to do
    }
    visitBooleanLiteralExpr(expr, context) {
        // nothing to do
    }
    visitNumberLiteralExpr(expr, context) {
        // nothing to do
    }
    visitStringLiteralExpr(expr, context) {
        // nothing to do
    }
    visitObjectLiteralExpr(expr, context) {
        // nothing to do
    }
    visitVarExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitHasAttributeExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitCallExpr(expr, context) {
        expr.args.forEach(childExpr => childExpr.accept(this, context));
        switch (expr.op) {
            case "dynamic-properties":
                context.volatile = true;
                break;
            case "feature-state":
                context.featureState = true;
                context.properties.add("$state");
                context.properties.add("$id");
                break;
            case "id":
                context.properties.add("$id");
                break;
            case "zoom":
            case "world-ppi-scale":
            case "world-discrete-ppi-scale":
                context.properties.add("$zoom");
                break;
            case "geometry-type":
                context.properties.add("$geometryType");
                break;
            default:
                break;
        }
    }
    visitLookupExpr(expr, context) {
        // Same behaviour as call expressions.
        return this.visitCallExpr(expr, context);
    }
    visitMatchExpr(expr, context) {
        expr.value.accept(this, context);
        expr.branches.forEach(([_, branch]) => branch.accept(this, context));
        expr.fallback.accept(this, context);
    }
    visitCaseExpr(expr, context) {
        expr.branches.forEach(([condition, branch]) => {
            condition.accept(this, context);
            branch.accept(this, context);
        });
        expr.fallback.accept(this, context);
    }
    visitStepExpr(expr, context) {
        expr.input.accept(this, context);
        expr.defaultValue.accept(this, context);
        expr.stops.forEach(([_, value]) => value.accept(this, context));
    }
    visitInterpolateExpr(expr, context) {
        expr.input.accept(this, context);
        expr.stops.forEach(([_, value]) => value.accept(this, context));
    }
}
ComputeExprDependencies.instance = new ComputeExprDependencies();
function isJsonExpr(v) {
    return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
exports.isJsonExpr = isJsonExpr;
/**
 * The evaluation scope of an {@link Expr}.
 * @internal
 */
var ExprScope;
(function (ExprScope) {
    /**
     * The scope of an {@link Expr} used as value of an attribute.
     */
    ExprScope[ExprScope["Value"] = 0] = "Value";
    /**
     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.
     */
    ExprScope[ExprScope["Condition"] = 1] = "Condition";
    /**
     * The scope of an {@link Expr} used as dynamic property attribute value.
     */
    ExprScope[ExprScope["Dynamic"] = 2] = "Dynamic";
})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));
/**
 * Abstract class representing the
 * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}
 * used in {@link Theme}.
 */
class Expr {
    /**
     * Tests of given value is an {@link Expr}.
     *
     * @param value - The object to test.
     */
    static isExpr(value) {
        return value instanceof Expr;
    }
    /**
     * Creates an expression from the given `code`.
     *
     * @param code - The code to parse.
     * @returns The parsed {@link Expr}.
     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.
     */
    static parse(code) {
        const parser = new ExprParser_1.ExprParser(code);
        const expr = parser.parse();
        return expr;
    }
    /**
     * Creates a style expression from JSON.
     *
     * @remarks
     * The optional set of {@link Theme.definitions | definitions} is used
     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.
     *
     * @param json - JSON object representing the expression to parse.
     * @param definitions - Optional set of definitions used to expand references.
     * @param definitionExprCache - Optional cache of `Expr` instances
     *
     * @example
     * ```typescript
     * const expr = Expr.fromJSON(["all",
     *     ["==", ["geometry-type"], "LineString"],
     *     ["has", "text"]
     * ]);
     * ```
     */
    static fromJSON(json, definitions, definitionExprCache) {
        const referenceResolverState = definitions !== undefined
            ? {
                definitions,
                lockedNames: new Set(),
                cache: definitionExprCache !== null && definitionExprCache !== void 0 ? definitionExprCache : new Map()
            }
            : undefined;
        return parseNode(json, referenceResolverState);
    }
    /**
     * Evaluate an expression returning a {@link Value} object.
     *
     * @param env - The {@link Env} used to lookup symbols.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param cache - A cache of previously computed results.
     */
    evaluate(env, scope = ExprScope.Value, cache) {
        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));
    }
    /**
     * Instantiates this {@link Expr}.
     *
     * @remarks
     * references to the `get` and `has` operator using the given instantiation context.
     *
     * @param context - The [[InstantationContext]] used to resolve names.
     */
    instantiate(context) {
        return this.accept(exprInstantiator, context);
    }
    /**
     * Gets the dependencies of this {@link Expr}.
     */
    dependencies() {
        if (!this.m_dependencies) {
            this.m_dependencies = ComputeExprDependencies.of(this);
        }
        return this.m_dependencies;
    }
    /**
     * Create a unique object that is structurally equivalent to this {@link Expr}.
     *
     * @param pool - The [[ExprPool]] used to create a unique
     * equivalent object of this {@link Expr}.
     */
    intern(pool) {
        return pool.add(this);
    }
    toJSON() {
        return new ExprSerializer().serialize(this);
    }
    /**
     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.
     */
    isDynamic() {
        if (this.m_isDynamic === undefined) {
            this.m_isDynamic = this.exprIsDynamic();
        }
        return this.m_isDynamic;
    }
}
exports.Expr = Expr;
/**
 * A node representing a `get` expression.
 * @internal
 */
class VarExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitVarExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.VarExpr = VarExpr;
/**
 * A node representing a `literal` expression.
 * @internal
 */
class LiteralExpr extends Expr {
    /**
     * Create a [[LiteralExpr]] from the given value.
     *
     * @param value - A constant value.
     */
    static fromValue(value) {
        switch (typeof value) {
            case "boolean":
                return new BooleanLiteralExpr(value);
            case "number":
                return new NumberLiteralExpr(value);
            case "string":
                return new StringLiteralExpr(value);
            case "object":
                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);
            default:
                throw new Error(`failed to create a literal from '${value}'`);
        } // switch
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.LiteralExpr = LiteralExpr;
/**
 * Null literal expression.
 * @internal
 */
class NullLiteralExpr extends LiteralExpr {
    constructor() {
        super();
        /** @override */
        this.value = null;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNullLiteralExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.NullLiteralExpr = NullLiteralExpr;
NullLiteralExpr.instance = new NullLiteralExpr();
/**
 * Boolean literal expression.
 * @internal
 */
class BooleanLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitBooleanLiteralExpr(this, context);
    }
}
exports.BooleanLiteralExpr = BooleanLiteralExpr;
/**
 * Number literal expression.
 * @internal
 */
class NumberLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNumberLiteralExpr(this, context);
    }
}
exports.NumberLiteralExpr = NumberLiteralExpr;
/**
 * String literal expression.
 * @internal
 */
class StringLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.
     */
    get promotedValue() {
        var _a, _b, _c;
        if (this.m_promotedValue === undefined) {
            this.m_promotedValue = (_b = (_a = RGBA_1.RGBA.parse(this.value)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(this.value)) !== null && _b !== void 0 ? _b : null;
        }
        return (_c = this.m_promotedValue) !== null && _c !== void 0 ? _c : undefined;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStringLiteralExpr(this, context);
    }
}
exports.StringLiteralExpr = StringLiteralExpr;
/**
 * Object literal expression.
 * @internal
 */
class ObjectLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    get isArrayLiteral() {
        return Array.isArray(this.value);
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitObjectLiteralExpr(this, context);
    }
}
exports.ObjectLiteralExpr = ObjectLiteralExpr;
/**
 * A node reperesenting a `has` expression.
 * @internal
 */
class HasAttributeExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitHasAttributeExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.HasAttributeExpr = HasAttributeExpr;
/**
 * A node representing a `call` expression.
 * @internal
 */
class CallExpr extends Expr {
    constructor(op, args) {
        super();
        this.op = op;
        this.args = args;
    }
    /**
     * Returns the child nodes of this {@link Expr}.
     *
     * @deprecated Use {@link CallExpr.args} instead.
     */
    get children() {
        return this.args;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCallExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        var _a;
        const descriptor = (_a = this.descriptor) !== null && _a !== void 0 ? _a : ExprEvaluator_1.ExprEvaluator.getOperator(this.op);
        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
            return true;
        }
        return this.args.some(e => e.isDynamic());
    }
}
exports.CallExpr = CallExpr;
/**
 * A `lookup` expression is a call expression using the `lookup` operator. Then only difference is
 * that the lookup table definition (first argument) is cached as a map for fast search
 * (see {@link ExprEvaluator.visitLookupExpr}).
 * @internal
 */
class LookupExpr extends CallExpr {
    /**
     * Constructs a LookupExpr instance.
     * @param args Arguments of the lookup expression. At least an argument for the lookup table.
     */
    constructor(args) {
        super("lookup", args);
        this.args = args;
    }
    /**
     * Creates a lookup expression from a {@link JsonArray}.
     * @param node The {@link JsonArray} to parse.
     * @param referenceResolverState Used to resolve references to definitions.
     * @returns A LookupExpr instance.
     */
    static parseArray(node, referenceResolverState) {
        const lookupTableNode = node[1];
        if (lookupTableNode === undefined) {
            throw new Error("missing lookup table in 'lookup' expression");
        }
        const lookupTableExpr = parseNode(lookupTableNode, referenceResolverState);
        if (!Array.isArray(lookupTableNode) || !(lookupTableExpr instanceof ObjectLiteralExpr)) {
            throw new Error(`Invalid lookup table expression for operator 'lookup'. It must be a literal or a ref to one.`);
        }
        const lookupTable = lookupTableExpr.value;
        if (!Array.isArray(lookupTable)) {
            throw new Error(`Invalid lookup table type (${typeof lookupTable}) for operator 'lookup'`);
        }
        // Skip the operator name and the lookup table and parse the rest of the arguments. Then add
        // the lookup table expr as first argument.
        const args = node.slice(2).map(childExpr => parseNode(childExpr, referenceResolverState));
        args.unshift(lookupTableExpr);
        return new LookupExpr(args);
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitLookupExpr(this, context);
    }
}
exports.LookupExpr = LookupExpr;
/**
 * A node representing a `match` expression.
 * @internal
 */
class MatchExpr extends Expr {
    constructor(value, branches, fallback) {
        super();
        this.value = value;
        this.branches = branches;
        this.fallback = fallback;
    }
    /**
     * Tests if the given JSON node is a valid label for the `"match"` operator.
     *
     * @param node - A JSON value.
     */
    static isValidMatchLabel(node) {
        switch (typeof node) {
            case "number":
            case "string":
                return true;
            case "object":
                if (!Array.isArray(node) || node.length === 0) {
                    return false;
                }
                const elementTy = typeof node[0];
                if (elementTy === "number" || elementTy === "string") {
                    return node.every(t => typeof t === elementTy);
                }
                return false;
            default:
                return false;
        } // switch
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitMatchExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.value.isDynamic() ||
            this.branches.some(([_, branch]) => branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.MatchExpr = MatchExpr;
/**
 * A node representing a `case` expression.
 * @internal
 */
class CaseExpr extends Expr {
    constructor(branches, fallback) {
        super();
        this.branches = branches;
        this.fallback = fallback;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCaseExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.CaseExpr = CaseExpr;
/**
 * A node representing a `step` expression.
 * @internal
 */
class StepExpr extends Expr {
    constructor(input, defaultValue, stops) {
        super();
        this.input = input;
        this.defaultValue = defaultValue;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStepExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.input.isDynamic() ||
            this.defaultValue.isDynamic() ||
            this.stops.some(([_, value]) => value.isDynamic()));
    }
}
exports.StepExpr = StepExpr;
/**
 * A node representing an `interpolate` expression.
 * @internal
 */
class InterpolateExpr extends Expr {
    constructor(mode, input, stops) {
        super();
        this.mode = mode;
        this.input = input;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitInterpolateExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());
    }
}
exports.InterpolateExpr = InterpolateExpr;
/**
 * Serializes the Expr to JSON.
 *
 * @internal
 */
class ExprSerializer {
    serialize(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        if (expr.value instanceof THREE.Vector2) {
            return ["make-vector", expr.value.x, expr.value.y];
        }
        else if (expr.value instanceof THREE.Vector3) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z];
        }
        else if (expr.value instanceof THREE.Vector4) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z, expr.value.w];
        }
        return ["literal", expr.value];
    }
    visitVarExpr(expr, context) {
        return ["get", expr.name];
    }
    visitHasAttributeExpr(expr, context) {
        return ["has", expr.name];
    }
    visitCallExpr(expr, context) {
        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];
    }
    visitLookupExpr(expr, context) {
        // Same serialization as call expressions.
        return this.visitCallExpr(expr, context);
    }
    visitMatchExpr(expr, context) {
        const branches = [];
        for (const [label, body] of expr.branches) {
            branches.push(label, this.serialize(body));
        }
        return ["match", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        for (const [condition, body] of expr.branches) {
            branches.push(this.serialize(condition), this.serialize(body));
        }
        return ["case", ...branches, this.serialize(expr.fallback)];
    }
    visitStepExpr(expr, context) {
        const result = ["step"];
        result.push(this.serialize(expr.input));
        result.push(this.serialize(expr.defaultValue));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
    visitInterpolateExpr(expr, context) {
        const result = ["interpolate", expr.mode];
        result.push(this.serialize(expr.input));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
}
function parseNode(node, referenceResolverState) {
    if (Array.isArray(node)) {
        return parseCall(node, referenceResolverState);
    }
    else if (node === null) {
        return NullLiteralExpr.instance;
    }
    else if (typeof node === "boolean") {
        return new BooleanLiteralExpr(node);
    }
    else if (typeof node === "number") {
        return new NumberLiteralExpr(node);
    }
    else if (typeof node === "string") {
        return new StringLiteralExpr(node);
    }
    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);
}
function parseCall(node, referenceResolverState) {
    const op = node[0];
    if (typeof op !== "string") {
        throw new Error("expected a builtin function name");
    }
    switch (op) {
        case "!has":
        case "!in":
            return new CallExpr("!", [parseCall([op.slice(1), ...node.slice(1)])]);
        case "ref":
            return resolveReference(node, referenceResolverState);
        case "get":
            return parseGetExpr(node, referenceResolverState);
        case "has":
            return parseHasExpr(node, referenceResolverState);
        case "literal":
            return parseLiteralExpr(node);
        case "match":
            return parseMatchExpr(node, referenceResolverState);
        case "case":
            return parseCaseExpr(node, referenceResolverState);
        case "interpolate":
            return parseInterpolateExpr(node, referenceResolverState);
        case "step":
            return parseStepExpr(node, referenceResolverState);
        case "lookup":
            return LookupExpr.parseArray(node, referenceResolverState);
        default:
            return makeCallExpr(op, node, referenceResolverState);
    } // switch
}
function parseGetExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("get", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new VarExpr(name);
}
function parseHasExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("has", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new HasAttributeExpr(name);
}
function parseLiteralExpr(node) {
    const obj = node[1];
    if (obj === null || typeof obj !== "object") {
        throw new Error("expected an object or array literal");
    }
    return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
    if (node.length < 4) {
        throw new Error("not enough arguments");
    }
    if (!(node.length % 2)) {
        throw new Error("fallback is missing in 'match' expression");
    }
    const value = parseNode(node[1], referenceResolverState);
    const conditions = [];
    for (let i = 2; i < node.length - 1; i += 2) {
        const label = node[i];
        if (!MatchExpr.isValidMatchLabel(label)) {
            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);
        }
        const expr = parseNode(node[i + 1], referenceResolverState);
        conditions.push([label, expr]);
    }
    const fallback = parseNode(node[node.length - 1], referenceResolverState);
    return new MatchExpr(value, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
    if (node.length < 3) {
        throw new Error("not enough arguments");
    }
    if (node.length % 2) {
        throw new Error("fallback is missing in 'case' expression");
    }
    const branches = [];
    for (let i = 1; i < node.length - 1; i += 2) {
        const condition = parseNode(node[i], referenceResolverState);
        const expr = parseNode(node[i + 1], referenceResolverState);
        branches.push([condition, expr]);
    }
    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);
    return new CaseExpr(branches, caseFallback);
}
function isInterpolationMode(object) {
    if (!Array.isArray(object)) {
        return false;
    }
    switch (object[0]) {
        case "discrete":
        case "linear":
        case "cubic":
        case "exponential":
            return true;
        default:
            return false;
    }
}
function parseInterpolateExpr(node, referenceResolverState) {
    const mode = node[1];
    if (!isInterpolationMode(mode)) {
        throw new Error("expected an interpolation type");
    }
    if (mode[0] === "exponential" && typeof mode[1] !== "number") {
        throw new Error("expected the base of the exponential interpolation");
    }
    const input = node[2] !== undefined ? parseNode(node[2], referenceResolverState) : undefined;
    if (!Expr.isExpr(input)) {
        throw new Error(`expected the input of the interpolation`);
    }
    if (node.length === 3 || !(node.length % 2)) {
        throw new Error("invalid number of samples");
    }
    const stops = [];
    for (let i = 3; i < node.length - 1; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new InterpolateExpr(mode, input, stops);
}
function parseStepExpr(node, referenceResolverState) {
    if (node.length < 2) {
        throw new Error("expected the input of the 'step' operator");
    }
    if (node.length < 3 || !(node.length % 2)) {
        throw new Error("not enough arguments");
    }
    const input = parseNode(node[1], referenceResolverState);
    const defaultValue = parseNode(node[2], referenceResolverState);
    const stops = [];
    for (let i = 3; i < node.length; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new StepExpr(input, defaultValue, stops);
}
function makeCallExpr(op, node, referenceResolverState) {
    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));
}
function resolveReference(node, referenceResolverState) {
    if (typeof node[1] !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    if (referenceResolverState === undefined) {
        throw new Error(`ref used with no definitions`);
    }
    const name = node[1];
    if (referenceResolverState.lockedNames.has(name)) {
        throw new Error(`circular referene to '${name}'`);
    }
    if (!(name in referenceResolverState.definitions)) {
        throw new Error(`definition '${name}' not found`);
    }
    const cachedEntry = referenceResolverState.cache.get(name);
    if (cachedEntry !== undefined) {
        return cachedEntry;
    }
    let definitionEntry = referenceResolverState.definitions[name];
    let result;
    const definitionValue = Theme_1.getDefinitionValue(definitionEntry);
    if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(definitionValue)) {
        // found a reference to an interpolation using
        // the deprecated object-like syntax.
        return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry));
    }
    else if (isJsonExpr(definitionValue)) {
        definitionEntry = definitionValue;
    }
    else {
        return Expr.fromJSON(definitionValue);
    }
    if (isJsonExpr(definitionEntry)) {
        referenceResolverState.lockedNames.add(name);
        try {
            result = parseNode(definitionEntry, referenceResolverState);
        }
        finally {
            referenceResolverState.lockedNames.delete(name);
        }
    }
    else {
        throw new Error(`unsupported definition ${name}`);
    }
    referenceResolverState.cache.set(name, result);
    return result;
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprEvaluator.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprEvaluator.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExprEvaluator = exports.ExprEvaluatorContext = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const ArrayOperators_1 = __webpack_require__(/*! ./operators/ArrayOperators */ "../harp-datasource-protocol/lib/operators/ArrayOperators.ts");
const CastOperators_1 = __webpack_require__(/*! ./operators/CastOperators */ "../harp-datasource-protocol/lib/operators/CastOperators.ts");
const ColorOperators_1 = __webpack_require__(/*! ./operators/ColorOperators */ "../harp-datasource-protocol/lib/operators/ColorOperators.ts");
const ComparisonOperators_1 = __webpack_require__(/*! ./operators/ComparisonOperators */ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts");
const FeatureOperators_1 = __webpack_require__(/*! ./operators/FeatureOperators */ "../harp-datasource-protocol/lib/operators/FeatureOperators.ts");
const FlowOperators_1 = __webpack_require__(/*! ./operators/FlowOperators */ "../harp-datasource-protocol/lib/operators/FlowOperators.ts");
const MapOperators_1 = __webpack_require__(/*! ./operators/MapOperators */ "../harp-datasource-protocol/lib/operators/MapOperators.ts");
const MathOperators_1 = __webpack_require__(/*! ./operators/MathOperators */ "../harp-datasource-protocol/lib/operators/MathOperators.ts");
const MiscOperators_1 = __webpack_require__(/*! ./operators/MiscOperators */ "../harp-datasource-protocol/lib/operators/MiscOperators.ts");
const ObjectOperators_1 = __webpack_require__(/*! ./operators/ObjectOperators */ "../harp-datasource-protocol/lib/operators/ObjectOperators.ts");
const StringOperators_1 = __webpack_require__(/*! ./operators/StringOperators */ "../harp-datasource-protocol/lib/operators/StringOperators.ts");
const TypeOperators_1 = __webpack_require__(/*! ./operators/TypeOperators */ "../harp-datasource-protocol/lib/operators/TypeOperators.ts");
const VectorOperators_1 = __webpack_require__(/*! ./operators/VectorOperators */ "../harp-datasource-protocol/lib/operators/VectorOperators.ts");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "../harp-datasource-protocol/lib/Pixels.ts");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "../harp-datasource-protocol/lib/RGBA.ts");
const operatorDescriptors = new Map();
/**
 * Promote string literals and values to color and pixel constants.
 *
 * @hidden
 * @internal
 */
function promoteValue(context, expr) {
    var _a, _b, _c;
    if (expr instanceof Expr_1.StringLiteralExpr) {
        return (_a = expr.promotedValue) !== null && _a !== void 0 ? _a : expr.value;
    }
    const value = context.evaluate(expr);
    if (typeof value === "string") {
        return (_c = (_b = RGBA_1.RGBA.parse(value)) !== null && _b !== void 0 ? _b : Pixels_1.Pixels.parse(value)) !== null && _c !== void 0 ? _c : value;
    }
    return value;
}
function cubicInterpolate(context, interp, t) {
    if (t < interp.stops[0][0]) {
        return promoteValue(context, interp.stops[0][1]);
    }
    else if (t >= interp.stops[interp.stops.length - 1][0]) {
        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);
    }
    // indices
    const i1 = interp.stops.findIndex(stop => stop[0] > t);
    const i0 = Math.max(0, i1 - 1);
    const iP = i0 === 0 ? i1 : i0 - 1;
    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;
    // keys
    const tP = interp.stops[iP][0];
    const t0 = interp.stops[i0][0];
    const t1 = interp.stops[i1][0];
    const tN = interp.stops[iN][0];
    const dt = (t1 - t0) * 0.5;
    const wP = dt / (t0 - tP);
    const wN = dt / (tN - t1);
    const p = (t - t0) / (t1 - t0);
    const pp = p * p;
    const ppp = pp * p;
    // coefficients
    const cP = -wP * ppp + 2 * wP * pp - wP * p;
    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const cN = wN * ppp - wN * pp;
    // values
    const vP = promoteValue(context, interp.stops[iP][1]);
    const v0 = promoteValue(context, interp.stops[i0][1]);
    const v1 = promoteValue(context, interp.stops[i1][1]);
    const vN = promoteValue(context, interp.stops[iN][1]);
    if (typeof vP === "number" &&
        typeof v0 === "number" &&
        typeof v1 === "number" &&
        typeof vN === "number") {
        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;
    }
    else if (vP instanceof RGBA_1.RGBA &&
        v0 instanceof RGBA_1.RGBA &&
        v1 instanceof RGBA_1.RGBA &&
        vN instanceof RGBA_1.RGBA) {
        return new RGBA_1.RGBA(THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1), THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1), THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1), THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1));
    }
    else if (vP instanceof Pixels_1.Pixels &&
        v0 instanceof Pixels_1.Pixels &&
        v1 instanceof Pixels_1.Pixels &&
        vN instanceof Pixels_1.Pixels) {
        return new Pixels_1.Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);
    }
    else if (vP instanceof THREE.Color &&
        v0 instanceof THREE.Color &&
        v1 instanceof THREE.Color &&
        vN instanceof THREE.Color) {
        return new THREE.Color(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b);
    }
    else if (vP instanceof THREE.Vector2 &&
        v0 instanceof THREE.Vector2 &&
        v1 instanceof THREE.Vector2 &&
        vN instanceof THREE.Vector2) {
        return new THREE.Vector2(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y);
    }
    else if (vP instanceof THREE.Vector3 &&
        v0 instanceof THREE.Vector3 &&
        v1 instanceof THREE.Vector3 &&
        vN instanceof THREE.Vector3) {
        return new THREE.Vector3(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z);
    }
    else if (vP instanceof THREE.Vector4 &&
        v0 instanceof THREE.Vector4 &&
        v1 instanceof THREE.Vector4 &&
        vN instanceof THREE.Vector4) {
        return new THREE.Vector4(cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x, cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y, cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z, cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w);
    }
    else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {
        const N = vP.length;
        const r = [];
        for (let i = 0; i < N; ++i) {
            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];
        }
        return r;
    }
    throw new Error(`failed to interpolate values`);
}
/*
 * @hidden
 */
class ExprEvaluatorContext {
    constructor(evaluator, env, scope, cache) {
        this.evaluator = evaluator;
        this.env = env;
        this.scope = scope;
        this.cache = cache;
    }
    /**
     * Evaluate the given expression.
     *
     * @param expr - The {@link Expr} to evaluate.
     */
    evaluate(expr) {
        var _a, _b;
        if (expr === undefined) {
            throw new Error("Failed to evaluate expression");
        }
        const cachedResult = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(expr);
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        const result = expr.accept(this.evaluator, this);
        (_b = this.cache) === null || _b === void 0 ? void 0 : _b.set(expr, result);
        return result;
    }
    /**
     * Wraps the given value in an {@link Expr} if needed.
     *
     * @param value -
     */
    wrapValue(value) {
        return Expr_1.Expr.isExpr(value) ? value : Expr_1.LiteralExpr.fromValue(value);
    }
}
exports.ExprEvaluatorContext = ExprEvaluatorContext;
/**
 * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.
 *
 * @hidden
 */
class ExprEvaluator {
    static defineOperator(op, builtin) {
        operatorDescriptors.set(op, builtin);
    }
    static defineOperators(builtins) {
        Object.getOwnPropertyNames(builtins).forEach(p => {
            this.defineOperator(p, builtins[p]);
        });
    }
    /**
     * Returns the [[OperatorDescriptor]] for the given operator name.
     * @hidden
     */
    static getOperator(op) {
        return operatorDescriptors.get(op);
    }
    visitVarExpr(expr, context) {
        const value = context.env.lookup(expr.name);
        return value !== undefined ? value : null;
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        return expr.value;
    }
    visitHasAttributeExpr(expr, context) {
        return context.env.lookup(expr.name) !== undefined;
    }
    visitMatchExpr(match, context) {
        const r = context.evaluate(match.value);
        for (const [label, body] of match.branches) {
            if (Array.isArray(label) && label.includes(r)) {
                return context.evaluate(body);
            }
            else if (label === r) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCaseExpr(match, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const firstDynamicCondition = match.branches.findIndex(([condition, _]) => condition.isDynamic());
            if (firstDynamicCondition !== -1) {
                let branches;
                for (let i = 0; i < match.branches.length; ++i) {
                    const [condition, body] = match.branches[i];
                    const evaluatedCondition = context.evaluate(condition);
                    const evaluatedBody = context.evaluate(body);
                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {
                        return evaluatedBody;
                    }
                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {
                        // skip this branch, it constantly evaluates to false.
                        continue;
                    }
                    if (branches === undefined) {
                        branches = [];
                    }
                    branches === null || branches === void 0 ? void 0 : branches.push([
                        context.wrapValue(evaluatedCondition),
                        context.wrapValue(evaluatedBody)
                    ]);
                    if (!Expr_1.Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {
                        // skip unreachble expressions
                        return new Expr_1.CaseExpr(branches, Expr_1.LiteralExpr.fromValue(null));
                    }
                }
                const fallback = context.evaluate(match.fallback);
                return branches === undefined
                    ? fallback
                    : new Expr_1.CaseExpr(branches, context.wrapValue(fallback));
            }
        }
        for (const [condition, body] of match.branches) {
            if (context.evaluate(condition)) {
                return context.evaluate(body);
            }
        }
        return context.evaluate(match.fallback);
    }
    visitCallExpr(expr, context) {
        var _a;
        const descriptor = (_a = expr.descriptor) !== null && _a !== void 0 ? _a : operatorDescriptors.get(expr.op);
        if (descriptor) {
            expr.descriptor = descriptor;
            let result;
            if (context.scope === Expr_1.ExprScope.Value && expr.isDynamic()) {
                if (expr.descriptor.partialEvaluate) {
                    return expr.descriptor.partialEvaluate(context, expr);
                }
                const args = expr.args.map(arg => {
                    return context.wrapValue(context.evaluate(arg));
                });
                if (args.every((arg, i) => arg === expr.args[i])) {
                    return expr;
                }
                result = new Expr_1.CallExpr(expr.op, args);
            }
            else {
                result = descriptor.call(context, expr);
            }
            return result;
        }
        throw new Error(`undefined operator '${expr.op}'`);
    }
    visitLookupExpr(expr, context) {
        // Same behaviour as call expressions.
        return this.visitCallExpr(expr, context);
    }
    visitStepExpr(expr, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const input = context.evaluate(expr.input);
            const defaultValue = context.evaluate(expr.defaultValue);
            return new Expr_1.StepExpr(context.wrapValue(input), context.wrapValue(defaultValue), expr.stops.map(([key, value]) => {
                const v = context.evaluate(value);
                return [key, context.wrapValue(v)];
            }));
        }
        else {
            const input = context.evaluate(expr.input);
            if (typeof input !== "number") {
                throw new Error(`input '${input}' must be a number`);
            }
            if (input < expr.stops[0][0]) {
                return context.evaluate(expr.defaultValue);
            }
            let index = expr.stops.findIndex(s => s[0] > input);
            if (index === -1) {
                index = expr.stops.length;
            }
            return context.evaluate(expr.stops[index - 1][1]);
        }
    }
    visitInterpolateExpr(expr, context) {
        if (context.scope === Expr_1.ExprScope.Value) {
            const input = context.evaluate(expr.input);
            return new Expr_1.InterpolateExpr(expr.mode, context.wrapValue(input), expr.stops.map(([key, value]) => {
                const v = context.evaluate(value);
                return [key, context.wrapValue(v)];
            }));
        }
        else {
            const param = context.evaluate(expr.input);
            if (typeof param !== "number") {
                throw new Error(`input must be a number`);
            }
            if (expr.mode[0] === "cubic") {
                return cubicInterpolate(context, expr, param);
            }
            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);
            if (keyIndex === -1) {
                // all the keys are smaller than the parameter
                return context.evaluate(expr.stops[expr.stops.length - 1][1]);
            }
            else if (keyIndex === 0) {
                return context.evaluate(expr.stops[0][1]);
            }
            const [key, value] = expr.stops[keyIndex];
            const [prevKey, prevValue] = expr.stops[keyIndex - 1];
            const v0 = promoteValue(context, prevValue);
            let t = 0;
            switch (expr.mode[0]) {
                case "discrete":
                    return v0;
                case "linear":
                    t = (param - prevKey) / (key - prevKey);
                    break;
                case "exponential": {
                    const base = expr.mode[1];
                    t =
                        base === 1
                            ? (param - prevKey) / (key - prevKey)
                            : (Math.pow(base, param - prevKey) - 1) /
                                (Math.pow(base, key - prevKey) - 1);
                    break;
                }
                default:
                    throw new Error(`interpolation mode ${JSON.stringify(expr.mode)} is not supported`);
            }
            const v1 = promoteValue(context, value);
            if (typeof v0 === "number" && typeof v1 === "number") {
                return THREE.MathUtils.lerp(v0, v1, t);
            }
            else if (v0 instanceof RGBA_1.RGBA && v1 instanceof RGBA_1.RGBA) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof Pixels_1.Pixels && v1 instanceof Pixels_1.Pixels) {
                return new Pixels_1.Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));
            }
            else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {
                return v0.clone().lerp(v1, t);
            }
            else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {
                return v0.clone().lerp(v1, t);
            }
            else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {
                return v0.map((x, i) => THREE.MathUtils.lerp(x, v1[i], t));
            }
            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);
        }
    }
}
exports.ExprEvaluator = ExprEvaluator;
ExprEvaluator.defineOperators(CastOperators_1.CastOperators);
ExprEvaluator.defineOperators(ComparisonOperators_1.ComparisonOperators);
ExprEvaluator.defineOperators(MathOperators_1.MathOperators);
ExprEvaluator.defineOperators(StringOperators_1.StringOperators);
ExprEvaluator.defineOperators(ColorOperators_1.ColorOperators);
ExprEvaluator.defineOperators(TypeOperators_1.TypeOperators);
ExprEvaluator.defineOperators(MiscOperators_1.MiscOperators);
ExprEvaluator.defineOperators(FlowOperators_1.FlowOperators);
ExprEvaluator.defineOperators(ArrayOperators_1.ArrayOperators);
ExprEvaluator.defineOperators(ObjectOperators_1.ObjectOperators);
ExprEvaluator.defineOperators(FeatureOperators_1.FeatureOperators);
ExprEvaluator.defineOperators(MapOperators_1.MapOperators);
ExprEvaluator.defineOperators(VectorOperators_1.VectorOperators);


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprInstantiator.ts":
/*!***********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprInstantiator.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExprInstantiator = void 0;
const Env_1 = __webpack_require__(/*! ./Env */ "../harp-datasource-protocol/lib/Env.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const emptyEnv = new Env_1.Env();
/**
 * @hidden
 */
class ExprInstantiator {
    visitNullLiteralExpr(expr, _context) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, _context) {
        return expr;
    }
    visitNumberLiteralExpr(expr, _context) {
        return expr;
    }
    visitStringLiteralExpr(expr, _context) {
        return expr;
    }
    visitObjectLiteralExpr(expr, _context) {
        return expr;
    }
    visitVarExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name);
        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);
    }
    visitHasAttributeExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name) !== undefined;
        return Expr_1.LiteralExpr.fromValue(value);
    }
    visitCallExprImpl(expr, context, constructor) {
        const args = expr.args.map(arg => arg.accept(this, context));
        if (args.some((a, i) => a !== expr.args[i])) {
            return constructor(expr.op, args);
        }
        return expr;
    }
    visitCallExpr(expr, context) {
        return this.visitCallExprImpl(expr, context, (op, args) => {
            return new Expr_1.CallExpr(op, args);
        });
    }
    visitLookupExpr(expr, context) {
        return this.visitCallExprImpl(expr, context, (op, args) => {
            return new Expr_1.LookupExpr(args);
        });
    }
    visitMatchExpr(match, context) {
        const value = match.value.accept(this, context);
        if (value instanceof Expr_1.LiteralExpr) {
            const r = value.value;
            for (const [label, body] of match.branches) {
                if (Array.isArray(label) && label.includes(r)) {
                    return body.accept(this, context);
                }
                else if (label === r) {
                    return body.accept(this, context);
                }
            }
            return match.fallback.accept(this, context);
        }
        let changed = match.value !== value;
        const branches = match.branches.map(([label, branch]) => {
            const newBranch = branch.accept(this, context);
            if (newBranch !== branch) {
                changed = true;
            }
            return [label, newBranch];
        });
        const fallback = match.fallback.accept(this, context);
        if (fallback !== match.fallback) {
            changed = true;
        }
        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        let changed = false;
        for (const [condition, branch] of expr.branches) {
            const newCondition = condition.accept(this, context);
            const deps = newCondition.dependencies();
            if (!condition.isDynamic() && deps.properties.size === 0) {
                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {
                    return branch.accept(this, context);
                }
            }
            else {
                if (newCondition !== condition) {
                    changed = true;
                }
                branches.push([newCondition, branch]);
            }
        }
        if (branches.length === 0) {
            // all the conditions of this CaseExpr evaluated
            // to false, so the resulting of instantiating this CaseExpr
            // is the same as instantiating its fallback expression.
            return expr.fallback.accept(this, context);
        }
        if (branches.length !== expr.branches.length) {
            // the number of branches changed, this means that
            // some of the branches had constant expressions that
            // evaluate to false. In this case the resulting
            // `CaseExpr` has less branches.
            changed = true;
        }
        // Instantiate the body of all the branches of this CaseExpr
        // that have dynamic conditions.
        branches.forEach(branch => {
            const instantiatedBranch = branch[1].accept(this, context);
            if (instantiatedBranch !== branch[1]) {
                changed = true;
            }
            branch[1] = instantiatedBranch;
        });
        const fallback = expr.fallback.accept(this, context);
        if (fallback !== expr.fallback) {
            changed = true;
        }
        if (!changed) {
            // nothing changed, return the old expression.
            return expr;
        }
        return new Expr_1.CaseExpr(branches, fallback);
    }
    visitStepExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.StepExpr(input, defaultValue, stops);
    }
    visitInterpolateExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.InterpolateExpr(expr.mode, input, stops);
    }
}
exports.ExprInstantiator = ExprInstantiator;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprParser.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprParser.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExprParser = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * Character value
 */
var Character;
(function (Character) {
    Character[Character["Tab"] = 9] = "Tab";
    Character[Character["Lf"] = 10] = "Lf";
    Character[Character["Cr"] = 13] = "Cr";
    Character[Character["Space"] = 32] = "Space";
    Character[Character["LParen"] = 40] = "LParen";
    Character[Character["RParen"] = 41] = "RParen";
    Character[Character["Comma"] = 44] = "Comma";
    Character[Character["Dot"] = 46] = "Dot";
    Character[Character["LBracket"] = 91] = "LBracket";
    Character[Character["Backslash"] = 92] = "Backslash";
    Character[Character["RBracket"] = 93] = "RBracket";
    Character[Character["_0"] = 48] = "_0";
    Character[Character["_9"] = 57] = "_9";
    Character[Character["_"] = 95] = "_";
    Character[Character["A"] = 64] = "A";
    Character[Character["Z"] = 90] = "Z";
    Character[Character["a"] = 97] = "a";
    Character[Character["z"] = 122] = "z";
    Character[Character["DoubleQuote"] = 34] = "DoubleQuote";
    Character[Character["SingleQuote"] = 39] = "SingleQuote";
    Character[Character["Exclaim"] = 33] = "Exclaim";
    Character[Character["Equal"] = 61] = "Equal";
    Character[Character["Caret"] = 94] = "Caret";
    Character[Character["Tilde"] = 126] = "Tilde";
    Character[Character["Dollar"] = 36] = "Dollar";
    Character[Character["Less"] = 60] = "Less";
    Character[Character["Greater"] = 62] = "Greater";
    Character[Character["Bar"] = 124] = "Bar";
    Character[Character["Amp"] = 38] = "Amp";
})(Character || (Character = {}));
/**
 * Check if a codepoint is a whitespace character.
 */
function isSpace(codepoint) {
    switch (codepoint) {
        case Character.Tab:
        case Character.Lf:
        case Character.Cr:
        case Character.Space:
            return true;
        default:
            return false;
    } // switch
}
/**
 * Check if codepoint is a digit character.
 */
function isNumber(codepoint) {
    return codepoint >= Character._0 && codepoint <= Character._9;
}
/**
 * Check if codepoint is a letter character.
 */
function isLetter(codepoint) {
    return ((codepoint >= Character.a && codepoint <= Character.z) ||
        (codepoint >= Character.A && codepoint <= Character.Z));
}
/**
 * Check if codepoint is either a digit or a letter character.
 */
function isLetterOrNumber(codepoint) {
    return isLetter(codepoint) || isNumber(codepoint);
}
/**
 * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.
 */
function isIdentChar(codepoint) {
    return (isLetterOrNumber(codepoint) ||
        codepoint === Character._ ||
        codepoint === Character.Dollar ||
        codepoint === Character.Dot ||
        codepoint === Character.LBracket ||
        codepoint === Character.RBracket);
}
/**
 * Tokens used in theme grammar.
 */
var Token;
(function (Token) {
    Token[Token["Eof"] = 0] = "Eof";
    Token[Token["Error"] = 1] = "Error";
    Token[Token["Identifier"] = 2] = "Identifier";
    Token[Token["Number"] = 3] = "Number";
    Token[Token["String"] = 4] = "String";
    Token[Token["Comma"] = 5] = "Comma";
    Token[Token["LParen"] = 6] = "LParen";
    Token[Token["RParen"] = 7] = "RParen";
    Token[Token["LBracket"] = 8] = "LBracket";
    Token[Token["RBracket"] = 9] = "RBracket";
    Token[Token["Exclaim"] = 10] = "Exclaim";
    Token[Token["TildeEqual"] = 11] = "TildeEqual";
    Token[Token["CaretEqual"] = 12] = "CaretEqual";
    Token[Token["DollarEqual"] = 13] = "DollarEqual";
    Token[Token["EqualEqual"] = 14] = "EqualEqual";
    Token[Token["ExclaimEqual"] = 15] = "ExclaimEqual";
    Token[Token["Less"] = 16] = "Less";
    Token[Token["Greater"] = 17] = "Greater";
    Token[Token["LessEqual"] = 18] = "LessEqual";
    Token[Token["GreaterEqual"] = 19] = "GreaterEqual";
    Token[Token["BarBar"] = 20] = "BarBar";
    Token[Token["AmpAmp"] = 21] = "AmpAmp";
})(Token || (Token = {}));
/**
 * Maps a token to its string name.
 */
function tokenSpell(token) {
    switch (token) {
        case Token.Eof:
            return "eof";
        case Token.Error:
            return "error";
        case Token.Identifier:
            return "identifier";
        case Token.Number:
            return "number";
        case Token.String:
            return "string";
        case Token.Comma:
            return ",";
        case Token.LParen:
            return "(";
        case Token.RParen:
            return ")";
        case Token.LBracket:
            return "[";
        case Token.RBracket:
            return "]";
        case Token.Exclaim:
            return "!";
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        case Token.BarBar:
            return "||";
        case Token.AmpAmp:
            return "&&";
        default:
            throw new Error(`invalid token ${token}`);
    }
}
/**
 * Lexer class implementation.
 */
class Lexer {
    constructor(code) {
        this.code = code;
        this.m_token = Token.Error;
        this.m_index = 0;
        this.m_char = Character.Lf;
    }
    /**
     * Single lexer token.
     */
    token() {
        return this.m_token;
    }
    /**
     * Parsed text.
     */
    text() {
        var _a;
        return (_a = this.m_text) !== null && _a !== void 0 ? _a : "";
    }
    /**
     * Go to the next token.
     */
    next() {
        this.m_token = this.yylex();
        if (this.m_token === Token.Error) {
            throw new Error(`unexpected character ${this.m_char}`);
        }
        return this.m_token;
    }
    yyinp() {
        var _a;
        this.m_char = (_a = this.code.codePointAt(this.m_index++)) !== null && _a !== void 0 ? _a : 0;
    }
    yylex() {
        this.m_text = undefined;
        while (isSpace(this.m_char)) {
            this.yyinp();
        }
        if (this.m_char === 0) {
            return Token.Eof;
        }
        const ch = this.m_char;
        this.yyinp();
        switch (ch) {
            case Character.LParen:
                return Token.LParen;
            case Character.RParen:
                return Token.RParen;
            case Character.LBracket:
                return Token.LBracket;
            case Character.RBracket:
                return Token.RBracket;
            case Character.Comma:
                return Token.Comma;
            case Character.SingleQuote:
            case Character.DoubleQuote: {
                const start = this.m_index - 1;
                while (this.m_char && this.m_char !== ch) {
                    // ### TODO handle escape sequences
                    this.yyinp();
                }
                if (this.m_char !== ch) {
                    throw new Error("Unfinished string literal");
                }
                this.yyinp();
                this.m_text = this.code.substring(start, this.m_index - 2);
                return Token.String;
            }
            case Character.Exclaim:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.ExclaimEqual;
                }
                return Token.Exclaim;
            case Character.Caret:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.CaretEqual;
                }
                return Token.Error;
            case Character.Tilde:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.TildeEqual;
                }
                return Token.Error;
            case Character.Equal:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.EqualEqual;
                }
                return Token.Error;
            case Character.Less:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.LessEqual;
                }
                return Token.Less;
            case Character.Greater:
                if (this.m_char === Character.Equal) {
                    this.yyinp();
                    return Token.GreaterEqual;
                }
                return Token.Greater;
            case Character.Bar:
                if (this.m_char === Character.Bar) {
                    this.yyinp();
                    return Token.BarBar;
                }
                return Token.Error;
            case Character.Amp:
                if (this.m_char === Character.Amp) {
                    this.yyinp();
                    return Token.AmpAmp;
                }
                return Token.Error;
            default: {
                const start = this.m_index - 2;
                if (isLetter(ch) ||
                    ch === Character._ ||
                    (ch === Character.Dollar && isIdentChar(this.m_char))) {
                    while (isIdentChar(this.m_char)) {
                        this.yyinp();
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Identifier;
                }
                else if (isNumber(ch)) {
                    while (isNumber(this.m_char)) {
                        this.yyinp();
                    }
                    if (this.m_char === Character.Dot) {
                        this.yyinp();
                        while (isNumber(this.m_char)) {
                            this.yyinp();
                        }
                    }
                    this.m_text = this.code.substring(start, this.m_index - 1);
                    return Token.Number;
                }
                else if (ch === Character.Dollar) {
                    if (this.m_char === Character.Equal) {
                        this.yyinp();
                        return Token.DollarEqual;
                    }
                    return Token.Error;
                }
            }
        }
        return Token.Error;
    }
}
function getEqualityOp(token) {
    switch (token) {
        case Token.TildeEqual:
            return "~=";
        case Token.CaretEqual:
            return "^=";
        case Token.DollarEqual:
            return "$=";
        case Token.EqualEqual:
            return "==";
        case Token.ExclaimEqual:
            return "!=";
        default:
            return undefined;
    } // switch
}
function getRelationalOp(token) {
    switch (token) {
        case Token.Less:
            return "<";
        case Token.Greater:
            return ">";
        case Token.LessEqual:
            return "<=";
        case Token.GreaterEqual:
            return ">=";
        default:
            return undefined;
    } // switch
}
class ExprParser {
    constructor(code) {
        this.lex = new Lexer(code);
        this.lex.next();
    }
    parse() {
        return this.parseLogicalOr();
    }
    yyexpect(token) {
        if (this.lex.token() !== token) {
            throw new Error(`Syntax error: Expected token '${tokenSpell(token)}' but ` +
                `found '${tokenSpell(this.lex.token())}'`);
        }
        this.lex.next();
    }
    parsePrimary() {
        switch (this.lex.token()) {
            case Token.Identifier: {
                const text = this.lex.text();
                switch (text) {
                    case "has":
                        this.lex.next(); // skip has keyword
                        this.yyexpect(Token.LParen);
                        const hasAttribute = this.lex.text();
                        this.yyexpect(Token.Identifier);
                        this.yyexpect(Token.RParen);
                        return new Expr_1.HasAttributeExpr(hasAttribute);
                    case "length":
                        this.lex.next(); // skip length keyword
                        this.yyexpect(Token.LParen);
                        const value = this.parseLogicalOr();
                        this.yyexpect(Token.RParen);
                        return new Expr_1.CallExpr("length", [value]);
                    default:
                        const expr = new Expr_1.VarExpr(text);
                        this.lex.next();
                        return expr;
                }
            }
            case Token.LParen: {
                this.lex.next();
                const expr = this.parseLogicalOr();
                this.yyexpect(Token.RParen);
                return expr;
            }
            default:
                return this.parseLiteral();
        } // switch
    }
    parseLiteral() {
        switch (this.lex.token()) {
            case Token.Number: {
                const expr = new Expr_1.NumberLiteralExpr(parseFloat(this.lex.text()));
                this.lex.next();
                return expr;
            }
            case Token.String: {
                const expr = new Expr_1.StringLiteralExpr(this.lex.text());
                this.lex.next();
                return expr;
            }
            default:
                throw new Error("Syntax error");
        } // switch
    }
    parseUnary() {
        if (this.lex.token() === Token.Exclaim) {
            this.lex.next();
            return new Expr_1.CallExpr("!", [this.parseUnary()]);
        }
        return this.parsePrimary();
    }
    parseRelational() {
        let expr = this.parseUnary();
        while (true) {
            if (this.lex.token() === Token.Identifier && this.lex.text() === "in") {
                this.lex.next();
                this.yyexpect(Token.LBracket);
                const elements = [this.parseLiteral()];
                while (this.lex.token() === Token.Comma) {
                    this.lex.next();
                    elements.push(this.parseLiteral());
                }
                this.yyexpect(Token.RBracket);
                expr = new Expr_1.CallExpr("in", [
                    expr,
                    Expr_1.LiteralExpr.fromValue(elements.map(({ value }) => value))
                ]);
            }
            else {
                const op = getRelationalOp(this.lex.token());
                if (op === undefined) {
                    break;
                }
                this.lex.next();
                const right = this.parseUnary();
                expr = new Expr_1.CallExpr(op, [expr, right]);
            }
        }
        return expr;
    }
    parseEquality() {
        let expr = this.parseRelational();
        while (true) {
            let op = getEqualityOp(this.lex.token());
            if (op === undefined) {
                break;
            }
            if (op === "~=") {
                op = "in";
            }
            this.lex.next();
            const right = this.parseRelational();
            expr = new Expr_1.CallExpr(op, [expr, right]);
        }
        return expr;
    }
    parseLogicalAnd() {
        const expr = this.parseEquality();
        if (this.lex.token() !== Token.AmpAmp) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseEquality());
        } while (this.lex.token() === Token.AmpAmp);
        return new Expr_1.CallExpr("all", expressions);
    }
    parseLogicalOr() {
        const expr = this.parseLogicalAnd();
        if (this.lex.token() !== Token.BarBar) {
            return expr;
        }
        const expressions = [expr];
        do {
            this.lex.next();
            expressions.push(this.parseLogicalAnd());
        } while (this.lex.token() === Token.BarBar);
        return new Expr_1.CallExpr("any", expressions);
    }
}
exports.ExprParser = ExprParser;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ExprPool.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/ExprPool.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExprPool = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
/**
 * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.
 *
 * @hidden
 */
class ExprPool {
    constructor() {
        this.m_booleanLiterals = new Map();
        this.m_numberLiterals = new Map();
        this.m_stringLiterals = new Map();
        this.m_objectLiterals = new Map();
        this.m_arrayLiterals = [];
        this.m_varExprs = new Map();
        this.m_hasAttributeExprs = new Map();
        this.m_matchExprs = [];
        this.m_caseExprs = [];
        this.m_interpolateExprs = [];
        this.m_stepExprs = [];
        this.m_callExprs = new Map();
    }
    /**
     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}
     * object that is structurally equivalent to `expr`.
     *
     * @param expr - The {@link Expr} to add to this [[ExprPool]].
     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.
     */
    add(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return Expr_1.NullLiteralExpr.instance;
    }
    visitBooleanLiteralExpr(expr, context) {
        const e = this.m_booleanLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_booleanLiterals.set(expr.value, expr);
        return expr;
    }
    visitNumberLiteralExpr(expr, context) {
        const e = this.m_numberLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_numberLiterals.set(expr.value, expr);
        return expr;
    }
    visitStringLiteralExpr(expr, context) {
        const e = this.m_stringLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_stringLiterals.set(expr.value, expr);
        return expr;
    }
    visitObjectLiteralExpr(expr, context) {
        const e = this.m_objectLiterals.get(expr.value);
        if (e) {
            return e;
        }
        if (Array.isArray(expr.value)) {
            const array = expr.value;
            const r = this.m_arrayLiterals.find(literal => {
                const elements = literal.value;
                if (elements.length !== array.length) {
                    return false;
                }
                return array.every((x, i) => x === elements[i]);
            });
            if (r !== undefined) {
                return r;
            }
            this.m_arrayLiterals.push(expr);
        }
        this.m_objectLiterals.set(expr.value, expr);
        return expr;
    }
    visitVarExpr(expr, context) {
        const e = this.m_varExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_varExprs.set(expr.name, expr);
        return expr;
    }
    visitHasAttributeExpr(expr, context) {
        const e = this.m_hasAttributeExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_hasAttributeExprs.set(expr.name, expr);
        return expr;
    }
    visitMatchExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const branches = expr.branches.map(([label, body]) => [
            label,
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_matchExprs) {
            if (candidate.value !== value) {
                continue;
            }
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.MatchExpr(value, branches, fallback);
        this.m_matchExprs.push(r);
        return r;
    }
    visitCaseExpr(expr, context) {
        const branches = expr.branches.map(([condition, body]) => [
            condition.accept(this, context),
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_caseExprs) {
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.CaseExpr(branches, fallback);
        this.m_caseExprs.push(r);
        return r;
    }
    visitCallExprImpl(expr, context, constructor) {
        // rewrite the actual arguments
        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));
        // ensure we have a valid set of interned expressions for the calls
        if (!this.m_callExprs.has(expr.op)) {
            this.m_callExprs.set(expr.op, []);
        }
        // get the calls for the given operator.
        const calls = this.m_callExprs.get(expr.op);
        for (const call of calls) {
            // check the number of arguments
            if (call.args.length !== expressions.length) {
                continue;
            }
            // find the index of the first mismatch.
            let index = 0;
            for (; index < call.args.length; ++index) {
                if (call.args[index] !== expressions[index]) {
                    break;
                }
            }
            if (index === call.args.length) {
                // no mismatch found, return the 'interned' call.
                return call;
            }
        }
        const e = constructor(expr.op, expressions);
        e.descriptor = expr.descriptor;
        calls.push(e);
        return e;
    }
    visitCallExpr(expr, context) {
        return this.visitCallExprImpl(expr, context, (op, args) => {
            return new Expr_1.CallExpr(op, args);
        });
    }
    visitLookupExpr(expr, context) {
        return this.visitCallExprImpl(expr, context, (op, args) => {
            return new Expr_1.LookupExpr(args);
        });
    }
    visitStepExpr(expr, context) {
        if (this.m_stepExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const step of this.m_stepExprs) {
            if (step.input === input &&
                step.defaultValue === defaultValue &&
                stops.length === step.stops.length &&
                stops.every(([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1])) {
                return step;
            }
        }
        const e = new Expr_1.StepExpr(input, defaultValue, stops);
        this.m_stepExprs.push(e);
        return e;
    }
    visitInterpolateExpr(expr, context) {
        if (this.m_interpolateExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const interp of this.m_interpolateExprs) {
            if (interp.input === input &&
                interp.mode[0] === expr.mode[0] &&
                interp.mode[1] === expr.mode[1] &&
                stops.length === interp.stops.length &&
                stops.every(([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1])) {
                return interp;
            }
        }
        const e = new Expr_1.InterpolateExpr(expr.mode, input, stops);
        this.m_interpolateExprs.push(e);
        return e;
    }
}
exports.ExprPool = ExprPool;


/***/ }),

/***/ "../harp-datasource-protocol/lib/GeoJsonDataType.ts":
/*!**********************************************************!*\
  !*** ../harp-datasource-protocol/lib/GeoJsonDataType.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFeatureGeometry = void 0;
function isFeatureGeometry(object) {
    const t = object.type;
    return (t === "Point" ||
        t === "MultiPoint" ||
        t === "LineString" ||
        t === "MultiLineString" ||
        t === "Polygon" ||
        t === "MultiPolygon");
}
exports.isFeatureGeometry = isFeatureGeometry;


/***/ }),

/***/ "../harp-datasource-protocol/lib/IMeshBuffers.ts":
/*!*******************************************************!*\
  !*** ../harp-datasource-protocol/lib/IMeshBuffers.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-datasource-protocol/lib/ITileDecoder.ts":
/*!*******************************************************!*\
  !*** ../harp-datasource-protocol/lib/ITileDecoder.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-datasource-protocol/lib/ITiler.ts":
/*!*************************************************!*\
  !*** ../harp-datasource-protocol/lib/ITiler.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.interpolatedPropertyDefinitionToJsonExpr = exports.isInterpolatedPropertyDefinition = exports.InterpolationMode = void 0;
/**
 * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.
 * @internal
 */
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Discrete"] = 0] = "Discrete";
    InterpolationMode[InterpolationMode["Linear"] = 1] = "Linear";
    InterpolationMode[InterpolationMode["Cubic"] = 2] = "Cubic";
    InterpolationMode[InterpolationMode["Exponential"] = 3] = "Exponential";
})(InterpolationMode = exports.InterpolationMode || (exports.InterpolationMode = {}));
/**
 * Checks if a property is interpolated.
 * @param p - property to be checked
 * @internal
 */
function isInterpolatedPropertyDefinition(p) {
    if (p &&
        p.interpolationMode === undefined &&
        Array.isArray(p.values) &&
        p.values.length > 0 &&
        p.values[0] !== undefined &&
        Array.isArray(p.zoomLevels) &&
        p.zoomLevels.length > 0 &&
        p.zoomLevels[0] !== undefined &&
        p.values.length === p.zoomLevels.length) {
        return true;
    }
    return false;
}
exports.isInterpolatedPropertyDefinition = isInterpolatedPropertyDefinition;
/**
 * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].
 *
 * @param property - A valid [[InterpolatedPropertyDefinition]]
 */
function interpolatedPropertyDefinitionToJsonExpr(property) {
    if (property.interpolation === undefined || property.interpolation === "Discrete") {
        const step = ["step", ["zoom"], property.values[0]];
        for (let i = 1; i < property.zoomLevels.length; ++i) {
            step.push(property.zoomLevels[i], property.values[i]);
        }
        return step;
    }
    const interpolation = ["interpolate"];
    switch (property.interpolation) {
        case "Linear":
            interpolation.push(["linear"]);
            break;
        case "Cubic":
            interpolation.push(["cubic"]);
            break;
        case "Exponential":
            interpolation.push([
                "exponential",
                property.exponent !== undefined ? property.exponent : 2
            ]);
            break;
        default:
            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);
    } //switch
    interpolation.push(["zoom"]);
    for (let i = 0; i < property.zoomLevels.length; ++i) {
        interpolation.push(property.zoomLevels[i], property.values[i]);
    }
    return interpolation;
}
exports.interpolatedPropertyDefinitionToJsonExpr = interpolatedPropertyDefinitionToJsonExpr;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Outliner.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/Outliner.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addPolygonEdges = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const currEdgeStart = new THREE.Vector2();
const currEdgeGoal = new THREE.Vector2();
const prevEdgeStart = new THREE.Vector2();
const prevEdgeGoal = new THREE.Vector2();
/**
 * Fills an index buffer with the indices for the edges of a polygon contour.
 *
 * @param indexBuffer - Edge index buffer to be filled.
 * @param vertexOffset - Starting offset of the vertices composing the contour.
 * @param vertexStride - Number of elements per contour vertex.
 * @param polygonContour - Vertices that compose the contour.
 * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.
 */
function addPolygonEdges(indexBuffer, vertexOffset, vertexStride, polygonContour, polygonContourEdges, isExtruded, addFootprintEdges, wallEdgeSlope) {
    for (let i = 0; i < polygonContourEdges.length; ++i) {
        if (polygonContourEdges[i]) {
            if (isExtruded === true) {
                const vFootprint0 = vertexOffset + i * 2;
                const vRoof0 = vFootprint0 + 1;
                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;
                const vRoof1 = vFootprint1 + 1;
                if (addFootprintEdges === true) {
                    indexBuffer.push(vFootprint0, vFootprint1);
                }
                indexBuffer.push(vRoof0, vRoof1);
                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;
                if (polygonContourEdges[prevEdgeIdx]) {
                    if (wallEdgeSlope !== undefined) {
                        const v0x = polygonContour[i * vertexStride];
                        const v0y = polygonContour[i * vertexStride + 1];
                        const v1x = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];
                        const v1y = polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride + 1];
                        currEdgeStart.set(v0x, v0y);
                        currEdgeGoal.set(v1x, v1y);
                        prevEdgeStart.set(polygonContour[prevEdgeIdx * vertexStride], polygonContour[prevEdgeIdx * vertexStride + 1]);
                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);
                        if (prevEdgeGoal
                            .sub(prevEdgeStart)
                            .normalize()
                            .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope) {
                            indexBuffer.push(vFootprint0, vRoof0);
                        }
                    }
                    else {
                        indexBuffer.push(vFootprint0, vRoof0);
                    }
                }
            }
            else {
                const vFoot0 = vertexOffset + i;
                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);
                indexBuffer.push(vFoot0, vRoof0);
            }
        }
    }
}
exports.addPolygonEdges = addPolygonEdges;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Pixels.ts":
/*!*************************************************!*\
  !*** ../harp-datasource-protocol/lib/Pixels.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pixels = void 0;
const RX = /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/;
/**
 * A class representing Pixels.
 *
 * @hidden
 * @internal
 */
class Pixels {
    /**
     * Constructs a [[Pixels]] literal
     *
     * @param value - The number of pixels.
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * Parses a pixel string literal.
     *
     * @param text - The string color literal
     */
    static parse(text) {
        const match = RX.exec(text);
        if (match === null) {
            return undefined;
        }
        return new Pixels(Number(match[1]));
    }
    toJSON() {
        return `${this.value}px`;
    }
}
exports.Pixels = Pixels;


/***/ }),

/***/ "../harp-datasource-protocol/lib/PostEffects.ts":
/*!******************************************************!*\
  !*** ../harp-datasource-protocol/lib/PostEffects.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-datasource-protocol/lib/PropertyValue.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/PropertyValue.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPropertyValue = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const Pixels_1 = __webpack_require__(/*! ./Pixels */ "../harp-datasource-protocol/lib/Pixels.ts");
const RGBA_1 = __webpack_require__(/*! ./RGBA */ "../harp-datasource-protocol/lib/RGBA.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PropertyValue");
/**
 * Get the value of the specified property in given `env`.
 *
 * @param property - Property of a technique.
 * @param env - The {@link Env} used to evaluate the property
 * @param cache - An optional expression cache.
 */
function getPropertyValue(property, env, cache) {
    var _a, _b, _c;
    if (Expr_1.Expr.isExpr(property)) {
        try {
            let r = property.evaluate(env, Expr_1.ExprScope.Dynamic, cache);
            if (typeof r === "string") {
                r = (_b = (_a = RGBA_1.RGBA.parse(r)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(r)) !== null && _b !== void 0 ? _b : r;
            }
            if (r instanceof RGBA_1.RGBA) {
                return r.getHex();
            }
            else if (r instanceof Pixels_1.Pixels) {
                return r.value * ((_c = Number(env.lookup("$pixelToMeters"))) !== null && _c !== void 0 ? _c : 1);
            }
            return r;
        }
        catch (error) {
            logger.error("failed to evaluate expression", JSON.stringify(property), "error", String(error));
            return null;
        }
    }
    if (property === null || typeof property === "undefined") {
        return null;
    }
    else if (typeof property !== "string") {
        // Property in numeric or array, etc. format
        return property;
    }
    else {
        // Non-interpolated string encoded numeral parsing
        const pixelToMeters = env.lookup("$pixelToMeters") || 1;
        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);
        return value !== undefined ? value : property;
    }
}
exports.getPropertyValue = getPropertyValue;


/***/ }),

/***/ "../harp-datasource-protocol/lib/RGBA.ts":
/*!***********************************************!*\
  !*** ../harp-datasource-protocol/lib/RGBA.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RGBA = void 0;
const three_1 = __webpack_require__(/*! three */ "three");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ./StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
/**
 * A class representing RGBA colors.
 *
 * @hidden
 * @internal
 */
class RGBA {
    /**
     * Constructs a [[RGBA]] color using the given components in the [0..1] range.
     */
    constructor(r = 1, g = 1, b = 1, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Parses a string describing a color.
     *
     * @param text - The string color literal
     */
    static parse(text) {
        const color = StringEncodedNumeral_1.parseStringEncodedColor(text);
        if (color === undefined) {
            return undefined;
        }
        return ColorUtils_1.ColorUtils.getRgbaFromHex(color);
    }
    /**
     * Clones this [[RGBA]] color.
     */
    clone() {
        return new RGBA(this.r, this.g, this.b, this.a);
    }
    /**
     * Returns this color encoded as one single number.
     */
    getHex() {
        return ColorUtils_1.ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);
    }
    /**
     * Linearly interpolate the components of this color.
     */
    lerp(target, t) {
        this.r = three_1.MathUtils.lerp(this.r, target.r, t);
        this.g = three_1.MathUtils.lerp(this.g, target.g, t);
        this.b = three_1.MathUtils.lerp(this.b, target.b, t);
        this.a = three_1.MathUtils.lerp(this.a, target.a, t);
        return this;
    }
    /**
     * Returns this color encoded as JSON literal.
     */
    toJSON() {
        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${this.a})`;
    }
}
exports.RGBA = RGBA;


/***/ }),

/***/ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StringEncodedNumeral.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseStringEncodedColor = exports.parseStringEncodedNumeral = exports.StringEncodedNumeralFormatMaxSize = exports.StringEncodedNumeralFormats = exports.StringEncodedColorFormats = exports.StringEncodedMetricFormats = exports.StringEncodedNumeralType = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
//@ts-ignore
const csscolorparser_1 = __webpack_require__(/*! csscolorparser */ "../../node_modules/csscolorparser/csscolorparser.js");
const ColorUtils_1 = __webpack_require__(/*! ./ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
/**
 * Enumeration of supported string encoded numerals.
 * @internal
 */
var StringEncodedNumeralType;
(function (StringEncodedNumeralType) {
    StringEncodedNumeralType[StringEncodedNumeralType["Meters"] = 0] = "Meters";
    StringEncodedNumeralType[StringEncodedNumeralType["Pixels"] = 1] = "Pixels";
    StringEncodedNumeralType[StringEncodedNumeralType["Hex"] = 2] = "Hex";
})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));
const StringEncodedMeters = {
    type: StringEncodedNumeralType.Meters,
    size: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedMeters.regExp.exec(encodedValue);
        return match ? (target[0] = Number(match[1])) !== undefined : false;
    }
};
const StringEncodedPixels = {
    type: StringEncodedNumeralType.Pixels,
    size: 1,
    mask: 1.0,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedPixels.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        target[0] = Number(match[1]);
        return true;
    }
};
const StringEncodedHex = {
    type: StringEncodedNumeralType.Hex,
    size: 4,
    regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedHex.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        const hex = match[1];
        const size = hex.length;
        // Only few sizes are possible for given reg-exp.
        harp_utils_1.assert(size === 4 || size === 8, `Matched incorrect hex color format`);
        // Note that we simply ignore alpha channel value.
        // TODO: To be resolved with HARP-7517
        if (size === 4) {
            // #RGB or #RGBA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
        }
        else if (size === 8) {
            // #RRGGBB or #RRGGBBAA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
        }
        return true;
    }
};
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.
 * @internal
 */
exports.StringEncodedMetricFormats = [
    StringEncodedMeters,
    StringEncodedPixels
];
const StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.
 * @internal
 */
exports.StringEncodedColorFormats = [StringEncodedHex];
const StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with
 * [[StringEncodedNumeralType]] enum).
 * @internal
 */
exports.StringEncodedNumeralFormats = [
    ...exports.StringEncodedMetricFormats,
    ...exports.StringEncodedColorFormats
];
/**
 * @internal
 */
exports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
const tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);
/**
 * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].
 *
 * @param numeral - The string representing numeric value.
 * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).
 * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression
 * provided in [[numeral]].
 */
function parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {
    return parseStringLiteral(numeral, exports.StringEncodedNumeralFormats, pixelToMeters);
}
exports.parseStringEncodedNumeral = parseStringEncodedNumeral;
/**
 * Parse string encoded color value using all known [[StringEncodedColorFormats]].
 *
 * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).
 * @returns The color parsed or __undefined__ if non of the known representations matches
 * the expression provided in [[color]].
 */
function parseStringEncodedColor(color) {
    return parseStringLiteral(color, exports.StringEncodedColorFormats);
}
exports.parseStringEncodedColor = parseStringEncodedColor;
function parseStringLiteral(text, formats, pixelToMeters = 1.0) {
    const matchedFormat = formats.find(format => {
        return format.decoder(text, tmpBuffer) ? true : false;
    });
    if (matchedFormat === undefined) {
        const components = csscolorparser_1.parseCSSColor(text);
        return Array.isArray(components) && !components.some(c => isNaN(c))
            ? ColorUtils_1.ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3])
            : undefined;
    }
    switch (matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type) {
        case StringEncodedNumeralType.Pixels:
            return tmpBuffer[0] * pixelToMeters;
        case StringEncodedNumeralType.Hex:
            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
        default:
            return tmpBuffer[0];
    }
}


/***/ }),

/***/ "../harp-datasource-protocol/lib/StyleSetEvaluator.ts":
/*!************************************************************!*\
  !*** ../harp-datasource-protocol/lib/StyleSetEvaluator.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeDecodedTechnique = exports.StyleSetEvaluator = void 0;
/*
 * Copyright (C) 2019-2022 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const ExprPool_1 = __webpack_require__(/*! ./ExprPool */ "../harp-datasource-protocol/lib/ExprPool.ts");
const InterpolatedPropertyDefs_1 = __webpack_require__(/*! ./InterpolatedPropertyDefs */ "../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts");
const TechniqueDescriptors_1 = __webpack_require__(/*! ./TechniqueDescriptors */ "../harp-datasource-protocol/lib/TechniqueDescriptors.ts");
const Techniques_1 = __webpack_require__(/*! ./Techniques */ "../harp-datasource-protocol/lib/Techniques.ts");
const logger = harp_utils_1.LoggerManager.instance.create("StyleSetEvaluator");
const DEFAULT_TECHNIQUE_ATTR_SCOPE = TechniqueDescriptors_1.AttrScope.TechniqueGeometry;
/**
 * Get the attribute scope of the given style property.
 *
 * @remarks
 * Certain Style properties change their dynamic scope behavior
 * based on other properties. For example, the `color` property
 * of `extruded-polygon` change behavior based on the usage
 * of `vertexColors`.
 *
 * @param style A valid Style.
 * @param attrName The name of the attribute of the {@link style}.
 */
function getStyleAttributeScope(style, attrName) {
    var _a, _b;
    if (style.technique === "extruded-polygon") {
        if (attrName === "color" && style.vertexColors !== false) {
            return DEFAULT_TECHNIQUE_ATTR_SCOPE;
        }
    }
    return ((_b = (_a = TechniqueDescriptors_1.getTechniqueAttributeDescriptor(style.technique, attrName)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : DEFAULT_TECHNIQUE_ATTR_SCOPE);
}
/**
 * `StyleConditionClassifier` searches for usages of `$layer` in `when` conditions
 * associated with styling rules.
 *
 * @hidden
 */
class StyleConditionClassifier {
    classify(style) {
        if (style._whenExpr) {
            const savedStyle = this.switchStyle(style);
            style._whenExpr = style._whenExpr.accept(this, undefined);
            this._style = savedStyle;
        }
    }
    visitNullLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitNumberLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitStringLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitObjectLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitVarExpr(expr, enclosingExpr) {
        return expr;
    }
    visitHasAttributeExpr(expr, enclosingExpr) {
        return expr;
    }
    visitMatchExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCaseExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCallExpr(call, enclosingExpr) {
        if (call.op === "all") {
            // processing of an `["all", e1, e2, ... eN]` expression. In this case
            // search for expressions matching comparison of `$layer` and string literals
            // in the sub expressions.
            const children = call.args
                .map(childExpr => childExpr.accept(this, call))
                .filter(childExpr => childExpr !== undefined);
            return new Expr_1.CallExpr(call.op, children);
        }
        else if (enclosingExpr) {
            // `call` is a direct child expression of an `"all"` operator.
            const matched = this.matchVarStringComparison(call);
            if (matched) {
                if (this._style.layer === undefined && matched.name === "$layer") {
                    // found a subexpression `["==", ["get", "$layer"], "some layer name"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $layer in
                    // [[StyleInternalParams]].
                    this._style.layer = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
                else if (this._style._geometryType === undefined &&
                    matched.name === "$geometryType") {
                    // found a subexpression `["==", ["get", "$geometryType"], "geometry"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $geometryType in
                    // [[StyleInternalParams]].
                    this._style._geometryType = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
            }
        }
        return call;
    }
    visitLookupExpr(lookup, enclosingExpr) {
        return this.visitCallExpr(lookup, enclosingExpr);
    }
    visitStepExpr(expr, enclosingExpr) {
        return expr;
    }
    visitInterpolateExpr(expr, enclosingExpr) {
        return expr;
    }
    /**
     * Tests if the given `call` matches the structure ["==", ["get", name], value].
     * If a match is found returns an object containing the `name` and the `value`;
     *
     * @param call - The expression to match.
     */
    matchVarStringComparison(call) {
        if (call.op === "==") {
            const left = call.args[0];
            const right = call.args[1];
            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {
                return { name: left.name, value: right.value };
            }
            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {
                return { name: right.name, value: left.value };
            }
        }
        return undefined;
    }
    /**
     * Sets the given `style` as current.
     *
     * @returns The previous `style`.
     */
    switchStyle(style) {
        const saved = this._style;
        this._style = style;
        return saved;
    }
}
class OptimizedSubSetKey {
    constructor(layer, geometryType) {
        this.key = "";
        this.set(layer, geometryType);
    }
    set(layer, geometryType, env) {
        let keyUpdateNeeded = false;
        if (layer === undefined) {
            const envLayer = env !== undefined ? env.lookup("$layer") : undefined;
            layer = typeof envLayer === "string" ? envLayer : undefined;
        }
        if (this.layer !== layer) {
            this.layer = layer;
            keyUpdateNeeded = true;
        }
        if (geometryType === undefined) {
            const envGeometryType = env !== undefined ? env.lookup("$geometryType") : undefined;
            geometryType = typeof envGeometryType === "string" ? envGeometryType : undefined;
        }
        if (this.geometryType !== geometryType) {
            this.geometryType = geometryType;
            keyUpdateNeeded = true;
        }
        if (keyUpdateNeeded) {
            this.updateKey();
        }
        return this;
    }
    updateKey() {
        if (this.layer !== undefined) {
            if (this.geometryType !== undefined) {
                this.key = `${this.layer}:${this.geometryType}`;
            }
            else {
                this.key = `${this.layer}:`;
            }
        }
        else {
            if (this.geometryType !== undefined) {
                this.key = `:${this.geometryType}`;
            }
            else {
                this.key = "all";
            }
        }
        this.cachedStyleSet = undefined;
    }
}
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
class StyleSetEvaluator {
    constructor(m_options) {
        this.m_options = m_options;
        this.m_techniques = [];
        this.m_exprPool = new ExprPool_1.ExprPool();
        this.m_cachedResults = new Map();
        this.m_styleConditionClassifier = new StyleConditionClassifier();
        this.m_subStyleSetCache = new Map();
        this.m_definitionExprCache = new Map();
        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();
        this.m_emptyEnv = new Expr_1.Env();
        this.m_featureDependencies = [];
        this.m_nextArrayBufferId = 0;
        this.m_definitions = this.m_options.definitions;
        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);
        computeDefaultRenderOrder(this.styleSet);
        this.compileStyleSet();
    }
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     * representation.
     * @param layer - The optional layer name used to filter techniques.
     * @param geometryType - The optional geometryType used to filter techniques.
     */
    getMatchingTechniques(env, layer, geometryType) {
        if (this.m_previousResult &&
            this.m_previousEnv &&
            this.m_featureDependencies.every(p => { var _a; return ((_a = this.m_previousEnv) === null || _a === void 0 ? void 0 : _a.lookup(p)) === env.lookup(p); })) {
            return this.m_previousResult;
        }
        const result = [];
        this.m_cachedResults.clear();
        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
        optimizedSubSetKey.set(layer, geometryType, env);
        // get the requested $layer and $geometryType, if any.
        this.m_layer = optimizedSubSetKey.layer;
        this.m_geometryType = optimizedSubSetKey.geometryType;
        this.m_zoomLevel = env.lookup("$zoom");
        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
        for (const currStyle of searchedStyleSet) {
            if (this.processStyle(env, currStyle, result)) {
                break;
            }
        }
        this.m_previousResult = result;
        this.m_previousEnv = env;
        return result;
    }
    /**
     * Check if `styleSet` contains any rule related to `layer`.
     *
     * @param layer - name of layer
     */
    wantsLayer(layer) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);
    }
    /**
     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.
     *
     * @param layer - name of layer
     * @param geometryType - type of layer - `point`, `line` or `polygon`
     */
    wantsFeature(layer, geometryType) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))
            .length > 0);
    }
    /**
     * Reset array of techniques.
     *
     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.
     */
    resetTechniques() {
        for (const techinque of this.m_techniques) {
            techinque._index = undefined;
        }
        this.m_techniques.length = 0;
        this.m_previousResult = undefined;
        this.m_previousEnv = undefined;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques() {
        return this.m_techniques;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get decodedTechniques() {
        return this.m_techniques.map(makeDecodedTechnique);
    }
    getOptimizedStyleSet(subSetKey) {
        if (subSetKey.cachedStyleSet !== undefined) {
            return subSetKey.cachedStyleSet;
        }
        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
        if (optimizedStyleSet !== undefined) {
            subSetKey.cachedStyleSet = optimizedStyleSet;
            return optimizedStyleSet;
        }
        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
        subSetKey.cachedStyleSet = optimizedStyleSet;
        return optimizedStyleSet;
    }
    createPreFilteredStyleSet(subSetKey) {
        const { layer, geometryType } = subSetKey;
        return this.styleSet.filter(style => {
            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {
                return false;
            }
            if (geometryType !== undefined &&
                style._geometryType !== undefined &&
                style._geometryType !== geometryType) {
                return false;
            }
            return true;
        });
    }
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    compileStyleSet() {
        this.m_featureDependencies = ["$layer", "$geometryType", "$zoom"];
        this.styleSet.forEach(style => this.compileStyle(style));
        // Create optimized styleSets for each `layer` & `geometryType` tuple.
        this.styleSet.forEach(style => {
            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
        });
    }
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style - The current style.
     */
    compileStyle(style) {
        this.checkStyleDynamicAttributes(style);
        if (style.when !== undefined) {
            try {
                style._whenExpr = Array.isArray(style.when)
                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)
                    : Expr_1.Expr.parse(style.when);
                // search for usages of '$layer' and any other
                // special symbol that can be used to speed up the evaluation
                // of the `when` conditions associated to this `style`.
                this.m_styleConditionClassifier.classify(style);
                if (style._whenExpr !== undefined) {
                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                }
                const deps = style._whenExpr.dependencies();
                deps === null || deps === void 0 ? void 0 : deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                if (Expr_1.isJsonExpr(style.minZoomLevel)) {
                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel, this.m_definitions).intern(this.m_exprPool);
                }
                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {
                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel, this.m_definitions).intern(this.m_exprPool);
                }
            }
            catch (err) {
                logger.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
            }
        }
    }
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param style - Current style (could also be top of stack).
     * @param result - The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    processStyle(env, style, result) {
        if (!this.checkZoomLevel(env, style)) {
            return false;
        }
        if (this.m_layer !== undefined &&
            style.layer !== undefined &&
            style.layer !== this.m_layer) {
            return false;
        }
        if (this.m_geometryType !== undefined &&
            style._geometryType !== undefined &&
            style._geometryType !== this.m_geometryType) {
            return false;
        }
        if (style._whenExpr) {
            try {
                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {
                    // Stop processing this styling rule. The `when` condition
                    // associated with the current `style` evaluates to false so
                    // no techinque defined by this style should be applied.
                    return false;
                }
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);
                return false;
            }
        }
        if (style.technique === undefined) {
            return false;
        }
        // we found a technique!
        if (style.technique !== "none") {
            result.push(this.getTechniqueForStyleMatch(env, style));
        }
        // stop processing if "final" is set
        return style.final === true;
    }
    checkZoomLevel(env, style) {
        var _a, _b;
        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {
            return true;
        }
        const zoomLevel = this.m_zoomLevel;
        if (zoomLevel === undefined) {
            return true;
        }
        if (style.minZoomLevel !== undefined) {
            let minZoomLevel = style.minZoomLevel;
            if (((_a = style._minZoomLevelExpr) === null || _a === void 0 ? void 0 : _a.isDynamic()) === false) {
                // Only filter by zoom level if the expression is not dynamic.
                try {
                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                return false;
            }
        }
        if (style.maxZoomLevel !== undefined) {
            let maxZoomLevel = style.maxZoomLevel;
            if (((_b = style._maxZoomLevelExpr) === null || _b === void 0 ? void 0 : _b.isDynamic()) === false) {
                // Only filter by zoom level if the expression is not dynamic.
                try {
                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
                return false;
            }
        }
        return true;
    }
    getTechniqueForStyleMatch(env, style) {
        let technique;
        if (style._dynamicTechniques !== undefined) {
            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);
            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);
            technique = style._dynamicTechniques.get(key);
            if (technique === undefined) {
                technique = this.createTechnique(style, key, dynamicAttributes);
                style._dynamicTechniques.set(key, technique);
            }
        }
        else {
            technique = style._staticTechnique;
            if (technique === undefined) {
                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);
            }
        }
        if (technique._index === undefined) {
            technique._index = this.m_techniques.length;
            this.m_techniques.push(technique);
        }
        return technique;
    }
    getDynamicTechniqueKey(style, dynamicAttributes) {
        const dynamicAttrKey = dynamicAttributes
            .map(([_attrName, attrValue]) => {
            if (attrValue === undefined) {
                return "U";
            }
            else if (typeof attrValue === "object") {
                return JSON.stringify(attrValue, (_, value) => {
                    if (value instanceof ArrayBuffer) {
                        // ArrayBuffers cannot be directly stringified. They can be converted
                        // to typed arrays and then stringified, but it's too slow. Instead,
                        // assign them unique ids.
                        let arrayBufferId = value.id;
                        if (arrayBufferId === undefined) {
                            arrayBufferId = value.id = this.m_nextArrayBufferId++;
                        }
                        return arrayBufferId;
                    }
                    return value;
                });
            }
            else {
                return JSON.stringify(attrValue);
            }
        })
            .join(":");
        return `${style._styleSetIndex}:${dynamicAttrKey}`;
    }
    checkStyleDynamicAttributes(style) {
        var _a;
        if (style._dynamicTechniqueAttributes !== undefined || style.technique === "none") {
            return;
        }
        style._dynamicTechniqueAttributes = [];
        style._dynamicFeatureAttributes = [];
        style._dynamicForwardedAttributes = [];
        style._staticAttributes = [];
        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;
        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;
        const targetStaticAttributes = style._staticAttributes;
        const processAttribute = (attrName, attrValue) => {
            if (attrValue === undefined) {
                return;
            }
            if (Expr_1.isJsonExpr(attrValue)) {
                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);
            }
            else if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(attrValue)) {
                // found a property using an object-like interpolation definition.
                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const deps = attrValue.dependencies();
                if (deps.featureState) {
                    if (attrName !== "enabled") {
                        logger.log("feature-state is not supported in this context");
                    }
                    else {
                        style._usesFeatureState = true;
                    }
                }
                if (deps.properties.size === 0 && !attrValue.isDynamic()) {
                    // no data-dependencies detected.
                    attrValue = attrValue.evaluate(this.m_emptyEnv);
                }
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const attrScope = getStyleAttributeScope(style, attrName);
                const deps = attrValue.dependencies();
                deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                switch (attrScope) {
                    case TechniqueDescriptors_1.AttrScope.FeatureGeometry:
                        dynamicFeatureAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptors_1.AttrScope.TechniqueGeometry:
                        dynamicTechniqueAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptors_1.AttrScope.TechniqueRendering:
                        if (deps.properties.size === 0) {
                            dynamicForwardedAttributes.push([attrName, attrValue]);
                        }
                        else {
                            dynamicTechniqueAttributes.push([attrName, attrValue]);
                        }
                        break;
                }
            }
            else if (attrValue !== undefined && attrValue !== null) {
                targetStaticAttributes.push([attrName, attrValue]);
            }
        };
        const replacement = new Map([
            ["category", "_category"],
            ["secondaryCategory", "_secondaryCategory"]
        ]);
        for (const p in style) {
            if (!style.hasOwnProperty(p)) {
                continue;
            }
            if (p.startsWith("_")) {
                continue;
            }
            if (["when", "technique", "layer", "attr", "description"].includes(p)) {
                continue;
            }
            const pp = (_a = replacement.get(p)) !== null && _a !== void 0 ? _a : p;
            processAttribute(pp, style[p]);
        }
        if (style.attr !== undefined) {
            for (const attrName in style.attr) {
                if (!style.attr.hasOwnProperty(attrName)) {
                    continue;
                }
                processAttribute(attrName, style.attr[attrName]);
            }
        }
        if (dynamicTechniqueAttributes.length > 0) {
            style._dynamicTechniques = new Map();
        }
    }
    evaluateTechniqueProperties(style, env) {
        if (style._dynamicTechniqueAttributes === undefined) {
            return [];
        }
        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {
            try {
                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);
                return [attrName, evaluatedValue];
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);
                return [attrName, null];
            }
        });
    }
    createTechnique(style, key, dynamicAttrs) {
        var _a, _b;
        const technique = {};
        technique.name = style.technique;
        if (style._staticAttributes !== undefined) {
            for (const [attrName, attrValue] of style._staticAttributes) {
                if (attrValue !== null) {
                    technique[attrName] = attrValue;
                }
            }
        }
        for (const [attrName, attrValue] of dynamicAttrs) {
            if (attrValue !== null) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicFeatureAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicForwardedAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {
                technique[attrName] = attrValue;
            }
        }
        technique._index = this.m_techniques.length;
        technique._styleSetIndex = style._styleSetIndex;
        if (style.styleSet !== undefined) {
            technique._styleSet = style.styleSet;
        }
        if (style._usesFeatureState !== undefined) {
            technique._usesFeatureState = style._usesFeatureState;
        }
        Techniques_1.setTechniqueRenderOrderOrPriority(technique, (_a = this.m_options.priorities) !== null && _a !== void 0 ? _a : [], (_b = this.m_options.labelPriorities) !== null && _b !== void 0 ? _b : []);
        this.m_techniques.push(technique);
        return technique;
    }
}
exports.StyleSetEvaluator = StyleSetEvaluator;
function computeDefaultRenderOrder(styleSet) {
    let techniqueRenderOrder = 0;
    let styleSetIndex = 0;
    for (const style of styleSet) {
        style._styleSetIndex = styleSetIndex++;
        if (style.technique !== undefined && style.renderOrder === undefined) {
            style.renderOrder = techniqueRenderOrder++;
        }
    }
}
function resolveReferences(styleSet, definitions) {
    return styleSet.map(style => resolveStyleReferences(style, definitions));
}
function resolveStyleReferences(style, definitions) {
    return Object.assign({}, style);
}
/**
 * Create transferable representation of dynamic technique.
 *
 * Converts  non-transferable {@link Expr}instances back to JSON form.
 */
function makeDecodedTechnique(technique) {
    const result = {};
    for (const attrName in technique) {
        if (!technique.hasOwnProperty(attrName)) {
            continue;
        }
        let attrValue = technique[attrName];
        if (typeof attrValue === "object" &&
            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {
            attrValue = Expr_1.LiteralExpr.fromValue(attrValue);
        }
        if (Expr_1.Expr.isExpr(attrValue)) {
            attrValue = attrValue.toJSON();
        }
        result[attrName] = attrValue;
    }
    return result;
}
exports.makeDecodedTechnique = makeDecodedTechnique;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueAttr.ts":
/*!********************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueAttr.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTechniqueAttr = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const PropertyValue_1 = __webpack_require__(/*! ./PropertyValue */ "../harp-datasource-protocol/lib/PropertyValue.ts");
function evaluateTechniqueAttr(context, attrValue, defaultValue) {
    if (attrValue === undefined) {
        return defaultValue;
    }
    const result = Expr_1.Env.isEnv(context)
        ? PropertyValue_1.getPropertyValue(attrValue, context)
        : PropertyValue_1.getPropertyValue(attrValue, context.env, context.cachedExprResults);
    return result !== null && result !== void 0 ? result : defaultValue;
}
exports.evaluateTechniqueAttr = evaluateTechniqueAttr;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueDescriptors.ts":
/*!***************************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueDescriptors.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTechniqueAutomaticAttrs = exports.getTechniqueAttributeDescriptor = exports.getTechniqueDescriptor = exports.AttrScope = void 0;
var AttrScope;
(function (AttrScope) {
    /**
     * Attributes that affect generation of feature geometry and thus must be resolved at decoding
     * time.
     *
     * @remarks
     * They may have huge variancy as they are implemented as vertex attributes or embedded in
     * generated meshes.
     *
     * These attributes are available only in decoding scope.
     */
    AttrScope[AttrScope["FeatureGeometry"] = 0] = "FeatureGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * These attributes affect generated geometry and  thus must be resolved at decoding time.
     *
     * @remarks
     * They shouldn't have big variancy and evaluate to at least dozens of values as each
     * combination of these attributes consitute new technique and material.
     *
     * These attributes are available in decoding and rendering scope.
     */
    AttrScope[AttrScope["TechniqueGeometry"] = 1] = "TechniqueGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     *
     * @remarks
     * Attributes that can be changed in resulting object/material from frame to frame. They are
     * usually implemented as uniforms.
     *
     * These attributes may be available only at rendering scope.
     */
    AttrScope[AttrScope["TechniqueRendering"] = 2] = "TechniqueRendering";
})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));
/**
 * @internal
 */
function mergeTechniqueDescriptor(...descriptors) {
    const result = {
        attrDescriptors: {}
    };
    for (const descriptor of descriptors) {
        if (descriptor.attrTransparencyColor !== undefined) {
            result.attrTransparencyColor = descriptor.attrTransparencyColor;
        }
        if (descriptor.attrDescriptors !== undefined) {
            result.attrDescriptors = Object.assign(Object.assign({}, result.attrDescriptors), descriptor.attrDescriptors);
        }
    }
    return result;
}
const baseTechniqueParamsDescriptor = {
    // TODO: Choose which techniques should support color with transparency.
    // For now we chosen all, but it maybe not suitable for text or line marker techniques.
    attrTransparencyColor: "color",
    attrDescriptors: {
        constantHeight: AttrScope.FeatureGeometry,
        enabled: AttrScope.FeatureGeometry,
        fadeFar: AttrScope.TechniqueRendering,
        fadeNear: AttrScope.TechniqueRendering,
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        side: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
};
const pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        size: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
const circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
const lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: AttrScope.FeatureGeometry,
        label: AttrScope.FeatureGeometry,
        useAbbreviation: AttrScope.FeatureGeometry,
        useIsoCode: AttrScope.FeatureGeometry,
        poiName: AttrScope.FeatureGeometry,
        imageTexture: AttrScope.FeatureGeometry,
        iconColor: AttrScope.TechniqueRendering,
        iconBrightness: AttrScope.TechniqueRendering,
        backgroundColor: AttrScope.TechniqueRendering,
        backgroundSize: AttrScope.TechniqueRendering,
        backgroundOpacity: AttrScope.TechniqueRendering,
        color: AttrScope.TechniqueRendering,
        opacity: AttrScope.TechniqueRendering,
        size: AttrScope.TechniqueRendering
    }
});
const polygonalTechniqueDescriptor = {
    attrDescriptors: {
        polygonOffset: { scope: AttrScope.TechniqueRendering, automatic: true },
        polygonOffsetFactor: { scope: AttrScope.TechniqueRendering, automatic: true },
        polygonOffsetUnits: { scope: AttrScope.TechniqueRendering, automatic: true },
        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineColor: AttrScope.TechniqueRendering,
        lineFadeFar: AttrScope.TechniqueRendering,
        lineFadeNear: AttrScope.TechniqueRendering
    }
};
const solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        lineWidth: AttrScope.TechniqueRendering,
        secondaryWidth: AttrScope.TechniqueRendering,
        secondaryColor: AttrScope.TechniqueRendering,
        dashSize: AttrScope.TechniqueRendering,
        gapSize: AttrScope.TechniqueRendering,
        outlineColor: { scope: AttrScope.TechniqueRendering, automatic: true },
        caps: { scope: AttrScope.TechniqueRendering, automatic: true },
        drawRangeStart: { scope: AttrScope.TechniqueRendering, automatic: true },
        drawRangeEnd: { scope: AttrScope.TechniqueRendering, automatic: true },
        dashes: { scope: AttrScope.TechniqueRendering, automatic: true },
        dashColor: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        // TODO, check, which are really dynamic !
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineWidth: AttrScope.FeatureGeometry
    }
});
const fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineWidth: AttrScope.TechniqueRendering,
        map: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        vertexColors: { scope: AttrScope.TechniqueRendering, automatic: true },
        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },
        roughness: { scope: AttrScope.TechniqueRendering, automatic: true },
        metalness: { scope: AttrScope.TechniqueRendering, automatic: true },
        alphaTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        emissive: { scope: AttrScope.TechniqueRendering, automatic: true },
        emissiveIntensity: { scope: AttrScope.TechniqueRendering, automatic: true },
        refractionRatio: { scope: AttrScope.TechniqueRendering, automatic: true },
        normalMapType: { scope: AttrScope.TechniqueRendering, automatic: true },
        map: { scope: AttrScope.TechniqueRendering, automatic: true },
        normalMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        displacementMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        roughnessMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        emissiveMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        bumpMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        metalnessMap: { scope: AttrScope.TechniqueRendering, automatic: true },
        alphaMap: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
    attrDescriptors: {
        height: AttrScope.FeatureGeometry,
        floorHeight: AttrScope.FeatureGeometry,
        color: AttrScope.FeatureGeometry,
        defaultColor: AttrScope.FeatureGeometry,
        defaultHeight: AttrScope.FeatureGeometry,
        boundaryWalls: AttrScope.FeatureGeometry,
        footprint: AttrScope.FeatureGeometry,
        maxSlope: AttrScope.FeatureGeometry,
        animateExtrusion: AttrScope.TechniqueRendering,
        lineWidth: AttrScope.TechniqueRendering,
        lineFadeNear: AttrScope.TechniqueRendering,
        lineFadeFar: AttrScope.TechniqueRendering,
        lineColor: AttrScope.TechniqueRendering
    }
});
const textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: AttrScope.FeatureGeometry,
        label: AttrScope.FeatureGeometry,
        useAbbreviation: AttrScope.FeatureGeometry,
        useIsoCode: AttrScope.FeatureGeometry,
        backgroundColor: AttrScope.TechniqueRendering,
        backgroundSize: AttrScope.TechniqueRendering,
        backgroundOpacity: AttrScope.TechniqueRendering,
        color: AttrScope.TechniqueRendering,
        opacity: AttrScope.TechniqueRendering,
        priority: AttrScope.TechniqueRendering,
        size: AttrScope.TechniqueRendering
    }
});
const shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        params: AttrScope.TechniqueRendering
    }
});
const techniqueDescriptors = {
    "extruded-polygon": extrudedPolygonTechniqueDescriptor,
    "line-marker": lineMarkerTechniquePropTypes,
    "labeled-icon": lineMarkerTechniquePropTypes,
    "solid-line": solidLineTechniqueDescriptor,
    "dashed-line": solidLineTechniqueDescriptor,
    terrain: standardTechniqueDescriptor,
    standard: standardTechniqueDescriptor,
    squares: squaresTechniquePropTypes,
    circles: circlesTechniquePropTypes,
    line: lineTechniqueDescriptor,
    segments: lineTechniqueDescriptor,
    fill: fillTechniqueDescriptor,
    text: textTechniqueDescriptor,
    shader: shaderTechniqueDescriptor
};
function getTechniqueDescriptor(technique) {
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    return techniqueDescriptors[technique];
}
exports.getTechniqueDescriptor = getTechniqueDescriptor;
function getTechniqueAttributeDescriptor(technique, attrName) {
    const techniqueDescriptor = getTechniqueDescriptor(technique);
    const attrDescriptors = techniqueDescriptor === null || techniqueDescriptor === void 0 ? void 0 : techniqueDescriptor.attrDescriptors;
    const descriptor = attrDescriptors === null || attrDescriptors === void 0 ? void 0 : attrDescriptors[attrName];
    if (typeof descriptor === undefined) {
        return undefined;
    }
    else if (typeof descriptor === "object") {
        return descriptor;
    }
    return { scope: descriptor };
}
exports.getTechniqueAttributeDescriptor = getTechniqueAttributeDescriptor;
const automaticAttributeCache = new Map();
function getTechniqueAutomaticAttrs(technique) {
    var _a;
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    if (automaticAttributeCache.has(technique)) {
        return automaticAttributeCache.get(technique);
    }
    const descriptors = [];
    const attrDescriptors = (_a = getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrDescriptors;
    if (attrDescriptors === undefined) {
        return descriptors;
    }
    for (const attrName in attrDescriptors) {
        if (!attrDescriptors.hasOwnProperty(attrName)) {
            continue;
        }
        const descr = attrDescriptors[attrName];
        if (descr === undefined || typeof descr === "number") {
            continue;
        }
        if (descr.automatic === true) {
            descriptors.push(attrName);
        }
    }
    automaticAttributeCache.set(technique, descriptors);
    return descriptors;
}
exports.getTechniqueAutomaticAttrs = getTechniqueAutomaticAttrs;


/***/ }),

/***/ "../harp-datasource-protocol/lib/TechniqueParams.ts":
/*!**********************************************************!*\
  !*** ../harp-datasource-protocol/lib/TechniqueParams.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTextureBuffer = exports.PlacementToken = exports.transientToPickability = exports.Pickability = exports.PoiStackMode = exports.TextureCoordinateType = exports.GeometryKindSet = exports.GeometryKind = exports.StandardGeometryKind = void 0;
/**
 * Standard kinds of geometry.
 * @deprecated See {@link BaseTechniqueParams.kind}.
 */
var StandardGeometryKind;
(function (StandardGeometryKind) {
    /**
     * Used in the enabledKinds/disabledKinds filter to match any kind.
     */
    StandardGeometryKind["All"] = "_all_";
    /**
     * Background geometry.
     */
    StandardGeometryKind["Background"] = "background";
    /**
     * Terrain geometry.
     */
    StandardGeometryKind["Terrain"] = "terrain";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Area"] = "area";
    /**
     * Default value for all line techniques.
     */
    StandardGeometryKind["Line"] = "line";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Water"] = "water";
    /**
     * Political borders.
     */
    StandardGeometryKind["Border"] = "border";
    /**
     * Basis for all roads.
     */
    StandardGeometryKind["Road"] = "road";
    /**
     * Default value for the ExtrudedPolygonTechnique.
     */
    StandardGeometryKind["Building"] = "building";
    /**
     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.
     */
    StandardGeometryKind["Label"] = "label";
    /**
     * Anything that may show up last.
     */
    StandardGeometryKind["Detail"] = "detail";
})(StandardGeometryKind = exports.StandardGeometryKind || (exports.StandardGeometryKind = {}));
// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge
// eslint-disable-next-line @typescript-eslint/no-redeclare
exports.GeometryKind = StandardGeometryKind;
/**
 * A set of {@link GeometryKind}s.
 */
class GeometryKindSet extends Set {
    /**
     * Return `true` if the Set is a superset of the set 'subset'.
     */
    isSuperset(subset) {
        for (const elem of subset) {
            if (!this.has(elem)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return `true` if the Set intersects Set 'set'.
     */
    hasIntersection(set) {
        for (const elem of set) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'
     * if set is not a Set.
     */
    hasOrIntersects(set) {
        if (set instanceof Set) {
            return this.hasIntersection(set);
        }
        return this.has(set);
    }
    /**
     * Return `true` if this set and the array of elements share at least a single element.
     */
    hasOrIntersectsArray(subset) {
        for (const elem of subset) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
}
exports.GeometryKindSet = GeometryKindSet;
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     *
     * @remarks
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     *
     * @remarks
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
    /**
     * Texture coordinates in feature space.
     *
     * @remarks
     * To compute texture coordinates in feature space,
     * the feature must have a property named `bbox` with value
     * the tuple `[west, south, east, north]`.
     */
    TextureCoordinateType["FeatureSpace"] = "feature-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Define the pickability of an object.
 */
var Pickability;
(function (Pickability) {
    /**
     * Pickable if visible.
     */
    Pickability["onlyVisible"] = "only-visible";
    /**
     * Not Pickable at all.
     */
    Pickability["transient"] = "transient";
    /**
     * All objects of this type pickable.
     */
    Pickability["all"] = "all";
})(Pickability = exports.Pickability || (exports.Pickability = {}));
/**
 * Converts backwards compatible transient property to pure {@type Pickabilty} object
 *
 * @param transient The transient property from the style
 */
function transientToPickability(transient) {
    let pickability = Pickability.onlyVisible;
    if (transient !== undefined && transient !== null) {
        pickability =
            typeof transient === "string"
                ? transient
                : transient === true
                    ? Pickability.transient
                    : Pickability.onlyVisible;
    }
    return pickability;
}
exports.transientToPickability = transientToPickability;
/**
 * Defines options (tokens) supported for text placements defined via [[placements]] attribute.
 *
 * @remarks
 * Possible values are defined as vertical placement letter and horizontal letter, where
 * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:
 * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),
 * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).
 * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:
 * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),
 * `SW` (south-west), `W` (west).
 */
var PlacementToken;
(function (PlacementToken) {
    PlacementToken["TopLeft"] = "TL";
    PlacementToken["Top"] = "T";
    PlacementToken["TopRight"] = "TR";
    PlacementToken["Right"] = "R";
    PlacementToken["BottomRight"] = "BR";
    PlacementToken["Bottom"] = "B";
    PlacementToken["BottomLeft"] = "BL";
    PlacementToken["Left"] = "L";
    PlacementToken["Center"] = "C";
    PlacementToken["NorthWest"] = "NW";
    PlacementToken["North"] = "N";
    PlacementToken["NorthEast"] = "NE";
    PlacementToken["East"] = "E";
    PlacementToken["SouthEast"] = "SE";
    PlacementToken["South"] = "S";
    PlacementToken["SouthWest"] = "SW";
    PlacementToken["West"] = "W";
})(PlacementToken = exports.PlacementToken || (exports.PlacementToken = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Techniques.ts":
/*!*****************************************************!*\
  !*** ../harp-datasource-protocol/lib/Techniques.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setTechniqueRenderOrderOrPriority = exports.composeTechniqueTextureName = exports.addBuffersToTransferList = exports.textureCoordinateType = exports.supportsTextures = exports.needsVertexNormals = exports.isLabelRejectionLineTechnique = exports.isShaderTechnique = exports.isTextTechnique = exports.isTerrainTechnique = exports.isStandardTechnique = exports.isExtrudedPolygonTechnique = exports.isFillTechnique = exports.isStandardExtrudedLineTechnique = exports.isBasicExtrudedLineTechnique = exports.isExtrudedLineTechnique = exports.isSegmentsTechnique = exports.isSpecialDashesLineTechnique = exports.isSolidLineTechnique = exports.isLineTechnique = exports.isLineMarkerTechnique = exports.isPoiTechnique = exports.isSquaresTechnique = exports.isCirclesTechnique = exports.TRANSPARENCY_PROPERTY_KEYS = exports.TEXTURE_PROPERTY_KEYS = void 0;
const TechniqueParams_1 = __webpack_require__(/*! ./TechniqueParams */ "../harp-datasource-protocol/lib/TechniqueParams.ts");
/**
 * Names of the supported texture properties.
 * @internal
 */
exports.TEXTURE_PROPERTY_KEYS = [
    "map",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "emissiveMap",
    "alphaMap",
    "metalnessMap",
    "bumpMap"
];
/**
 * Names of the properties controlling transparency.
 * @internal
 */
exports.TRANSPARENCY_PROPERTY_KEYS = ["opacity", "transparent"];
/**
 * Type guard to check if an object is an instance of `CirclesTechnique`.
 */
function isCirclesTechnique(technique) {
    return technique.name === "circles";
}
exports.isCirclesTechnique = isCirclesTechnique;
/**
 * Type guard to check if an object is an instance of `SquaresTechnique`.
 */
function isSquaresTechnique(technique) {
    return technique.name === "squares";
}
exports.isSquaresTechnique = isSquaresTechnique;
/**
 * Type guard to check if an object is an instance of `PoiTechnique`.
 */
function isPoiTechnique(technique) {
    return technique.name === "labeled-icon";
}
exports.isPoiTechnique = isPoiTechnique;
/**
 * Type guard to check if an object is an instance of `LineMarkerTechnique`.
 */
function isLineMarkerTechnique(technique) {
    return technique.name === "line-marker";
}
exports.isLineMarkerTechnique = isLineMarkerTechnique;
/**
 * Type guard to check if an object is an instance of `LineTechnique`.
 */
function isLineTechnique(technique) {
    return technique.name === "line";
}
exports.isLineTechnique = isLineTechnique;
/**
 * Type guard to check if an object is an instance of `SolidLineTechnique`.
 */
function isSolidLineTechnique(technique) {
    return technique.name === "solid-line" || technique.name === "dashed-line";
}
exports.isSolidLineTechnique = isSolidLineTechnique;
/**
 * Type guard to check if an object is an instance of `SolidLineTechnique` and is a kind that
 * has special dashes.
 * @note Lines with special dashes need line caps to render properly.
 */
function isSpecialDashesLineTechnique(technique) {
    return ((technique.name === "solid-line" || technique.name === "dashed-line") &&
        technique.dashes !== undefined &&
        technique.dashes !== "Square");
}
exports.isSpecialDashesLineTechnique = isSpecialDashesLineTechnique;
/**
 * Type guard to check if an object is an instance of `SegmentsTechnique`.
 */
function isSegmentsTechnique(technique) {
    return technique.name === "segments";
}
exports.isSegmentsTechnique = isSegmentsTechnique;
/**
 * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`
 * or `StandardExtrudedLineTechnique`.
 */
function isExtrudedLineTechnique(technique) {
    return technique.name === "extruded-line";
}
exports.isExtrudedLineTechnique = isExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`.
 */
function isBasicExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "basic";
}
exports.isBasicExtrudedLineTechnique = isBasicExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of `StandardExtrudedLineTechnique`.
 */
function isStandardExtrudedLineTechnique(technique) {
    return isExtrudedLineTechnique(technique) && technique.shading === "standard";
}
exports.isStandardExtrudedLineTechnique = isStandardExtrudedLineTechnique;
/**
 * Type guard to check if an object is an instance of `FillTechnique`.
 */
function isFillTechnique(technique) {
    return technique.name === "fill";
}
exports.isFillTechnique = isFillTechnique;
/**
 * Type guard to check if an object is an instance of `ExtrudedPolygonTechnique`.
 */
function isExtrudedPolygonTechnique(technique) {
    return technique.name === "extruded-polygon";
}
exports.isExtrudedPolygonTechnique = isExtrudedPolygonTechnique;
/**
 * Type guard to check if an object is an instance of `StandardTechnique`.
 */
function isStandardTechnique(technique) {
    return technique.name === "standard";
}
exports.isStandardTechnique = isStandardTechnique;
/**
 * Type guard to check if an object is an instance of `TerrainTechnique`.
 */
function isTerrainTechnique(technique) {
    return technique.name === "terrain";
}
exports.isTerrainTechnique = isTerrainTechnique;
/**
 * Type guard to check if an object is an instance of `TextTechnique`.
 */
function isTextTechnique(technique) {
    return technique.name === "text";
}
exports.isTextTechnique = isTextTechnique;
/**
 * Type guard to check if an object is an instance of `ShaderTechnique`.
 */
function isShaderTechnique(technique) {
    return technique.name === "shader";
}
exports.isShaderTechnique = isShaderTechnique;
function isLabelRejectionLineTechnique(technique) {
    return technique.name === "label-rejection-line";
}
exports.isLabelRejectionLineTechnique = isLabelRejectionLineTechnique;
/**
 * Check if vertex normals should be generated for this technique (if no normals are in the data).
 * @param technique - Technique to check.
 */
function needsVertexNormals(technique) {
    return (isExtrudedPolygonTechnique(technique) ||
        isFillTechnique(technique) ||
        isStandardTechnique(technique) ||
        isTerrainTechnique(technique) ||
        isStandardExtrudedLineTechnique(technique));
}
exports.needsVertexNormals = needsVertexNormals;
/**
 * Type guard to check if an object is an instance of a technique with textures.
 */
function supportsTextures(technique) {
    return (isFillTechnique(technique) ||
        isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique));
}
exports.supportsTextures = supportsTextures;
/**
 * Get the texture coordinate type if the technique supports it.
 */
function textureCoordinateType(technique) {
    return supportsTextures(technique) || isShaderTechnique(technique)
        ? technique.textureCoordinateType
        : undefined;
}
exports.textureCoordinateType = textureCoordinateType;
/**
 * Add all the buffers of the technique to the transfer list.
 */
function addBuffersToTransferList(technique, transferList) {
    if (isStandardTechnique(technique) ||
        isExtrudedPolygonTechnique(technique) ||
        isTerrainTechnique(technique)) {
        for (const texturePropertyKey of exports.TEXTURE_PROPERTY_KEYS) {
            const textureProperty = technique[texturePropertyKey];
            if (TechniqueParams_1.isTextureBuffer(textureProperty)) {
                if (textureProperty.buffer instanceof ArrayBuffer) {
                    transferList.push(textureProperty.buffer);
                }
            }
        }
    }
}
exports.addBuffersToTransferList = addBuffersToTransferList;
/**
 * Compose full texture name for given image name with technique specified.
 * Some techniques allows to add prefix/postfix to icons names specified, this
 * function uses technique information to create fully qualified texture name.
 * @param imageName - base name of the marker icon.
 * @param technique - the technique describing POI or line marker.
 * @returns fully qualified texture name for loading from atlas (without extension).
 */
function composeTechniqueTextureName(imageName, technique) {
    let textureName = imageName;
    if (typeof technique.imageTexturePrefix === "string") {
        textureName = technique.imageTexturePrefix + textureName;
    }
    if (typeof technique.imageTexturePostfix === "string") {
        textureName = textureName + technique.imageTexturePostfix;
    }
    return textureName;
}
exports.composeTechniqueTextureName = composeTechniqueTextureName;
/**
 * Sets a technique's render order (or priority for screen-space techniques) depending on its
 * category and the priorities specified in a given theme.
 * @param technique- The technique whose render order or priority will be set.
 * @param theme - The theme from which the category priorities will be taken.
 */
function setTechniqueRenderOrderOrPriority(technique, priorities, labelPriorities) {
    if (isTextTechnique(technique) ||
        isPoiTechnique(technique) ||
        isLineMarkerTechnique(technique)) {
        // for screen-space techniques the `category` is used to assign
        // priorities.
        if (labelPriorities && typeof technique._category === "string") {
            // override the `priority` when the technique uses `category`.
            const priority = labelPriorities.indexOf(technique._category);
            if (priority !== -1) {
                technique.priority = labelPriorities.length - priority;
            }
        }
    }
    else if (priorities && technique._styleSet !== undefined) {
        // Compute the render order based on the style category and styleSet.
        const computeRenderOrder = (category) => {
            const priority = priorities === null || priorities === void 0 ? void 0 : priorities.findIndex(entry => entry.group === technique._styleSet && entry.category === category);
            return priority !== undefined && priority !== -1 ? (priority + 1) * 10 : undefined;
        };
        if (typeof technique._category === "string") {
            // override the renderOrder when the technique is using categories.
            const renderOrder = computeRenderOrder(technique._category);
            if (renderOrder !== undefined) {
                technique.renderOrder = renderOrder;
            }
        }
        if (typeof technique._secondaryCategory === "string") {
            // override the secondaryRenderOrder when the technique is using categories.
            const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);
            if (secondaryRenderOrder !== undefined) {
                technique.secondaryRenderOrder = secondaryRenderOrder;
            }
        }
    }
}
exports.setTechniqueRenderOrderOrPriority = setTechniqueRenderOrderOrPriority;


/***/ }),

/***/ "../harp-datasource-protocol/lib/Theme.ts":
/*!************************************************!*\
  !*** ../harp-datasource-protocol/lib/Theme.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStyles = exports.isStylesDictionary = exports.isJsonExprReference = exports.getDefinitionValue = exports.isVerboseDefinition = void 0;
/**
 * This is to distinguish between definition types at runtime, to be deprecated with
 * {@link VerboseDefinition}
 * @deprecated
 *
 * @param definition
 * @returns `true` if the Definition is of the deprecated {@link VerboseDefinition} type
 */
function isVerboseDefinition(definition) {
    var _a;
    return ((_a = definition) === null || _a === void 0 ? void 0 : _a.value) !== undefined;
}
exports.isVerboseDefinition = isVerboseDefinition;
/**
 * This is a utility function to retrive a definitions value until {@link VerboseDefinition} is fully
 * deprecated
 * @deprecated
 *
 * @param definition
 * @returns value of the given definition.
 */
function getDefinitionValue(definition) {
    return isVerboseDefinition(definition)
        ? definition.value
        : definition;
}
exports.getDefinitionValue = getDefinitionValue;
/**
 * Checks if the given value is a reference to a definition.
 *
 * @param value - The value of a technique property.
 */
function isJsonExprReference(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        value[0] === "ref" &&
        typeof value[1] === "string");
}
exports.isJsonExprReference = isJsonExprReference;
/**
 * Utility function to convert old style format to new one, to be deprecated with
 * {@link StylesDictionary}
 *
 * @param stylesDict
 * @returns
 *
 */
function convertDictionaryToStyles(stylesDict) {
    const styles = [];
    for (const styleSetName in stylesDict) {
        stylesDict[styleSetName].forEach(style => {
            if (style.styleSet === undefined) {
                style.styleSet = styleSetName;
            }
            styles.push(style);
        });
    }
    return styles;
}
/**
 * Utility function to distinguish Styles until {@link StylesDictionary} is deprecated
 *
 * @deprecated
 * @param styles
 * @returns
 */
function isStylesDictionary(styles) {
    return styles !== undefined && !Array.isArray(styles);
}
exports.isStylesDictionary = isStylesDictionary;
/**
 * Utility function to retrieve Styles until {@link StylesDictionary} is deprecated
 *
 * @deprecated
 * @param styles
 * @returns
 */
function getStyles(styles) {
    if (styles === undefined) {
        return [];
    }
    else if (isStylesDictionary(styles)) {
        return convertDictionaryToStyles(styles);
    }
    else {
        return styles;
    }
}
exports.getStyles = getStyles;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ThemeVisitor.ts":
/*!*******************************************************!*\
  !*** ../harp-datasource-protocol/lib/ThemeVisitor.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemeVisitor = void 0;
const Expr_1 = __webpack_require__(/*! ./Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const Theme_1 = __webpack_require__(/*! ./Theme */ "../harp-datasource-protocol/lib/Theme.ts");
/**
 * The ThemeVisitor visits every style in the theme in a depth-first fashion.
 */
class ThemeVisitor {
    constructor(theme) {
        this.theme = theme;
    }
    /**
     * Applies a function to every style in the theme.
     *
     * @param visitFunc - Function to be called with `style` as an argument. Function should return
     *                  `true` to cancel visitation.
     * @returns `true` if function has finished prematurely.
     */
    visitStyles(visitFunc) {
        const visit = (style) => {
            if (Expr_1.isJsonExpr(style)) {
                return false;
            }
            if (visitFunc(style)) {
                return true;
            }
            return false;
        };
        if (this.theme.styles !== undefined) {
            for (const style of Theme_1.getStyles(this.theme.styles)) {
                if (visit(style)) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.ThemeVisitor = ThemeVisitor;


/***/ }),

/***/ "../harp-datasource-protocol/lib/ThreeBufferUtils.ts":
/*!***********************************************************!*\
  !*** ../harp-datasource-protocol/lib/ThreeBufferUtils.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThreeBufferUtils = void 0;
const DecodedTile_1 = __webpack_require__(/*! ./DecodedTile */ "../harp-datasource-protocol/lib/DecodedTile.ts");
/**
 * Collection of helper methods to convert
 * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}
 * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.
 * See also [[CustomDatasourceExample]].
 */
var ThreeBufferUtils;
(function (ThreeBufferUtils) {
    function getBufferElementType(buffer) {
        if (buffer instanceof Int8Array) {
            return "int8";
        }
        else if (buffer instanceof Uint8Array) {
            return "uint8";
        }
        else if (buffer instanceof Int16Array) {
            return "int16";
        }
        else if (buffer instanceof Uint16Array) {
            return "uint16";
        }
        else if (buffer instanceof Int32Array) {
            return "int32";
        }
        else if (buffer instanceof Uint32Array) {
            return "uint32";
        }
        else if (buffer instanceof Float32Array) {
            return "float";
        }
        throw new Error(`Unsupported buffer type ${name}`);
    }
    ThreeBufferUtils.getBufferElementType = getBufferElementType;
    function fromThreeBufferAttribute(bufferAttribute) {
        const buffer = bufferAttribute.array;
        return {
            name: bufferAttribute.name,
            buffer: buffer.buffer,
            type: getBufferElementType(buffer),
            itemCount: bufferAttribute.itemSize,
            normalized: bufferAttribute.normalized
        };
    }
    ThreeBufferUtils.fromThreeBufferAttribute = fromThreeBufferAttribute;
    function fromThreeInterleavedBufferAttribute(bufferAttribute) {
        throw new Error("Not implemented yet");
    }
    ThreeBufferUtils.fromThreeInterleavedBufferAttribute = fromThreeInterleavedBufferAttribute;
    function fromThreeBufferGeometry(bufferGeometry, techniqueIndex) {
        const vertexAttributes = [];
        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);
        for (const name of attributeNames) {
            const attribute = bufferGeometry.attributes[name];
            // FIXME: Also support InterleavedBufferAttribute
            const vertexAttribute = fromThreeBufferAttribute(attribute);
            vertexAttribute.name = name;
            vertexAttributes.push(vertexAttribute);
        }
        const index = bufferGeometry.index !== null
            ? fromThreeBufferAttribute(bufferGeometry.index)
            : undefined;
        let count = 0;
        if (index !== undefined) {
            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;
        }
        else {
            // If there is no index buffer, try to deduce the count from the position attribute.
            const posAttr = bufferGeometry.attributes.position;
            if (posAttr === undefined) {
                throw new Error("Missing position attibute to deduce item count");
            }
            count = posAttr.count;
        }
        return {
            type: DecodedTile_1.GeometryType.Unspecified,
            vertexAttributes,
            index,
            groups: [{ start: 0, count, technique: techniqueIndex }]
        };
    }
    ThreeBufferUtils.fromThreeBufferGeometry = fromThreeBufferGeometry;
})(ThreeBufferUtils = exports.ThreeBufferUtils || (exports.ThreeBufferUtils = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/TileInfo.ts":
/*!***************************************************!*\
  !*** ../harp-datasource-protocol/lib/TileInfo.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerDecoderProtocol = exports.RequestController = void 0;
/**
 * Allows to cancel and prioritize requests inside the requestQueue.
 *
 * @remarks
 * Useful to optimize the order of decoding tiles during animations and camera movements.
 *
 * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.
 */
class RequestController {
    /**
     * Creates an instance of `RequestController`.
     *
     * @param {number} priority
     * @param {AbortController} abortController Optional [[AbortController]] used internally, since
     *      [[AbortController]]s should not be subclassed.
     */
    constructor(priority = 0, abortController = new AbortController()) {
        this.priority = priority;
        this.abortController = abortController;
    }
    get signal() {
        return this.abortController.signal;
    }
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and
     * signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        this.abortController.abort();
    }
}
exports.RequestController = RequestController;
/**
 * Communication protocol with [[ITileDecoder]].
 */
var WorkerDecoderProtocol;
(function (WorkerDecoderProtocol) {
    /**
     * Define possible names of messages exchanged with decoder services within `WebWorker`.
     */
    let DecoderMessageName;
    (function (DecoderMessageName) {
        DecoderMessageName["Configuration"] = "configuration";
    })(DecoderMessageName = WorkerDecoderProtocol.DecoderMessageName || (WorkerDecoderProtocol.DecoderMessageName = {}));
    /**
     * Type guard to check if an object is an instance of `ConfigurationMessage`.
     */
    function isConfigurationMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === DecoderMessageName.Configuration);
    }
    WorkerDecoderProtocol.isConfigurationMessage = isConfigurationMessage;
    /**
     * Define possible names of requests called on decoder services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["DecodeTileRequest"] = "decode-tile-request";
        Requests["TileInfoRequest"] = "tile-info-request";
    })(Requests = WorkerDecoderProtocol.Requests || (WorkerDecoderProtocol.Requests = {}));
    /**
     * Type guard to check if an object is a decoded tile object sent to a worker.
     */
    function isDecodeTileRequest(message) {
        return (message &&
            typeof message.type === "string" &&
            message.type === Requests.DecodeTileRequest);
    }
    WorkerDecoderProtocol.isDecodeTileRequest = isDecodeTileRequest;
    /**
     * Type guard to check if an object is an info tile object sent to a worker.
     */
    function isTileInfoRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.TileInfoRequest);
    }
    WorkerDecoderProtocol.isTileInfoRequest = isTileInfoRequest;
})(WorkerDecoderProtocol = exports.WorkerDecoderProtocol || (exports.WorkerDecoderProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerServiceProtocol.ts":
/*!****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerServiceProtocol.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerServiceProtocol = void 0;
/**
 * Common communication protocol for [[WorkerService]].
 */
var WorkerServiceProtocol;
(function (WorkerServiceProtocol) {
    /**
     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service
     * instances in workers.
     */
    WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID = "worker-service-manager";
    /**
     * Define possible names of messages exchanged with services within `WebWorker`.
     */
    let ServiceMessageName;
    (function (ServiceMessageName) {
        ServiceMessageName["Initialized"] = "initialized";
        ServiceMessageName["Request"] = "request";
        ServiceMessageName["Response"] = "response";
    })(ServiceMessageName = WorkerServiceProtocol.ServiceMessageName || (WorkerServiceProtocol.ServiceMessageName = {}));
    /**
     * Type guard to check if an object is a signal message from worker.
     */
    function isInitializedMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Initialized);
    }
    WorkerServiceProtocol.isInitializedMessage = isInitializedMessage;
    /**
     * Define possible names of requests called on services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["CreateService"] = "create-service";
        Requests["DestroyService"] = "destroy-service";
    })(Requests = WorkerServiceProtocol.Requests || (WorkerServiceProtocol.Requests = {}));
    /**
     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.
     */
    function isUnknownServiceError(error) {
        return error.message.includes("unknown targetServiceType requested: ");
    }
    WorkerServiceProtocol.isUnknownServiceError = isUnknownServiceError;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isRequestMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Request);
    }
    WorkerServiceProtocol.isRequestMessage = isRequestMessage;
    /**
     * Type guard to check if an object is a request message sent to a worker.
     */
    function isResponseMessage(message) {
        return (message &&
            typeof message.service === "string" &&
            typeof message.type === "string" &&
            message.type === ServiceMessageName.Response);
    }
    WorkerServiceProtocol.isResponseMessage = isResponseMessage;
})(WorkerServiceProtocol = exports.WorkerServiceProtocol || (exports.WorkerServiceProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/WorkerTilerProtocol.ts":
/*!**************************************************************!*\
  !*** ../harp-datasource-protocol/lib/WorkerTilerProtocol.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerTilerProtocol = void 0;
/**
 * Communication protocol with {@link ITiler}.
 */
var WorkerTilerProtocol;
(function (WorkerTilerProtocol) {
    /**
     * Define possible names of requests called on tiler services within `WebWorker`.
     */
    let Requests;
    (function (Requests) {
        Requests["RegisterIndex"] = "register-index";
        Requests["UpdateIndex"] = "update-index";
        Requests["TileRequest"] = "tile-request";
    })(Requests = WorkerTilerProtocol.Requests || (WorkerTilerProtocol.Requests = {}));
    /**
     * Type guard to check if an object is an index registration request sent to a worker.
     */
    function isRegisterIndexRequest(message) {
        return (message && typeof message.type === "string" && message.type === Requests.RegisterIndex);
    }
    WorkerTilerProtocol.isRegisterIndexRequest = isRegisterIndexRequest;
    /**
     * Type guard to check if an object is an update request for the index registration.
     */
    function isUpdateIndexRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.UpdateIndex;
    }
    WorkerTilerProtocol.isUpdateIndexRequest = isUpdateIndexRequest;
    /**
     * Type guard to check if an object is a tile request sent to a worker.
     */
    function isTileRequest(message) {
        return message && typeof message.type === "string" && message.type === Requests.TileRequest;
    }
    WorkerTilerProtocol.isTileRequest = isTileRequest;
})(WorkerTilerProtocol = exports.WorkerTilerProtocol || (exports.WorkerTilerProtocol = {}));


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ArrayOperators.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ArrayOperators.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const VALID_ELEMENT_TYPES = ["boolean", "number", "string"];
function checkElementTypes(arg, array) {
    if (!(arg instanceof Expr_1.StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {
        throw new Error(`expected "boolean", "number" or "string" instead of '${JSON.stringify(arg)}'`);
    }
    const ty = arg.value;
    array.forEach((element, index) => {
        if (typeof element !== ty) {
            throw new Error(`expected array element at index ${index} to have type '${ty}'`);
        }
    });
}
function checkArrayLength(arg, array) {
    if (!(arg instanceof Expr_1.NumberLiteralExpr)) {
        throw new Error(`missing expected number of elements`);
    }
    const length = arg.value;
    if (array.length !== length) {
        throw new Error(`the array must have ${length} element(s)`);
    }
}
function checkArray(context, arg) {
    const value = context.evaluate(arg);
    if (!Array.isArray(value)) {
        throw new Error(`'${value}' is not an array`);
    }
    return value;
}
const operators = {
    array: {
        call: (context, call) => {
            switch (call.args.length) {
                case 0:
                    throw new Error("not enough arguments");
                case 1:
                    return checkArray(context, call.args[0]);
                case 2: {
                    const array = checkArray(context, call.args[1]);
                    checkElementTypes(call.args[0], array);
                    return array;
                }
                case 3: {
                    const array = checkArray(context, call.args[2]);
                    checkArrayLength(call.args[1], array);
                    checkElementTypes(call.args[0], array);
                    return array;
                }
                default:
                    throw new Error("too many arguments");
            }
        }
    },
    "make-array": {
        call: (context, call) => {
            if (call.args.length === 0) {
                throw new Error("not enough arguments");
            }
            return [...call.args.map(arg => context.evaluate(arg))];
        }
    },
    at: {
        call: (context, call) => {
            const args = call.args;
            const index = context.evaluate(args[0]);
            if (typeof index !== "number") {
                throw new Error(`expected the index of the element to retrieve`);
            }
            const value = context.evaluate(args[1]);
            if (!Array.isArray(value)) {
                throw new Error(`expected an array`);
            }
            return index >= 0 && index < value.length ? value[index] : null;
        }
    },
    slice: {
        call: (context, call) => {
            if (call.args.length < 2) {
                throw new Error("not enough arguments");
            }
            const input = context.evaluate(call.args[0]);
            if (!(typeof input === "string" || Array.isArray(input))) {
                throw new Error("input must be a string or an array");
            }
            const start = context.evaluate(call.args[1]);
            if (typeof start !== "number") {
                throw new Error("expected an index");
            }
            let end;
            if (call.args.length > 2) {
                end = context.evaluate(call.args[2]);
                if (typeof end !== "number") {
                    throw new Error("expected an index");
                }
            }
            return input.slice(start, end);
        }
    }
};
exports.ArrayOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/CastOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/CastOperators.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CastOperators = void 0;
const operators = {
    "to-boolean": {
        call: (context, call) => {
            return Boolean(context.evaluate(call.args[0]));
        }
    },
    "to-string": {
        call: (context, call) => {
            return String(context.evaluate(call.args[0]));
        }
    },
    "to-number": {
        call: (context, call) => {
            for (const arg of call.args) {
                const value = Number(context.evaluate(arg));
                if (!isNaN(value)) {
                    return value;
                }
            }
            throw new Error("cannot convert the value to a number");
        }
    }
};
exports.CastOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ColorOperators.ts":
/*!*******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ColorOperators.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorOperators = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const ColorUtils_1 = __webpack_require__(/*! ../ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const StringEncodedNumeral_1 = __webpack_require__(/*! ../StringEncodedNumeral */ "../harp-datasource-protocol/lib/StringEncodedNumeral.ts");
const operators = {
    alpha: {
        call: (context, call) => {
            let color = context.evaluate(call.args[0]);
            if (typeof color === "string") {
                color = StringEncodedNumeral_1.parseStringEncodedColor(color);
            }
            const alpha = typeof color === "number" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;
            return alpha;
        }
    },
    rgba: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            const a = context.evaluate(call.args[3]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                typeof a === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0 &&
                a >= 0 &&
                a <= 1) {
                return rgbaToHex(r, g, b, a);
            }
            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);
        }
    },
    rgb: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0) {
                return rgbToHex(r, g, b);
            }
            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);
        }
    },
    // Hsl operator contains angle modulated to <0, 360> range, percent of
    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)
    hsl: {
        call: (context, call) => {
            const h = context.evaluate(call.args[0]);
            const s = context.evaluate(call.args[1]);
            const l = context.evaluate(call.args[2]);
            if (typeof h === "number" &&
                typeof s === "number" &&
                typeof l === "number" &&
                h >= 0 &&
                s >= 0 &&
                l >= 0) {
                return hslToHex(h, s, l);
            }
            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);
        }
    }
};
function rgbaToHex(r, g, b, a) {
    // We decode rgba color channels using custom hex format with transparency.
    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255, THREE.MathUtils.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.MathUtils.euclideanModulo(h, 360) / 360, THREE.MathUtils.clamp(s, 0, 100) / 100, THREE.MathUtils.clamp(l, 0, 100) / 100);
}
exports.ColorOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ComparisonOperators.ts":
/*!************************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ComparisonOperators.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComparisonOperators = void 0;
function compare(context, call, strict = false) {
    const left = context.evaluate(call.args[0]);
    const right = context.evaluate(call.args[1]);
    if (!((typeof left === "number" && typeof right === "number") ||
        (typeof left === "string" && typeof right === "string"))) {
        if (strict) {
            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);
        }
    }
    switch (call.op) {
        case "<":
            return left < right;
        case ">":
            return left > right;
        case "<=":
            return left <= right;
        case ">=":
            return left >= right;
        default:
            throw new Error(`invalid comparison operator '${call.op}'`);
    }
}
const operators = {
    "!": {
        call: (context, call) => {
            return !context.evaluate(call.args[0]);
        }
    },
    "==": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left === right;
        }
    },
    "!=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            return left !== right;
        }
    },
    "<": { call: (context, call) => compare(context, call) },
    ">": { call: (context, call) => compare(context, call) },
    "<=": { call: (context, call) => compare(context, call) },
    ">=": { call: (context, call) => compare(context, call) }
};
exports.ComparisonOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/FeatureOperators.ts":
/*!*********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/FeatureOperators.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeatureOperators = void 0;
const Env_1 = __webpack_require__(/*! ../Env */ "../harp-datasource-protocol/lib/Env.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const operators = {
    "geometry-type": {
        call: (context, call) => {
            const geometryType = context.env.lookup("$geometryType");
            switch (geometryType) {
                case "point":
                    return "Point";
                case "line":
                    return "LineString";
                case "polygon":
                    return "Polygon";
                default:
                    return null;
            }
        }
    },
    "feature-state": {
        isDynamicOperator: () => true,
        call: (context, call) => {
            var _a, _b;
            if (context.scope !== Expr_1.ExprScope.Dynamic) {
                throw new Error("feature-state cannot be used in this context");
            }
            const property = context.evaluate(call.args[0]);
            if (typeof property !== "string") {
                throw new Error(`expected the name of the property of the feature state`);
            }
            const state = context.env.lookup("$state");
            if (Env_1.Env.isEnv(state)) {
                return (_a = state.lookup(property)) !== null && _a !== void 0 ? _a : null;
            }
            else if (state instanceof Map) {
                return (_b = state.get(property)) !== null && _b !== void 0 ? _b : null;
            }
            return null;
        }
    },
    id: {
        call: (context, call) => {
            var _a;
            return (_a = context.env.lookup("$id")) !== null && _a !== void 0 ? _a : null;
        }
    }
};
exports.FeatureOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/FlowOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/FlowOperators.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlowOperators = void 0;
function conditionalCast(context, type, args) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            for (const childExpr of args) {
                const value = context.evaluate(childExpr);
                if (typeof value === type) {
                    return value;
                }
            }
            throw new Error(`expected a '${type}'`);
        default:
            throw new Error(`invalid type '${type}'`);
    } // switch
}
const operators = {
    all: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (!context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    any: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return true;
                }
            }
            return false;
        }
    },
    none: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                if (context.evaluate(childExpr)) {
                    return false;
                }
            }
            return true;
        }
    },
    boolean: {
        call: (context, call) => {
            return conditionalCast(context, "boolean", call.args);
        }
    },
    number: {
        call: (context, call) => {
            return conditionalCast(context, "number", call.args);
        }
    },
    string: {
        call: (context, call) => {
            return conditionalCast(context, "string", call.args);
        }
    }
};
exports.FlowOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MapOperators.ts":
/*!*****************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MapOperators.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapOperators = void 0;
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const operators = {
    "ppi-scale": {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            return value * scaleFactor;
        }
    },
    "world-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);
            const v = pixels * zoomWidth * scaleFactor;
            return v;
        }
    },
    "world-discrete-ppi-scale": {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            const pixels = context.evaluate(call.args[0]);
            const scaleFactor = call.args[1] ? context.evaluate(call.args[1]) : 1;
            const zoom = context.env.lookup("$zoom");
            const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));
            const v = pixels * zoomWidthDiscrete * scaleFactor;
            return v;
        }
    },
    ppi: {
        call: (context) => {
            const ppi = context.env.lookup("$ppi");
            if (typeof ppi === "number") {
                return ppi;
            }
            return 72;
        }
    },
    zoom: {
        isDynamicOperator: () => {
            return true;
        },
        call: (context, call) => {
            var _a;
            if (context.scope === Expr_1.ExprScope.Value) {
                return call;
            }
            return (_a = context.env.lookup("$zoom")) !== null && _a !== void 0 ? _a : null;
        }
    }
};
exports.MapOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MathOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MathOperators.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathOperators = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const operators = {
    "^": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '^'`);
            }
            return Math.pow(a, b);
        }
    },
    "-": {
        call: (context, call) => {
            if (call.args.length === 1) {
                const value = context.evaluate(call.args[0]);
                if (typeof value !== "number") {
                    throw new Error(`nvalid operand '${typeof value} for operator '-'`);
                }
                return -value;
            }
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '-'`);
            }
            return a - b;
        }
    },
    "/": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '/'`);
            }
            return a / b;
        }
    },
    "%": {
        call: (context, call) => {
            const a = context.evaluate(call.args[0]);
            const b = context.evaluate(call.args[1]);
            if (typeof a !== "number" || typeof b !== "number") {
                throw new Error(`invalid operands '${typeof a}' and '${typeof b}' for operator '%'`);
            }
            return a % b;
        }
    },
    "+": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);
        }
    },
    "*": {
        call: (context, call) => {
            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);
        }
    },
    abs: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'abs'`);
            }
            return Math.abs(value);
        }
    },
    acos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'acos'`);
            }
            return Math.acos(value);
        }
    },
    asin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'asin'`);
            }
            return Math.asin(value);
        }
    },
    atan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'atan'`);
            }
            return Math.atan(value);
        }
    },
    ceil: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ceil'`);
            }
            return Math.ceil(value);
        }
    },
    cos: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'cos'`);
            }
            return Math.cos(value);
        }
    },
    e: {
        call: () => {
            return Math.E;
        }
    },
    floor: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'floor'`);
            }
            return Math.floor(value);
        }
    },
    ln: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln'`);
            }
            return Math.log(value);
        }
    },
    ln2: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'ln2'`);
            }
            return Math.log2(value);
        }
    },
    log10: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'log10'`);
            }
            return Math.log10(value);
        }
    },
    max: {
        call: (context, call) => {
            return Math.max(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    min: {
        call: (context, call) => {
            return Math.min(...call.args.map(v => Number(context.evaluate(v))));
        }
    },
    /**
     * Clamp numeric value to given range, inclusive.
     *
     * Synopsis:
     * ```
     * ["clamp", v: number, min: number, max: number]`
     * ```
     */
    clamp: {
        call: (context, call) => {
            const v = context.evaluate(call.args[0]);
            const min = context.evaluate(call.args[1]);
            const max = context.evaluate(call.args[2]);
            if (typeof v !== "number" || typeof min !== "number" || typeof max !== "number") {
                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);
            }
            return THREE.MathUtils.clamp(v, min, max);
        }
    },
    pi: {
        call: () => {
            return Math.PI;
        }
    },
    round: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'round'`);
            }
            return Math.round(value);
        }
    },
    sin: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sin'`);
            }
            return Math.sin(value);
        }
    },
    sqrt: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);
            }
            return Math.sqrt(value);
        }
    },
    tan: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (typeof value !== "number") {
                throw new Error(`invalid operand '${value}' for operator 'tan'`);
            }
            return Math.tan(value);
        }
    }
};
exports.MathOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/MiscOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/MiscOperators.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiscOperators = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
function joinKeyValues(keys) {
    return keys.join("&");
}
function stringifyKeyValue(key, value) {
    return key + "=" + JSON.stringify(value);
}
/**
 * Joins the strings of each given array.
 * @param combinations Array of string arrays that must be joined.
 * @returns The joined strings sorted from longest to shortest (in number of substrings).
 */
function joinCombinations(combinations) {
    // sort from longest (more specific) to shortest (more generic).
    combinations.sort((lhs, rhs) => rhs.length - lhs.length);
    const result = combinations.map((keys) => joinKeyValues(keys));
    // Add the empty combination which will match a default table entry (an entry without keys) if
    // it exists.
    result.push("");
    return result;
}
/**
 * Gets all combinations of all lengths of a list of strings.
 * @param input An array containing all strings.
 * @param index Start index of the strings in `input` that will be considered.
 * @returns An array of all combinations. The strings within each combination are in the inverse
 * order of the input array.
 */
function getAllCombinations(input, index = 0) {
    if (index >= input.length) {
        return [];
    }
    const combinations = getAllCombinations(input, index + 1);
    const initLength = combinations.length;
    for (let i = 0; i < initLength; i += 1) {
        combinations.push([...combinations[i], input[index]]);
    }
    combinations.push([input[index]]);
    return combinations;
}
/**
 * Make all combinations of all lengths with the search keys of the given lookup expression.
 * @param lookupExpr The lookup expression.
 * @param context The context to evaluate expressions.
 * @returns All combinations, sorted from longest(more specific) to shortest (more generic).
 */
function getKeyCombinations(lookupExpr, context) {
    const keys = lookupExpr.args.slice(1);
    const result = [];
    for (let i = 0; i < keys.length; i += 2) {
        const value = context.evaluate(keys[i + 1]);
        // ignore keys whose values evaluate to null.
        if (value === null) {
            continue;
        }
        const key = context.evaluate(keys[i]);
        result.push(stringifyKeyValue(key, value));
    }
    // Reverse sort, getAllCombinations reverses the order.
    result.sort().reverse();
    return joinCombinations(getAllCombinations(result));
}
/**
 * Creates a map from the lookup entries in a given array.
 * @param lookupArray The array to transform.
 * @returns The resulting map.
 */
function createLookupMap(lookupArray) {
    const map = new Map();
    for (const entry of lookupArray) {
        if (typeof entry !== "object") {
            throw new Error(`Invalid lookup table entry type (${typeof entry})`);
        }
        if (!entry.keys) {
            throw new Error(`Lookup table entry has no 'keys' property.`);
        }
        if (!entry.attributes) {
            throw new Error(`Lookup table entry has no 'attributes' property.`);
        }
        const key = joinKeyValues(Object.getOwnPropertyNames(entry.keys)
            .sort()
            .map(key => stringifyKeyValue(key, entry.keys[key])));
        map.set(key, entry.attributes);
    }
    return map;
}
/**
 * Searches matches of the given keys in a map.
 * @param keys Keys to search in the map.
 * @param map The lookup map.
 * @returns The first match (in the order in which keys are given) or null if no match found.
 */
function searchLookupMap(keys, map) {
    for (const key of keys) {
        const matchAttributes = map.get(key);
        if (matchAttributes) {
            return matchAttributes;
        }
    }
    return null;
}
const operators = {
    length: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            if (Array.isArray(value) || typeof value === "string") {
                return value.length;
            }
            throw new Error(`invalid operand '${value}' for operator 'length'`);
        }
    },
    coalesce: {
        call: (context, call) => {
            for (const childExpr of call.args) {
                const value = context.evaluate(childExpr);
                if (value !== null) {
                    return value;
                }
            }
            return null;
        }
    },
    lookup: {
        call: (context, lookup) => {
            // Argument types are checked on parsing, see LookupExpr.parseArray().
            harp_utils_1.assert(lookup.args.length > 0, "missing lookup table");
            const keyCombinations = getKeyCombinations(lookup, context);
            let table = context.evaluate(lookup.args[0]);
            harp_utils_1.assert(Array.isArray(table) || table instanceof Map, "wrong lookup table type");
            if (Array.isArray(table)) {
                // Transform the lookup table into a map to speedup lookup, since the same table
                // might be used by multiple lookup expressions.
                table = createLookupMap(table);
                const lookupMapExpr = new Expr_1.ObjectLiteralExpr(table);
                // Replace the lookup table argument with the map. Next calls to the same expression
                // (e.g. re-evaluations due to data dependencies) will use the map.
                lookup.args[0] = lookupMapExpr;
            }
            return searchLookupMap(keyCombinations, table);
        }
    }
};
exports.MiscOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/ObjectOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/ObjectOperators.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectOperators = void 0;
const Env_1 = __webpack_require__(/*! ../Env */ "../harp-datasource-protocol/lib/Env.ts");
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
const hasOwnProperty = Object.prototype.hasOwnProperty;
var LookupMode;
(function (LookupMode) {
    LookupMode[LookupMode["get"] = 0] = "get";
    LookupMode[LookupMode["has"] = 1] = "has";
})(LookupMode || (LookupMode = {}));
function lookupMember(context, args, lookupMode) {
    var _a;
    const memberName = context.evaluate(args[0]);
    if (typeof memberName !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    const object = context.evaluate(args[1]);
    if (object && typeof object === "object") {
        if (Env_1.Env.isEnv(object)) {
            const value = (_a = object.lookup(memberName)) !== null && _a !== void 0 ? _a : null;
            return lookupMode === LookupMode.get ? value : value !== null;
        }
        if (hasOwnProperty.call(object, memberName)) {
            return lookupMode === LookupMode.get ? object[memberName] : true;
        }
    }
    return lookupMode === LookupMode.get ? null : false;
}
const operators = {
    in: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const object = context.evaluate(call.args[1]);
            if (typeof value === "string" && typeof object === "string") {
                return object.includes(value);
            }
            else if (Array.isArray(object)) {
                return object.includes(value);
            }
            return false;
        }
    },
    get: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.get)
    },
    has: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.has)
    },
    "dynamic-properties": {
        isDynamicOperator: () => true,
        call: (context, call) => {
            if (context.scope === Expr_1.ExprScope.Dynamic) {
                return context.env;
            }
            return call;
        }
    }
};
exports.ObjectOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/StringOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/StringOperators.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringOperators = void 0;
const operators = {
    concat: {
        call: (context, call) => {
            return "".concat(...call.args.map(a => String(context.evaluate(a))));
        }
    },
    downcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleLowerCase();
        }
    },
    upcase: {
        call: (context, call) => {
            return String(context.evaluate(call.args[0])).toLocaleUpperCase();
        }
    },
    "~=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.includes(right);
            }
            return false;
        }
    },
    "^=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.startsWith(right);
            }
            return false;
        }
    },
    "$=": {
        call: (context, call) => {
            const left = context.evaluate(call.args[0]);
            const right = context.evaluate(call.args[1]);
            if (typeof left === "string" && typeof right === "string") {
                return left.endsWith(right);
            }
            return false;
        }
    }
};
exports.StringOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/TypeOperators.ts":
/*!******************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/TypeOperators.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeOperators = void 0;
const operators = {
    typeof: {
        call: (context, call) => {
            return typeof context.evaluate(call.args[0]);
        }
    }
};
exports.TypeOperators = operators;


/***/ }),

/***/ "../harp-datasource-protocol/lib/operators/VectorOperators.ts":
/*!********************************************************************!*\
  !*** ../harp-datasource-protocol/lib/operators/VectorOperators.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VectorOperators = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const Expr_1 = __webpack_require__(/*! ../Expr */ "../harp-datasource-protocol/lib/Expr.ts");
function isVector(context, call, type) {
    let ctor;
    switch (type) {
        case "vector2":
            ctor = THREE.Vector2;
            break;
        case "vector3":
            ctor = THREE.Vector3;
            break;
        case "vector4":
            ctor = THREE.Vector4;
            break;
    }
    for (const childExpr of call.args) {
        const value = context.evaluate(childExpr);
        if (value instanceof ctor) {
            return value;
        }
    }
    throw new Error(`expected a "${type}"`);
}
function toVector(context, call, type) {
    let VectorCtor;
    let components;
    switch (type) {
        case "vector2":
            VectorCtor = THREE.Vector2;
            components = 2;
            break;
        case "vector3":
            VectorCtor = THREE.Vector3;
            components = 3;
            break;
        case "vector4":
            VectorCtor = THREE.Vector4;
            components = 4;
            break;
    }
    for (const childExpr of call.args) {
        const value = context.evaluate(childExpr);
        if (value instanceof VectorCtor) {
            return value;
        }
        else if (Array.isArray(value) &&
            value.length === components &&
            value.every(v => typeof v === "number")) {
            return new VectorCtor().fromArray(value);
        }
    }
    throw new Error(`expected a "${type}"`);
}
const operators = {
    "make-vector": {
        call: (context, call) => {
            if (call._value !== undefined) {
                return call._value;
            }
            if (call.args.length < 2) {
                throw new Error("not enough arguments");
            }
            else if (call.args.length > 4) {
                throw new Error("too many arguments");
            }
            const components = call.args.map(arg => context.evaluate(arg));
            components.forEach((element, index) => {
                if (typeof element !== "number") {
                    throw new Error(`expected vector component at index ${index} to have type "number"`);
                }
            });
            let result;
            switch (components.length) {
                case 2:
                    result = new THREE.Vector2().fromArray(components);
                    break;
                case 3:
                    result = new THREE.Vector3().fromArray(components);
                    break;
                case 4:
                    result = new THREE.Vector4().fromArray(components);
                    break;
                default:
                    throw new Error("too many arguments");
            }
            if (call.args.every(arg => arg instanceof Expr_1.NumberLiteralExpr)) {
                call._value = result;
            }
            return result;
        }
    },
    vector2: {
        call: (context, call) => isVector(context, call, "vector2")
    },
    vector3: {
        call: (context, call) => isVector(context, call, "vector3")
    },
    vector4: {
        call: (context, call) => isVector(context, call, "vector4")
    },
    "to-vector2": {
        call: (context, call) => toVector(context, call, "vector2")
    },
    "to-vector3": {
        call: (context, call) => toVector(context, call, "vector3")
    },
    "to-vector4": {
        call: (context, call) => toVector(context, call, "vector4")
    }
};
exports.VectorOperators = operators;


/***/ }),

/***/ "../harp-debug-datasource/index.ts":
/*!*****************************************!*\
  !*** ../harp-debug-datasource/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Overlay useful for debugging map data.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/DebugTileDataSource */ "../harp-debug-datasource/lib/DebugTileDataSource.ts"), exports);


/***/ }),

/***/ "../harp-debug-datasource/lib/DebugTileDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-debug-datasource/lib/DebugTileDataSource.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugTileDataSource = exports.DebugTile = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0xff0000,
    linewidth: 1,
    depthTest: false
});
// Set maximum priority.
const PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;
// Size/scale of text showing the tiles key
const TEXT_SCALE = 0.8;
class DebugTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey, gridColor = "#ff0000") {
        super(dataSource, tileKey);
        this.geometry = new THREE.BufferGeometry();
        this.m_labelPositions = new THREE.BufferAttribute(new Float32Array(3), 3);
        const tilingScheme = dataSource.getTilingScheme();
        const worldBox = tilingScheme.boundingBoxGenerator.getWorldBox(tileKey);
        const projection = tilingScheme.projection;
        const geoCoordinates = [
            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.min.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.min.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.max.y, 0)),
            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.max.y, 0))
        ];
        const middlePoint = new THREE.Vector3();
        const vertices = [];
        geoCoordinates.forEach(geoPoint => {
            const pt = new THREE.Vector3();
            this.projection.projectPoint(geoPoint, pt);
            pt.sub(this.center);
            vertices.push(...pt.toArray());
            middlePoint.add(pt);
        });
        this.geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
        middlePoint.divideScalar(geoCoordinates.length);
        const lineObject = new THREE.Line(this.geometry, debugMaterial);
        lineObject.renderOrder = PRIORITY_ALWAYS;
        this.objects.push(lineObject);
        this.m_labelPositions.setXYZ(0, 0, 0, 0);
        const textPosition = new THREE.Vector3();
        if (this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // place the text position at north/west for planar projections.
            textPosition.set(this.geometry.getAttribute("position").getX(3), this.geometry.getAttribute("position").getY(3), this.geometry.getAttribute("position").getZ(3));
            textPosition.multiplyScalar(0.95);
            this.m_textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
                verticalAlignment: harp_text_canvas_1.VerticalAlignment.Below,
                horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Left
            });
        }
        else {
            textPosition.copy(middlePoint);
            this.m_textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
                verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
                horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center
            });
        }
        this.m_textRenderStyle = new harp_text_canvas_1.TextRenderStyle({
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: 16,
                backgroundSize: 0
            },
            color: new THREE.Color(gridColor)
        });
        const text = `${tileKey.mortonCode()} (${tileKey.row}, ${tileKey.column}, ${tileKey.level})`;
        textPosition.add(this.center);
        const textElement = new harp_mapview_1.TextElement(text, textPosition, this.m_textRenderStyle, this.m_textLayoutStyle, PRIORITY_ALWAYS, TEXT_SCALE);
        textElement.mayOverlap = true;
        textElement.reserveSpace = false;
        textElement.alwaysOnTop = true;
        textElement.ignoreDistance = true;
        this.addTextElement(textElement);
    }
}
exports.DebugTile = DebugTile;
class DebugTileDataSource extends harp_mapview_1.DataSource {
    constructor(m_tilingScheme, name = "debug", maxDbgZoomLevel = 20) {
        super({ name, minDataLevel: 1, maxDataLevel: 20, storageLevelOffset: -1 });
        this.m_tilingScheme = m_tilingScheme;
        this.maxDbgZoomLevel = maxDbgZoomLevel;
        this.cacheable = true;
        this.enablePicking = false;
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new DebugTile(this, tileKey);
        return tile;
    }
    /** @override */
    canGetTile(zoomLevel, tileKey) {
        if (tileKey.level > this.maxDbgZoomLevel) {
            return false;
        }
        return super.canGetTile(zoomLevel, tileKey);
    }
}
exports.DebugTileDataSource = DebugTileDataSource;


/***/ }),

/***/ "../harp-features-datasource/index.ts":
/*!********************************************!*\
  !*** ../harp-features-datasource/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Provides support for rendering custom carto features.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/Features */ "../harp-features-datasource/lib/Features.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/FeaturesDataSource */ "../harp-features-datasource/lib/FeaturesDataSource.ts"), exports);


/***/ }),

/***/ "../harp-features-datasource/lib/Features.ts":
/*!***************************************************!*\
  !*** ../harp-features-datasource/lib/Features.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewMultiPointFeature = exports.MapViewPointFeature = exports.MapViewMultiPolygonFeature = exports.MapViewPolygonFeature = exports.MapViewMultiLineFeature = exports.MapViewLineFeature = exports.MapViewFeature = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Base class to create features.
 */
class MapViewFeature {
    /**
     * Builds a new `MapViewFeature`.
     *
     * @param coordinates - The GeoJson geometry.
     * @param style - The style to render the geometry.
     */
    constructor(coordinates, properties) {
        this.coordinates = coordinates;
        this.properties = properties;
        /**
         * The type of the feature. The extended class should initialize this value. It defaults to
         * "Point" in order to avoid allowing `null` or `undefined`.
         */
        this.type = "Point";
        /**
         * A string identifying this feature.
         */
        this.uuid = THREE.MathUtils.generateUUID();
    }
}
exports.MapViewFeature = MapViewFeature;
class MapViewLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "LineString";
    }
}
exports.MapViewLineFeature = MapViewLineFeature;
class MapViewMultiLineFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiLineString";
    }
}
exports.MapViewMultiLineFeature = MapViewMultiLineFeature;
class MapViewPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "Polygon";
    }
}
exports.MapViewPolygonFeature = MapViewPolygonFeature;
class MapViewMultiPolygonFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiPolygon";
    }
}
exports.MapViewMultiPolygonFeature = MapViewMultiPolygonFeature;
class MapViewPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "Point";
    }
}
exports.MapViewPointFeature = MapViewPointFeature;
class MapViewMultiPointFeature extends MapViewFeature {
    constructor(coordinates, properties) {
        super(coordinates, properties);
        this.coordinates = coordinates;
        this.properties = properties;
        /** @override */
        this.type = "MultiPoint";
    }
}
exports.MapViewMultiPointFeature = MapViewMultiPointFeature;


/***/ }),

/***/ "../harp-features-datasource/lib/FeaturesDataSource.ts":
/*!*************************************************************!*\
  !*** ../harp-features-datasource/lib/FeaturesDataSource.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeaturesDataSource = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("FeaturesDataSource");
const NAME = "user-features-datasource";
const DEFAULT_GEOJSON = {
    type: "FeatureCollection",
    features: []
};
/**
 * [[DataSource]] implementation to use for the addition of custom features.
 */
class FeaturesDataSource extends harp_vectortile_datasource_1.VectorTileDataSource {
    /**
     * Builds a `FeaturesDataSource`.
     *
     * @param options - specify custom options using [[FeatureDataSourceOptions]] interface.
     */
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { dataProvider: new harp_vectortile_datasource_1.GeoJsonDataProvider(NAME, DEFAULT_GEOJSON, options), addGroundPlane: false }));
        this.m_isAttached = false;
        this.m_featureCollection = this.emptyGeojson();
        if (options !== undefined) {
            if (options.features !== undefined) {
                this.add(...options.features);
            }
            if (options.geojson !== undefined) {
                this.setFromGeojson(options.geojson);
            }
        }
    }
    /**
     * This method allows to directly add a GeoJSON without using [[MapViewFeature]] instances. It
     * also overwrites existing features in this data source. To add a GeoJSON without overwriting
     * the data source, one should loop through it to create [[MapViewFeature]] and add them with
     * the `add` method.
     *
     * @param geojson - A javascript object matching the GeoJSON specification.
     */
    setFromGeojson(geojson) {
        if (geojson.type === "FeatureCollection") {
            this.m_featureCollection = geojson;
        }
        else if (geojson.type === "Feature") {
            this.m_featureCollection = this.emptyGeojson();
            this.m_featureCollection.features.push(geojson);
        }
        else if (geojson.type === "GeometryCollection") {
            this.m_featureCollection = this.emptyGeojson();
            for (const geometry of geojson.geometries) {
                this.m_featureCollection.features.push({
                    type: "Feature",
                    geometry
                });
            }
        }
        else {
            throw new TypeError("The provided object is not a valid GeoJSON object.");
        }
        this.update();
        return this;
    }
    /**
     * Adds a custom feature in the datasource.
     *
     * @param features - The features to add in the datasource.
     */
    add(...features) {
        for (const feature of features) {
            this.addFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes a custom feature in the datasource.
     *
     * @param features - The features to add in the datasource.
     */
    remove(...features) {
        for (const feature of features) {
            this.removeFeature(feature);
        }
        this.update();
        return this;
    }
    /**
     * Removes all the custom features in this `FeaturesDataSource`.
     */
    clear() {
        this.m_featureCollection = this.emptyGeojson();
        this.update();
    }
    /** @override */
    async connect() {
        await super.connect();
        if (this.m_featureCollection.features.length > 0) {
            await this.update();
        }
    }
    /**
     * Override [[DataSource.attach]] to know if we're really connected to [[MapView]].
     * @param mapView -
     * @override
     */
    attach(mapView) {
        super.attach(mapView);
        this.m_isAttached = true;
    }
    /**
     * Override [[DataSource.detach]] to know if we're really connected to [[MapView]].
     * @param mapView -
     * @override
     */
    detach(mapView) {
        super.detach(mapView);
        this.m_isAttached = false;
    }
    /**
     * Get [[GeoBox]] containing all the points in datasource.
     *
     * Returns undefined if there were no features added to this DS.
     */
    getGeoBox() {
        let result;
        const addPoint = (geoJsonCoords) => {
            // NOTE: GeoJson coordinates are in [longitude, latitude] order!
            const coords = new harp_geoutils_1.GeoCoordinates(geoJsonCoords[1], geoJsonCoords[0]);
            if (result === undefined) {
                result = new harp_geoutils_1.GeoBox(coords, coords.clone());
            }
            else {
                result.growToContain(coords);
            }
        };
        for (const feature of this.m_featureCollection.features) {
            switch (feature.geometry.type) {
                case "Point":
                    addPoint(feature.geometry.coordinates);
                    break;
                case "MultiPoint":
                case "LineString":
                    feature.geometry.coordinates.forEach(addPoint);
                    break;
                case "MultiLineString":
                case "Polygon":
                    feature.geometry.coordinates.forEach(segment => segment.forEach(addPoint));
                    break;
                case "MultiPolygon":
                    feature.geometry.coordinates.forEach(polygon => polygon.forEach(segment => segment.forEach(addPoint)));
                    break;
            }
        }
        return result;
    }
    addFeature(feature) {
        // Check if the feature is not already in there.
        const hasFeature = this.m_featureCollection.features.some(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (hasFeature) {
            return;
        }
        // Create a GeoJson feature from the feature coordinates and push it.
        const geometry = {
            type: feature.type,
            coordinates: feature.coordinates
        };
        const geojsonFeature = {
            type: "Feature",
            geometry,
            properties: Object.assign(Object.assign({}, feature.properties), { __mapViewUuid: feature.uuid })
        };
        this.m_featureCollection.features.push(geojsonFeature);
    }
    removeFeature(feature) {
        // Remove geojson feature from the root FeatureCollection.
        const index = this.m_featureCollection.features.findIndex(_feature => _feature.properties.__mapViewUuid === feature.uuid);
        if (index === -1) {
            return;
        }
        this.m_featureCollection.features.splice(index, 1);
    }
    async update() {
        const dataProvider = this.dataProvider();
        if (!this.m_isAttached || !dataProvider.ready()) {
            return;
        }
        try {
            await dataProvider.updateInput(this.m_featureCollection);
            if (this.m_isAttached) {
                this.mapView.markTilesDirty(this);
            }
        }
        catch (error) {
            // We use `update` in sync API, so there's no-one to react to errors so log them.
            logger.error(`[${this.name}]: failed to update tile index`, error);
        }
    }
    emptyGeojson() {
        return {
            features: [],
            type: "FeatureCollection"
        };
    }
}
exports.FeaturesDataSource = FeaturesDataSource;


/***/ }),

/***/ "../harp-fetch/index.web.ts":
/*!**********************************!*\
  !*** ../harp-fetch/index.web.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-geojson-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-geojson-datasource/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Provides support for GeoJSON datasource.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataSource */ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts"), exports);


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataProvider.ts":
/*!*************************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataProvider.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoJsonDataProvider = void 0;
var harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts");
Object.defineProperty(exports, "GeoJsonDataProvider", ({ enumerable: true, get: function () { return harp_vectortile_datasource_1.GeoJsonDataProvider; } }));


/***/ }),

/***/ "../harp-geojson-datasource/lib/GeoJsonDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-geojson-datasource/lib/GeoJsonDataSource.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoJsonDataSource = void 0;
const harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts");
/**
 * `GeoJsonDataSource` is used for the visualization of geometric objects provided in the GeoJSON
 * format. To be able to render GeoJSON data, a `GeoJsonDataSource` instance must be added to the
 * {@link @here/harp-mapview#MapView} instance.
 *
 * @example
 * ```typescript
 *    const geoJsonDataProvider = new GeoJsonDataProvider(
 *        "italy",
 *        new URL("resources/italy.json", window.location.href)
 *    );
 *    const geoJsonDataSource = new GeoJsonDataSource({
 *        dataProvider: geoJsonDataProvider,
 *        styleSetName: "geojson"
 *    });
 *    mapView.addDataSource(geoJsonDataSource);
 *   ```
 */
class GeoJsonDataSource extends harp_vectortile_datasource_1.VectorTileDataSource {
    /**
     * Default constructor.
     *
     * @param params - Data source configuration's parameters.
     */
    constructor(params) {
        super(Object.assign({ styleSetName: "geojson" }, params));
    }
}
exports.GeoJsonDataSource = GeoJsonDataSource;


/***/ }),

/***/ "../harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.ts":
/*!*********************************************************************!*\
  !*** ../harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EdgeLengthGeometrySubdivisionModifier = exports.SubdivisionMode = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "../harp-geometry/lib/SubdivisionModifier.ts");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3()];
var SubdivisionMode;
(function (SubdivisionMode) {
    /**
     * Subdivide all edges
     */
    SubdivisionMode[SubdivisionMode["All"] = 0] = "All";
    /**
     * Only subdivide horizontal and vertical edges
     */
    SubdivisionMode[SubdivisionMode["NoDiagonals"] = 1] = "NoDiagonals";
})(SubdivisionMode = exports.SubdivisionMode || (exports.SubdivisionMode = {}));
/**
 * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on
 * length of edges.
 */
class EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].
     *
     * @param subdivision - The subdivision factor
     * @param geoBox - The geo bounding box of a tile
     * @param subdivisionMode - Configures what edges to divide
     * @param projection - The projection that defines the world space of this geometry.
     */
    constructor(subdivision, geoBox, subdivisionMode = SubdivisionMode.All, projection) {
        super();
        this.subdivision = subdivision;
        this.geoBox = geoBox;
        this.subdivisionMode = subdivisionMode;
        this.projection = projection;
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Planar, "EdgeLengthGeometrySubdivisionModifier only supports planar projections");
        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);
        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);
        this.m_projectedBox = {
            min: {
                x: Math.min(northEast.x, southWest.x),
                y: Math.min(northEast.y, southWest.y),
                z: Math.min(northEast.z, southWest.z)
            },
            max: {
                x: Math.max(northEast.x, southWest.x),
                y: Math.max(northEast.y, southWest.y),
                z: Math.max(northEast.z, southWest.z)
            }
        };
        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;
        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;
        // Increase max length slightly to account for precision errors
        if (this.subdivisionMode === SubdivisionMode.All) {
            this.m_maxLengthX *= 1.1;
            this.m_maxLengthY *= 1.1;
        }
        this.m_maxLength = Math.sqrt(this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY);
    }
    /**
     * Return upper bound for length of diagonal edges
     */
    get maxLength() {
        return this.m_maxLength;
    }
    /**
     * Return upper bound for edge length in x direction
     */
    get maxLengthX() {
        return this.m_maxLengthX;
    }
    /**
     * Return upper bound for edge length in y direction
     */
    get maxLengthY() {
        return this.m_maxLengthY;
    }
    /** @override */
    shouldSplitTriangle(a, b, c) {
        const shouldSplitAB = this.shouldSplitEdge(a, b);
        const shouldSplitBC = this.shouldSplitEdge(b, c);
        const shouldSplitCA = this.shouldSplitEdge(c, a);
        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;
        if (!shouldSplit) {
            return;
        }
        const ab = a.distanceTo(b);
        const bc = b.distanceTo(c);
        const ca = c.distanceTo(a);
        const maxDistance = Math.max(shouldSplitAB ? ab : 0, shouldSplitBC ? bc : 0, shouldSplitCA ? ca : 0);
        if (ab === maxDistance) {
            return 0;
        }
        else if (bc === maxDistance) {
            return 1;
        }
        else if (ca === maxDistance) {
            return 2;
        }
        throw new Error("Could not split triangle.");
    }
    shouldSplitEdge(a, b) {
        switch (this.subdivisionMode) {
            case SubdivisionMode.All:
                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||
                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||
                    a.distanceTo(b) > this.m_maxLength);
            case SubdivisionMode.NoDiagonals:
                return ((a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||
                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY));
        }
    }
}
exports.EdgeLengthGeometrySubdivisionModifier = EdgeLengthGeometrySubdivisionModifier;


/***/ }),

/***/ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts":
/*!********************************************************************!*\
  !*** ../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SphericalGeometrySubdivisionModifier = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const SubdivisionModifier_1 = __webpack_require__(/*! ./SubdivisionModifier */ "../harp-geometry/lib/SubdivisionModifier.ts");
const VERTEX_POSITION_CACHE = [new three_1.Vector3(), new three_1.Vector3(), new three_1.Vector3()];
/**
 * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned
 * on the surface of a sphere centered at `(0, 0, 0)`.
 */
class SphericalGeometrySubdivisionModifier extends SubdivisionModifier_1.SubdivisionModifier {
    /**
     * Constructs a new [[SphericalGeometrySubdivisionModifier]].
     *
     * @param angle - The maximum angle in radians between two vertices and the origin.
     * @param projection - The projection that defines the world space of this geometry.
     */
    constructor(angle, projection = harp_geoutils_1.sphereProjection) {
        super();
        this.angle = angle;
        this.projection = projection;
    }
    /** @override */
    shouldSplitTriangle(a, b, c) {
        const aa = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);
        const bb = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);
        const cc = harp_geoutils_1.sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);
        const alpha = aa.angleTo(bb);
        const beta = bb.angleTo(cc);
        const gamma = cc.angleTo(aa);
        // find the maximum angle
        const m = Math.max(alpha, Math.max(beta, gamma));
        // split the triangle if needed.
        if (m < this.angle) {
            return undefined;
        }
        if (m === alpha) {
            return 0;
        }
        else if (m === beta) {
            return 1;
        }
        else if (m === gamma) {
            return 2;
        }
        throw new Error("failed to split triangle");
    }
}
exports.SphericalGeometrySubdivisionModifier = SphericalGeometrySubdivisionModifier;


/***/ }),

/***/ "../harp-geometry/lib/SubdivisionModifier.ts":
/*!***************************************************!*\
  !*** ../harp-geometry/lib/SubdivisionModifier.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubdivisionModifier = void 0;
const three_1 = __webpack_require__(/*! three */ "three");
const tmpVectorA = new three_1.Vector3();
const tmpVectorB = new three_1.Vector3();
const tmpVectorC = new three_1.Vector3();
/**
 * The [[SubdivisionModifier]] subdivides triangle mesh geometries.
 */
class SubdivisionModifier {
    /**
     * Constructs a new [[SubdivisionModifier]].
     */
    constructor() {
        // nothing to do
    }
    /**
     * Subdivides the faces of the given [[THREE.BufferGeometry]].
     *
     * This method modifies (in-place) the vertices and the faces of the geometry.
     * Please note that only the vertex position and their UV coordinates are subdivided.
     * Normals, vertex colors and other attributes are left unmodified.
     *
     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.
     */
    modify(geometry) {
        const positionAttr = geometry.getAttribute("position");
        const position = Array.from(positionAttr.array);
        const uvAttr = geometry.getAttribute("uv");
        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;
        const edgeAttr = geometry.getAttribute("edge");
        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;
        const wallAttr = geometry.getAttribute("wall");
        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;
        const indexAttr = geometry.getIndex();
        const indices = Array.from(indexAttr.array);
        // A cache containing the indices of the vertices added
        // when subdiving the faces of the geometry.
        const cache = new Map();
        /**
         * Returns the index of the vertex positioned in the middle of the given vertices.
         */
        function middleVertex(i, j) {
            // Build a unique `key` for the pair of indices `(i, j)`.
            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;
            const h = cache.get(key);
            if (h !== undefined) {
                // Nothing to do, a vertex in the middle of (i, j) was already created.
                return h;
            }
            // The position of the new vertex.
            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);
            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
            // The index of the new vertex.
            const index = position.length / 3;
            position.push(...tmpVectorC.toArray());
            // Cache the position of the new vertex.
            cache.set(key, index);
            // The uvs of the new vertex.
            if (uv !== undefined) {
                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);
                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);
                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);
                uv.push(tmpVectorC.x, tmpVectorC.y);
            }
            // The edge and wall attributes of the new vertex.
            // If a new vertex has been introduced between i and j, connect the elements
            // accordingly.
            if (edge !== undefined) {
                if (edge[i] === j) {
                    edge.push(j);
                    edge[i] = index;
                }
                else if (edge[j] === i) {
                    edge.push(i);
                    edge[j] = index;
                }
                else {
                    edge.push(-1);
                }
            }
            if (wall !== undefined) {
                if (wall[i] === j) {
                    wall.push(j);
                    wall[i] = index;
                }
                else if (wall[j] === i) {
                    wall.push(i);
                    wall[j] = index;
                }
                else {
                    wall.push(-1);
                }
            }
            return index;
        }
        const newIndices = [];
        while (indices.length >= 3) {
            const v0 = indices.shift();
            const v1 = indices.shift();
            const v2 = indices.shift();
            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);
            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);
            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);
            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);
            switch (edgeToSplit) {
                case 0: {
                    const v3 = middleVertex(v0, v1);
                    indices.push(v0, v3, v2, v3, v1, v2);
                    break;
                }
                case 1: {
                    const v3 = middleVertex(v1, v2);
                    indices.push(v0, v1, v3, v0, v3, v2);
                    break;
                }
                case 2: {
                    const v3 = middleVertex(v2, v0);
                    indices.push(v0, v1, v3, v3, v1, v2);
                    break;
                }
                case undefined: {
                    newIndices.push(v0, v1, v2);
                    break;
                }
                default:
                    throw new Error("failed to subdivide the given geometry");
            }
        }
        positionAttr.array =
            positionAttr.array instanceof Float32Array
                ? new Float32Array(position)
                : new Float64Array(position);
        positionAttr.count = position.length / positionAttr.itemSize;
        positionAttr.needsUpdate = true;
        geometry.setIndex(newIndices);
        if (uv !== undefined) {
            uvAttr.array = new Float32Array(uv);
            uvAttr.count = uv.length / uvAttr.itemSize;
            uvAttr.needsUpdate = true;
        }
        if (edge !== undefined) {
            edgeAttr.array = new Float32Array(edge);
            edgeAttr.count = edge.length / edgeAttr.itemSize;
            edgeAttr.needsUpdate = true;
        }
        return geometry;
    }
}
exports.SubdivisionModifier = SubdivisionModifier;


/***/ }),

/***/ "../harp-geoutils/index.ts":
/*!*********************************!*\
  !*** ../harp-geoutils/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Utility classes for working with geospatial data.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoBoxExtentLike */ "../harp-geoutils/lib/coordinates/GeoBoxExtentLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPointLike */ "../harp-geoutils/lib/coordinates/GeoPointLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygonLike */ "../harp-geoutils/lib/coordinates/GeoPolygonLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/GeoPolygon */ "../harp-geoutils/lib/coordinates/GeoPolygon.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/coordinates/LatLngLike */ "../harp-geoutils/lib/coordinates/LatLngLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/IdentityProjection */ "../harp-geoutils/lib/projection/IdentityProjection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/Projection */ "../harp-geoutils/lib/projection/Projection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/TransverseMercatorProjection */ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/projection/SphereProjection */ "../harp-geoutils/lib/projection/SphereProjection.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/QuadTree */ "../harp-geoutils/lib/tiling/QuadTree.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/SubdivisionScheme */ "../harp-geoutils/lib/tiling/SubdivisionScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/HereTilingScheme */ "../harp-geoutils/lib/tiling/HereTilingScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/WebMercatorTilingScheme */ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/MercatorTilingScheme */ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/tiling/PolarTilingScheme */ "../harp-geoutils/lib/tiling/PolarTilingScheme.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/Vector2Like */ "../harp-geoutils/lib/math/Vector2Like.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/Vector3Like */ "../harp-geoutils/lib/math/Vector3Like.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/TransformLike */ "../harp-geoutils/lib/math/TransformLike.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/math/OrientedBox3 */ "../harp-geoutils/lib/math/OrientedBox3.ts"), exports);


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoBox.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoBox.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoBox = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
/**
 * `GeoBox` is used to represent a bounding box in geo coordinates.
 */
class GeoBox {
    /**
     * Constructs a new `GeoBox` with the given geo coordinates.
     *
     * @param southWest - The south west position in geo coordinates.
     * @param northEast - The north east position in geo coordinates.
     */
    constructor(southWest, northEast) {
        this.southWest = southWest;
        this.northEast = northEast;
        if (this.west > this.east) {
            this.northEast.longitude += 360;
        }
    }
    /**
     * Returns a `GeoBox` with the given geo coordinates.
     *
     * @param southWest - The south west position in geo coordinates.
     * @param northEast - The north east position in geo coordinates.
     */
    static fromCoordinates(southWest, northEast) {
        return new GeoBox(southWest, northEast);
    }
    /**
     * Returns a `GeoBox` with the given center and dimensions.
     *
     * @param center - The center position of geo box.
     * @param extent - Box latitude and logitude span
     */
    static fromCenterAndExtents(center, extent) {
        return new GeoBox(new GeoCoordinates_1.GeoCoordinates(center.latitude - extent.latitudeSpan / 2, center.longitude - extent.longitudeSpan / 2), new GeoCoordinates_1.GeoCoordinates(center.latitude + extent.latitudeSpan / 2, center.longitude + extent.longitudeSpan / 2));
    }
    /**
     * Returns the minimum altitude or `undefined`.
     */
    get minAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.min(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the maximum altitude or `undefined`.
     */
    get maxAltitude() {
        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {
            return undefined;
        }
        return Math.max(this.southWest.altitude, this.northEast.altitude);
    }
    /**
     * Returns the south latitude in degrees of this `GeoBox`.
     */
    get south() {
        return this.southWest.latitude;
    }
    /**
     * Returns the north altitude in degrees of this `GeoBox`.
     */
    get north() {
        return this.northEast.latitude;
    }
    /**
     * Returns the west longitude in degrees of this `GeoBox`.
     */
    get west() {
        return this.southWest.longitude;
    }
    /**
     * Returns the east longitude in degrees of this `GeoBox`.
     */
    get east() {
        return this.northEast.longitude;
    }
    /**
     * Returns the center of this `GeoBox`.
     */
    get center() {
        const latitude = (this.south + this.north) * 0.5;
        const { west, east } = this;
        const { minAltitude, altitudeSpan } = this;
        let altitude;
        if (minAltitude !== undefined && altitudeSpan !== undefined) {
            altitude = minAltitude + altitudeSpan * 0.5;
        }
        if (west <= east) {
            return new GeoCoordinates_1.GeoCoordinates(latitude, (west + east) * 0.5, altitude);
        }
        let longitude = (360 + east + west) * 0.5;
        if (longitude > 360) {
            longitude -= 360;
        }
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns the latitude span in radians.
     */
    get latitudeSpanInRadians() {
        return THREE.MathUtils.degToRad(this.latitudeSpan);
    }
    /**
     * Returns the longitude span in radians.
     */
    get longitudeSpanInRadians() {
        return THREE.MathUtils.degToRad(this.longitudeSpan);
    }
    /**
     * Returns the latitude span in degrees.
     */
    get latitudeSpan() {
        return this.north - this.south;
    }
    get altitudeSpan() {
        if (this.maxAltitude === undefined || this.minAltitude === undefined) {
            return undefined;
        }
        return this.maxAltitude - this.minAltitude;
    }
    /**
     * Returns the longitude span in degrees.
     */
    get longitudeSpan() {
        let width = this.northEast.longitude - this.southWest.longitude;
        if (width < 0) {
            width += 360;
        }
        return width;
    }
    /**
     * Returns the latitude span in degrees.
     * @deprecated Use [[latitudeSpan]] instead.
     */
    get latitudeSpanInDegrees() {
        return this.latitudeSpan;
    }
    /**
     * Returns the longitude span in degrees.
     * @deprecated Use [[longitudeSpan]] instead.
     */
    get longitudeSpanInDegrees() {
        return this.longitudeSpan;
    }
    /**
     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.
     *
     * @param point - The geo coordinates.
     */
    contains(point) {
        if (point.altitude === undefined ||
            this.minAltitude === undefined ||
            this.maxAltitude === undefined) {
            return this.containsHelper(point);
        }
        const isFlat = this.minAltitude === this.maxAltitude;
        const isSameAltitude = this.minAltitude === point.altitude;
        const isWithinAltitudeRange = this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;
        // If box is flat, we should check the altitude and containment,
        // otherwise we should check also altitude difference where we consider
        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!
        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {
            return this.containsHelper(point);
        }
        return false;
    }
    /**
     * Clones this `GeoBox` instance.
     */
    clone() {
        return new GeoBox(this.southWest.clone(), this.northEast.clone());
    }
    /**
     * Update the bounding box by considering a given point.
     *
     * @param point - The point that may expand the bounding box.
     */
    growToContain(point) {
        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);
        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);
        this.southWest.altitude =
            this.southWest.altitude !== undefined && point.altitude !== undefined
                ? Math.min(this.southWest.altitude, point.altitude)
                : this.southWest.altitude !== undefined
                    ? this.southWest.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);
        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);
        this.northEast.altitude =
            this.northEast.altitude !== undefined && point.altitude !== undefined
                ? Math.max(this.northEast.altitude, point.altitude)
                : this.northEast.altitude !== undefined
                    ? this.northEast.altitude
                    : point.altitude !== undefined
                        ? point.altitude
                        : undefined;
    }
    containsHelper(point) {
        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {
            return false;
        }
        const { west, east } = this;
        let longitude = point.longitude;
        if (east > GeoCoordinates_1.MAX_LONGITUDE) {
            while (longitude < west) {
                longitude = longitude + 360;
            }
        }
        if (longitude > east) {
            while (longitude > west + 360) {
                longitude = longitude - 360;
            }
        }
        return longitude >= west && longitude < east;
    }
}
exports.GeoBox = GeoBox;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoBoxExtentLike.ts":
/*!************************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoBoxExtentLike.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGeoBoxExtentLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.
 */
function isGeoBoxExtentLike(obj) {
    return (obj &&
        typeof obj === "object" &&
        typeof obj.latitudeSpan === "number" &&
        typeof obj.longitudeSpan === "number");
}
exports.isGeoBoxExtentLike = isGeoBoxExtentLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordLike.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordLike.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGeoCoordLike = exports.geoCoordLikeToGeoPointLike = exports.geoCoordLikeToGeoCoordinatesLike = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ "../harp-geoutils/lib/coordinates/GeoPointLike.ts");
const LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ "../harp-geoutils/lib/coordinates/LatLngLike.ts");
function geoCoordLikeToGeoCoordinatesLike(coord) {
    return GeoCoordinatesLike_1.isGeoCoordinatesLike(coord)
        ? coord
        : LatLngLike_1.isLatLngLike(coord)
            ? { latitude: coord.lat, longitude: coord.lng }
            : { latitude: coord[1], longitude: coord[0] };
}
exports.geoCoordLikeToGeoCoordinatesLike = geoCoordLikeToGeoCoordinatesLike;
function geoCoordLikeToGeoPointLike(coord) {
    return GeoPointLike_1.isGeoPointLike(coord)
        ? coord
        : LatLngLike_1.isLatLngLike(coord)
            ? [coord.lng, coord.lat]
            : [coord.longitude, coord.latitude];
}
exports.geoCoordLikeToGeoPointLike = geoCoordLikeToGeoPointLike;
function isGeoCoordLike(object) {
    return GeoCoordinatesLike_1.isGeoCoordinatesLike(object) || LatLngLike_1.isLatLngLike(object) || !GeoPointLike_1.isGeoPointLike(object);
}
exports.isGeoCoordLike = isGeoCoordLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts":
/*!**********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinates.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoCoordinates = exports.MIN_LONGITUDE = exports.MAX_LONGITUDE = exports.MIN_LATITUDE = exports.MAX_LATITUDE = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const GeoCoordinatesLike_1 = __webpack_require__(/*! ./GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const GeoPointLike_1 = __webpack_require__(/*! ./GeoPointLike */ "../harp-geoutils/lib/coordinates/GeoPointLike.ts");
const LatLngLike_1 = __webpack_require__(/*! ./LatLngLike */ "../harp-geoutils/lib/coordinates/LatLngLike.ts");
exports.MAX_LATITUDE = 90;
exports.MIN_LATITUDE = -90;
exports.MAX_LONGITUDE = 180;
exports.MIN_LONGITUDE = -180;
const tmpV0 = new THREE.Vector3();
const tmpV1 = new THREE.Vector3();
/**
 * Compute the modulo.
 *
 * @internal
 */
function mod(dividend, divisor) {
    const modulo = dividend % divisor;
    const modulo_sign = modulo < 0;
    const divisor_sign = divisor < 0;
    return modulo_sign === divisor_sign ? modulo : modulo + divisor;
}
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
class GeoCoordinates {
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    constructor(latitude, longitude, altitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.altitude = altitude;
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    static fromDegrees(latitude, longitude, altitude) {
        return new GeoCoordinates(latitude, longitude, altitude);
    }
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in radians.
     * @param longitude - Longitude in radians.
     * @param altitude - Altitude in meters.
     */
    static fromRadians(latitude, longitude, altitude) {
        return new GeoCoordinates(THREE.MathUtils.radToDeg(latitude), THREE.MathUtils.radToDeg(longitude), altitude);
    }
    /**
     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.
     * ```typescript
     * const center = { lat: 53.3, lng: 13.4 };
     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
     * ```
     * @param latLng - A {@link LatLngLike} object literal.
     */
    static fromLatLng(latLng) {
        return new GeoCoordinates(latLng.lat, latLng.lng);
    }
    /**
     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.
     *
     * Example:
     * ```typescript
     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);
     *
     * let geoCoords: number[] = ...;
     *
     * if (isGeoPointLike(geoCoords)) {
     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);
     * }
     * ```
     * @param geoPoint - An [[Array]] of at least two elements following the order
     * longitude, latitude, altitude.
     */
    static fromGeoPoint(geoPoint) {
        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);
    }
    /**
     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.
     *
     * Example:
     * ```typescript
     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);
     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });
     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));
     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });
     * ```
     *
     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}
     * or {@link LatLngLike} object literal.
     */
    static fromObject(geoPoint) {
        if (GeoPointLike_1.isGeoPointLike(geoPoint)) {
            return GeoCoordinates.fromGeoPoint(geoPoint);
        }
        else if (GeoCoordinatesLike_1.isGeoCoordinatesLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.latitude, geoPoint.longitude, geoPoint.altitude);
        }
        else if (LatLngLike_1.isLatLngLike(geoPoint)) {
            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);
        }
        throw new Error("Invalid input coordinate format.");
    }
    /**
     * Returns a `GeoCoordinates` resulting from the linear interpolation of other two.
     * @param geoCoords0 - One of the `GeoCoordinates` used for interpolation.
     * @param geoCoords1 - The other `GeoCoordinates` used for interpolation.
     * @param factor - Interpolation factor. If `0` result will be equal to `geoCoords0`, if `1`
     * it'll be equal to `geoCoords1`.
     * @param wrap - If `true`, interpolation will be done across the antimeridian, otherwise it's
     * done across the Greenwich meridian. Supported only if longitude span is less than 360 deg.
     * @default false
     * @param normalize - If `true`, interpolation result will be normalized. @default false
     */
    static lerp(geoCoords0, geoCoords1, factor, wrap = false, normalize = false) {
        var _a, _b;
        if (wrap) {
            if (geoCoords0.lng < geoCoords1.lng) {
                const geoCoordsEnd = geoCoords0.clone();
                geoCoordsEnd.longitude += 360;
                return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);
            }
            else {
                const geoCoordsEnd = geoCoords1.clone();
                geoCoordsEnd.longitude += 360;
                return this.lerp(geoCoords0, geoCoordsEnd, factor);
            }
        }
        const v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, (_a = geoCoords0.altitude) !== null && _a !== void 0 ? _a : 0);
        const v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, (_b = geoCoords1.altitude) !== null && _b !== void 0 ? _b : 0);
        v0.lerp(v1, factor);
        const result = new GeoCoordinates(v0.x, v0.y, v0.z);
        return normalize ? result.normalized() : result;
    }
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians() {
        return THREE.MathUtils.degToRad(this.latitude);
    }
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians() {
        return THREE.MathUtils.degToRad(this.longitude);
    }
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees() {
        return this.latitude;
    } // compat api
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees() {
        return this.longitude;
    } // compat api
    /**
     * The latitude in the degrees.
     */
    get lat() {
        return this.latitude;
    }
    /**
     * The longitude in the degrees.
     */
    get lng() {
        return this.longitude;
    }
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid() {
        return !isNaN(this.latitude) && !isNaN(this.longitude);
    }
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized() {
        let { latitude, longitude } = this;
        if (isNaN(latitude) || isNaN(longitude)) {
            return this;
        }
        if (longitude < -180 || longitude > 180) {
            longitude = mod(longitude + 180, 360) - 180;
        }
        latitude = THREE.MathUtils.clamp(latitude, -90, 90);
        return new GeoCoordinates(latitude, longitude, this.altitude);
    }
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other - GeoCoordinatesLike to compare to.
     */
    equals(other) {
        return (this.latitude === other.latitude &&
            this.longitude === other.longitude &&
            this.altitude === other.altitude);
    }
    /**
     * Copy values from the other.
     *
     * @param other - GeoCoordinatesLike to copy all values from.
     */
    copy(other) {
        this.latitude = other.latitude;
        this.longitude = other.longitude;
        this.altitude = other.altitude;
        return this;
    }
    /**
     * Clones this `GeoCoordinates`.
     */
    clone() {
        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);
    }
    /**
     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.
     */
    toLatLng() {
        return { lat: this.latitude, lng: this.longitude };
    }
    /**
     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].
     */
    toGeoPoint() {
        return this.altitude !== undefined
            ? [this.longitude, this.latitude, this.altitude]
            : [this.longitude, this.latitude];
    }
    /**
     * Returns the minimum longitude span from this `GeoCoordinates` to another.
     *
     * @param other - The other GeoCoordinatesLike defining the longitude span.
     */
    minLongitudeSpanTo(other) {
        const minLongitude = Math.min(this.longitude, other.longitude);
        const maxLongitude = Math.max(this.longitude, other.longitude);
        return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);
    }
}
exports.GeoCoordinates = GeoCoordinates;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGeoCoordinatesLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.
 */
function isGeoCoordinatesLike(object) {
    return (object &&
        typeof object.latitude === "number" &&
        typeof object.longitude === "number" &&
        (typeof object.altitude === "number" || typeof object.altitude === "undefined"));
}
exports.isGeoCoordinatesLike = isGeoCoordinatesLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoPointLike.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoPointLike.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGeoPointLike = void 0;
/**
 * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.
 */
function isGeoPointLike(geoPoint) {
    if (Array.isArray(geoPoint)) {
        const [longitude, latitude, altitude] = geoPoint;
        return (typeof longitude === "number" &&
            typeof latitude === "number" &&
            (altitude === undefined || typeof altitude === "number"));
    }
    return false;
}
exports.isGeoPointLike = isGeoPointLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoPolygon.ts":
/*!******************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoPolygon.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoPolygon = exports.isAntimeridianCrossing = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const three_1 = __webpack_require__(/*! three */ "three");
const GeoBox_1 = __webpack_require__(/*! ./GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ./GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ "../harp-geoutils/lib/coordinates/GeoCoordLike.ts");
function computeLonSpanAcrossGreewich(lonA, lonB) {
    return Math.max(lonA, lonB) - Math.min(lonA, lonB);
}
function isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {
    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
function isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {
    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);
}
function isAntimeridianCrossing(lonStart, lonEnd) {
    return (Math.sign(lonStart) === -Math.sign(lonEnd) &&
        computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180);
}
exports.isAntimeridianCrossing = isAntimeridianCrossing;
/**
 * A GeoPolygon in 2D Space (altitudes will be ignored).
 * Coordinates are expected in counter-clockwise order, for convex polygons a sorting is
 * available.
 * Clockwise ordered or selfintersecting Polygons might lead to no or unexpected results.
 *
 * @beta @internal
 */
class GeoPolygon {
    /**
     * Creates a GeoPolygon instance
     *
     * @param coordinates An array of GeoCoordinates acting as the Vertices of the Polygon.
     * @param needsSort  If `true` it will sort the coordinates in ccw order, this will only
     *  result correctly for convex polygons @default false
     * @param needsWrapping  If `true` it will wrap around coordinates crossing the antemeridian.
     * Only supported for polygons with sides that don't span more than 180 degrees longitude.
     * @default false
     */
    constructor(coordinates, needsSort = false, needsWrapping = false) {
        this.m_coordinates = coordinates.map(coord => {
            return GeoCoordLike_1.geoCoordLikeToGeoCoordinatesLike(coord);
        });
        if (needsSort) {
            this.sortCCW();
        }
        if (needsWrapping) {
            this.wrapCoordinatesAround();
        }
    }
    get coordinates() {
        return this.m_coordinates;
    }
    /**
     * Gets a BoundingBox for the Polygon
     *
     * Might have unexpected results for twisted or concave Polygons
     */
    getGeoBoundingBox() {
        const centroid = this.getCentroid();
        if (centroid === undefined) {
            //return a BBox without extend if the centroid could not be generated
            return GeoBox_1.GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);
        }
        const { east, west } = this.getEastAndWest(centroid);
        const { north, south } = this.getNorthAndSouth();
        return GeoBox_1.GeoBox.fromCoordinates(new GeoCoordinates_1.GeoCoordinates(south, west), new GeoCoordinates_1.GeoCoordinates(north, east));
    }
    /**
     * Gets the Centroid for the Polygon
     *
     * Might be undefined or with unexpected results for twisted or concave Polygons.
     */
    getCentroid() {
        const area = this.getArea();
        if (area === 0) {
            return undefined;
        }
        let latitude = 0;
        let longitude = 0;
        let f;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            f =
                coordinate.latitude * previousCoordinate.longitude -
                    previousCoordinate.latitude * coordinate.longitude;
            latitude += (coordinate.latitude + previousCoordinate.latitude) * f;
            longitude += (coordinate.longitude + previousCoordinate.longitude) * f;
            previousIndex = index;
        });
        f = area * 6;
        return new GeoCoordinates_1.GeoCoordinates(latitude / f, area < 0 /* antimeridian crossing */ ? -180 + longitude / f : longitude / f);
    }
    sortCCW() {
        const polyCenter = this.getPolyAverageCenter();
        if (!polyCenter) {
            return;
        }
        //sorts by angle from x-axis
        this.m_coordinates.sort((a, b) => {
            const veca = new three_1.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();
            const vecb = new three_1.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();
            return vecb.angle() - veca.angle();
        });
    }
    wrapCoordinatesAround() {
        const firstAntimerCrossIndex = this.m_coordinates.findIndex((val, index) => {
            const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;
            const prevLon = this.m_coordinates[prevLonIndex].longitude;
            const lon = val.longitude;
            return isLeftToRightAntimeridianCrossing(prevLon, lon);
        });
        if (firstAntimerCrossIndex < 0) {
            return;
        }
        let wrapAround = true;
        for (let i = 0; i < this.m_coordinates.length; i++) {
            const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;
            const currentLon = this.m_coordinates[index].longitude;
            const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;
            if (wrapAround) {
                this.m_coordinates[index].longitude += 360;
            }
            if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {
                wrapAround = false;
            }
            else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {
                wrapAround = true;
            }
        }
    }
    getPolyAverageCenter() {
        const polySum = this.m_coordinates.reduce((prev, curr) => {
            return new GeoCoordinates_1.GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);
        });
        //create an average center point
        return new GeoCoordinates_1.GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);
    }
    getArea() {
        let area = 0;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            area += coordinate.latitude * previousCoordinate.longitude;
            area -= coordinate.longitude * previousCoordinate.latitude;
            previousIndex = index;
        });
        return (area /= 2);
    }
    getEastAndWest(center) {
        let west = center.longitude;
        let east = center.longitude;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            previousIndex = index;
            const veca = new three_1.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();
            const vecb = new three_1.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();
            let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;
            // overwrite in case of angle over axis
            if (vecb.y >= 0 && veca.y < 0) {
                ccw = true;
            }
            const long = coordinate.longitude;
            if (long < center.longitude) {
                if (ccw) {
                    west = Math.min(west, long);
                }
                else {
                    east = Math.min(east, long);
                }
            }
            else {
                if (ccw) {
                    east = Math.max(east, long);
                }
                else {
                    west = Math.max(west, long);
                }
            }
        });
        return { east, west };
    }
    getNorthAndSouth() {
        let north = GeoCoordinates_1.MIN_LATITUDE;
        let south = GeoCoordinates_1.MAX_LATITUDE;
        this.m_coordinates.forEach((coordinate, index) => {
            north = Math.max(north, coordinate.latitude);
            south = Math.min(south, coordinate.latitude);
        });
        return { north, south };
    }
}
exports.GeoPolygon = GeoPolygon;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/GeoPolygonLike.ts":
/*!**********************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/GeoPolygonLike.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGeoPolygonLike = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const GeoCoordLike_1 = __webpack_require__(/*! ./GeoCoordLike */ "../harp-geoutils/lib/coordinates/GeoCoordLike.ts");
/**
 * Type guard to assert that `object` conforms to {@link GeoPolygonLike} data interface.
 *
 * @beta, @internal
 */
function isGeoPolygonLike(object) {
    if (!object || (!Array.isArray(object.coordinates) && object.coordinates.length > 2)) {
        return false;
    }
    let isValid = true;
    //TODO: this might take a while, not sure this should be that extensive
    object.coordinates.forEach((coord) => {
        if (!GeoCoordLike_1.isGeoCoordLike(object)) {
            isValid = false;
        }
    });
    return isValid;
}
exports.isGeoPolygonLike = isGeoPolygonLike;


/***/ }),

/***/ "../harp-geoutils/lib/coordinates/LatLngLike.ts":
/*!******************************************************!*\
  !*** ../harp-geoutils/lib/coordinates/LatLngLike.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isLatLngLike = void 0;
/**
 * Type guard to assert that `object` conforms to {@link LatLngLike} interface.
 */
function isLatLngLike(object) {
    return object && typeof object.lat === "number" && typeof object.lng === "number";
}
exports.isLatLngLike = isLatLngLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Box3Like.ts":
/*!*********************************************!*\
  !*** ../harp-geoutils/lib/math/Box3Like.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBox3Like = void 0;
/**
 * Returns true if the given object implements the {@link Box3Like} interface.
 *
 * @param object - A valid object.
 */
function isBox3Like(object) {
    const box3 = object;
    return box3.min !== undefined && box3.max !== undefined;
}
exports.isBox3Like = isBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/MathUtils.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/math/MathUtils.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathUtils = void 0;
const THREE = __webpack_require__(/*! three */ "three");
var MathUtils;
(function (MathUtils) {
    /**
     * Creates a new empty bounding box.
     *
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.
     */
    function newEmptyBox3() {
        return {
            min: { x: Infinity, y: Infinity, z: Infinity },
            max: { x: -Infinity, y: -Infinity, z: -Infinity }
        };
    }
    MathUtils.newEmptyBox3 = newEmptyBox3;
    /**
     * Set the components of the given [Vector3Like] instance.
     *
     * @param x - The x component.
     * @param y - The y component.
     * @param z - The z component.
     * @param v - The [Vector3Like]
     */
    function newVector3(x, y, z, v) {
        if (v === undefined) {
            return { x, y, z };
        }
        v.x = x;
        v.y = y;
        v.z = z;
        return v;
    }
    MathUtils.newVector3 = newVector3;
    /**
     * Copies the vector across.
     *
     * @param from - The vector to copy from.
     * @param to - The resulting [Vector3Like] instance, with the contents copied from from
     */
    function copyVector3(from, to) {
        to.x = from.x;
        to.y = from.y;
        to.z = from.z;
        return to;
    }
    MathUtils.copyVector3 = copyVector3;
    /**
     * Converts an angle measured in degrees to an equivalent value in radians.
     *
     * @param degrees - Value in degrees.
     * @returns Value in radians.
     * @deprecated use THREE.MathUtils.degToRad instead
     */
    MathUtils.degToRad = THREE.MathUtils.degToRad;
    /**
     * Converts an angle measured in radians to an equivalent value in degrees.
     *
     * @param degrees - Value in radians.
     * @returns Value in degrees.
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg
     *                | THREE.MathUtils.radToDeg}.
     */
    MathUtils.radToDeg = THREE.MathUtils.radToDeg;
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     * @returns Clamped value.
     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp
     *                | THREE.MathUtils.clamp}.
     */
    MathUtils.clamp = THREE.MathUtils.clamp;
    /**
     * Normalize angle in degrees to range `[0, 360)`.
     *
     * @param a - Angle in degrees.
     * @returns Angle in degrees in range `[0, 360)`.
     */
    function normalizeAngleDeg(a) {
        a = a % 360;
        if (a < 0) {
            a = a + 360;
        }
        return a;
    }
    MathUtils.normalizeAngleDeg = normalizeAngleDeg;
    /**
     * Normalize latitude angle in degrees to range `[-180, 180]`.
     *
     * @param a - Latitude angle in degrees.
     * @returns Latitude angle in degrees in range `[-180, 180]`.
     */
    function normalizeLongitudeDeg(a) {
        a = normalizeAngleDeg(a);
        if (a > 180) {
            a = a - 360;
        }
        return a;
    }
    MathUtils.normalizeLongitudeDeg = normalizeLongitudeDeg;
    /**
     * Return the minimal delta between angles `a` and `b` given in degrees.
     *
     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed
     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.
     *
     * Useful when interpolating between `b` and `a` in angle space.
     *
     * @param a - Start angle in degrees.
     * @param b - End angle in degrees.
     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.
     */
    function angleDistanceDeg(a, b) {
        a = normalizeAngleDeg(a);
        b = normalizeAngleDeg(b);
        const d = a - b;
        if (d > 180) {
            return d - 360;
        }
        else if (d <= -180) {
            return d + 360;
        }
        else {
            return d;
        }
    }
    MathUtils.angleDistanceDeg = angleDistanceDeg;
    /**
     * Interpolate linearly between two angles given in degrees.
     *
     * @param p0 - Angle from in degrees
     * @param p1 - Angle to in degrees
     * @param t - Interpolation factor (alpha), in range `0-1`.
     */
    function interpolateAnglesDeg(p0, p1, t) {
        // hand crafted version,
        // see stack for maybe better versions:
        //    https://stackoverflow.com/questions/2708476/rotation-interpolation
        const d = angleDistanceDeg(p1, p0);
        const r = (p0 + d * t) % 360;
        return r;
    }
    MathUtils.interpolateAnglesDeg = interpolateAnglesDeg;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-geoutils/lib/math/OrientedBox3.ts":
/*!*************************************************!*\
  !*** ../harp-geoutils/lib/math/OrientedBox3.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrientedBox3 = void 0;
const three_1 = __webpack_require__(/*! three */ "three");
function intersectsSlab(rayDir, p, axis, extent, t) {
    const epsilon = 1e-20;
    const e = axis.dot(p);
    const f = axis.dot(rayDir);
    if (Math.abs(f) < epsilon) {
        // ray parallel to near/far slab lines.
        return Math.abs(e) <= extent;
    }
    // ray intersects near/far slab lines.
    const finv = 1 / f;
    const t1 = (e + extent) * finv;
    const t2 = (e - extent) * finv;
    if (t1 > t2) {
        // t1 is far intersect, t2 is near.
        if (t2 > t.min) {
            t.min = t2;
        }
        if (t1 < t.max) {
            t.max = t1;
        }
    }
    else {
        // t1 is near intersect, t2 is far.
        if (t1 > t.min) {
            t.min = t1;
        }
        if (t2 < t.max) {
            t.max = t2;
        }
    }
    return t.min <= t.max && t.max >= 0;
}
const tmpVec = new three_1.Vector3();
const tmpT = { min: -Infinity, max: Infinity };
class OrientedBox3 {
    /**
     * Creates a new `OrientedBox3`.
     *
     * @hideconstructor
     */
    constructor(position, rotationMatrix, extents) {
        /**
         * The position of the center of this `OrientedBox3`.
         */
        this.position = new three_1.Vector3();
        /**
         * The x-axis of this `OrientedBox3`.
         */
        this.xAxis = new three_1.Vector3(1, 0, 0);
        /**
         * The y-axis of this `OrientedBox3`.
         */
        this.yAxis = new three_1.Vector3(0, 1, 0);
        /**
         * The z-axis of this `OrientedBox3`.
         */
        this.zAxis = new three_1.Vector3(0, 0, 1);
        /**
         * The extents of this `OrientedBox3`.
         */
        this.extents = new three_1.Vector3();
        if (position !== undefined) {
            this.position.copy(position);
        }
        if (rotationMatrix !== undefined) {
            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);
        }
        if (extents !== undefined) {
            this.extents.copy(extents);
        }
    }
    /**
     * Create a copy of this [[OrientedBoundingBox]].
     */
    clone() {
        const newBox = new OrientedBox3();
        newBox.copy(this);
        return newBox;
    }
    /**
     * Copies the values of `other` to this {@link OrientedBox3}.
     * @param other - The other {@link OrientedBox3} to copy.
     */
    copy(other) {
        this.position.copy(other.position);
        this.xAxis.copy(other.xAxis);
        this.yAxis.copy(other.yAxis);
        this.zAxis.copy(other.zAxis);
        this.extents.copy(other.extents);
    }
    /**
     * Gets the center position of this {@link OrientedBox3}.
     *
     * @param center - The returned center position.
     */
    getCenter(center = new three_1.Vector3()) {
        return center.copy(this.position);
    }
    /**
     * Gets the size of this {@link OrientedBox3}.
     *
     * @param size - The returned size.
     */
    getSize(size = new three_1.Vector3()) {
        return size.copy(this.extents).multiplyScalar(2);
    }
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix - The output orientation matrix.
     */
    getRotationMatrix(matrix = new three_1.Matrix4()) {
        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);
    }
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes - Frustum or array of planes.
     */
    intersects(frustumOrPlanes) {
        const planes = Array.isArray(frustumOrPlanes)
            ? frustumOrPlanes
            : frustumOrPlanes.planes;
        for (const plane of planes) {
            const r = Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +
                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +
                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);
            const d = plane.distanceToPoint(this.position);
            if (d + r < 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks intersection with the given ray.
     *
     * @param ray - The ray to test.
     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.
     */
    intersectsRay(ray) {
        // Slabs intersection algorithm.
        tmpT.min = -Infinity;
        tmpT.max = Infinity;
        tmpVec.copy(this.position).sub(ray.origin);
        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {
            return undefined;
        }
        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {
            return undefined;
        }
        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {
            return undefined;
        }
        return tmpT.min > 0 ? tmpT.min : tmpT.max;
    }
    /**
     * Returns true if this {@link OrientedBox3} contains the given point.
     *
     * @param point - A valid point.
     */
    contains(point) {
        const dx = point.x - this.position.x;
        const dy = point.y - this.position.y;
        const dz = point.z - this.position.z;
        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);
        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);
        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);
        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPoint(point) {
        return Math.sqrt(this.distanceToPointSquared(point));
    }
    /**
     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPointSquared(point) {
        const d = new three_1.Vector3();
        d.subVectors(point, this.position);
        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];
        let result = 0;
        for (let i = 0; i < 3; ++i) {
            const length = lengths[i];
            const extent = this.extents.getComponent(i);
            if (length < -extent) {
                const dd = extent + length;
                result += dd * dd;
            }
            else if (length > extent) {
                const dd = length - extent;
                result += dd * dd;
            }
        }
        return result;
    }
}
exports.OrientedBox3 = OrientedBox3;


/***/ }),

/***/ "../harp-geoutils/lib/math/OrientedBox3Like.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/math/OrientedBox3Like.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isOrientedBox3Like = void 0;
/**
 * Returns true if the given object implements the interface {@link OrientedBox3Like}.
 *
 * @param object - The object.
 */
function isOrientedBox3Like(object) {
    const obb = object;
    return (obb.position !== undefined &&
        obb.xAxis !== undefined &&
        obb.yAxis !== undefined &&
        obb.zAxis !== undefined &&
        obb.extents !== undefined);
}
exports.isOrientedBox3Like = isOrientedBox3Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/TransformLike.ts":
/*!**************************************************!*\
  !*** ../harp-geoutils/lib/math/TransformLike.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTransformLike = void 0;
/**
 * Returns true if the given object implements the interface {@link TransformLike}.
 *
 * @param object - The object.
 */
function isTransformLike(object) {
    const transform = object;
    return (transform.position !== undefined &&
        transform.xAxis !== undefined &&
        transform.yAxis !== undefined &&
        transform.zAxis !== undefined);
}
exports.isTransformLike = isTransformLike;


/***/ }),

/***/ "../harp-geoutils/lib/math/Vector2Like.ts":
/*!************************************************!*\
  !*** ../harp-geoutils/lib/math/Vector2Like.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVector2Like = void 0;
function isVector2Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number";
}
exports.isVector2Like = isVector2Like;


/***/ }),

/***/ "../harp-geoutils/lib/math/Vector3Like.ts":
/*!************************************************!*\
  !*** ../harp-geoutils/lib/math/Vector3Like.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVector3Like = void 0;
function isVector3Like(v) {
    return v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
exports.isVector3Like = isVector3Like;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EarthConstants.ts":
/*!*********************************************************!*\
  !*** ../harp-geoutils/lib/projection/EarthConstants.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EarthConstants = void 0;
class EarthConstants {
}
exports.EarthConstants = EarthConstants;
/** The equatorial circumference in meters. */
EarthConstants.EQUATORIAL_CIRCUMFERENCE = 40075016.6855784861531768177614;
/** The equatorial radius in meters. */
EarthConstants.EQUATORIAL_RADIUS = 6378137.0;
/** The lowest point on earth (Dead Sea) in meters. */
EarthConstants.MIN_ELEVATION = -433.0;
/** The highest point on earth (Mt. Everest) in meters. */
EarthConstants.MAX_ELEVATION = 8848.0;
/** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */
EarthConstants.MAX_BUILDING_HEIGHT = 828;


/***/ }),

/***/ "../harp-geoutils/lib/projection/EquirectangularProjection.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/projection/EquirectangularProjection.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equirectangularProjection = exports.normalizedEquirectangularProjection = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
class EquirectangularProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = 0.0;
        result.min.y = 0.0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale / 2;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        var _a;
        if (result === undefined) {
            result = { x: 0, y: 0, z: 0 };
        }
        result.x =
            (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.y =
            (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *
                EquirectangularProjection.geoToWorldScale *
                this.unitScale;
        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians((worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -
            Math.PI * 0.5, (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        const worldCenter = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0));
        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;
        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;
        if (!result) {
            result = new THREE.Box3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;
            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;
            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;
            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = sizeX * 0.5 * this.unitScale;
            result.extents.y = sizeY * 0.5 * this.unitScale;
            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan !== null && altitudeSpan !== void 0 ? altitudeSpan : 0) * 0.5);
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
EquirectangularProjection.geoToWorldScale = 1.0 / (2.0 * Math.PI);
EquirectangularProjection.worldToGeoScale = (2.0 * Math.PI) / 1.0;
/**
 * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice
 * versa.
 */
exports.normalizedEquirectangularProjection = new EquirectangularProjection(1);
/**
 * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice
 * versa.
 */
exports.equirectangularProjection = new EquirectangularProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/IdentityProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/IdentityProjection.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.identityProjection = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
class IdentityProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = -Math.PI;
        result.min.y = -Math.PI * 0.5;
        result.min.z = minAltitude;
        result.max.x = Math.PI;
        result.max.y = Math.PI * 0.5;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        var _a;
        if (!result) {
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);
        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);
        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        const min = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude));
        const max = this.projectPoint(new GeoCoordinates_1.GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude));
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = min.x;
            result.min.y = min.y;
            result.min.z = min.z;
            result.max.x = max.x;
            result.max.y = max.y;
            result.max.z = max.z;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (min.x + max.x) * 0.5;
            result.position.y = (min.y + max.y) * 0.5;
            result.position.z = (min.z + max.z) * 0.5;
            result.extents.x = (max.x - min.x) * 0.5;
            result.extents.y = (max.y - min.y) * 0.5;
            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        return GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
}
/**
 * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.
 */
exports.identityProjection = new IdentityProjection(1);


/***/ }),

/***/ "../harp-geoutils/lib/projection/MercatorProjection.ts":
/*!*************************************************************!*\
  !*** ../harp-geoutils/lib/projection/MercatorProjection.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webMercatorProjection = exports.mercatorProjection = exports.MercatorConstants = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
class MercatorProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
    }
    static clamp(val, min, max) {
        return Math.min(Math.max(min, val), max);
    }
    static latitudeClamp(latitude) {
        return MercatorProjection.clamp(latitude, -MercatorConstants.MAXIMUM_LATITUDE, MercatorConstants.MAXIMUM_LATITUDE);
    }
    static latitudeProject(latitude) {
        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;
    }
    static latitudeClampProject(latitude) {
        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));
    }
    static unprojectLatitude(y) {
        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPointLike, result) {
        var _a;
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        if (!result) {
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        result.y =
            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *
                this.unitScale;
        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0), (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI, worldPoint.z);
        return geoPoint;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    projectBox(geoBox, result) {
        var _a;
        const worldCenter = this.projectPoint(geoBox.center);
        const worldNorth = (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldSouth = (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +
            0.5) *
            this.unitScale;
        const worldYCenter = (worldNorth + worldSouth) * 0.5;
        worldCenter.y = worldYCenter;
        const latitudeSpan = worldNorth - worldSouth;
        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;
        if (!result) {
            result = new THREE.Box3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = worldCenter.x - longitudeSpan * 0.5;
            result.min.y = worldCenter.y - latitudeSpan * 0.5;
            result.max.x = worldCenter.x + longitudeSpan * 0.5;
            result.max.y = worldCenter.y + latitudeSpan * 0.5;
            const altitudeSpan = geoBox.altitudeSpan;
            if (altitudeSpan !== undefined) {
                result.min.z = worldCenter.z - altitudeSpan * 0.5;
                result.max.z = worldCenter.z + altitudeSpan * 0.5;
            }
            else {
                result.min.z = 0;
                result.max.z = 0;
            }
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = worldCenter.x;
            result.position.y = worldCenter.y;
            result.position.z = worldCenter.z;
            result.extents.x = longitudeSpan * 0.5;
            result.extents.y = latitudeSpan * 0.5;
            result.extents.z = Math.max(Number.EPSILON, ((_a = geoBox.altitudeSpan) !== null && _a !== void 0 ? _a : 0) * 0.5);
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = 1;
        }
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        // this implementation of [[reprojectPoint]] supports both
        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only
        // difference betweeen these two variants of WEB Mercator
        // is in the orientation of the Y axis, so we just flip Y coordinates
        // when reprojecting between them.
        if (sourceProjection !== this &&
            (sourceProjection === exports.webMercatorProjection || sourceProjection === exports.mercatorProjection)) {
            if (result === undefined) {
                result = {};
            }
            result.x = worldPos.x;
            result.y = this.unitScale - worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
}
class WebMercatorProjection extends MercatorProjection {
    /** @override */
    projectPoint(geoPointLike, result) {
        var _a;
        let geoPoint;
        if (geoPointLike instanceof GeoCoordinates_1.GeoCoordinates) {
            geoPoint = geoPointLike;
        }
        else {
            geoPoint = new GeoCoordinates_1.GeoCoordinates(geoPointLike.latitude, geoPointLike.longitude, geoPointLike.altitude);
        }
        /*
         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]
         * might be a concrete class which is not available at runtime.
         * Consider the following example:
         *
         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);
         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);
         *
         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!
         */
        if (!result) {
            result = { x: 0, y: 0, z: 0 };
        }
        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;
        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));
        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;
        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const x = worldPoint.x / this.unitScale - 0.5;
        const y = 0.5 - worldPoint.y / this.unitScale;
        const longitude = 360 * x;
        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;
        return new GeoCoordinates_1.GeoCoordinates(latitude, longitude, worldPoint.z);
    }
    /** @override */
    projectBox(geoBox, result) {
        const r = super.projectBox(geoBox, result);
        if (Box3Like_1.isBox3Like(r)) {
            // Invert the y axis for web mercator, this means that max => min & min => max
            const maxY = r.max.y;
            r.max.y = this.unitScale - r.min.y;
            r.min.y = this.unitScale - maxY;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(r)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, r.xAxis);
            MathUtils_1.MathUtils.newVector3(0, -1, 0, r.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, -1, r.zAxis);
            r.position.y = this.unitScale - r.position.y;
        }
        return r;
    }
    /** @override */
    unprojectBox(worldBox) {
        const minGeo = this.unprojectPoint(worldBox.min);
        const maxGeo = this.unprojectPoint(worldBox.max);
        const geoBox = new GeoBox_1.GeoBox(new GeoCoordinates_1.GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude), new GeoCoordinates_1.GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude));
        return geoBox;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
    /** @override */
    localTangentSpace(point, result) {
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
        }
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, -1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, -1, result.zAxis);
        return result;
    }
}
class MercatorConstants {
}
exports.MercatorConstants = MercatorConstants;
// Math.atan(Math.sinh(Math.PI))
MercatorConstants.MAXIMUM_LATITUDE = 1.4844222297453323;
/**
 * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.
 */
exports.mercatorProjection = new MercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);
/**
 * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates
 * and vice versa.
 */
exports.webMercatorProjection = new WebMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/projection/Projection.ts":
/*!*****************************************************!*\
  !*** ../harp-geoutils/lib/projection/Projection.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Projection = exports.ProjectionType = void 0;
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
/**
 * The type of projection.
 */
var ProjectionType;
(function (ProjectionType) {
    /**
     * A type of [Projection] with zero curvature.
     */
    ProjectionType[ProjectionType["Planar"] = 0] = "Planar";
    /**
     * A spherical [Projection].
     */
    ProjectionType[ProjectionType["Spherical"] = 1] = "Spherical";
})(ProjectionType = exports.ProjectionType || (exports.ProjectionType = {}));
/**
 * `Projection` is used to convert positions from geo coordinates to world coordinates and vice
 * versa.
 */
class Projection {
    /**
     * Constructs the Projection
     *
     * @param unitScale - How to transform the projected coordinates to world units.
     */
    constructor(unitScale) {
        this.unitScale = unitScale;
        //Prevent empty constructor error.
    }
    /**
     * Gets the {@link TransformLike} of the local tangent space at the given point.
     *
     * @param point - The geo / world coordinates.
     * @param result - The {@link TransformLike}.
     */
    localTangentSpace(point, result) {
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
        }
        MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
        MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
        return result;
    }
    /**
     * Reproject a world position from the given source {@link Projection}.
     * Implementations should be aware of worldPos and result may be one object
     *
     * @param sourceProjection - The source projection.
     * @param worldPos - A valid position in the world space defined by the source projection.
     * @param result - The resulting position reprojected using this {@link Projection}.
     * @hidden
     */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === this) {
            if (result === undefined) {
                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };
            }
            result.x = worldPos.x;
            result.y = worldPos.y;
            result.z = worldPos.z;
            return result;
        }
        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);
    }
}
exports.Projection = Projection;


/***/ }),

/***/ "../harp-geoutils/lib/projection/SphereProjection.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/projection/SphereProjection.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sphereProjection = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const GeoCoordinatesLike_1 = __webpack_require__(/*! ../coordinates/GeoCoordinatesLike */ "../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const MercatorProjection_1 = __webpack_require__(/*! ./MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
/**
 * Transforms the given vector using the provided basis.
 */
function apply(xAxis, yAxis, zAxis, v) {
    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;
    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;
    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
/**
 * Returns the quadrants for the given longitude. The quadrant is defined as:
 *  - quadrant(+Math.PI * -1.0) = 0
 *  - quadrant(+Math.PI * -0.5) = 1
 *  - quadrant(+Math.PI *  0.0) = 2
 *  - quadrant(+Math.PI *  0.5) = 3
 *  - quadrant(+Math.PI *  1.0) = 4
 *
 * @param longitude - The longitude in radians.
 */
function getLongitudeQuadrant(longitude) {
    const oneOverPI = 1 / Math.PI;
    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));
    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);
}
function lengthOfVector3(worldPoint) {
    const d = Math.sqrt(worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z);
    return d;
}
/**
 * Creates a Box3 enclosing the geobox.
 *
 * @param geoBox - Ghe given geobox
 * @param worldBox - The resulting axis aligned bounding box.
 */
function makeBox3(geoBox, worldBox, unitScale) {
    var _a;
    const halfEquatorialRadius = (unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;
    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);
    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);
    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);
    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);
    let xMin = Math.cos(minLongitude);
    let xMax = xMin;
    let yMin = Math.sin(minLongitude);
    let yMax = yMin;
    for (let quadrantIndex = minLongitudeQuadrant + 1; quadrantIndex <= maxLongitudeQuadrant; quadrantIndex++) {
        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);
        xMin = Math.min(x, xMin);
        xMax = Math.max(x, xMax);
        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);
        yMin = Math.min(y, yMin);
        yMax = Math.max(y, yMax);
    }
    const cosMaxLongitude = Math.cos(maxLongitude);
    xMin = Math.min(cosMaxLongitude, xMin);
    xMax = Math.max(cosMaxLongitude, xMax);
    const sinMaxLongitude = Math.sin(maxLongitude);
    yMin = Math.min(sinMaxLongitude, yMin);
    yMax = Math.max(sinMaxLongitude, yMax);
    const xCenter = (xMax + xMin) * halfEquatorialRadius;
    const xExtent = (xMax - xMin) * halfEquatorialRadius;
    const yCenter = (yMax + yMin) * halfEquatorialRadius;
    const yExtent = (yMax - yMin) * halfEquatorialRadius;
    // Calculate Z boundaries.
    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);
    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);
    const zMax = Math.sin(maxLatutide);
    const zMin = Math.sin(minLatitude);
    const zCenter = (zMax + zMin) * halfEquatorialRadius;
    const zExtent = (zMax - zMin) * halfEquatorialRadius;
    worldBox.min.x = xCenter - xExtent;
    worldBox.min.y = yCenter - yExtent;
    worldBox.min.z = zCenter - zExtent;
    worldBox.max.x = xCenter + xExtent;
    worldBox.max.y = yCenter + yExtent;
    worldBox.max.z = zCenter + zExtent;
    return worldBox;
}
/**
 * Computes the spherical projection of the given geo coordinates.
 *
 * @param geoPoint - The geo coordinates.
 * @param worldpoint - The resulting world coordinates.
 */
function project(geoPoint, worldpoint, unitScale) {
    var _a;
    const radius = unitScale + ((_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0);
    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);
    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);
    const cosLatitude = Math.cos(latitude);
    worldpoint.x = radius * cosLatitude * Math.cos(longitude);
    worldpoint.y = radius * cosLatitude * Math.sin(longitude);
    worldpoint.z = radius * Math.sin(latitude);
    return worldpoint;
}
class SphereProjection extends Projection_1.Projection {
    constructor() {
        super(...arguments);
        /** @override */
        this.type = Projection_1.ProjectionType.Spherical;
    }
    /** @override */
    worldExtent(_minElevation, maxElevation, result = new THREE.Box3()) {
        const radius = this.unitScale + maxElevation;
        result.min.x = -radius;
        result.min.y = -radius;
        result.min.z = -radius;
        result.max.x = radius;
        result.max.y = radius;
        result.max.z = radius;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result = MathUtils_1.MathUtils.newVector3(0, 0, 0)) {
        return project(geoPoint, result, this.unitScale);
    }
    /** @override */
    unprojectPoint(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y;
        const parallelRadius = Math.sqrt(parallelRadiusSq);
        const v = point.z / parallelRadius;
        if (isNaN(v)) {
            return GeoCoordinates_1.GeoCoordinates.fromRadians(0, 0, -this.unitScale);
        }
        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);
        return GeoCoordinates_1.GeoCoordinates.fromRadians(Math.atan(v), Math.atan2(point.y, point.x), radius - this.unitScale);
    }
    /** @override */
    unprojectAltitude(point) {
        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;
        return Math.sqrt(parallelRadiusSq) - EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
    }
    /** @override */
    projectBox(geoBox, result = new THREE.Box3()) {
        var _a, _b;
        if (Box3Like_1.isBox3Like(result)) {
            return makeBox3(geoBox, result, this.unitScale);
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            if (geoBox.longitudeSpan >= 90) {
                const bounds = makeBox3(geoBox, new THREE.Box3(), this.unitScale);
                MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
                MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
                MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;
                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;
                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;
                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;
                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;
                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;
                return result;
            }
            const { south, west, north, east, center: mid } = geoBox;
            const midX = mid.longitude;
            const midY = mid.latitude;
            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));
            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));
            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));
            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));
            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));
            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));
            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));
            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));
            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));
            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));
            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));
            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));
            // Build the orientation of the OBB using the normal vector and its partial derivates.
            // the sperical coordinates of the mid point of the geobox.
            MathUtils_1.MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);
            // the partial derivates of the normal vector.
            MathUtils_1.MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);
            let width;
            let minY;
            let maxY;
            if (south >= 0) {
                // abs(dot(southWest - southEast, xAxis))
                width = Math.abs(cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                // dot(south, yAxis)
                minY = cosMidY * sinSouth - sinMidY * cosSouth;
                // dot(northEast, zAxis)
                maxY =
                    cosMidY * sinNorth -
                        sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            else {
                if (north <= 0) {
                    // abs(dot(northWest - northEast, xAxis))
                    width = Math.abs(cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest)));
                    // dot(north, yAxis)
                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;
                }
                else {
                    // abs(dot(west - east, xAxis))
                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));
                    // dot(northEast, yAxis)
                    maxY =
                        cosMidY * sinNorth -
                            sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);
                }
                // dot(southEast, yAxis)
                minY =
                    cosMidY * sinSouth -
                        sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);
            }
            const rMax = (this.unitScale + ((_a = geoBox.maxAltitude) !== null && _a !== void 0 ? _a : 0)) * 0.5;
            const rMin = (this.unitScale + ((_b = geoBox.minAltitude) !== null && _b !== void 0 ? _b : 0)) * 0.5;
            // min(dot(southEast, zAxis), dot(northEast, zAxis))
            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);
            const minZ = Math.min(cosNorth * d + sinNorth * sinMidY, cosSouth * d + sinSouth * sinMidY);
            MathUtils_1.MathUtils.newVector3(width * rMax, (maxY - minY) * rMax, rMax - minZ * rMin, result.extents);
            MathUtils_1.MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);
            apply(result.xAxis, result.yAxis, result.zAxis, result.position);
            result.position.x = result.position.x - result.zAxis.x * result.extents.z;
            result.position.y = result.position.y - result.zAxis.y * result.extents.z;
            result.position.z = result.position.z - result.zAxis.z * result.extents.z;
            return result;
        }
        throw new Error("Invalid bounding box");
    }
    /** @override */
    unprojectBox(_worldBox) {
        throw new Error("Method not implemented.");
    }
    /** @override */
    getScaleFactor(_worldPoint) {
        return 1;
    }
    /** @override */
    groundDistance(worldPoint) {
        return lengthOfVector3(worldPoint) - this.unitScale;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);
        worldPoint.x *= scale;
        worldPoint.y *= scale;
        worldPoint.z *= scale;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: 0 };
        }
        const scale = 1 / (lengthOfVector3(worldPoint) || 1);
        normal.x = worldPoint.x * scale;
        normal.y = worldPoint.y * scale;
        normal.z = worldPoint.z * scale;
        return normal;
    }
    /** @override */
    reprojectPoint(sourceProjection, worldPos, result) {
        if (sourceProjection === MercatorProjection_1.mercatorProjection || sourceProjection === MercatorProjection_1.webMercatorProjection) {
            const { x, y, z } = worldPos;
            const r = this.unitScale;
            const mx = x / r - Math.PI;
            const my = y / r - Math.PI;
            const w = Math.exp(my);
            const d = w * w;
            const gx = (2 * w) / (d + 1);
            const gy = (d - 1) / (d + 1);
            const scale = r + z;
            if (result === undefined) {
                result = {};
            }
            result.x = Math.cos(mx) * gx * scale;
            result.y = Math.sin(mx) * gx * scale;
            result.z = gy * scale;
            if (sourceProjection === MercatorProjection_1.webMercatorProjection) {
                result.z = -result.z;
            }
            return result;
        }
        return super.reprojectPoint(sourceProjection, worldPos, result);
    }
    /** @override */
    localTangentSpace(point, result) {
        let geoPoint;
        if (GeoCoordinatesLike_1.isGeoCoordinatesLike(point)) {
            this.projectPoint(point, result.position);
            geoPoint = point;
        }
        else {
            MathUtils_1.MathUtils.copyVector3(point, result.position);
            geoPoint = this.unprojectPoint(point);
        }
        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);
        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);
        const cosLongitude = Math.cos(longitude);
        const sinLongitude = Math.sin(longitude);
        const cosLatitude = Math.cos(latitude);
        const sinLatitude = Math.sin(latitude);
        MathUtils_1.MathUtils.newVector3(cosLongitude * cosLatitude, sinLongitude * cosLatitude, sinLatitude, result.zAxis);
        MathUtils_1.MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);
        MathUtils_1.MathUtils.newVector3(-cosLongitude * sinLatitude, -sinLongitude * sinLatitude, cosLatitude, result.yAxis);
        return result;
    }
}
exports.sphereProjection = new SphereProjection(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);


/***/ }),

/***/ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts":
/*!***********************************************************************!*\
  !*** ../harp-geoutils/lib/projection/TransverseMercatorProjection.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transverseMercatorProjection = exports.TransverseMercatorUtils = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const GeoBox_1 = __webpack_require__(/*! ../coordinates/GeoBox */ "../harp-geoutils/lib/coordinates/GeoBox.ts");
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const Box3Like_1 = __webpack_require__(/*! ../math/Box3Like */ "../harp-geoutils/lib/math/Box3Like.ts");
const MathUtils_1 = __webpack_require__(/*! ../math/MathUtils */ "../harp-geoutils/lib/math/MathUtils.ts");
const OrientedBox3Like_1 = __webpack_require__(/*! ../math/OrientedBox3Like */ "../harp-geoutils/lib/math/OrientedBox3Like.ts");
const EarthConstants_1 = __webpack_require__(/*! ./EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const Projection_1 = __webpack_require__(/*! ./Projection */ "../harp-geoutils/lib/projection/Projection.ts");
/**
 *
 * https://en.wikipedia.org/wiki/Transverse_Mercator_projection
 * http://mathworld.wolfram.com/MercatorProjection.html
 *
 */
class TransverseMercatorProjection extends Projection_1.Projection {
    constructor(unitScale) {
        super(unitScale);
        this.unitScale = unitScale;
        /** @override */
        this.type = Projection_1.ProjectionType.Planar;
        this.m_phi0 = 0;
        this.m_lambda0 = 0;
    }
    /**
     * Like in regular Mercator projection, there are two points on sphere
     * with radius about 5 degrees, that is out of projected space.
     *
     *
     * in regular Mercator these points are:
     *     (90, any), (-90, any)
     *
     * and in transverse Mercator:
     *     (0, 90), (0, -90)
     *
     * So, in transverse we need to compute distnce to poles, and clamp if
     * radius is exceeded
     */
    static clampGeoPoint(geoPoint, _unitScale) {
        const lat = geoPoint.latitude;
        const lon = geoPoint.longitude;
        const r = TransverseMercatorUtils.POLE_RADIUS;
        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;
        const nearestQuarter = Math.round(lon / 90);
        const deltaLon = nearestQuarter * 90 - lon;
        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {
            return geoPoint;
        }
        const deltaLat = lat - 0;
        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;
        if (distanceToPoleSq < rsq) {
            const distanceToPole = Math.sqrt(distanceToPoleSq);
            const scale = (r - distanceToPole) / distanceToPole;
            // const quarter = ((nearestQuarter % 4) + 4) % 4;
            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;
            const dir = 1;
            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;
            return new GeoCoordinates_1.GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);
        }
        return geoPoint;
    }
    /** @override */
    getScaleFactor(worldPoint) {
        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);
    }
    /** @override */
    worldExtent(minAltitude, maxAltitude, result) {
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = 0;
        result.min.y = 0;
        result.min.z = minAltitude;
        result.max.x = this.unitScale;
        result.max.y = this.unitScale;
        result.max.z = maxAltitude;
        return result;
    }
    /** @override */
    projectPoint(geoPoint, result) {
        var _a;
        if (!result) {
            result = { x: 0, y: 0, z: 0 };
        }
        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);
        const normalLon = clamped.longitude / 360 + 0.5;
        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);
        const phi = THREE.MathUtils.degToRad(clamped.latitude);
        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;
        const B = Math.cos(phi) * Math.sin(lambda);
        // result.x = 1/2 * Math.log((1 + B) / (1 - B));
        result.x = Math.atanh(B);
        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;
        const outScale = 0.5 / Math.PI;
        result.x =
            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);
        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);
        result.z = (_a = geoPoint.altitude) !== null && _a !== void 0 ? _a : 0;
        return result;
    }
    /** @override */
    unprojectPoint(worldPoint) {
        const tau = Math.PI * 2;
        const nx = worldPoint.x / this.unitScale;
        const ny = worldPoint.y / this.unitScale;
        const offset = nx === 1 ? 0 : Math.floor(nx);
        const x = tau * (nx - 0.5 - offset);
        const y = tau * (ny - 0.5);
        const z = worldPoint.z || 0;
        const D = y + this.m_phi0;
        const phi = Math.asin(Math.sin(D) / Math.cosh(x));
        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;
        const geoPoint = GeoCoordinates_1.GeoCoordinates.fromRadians(phi, lambda, z);
        return geoPoint;
    }
    /** @override */
    projectBox(geoBox, result) {
        const { north, south, east, west } = geoBox;
        const pointsToCheck = [
            geoBox.center,
            geoBox.northEast,
            geoBox.southWest,
            new GeoCoordinates_1.GeoCoordinates(south, east),
            new GeoCoordinates_1.GeoCoordinates(north, west)
        ];
        const E = TransverseMercatorUtils.POLE_EDGE_DEG;
        const containsWestCut = west < -90 && east > -90;
        const containsEastCut = west < 90 && east > 90;
        const containsCenterX = west < 0 && east > 0;
        const containsCenterY = west < E && east > -E && north > 0 && south < 0;
        if (containsWestCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, -90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, -90));
        }
        if (containsEastCut) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 90));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 90));
        }
        if (containsCenterX) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(north, 0));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(south, 0));
        }
        if (containsCenterY) {
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, west));
            pointsToCheck.push(new GeoCoordinates_1.GeoCoordinates(0, east));
        }
        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);
        const projected = pointsToCheck.map(p => this.projectPoint(p));
        const vx = projected.map(p => p.x);
        const vy = projected.map(p => p.y);
        const vz = projected.map(p => p.z);
        const minX = Math.min(...vx);
        const minY = Math.min(...vy);
        const minZ = Math.min(...vz);
        const maxX = Math.max(...vx);
        const maxY = Math.max(...vy);
        const maxZ = Math.max(...vz);
        if (!result) {
            result = new THREE.Box3();
        }
        if (Box3Like_1.isBox3Like(result)) {
            result.min.x = minX;
            result.min.y = minY;
            result.min.z = minZ;
            result.max.x = maxX;
            result.max.y = maxY;
            result.max.z = maxZ;
        }
        else if (OrientedBox3Like_1.isOrientedBox3Like(result)) {
            MathUtils_1.MathUtils.newVector3(1, 0, 0, result.xAxis);
            MathUtils_1.MathUtils.newVector3(0, 1, 0, result.yAxis);
            MathUtils_1.MathUtils.newVector3(0, 0, 1, result.zAxis);
            result.position.x = (minX + maxX) / 2;
            result.position.y = (minY + maxY) / 2;
            result.position.z = (minZ + maxZ) / 2;
            result.extents.x = (maxX - minX) / 2;
            result.extents.y = (maxY - minY) / 2;
            result.extents.z = (maxZ - minZ) / 2;
        }
        else {
            throw new Error("invalid bounding box");
        }
        return result;
    }
    /**
     * There are 8 sub-regions on entire projection space
     * where both longitude and latitude preserve direction.
     * If bounding box hits more than one region, it should be splitted
     * into sub-boxes by regions, (un)projected and then united again.
     *
     *
     * directions in form [latitude / longitude]:
     *    1 |
     *       dr / dl | dl / ul 
     * 0.75 ----------|----------
     *       ur / dr | ul / ur 
     * 0.5  ----------|----------
     *       ul / ur | ur / dr 
     * 0.25 ----------|----------
     *       dl / ul | dr / dl 
     *      |
     *     0         0.5        1
     *     @override
     */
    unprojectBox(worldBox) {
        const s = this.unitScale;
        const min = worldBox.min;
        const max = worldBox.max;
        const pointsToCheck = [
            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },
            min,
            max,
            { x: min.x, y: max.y, z: 0 },
            { x: max.x, y: min.y, z: 0 }
        ];
        const center = 0.5 * s;
        const lowerQ = 0.25 * s;
        const upperQ = 0.75 * s;
        const containsCenterX = min.x < center && max.x > center;
        const containsCenterY = min.y < center && max.y > center;
        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;
        const containsUpperQY = min.y < upperQ && max.y > upperQ;
        if (containsCenterY) {
            pointsToCheck.push({ x: min.x, y: center, z: 0 });
            pointsToCheck.push({ x: max.x, y: center, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: center, z: 0 });
            }
        }
        if (containsLowerQY) {
            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });
            }
        }
        if (containsUpperQY) {
            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });
            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });
            if (containsCenterX) {
                pointsToCheck.push({ x: center, y: upperQ, z: 0 });
            }
        }
        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));
        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);
        const latitudes = geoPoints.map(g => g.latitude);
        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);
        const altitudes = geoPoints.map(g => { var _a; return (_a = g.altitude) !== null && _a !== void 0 ? _a : 0; });
        const minGeo = new GeoCoordinates_1.GeoCoordinates(Math.min(...latitudes), Math.min(...longitudes), Math.min(...altitudes));
        const maxGeo = new GeoCoordinates_1.GeoCoordinates(Math.max(...latitudes), Math.max(...longitudes), Math.max(...altitudes));
        const geoBox = GeoBox_1.GeoBox.fromCoordinates(minGeo, maxGeo);
        return geoBox;
    }
    /** @override */
    unprojectAltitude(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    groundDistance(worldPoint) {
        return worldPoint.z;
    }
    /** @override */
    scalePointToSurface(worldPoint) {
        worldPoint.z = 0;
        return worldPoint;
    }
    /** @override */
    surfaceNormal(_worldPoint, normal) {
        if (normal === undefined) {
            normal = { x: 0, y: 0, z: -1 };
        }
        else {
            normal.x = 0;
            normal.y = 0;
            normal.z = -1;
        }
        return normal;
    }
}
class TransverseMercatorUtils {
    /**
     * There are two regions on projected space that have same geo coordinates,
     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }
     * they both have geo coordinates of   (0, [-90..+90])
     * and should be aligned somehow to fall into first or second region
     * to make proper bounding boxes, tile bounds, etc.
     */
    static alignLatitude(points, referencePoint) {
        const EPSILON = 1e-9;
        for (const point of points) {
            if (point.latitude === 0) {
                point.latitude = referencePoint.latitude * EPSILON;
            }
        }
    }
    /**
     * There are two regions on projected plane,
     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }
     * that represent longitude edge where -180 and +180 met.
     * Points falling in this regions should be aligned to get proper boxes etc.
     */
    static alignLongitude(points, referencePoint) {
        const bad = referencePoint.longitude < 0 ? 180 : -180;
        const good = referencePoint.longitude < 0 ? -180 : 180;
        for (const point of points) {
            if (point.longitude === bad) {
                point.longitude = good;
            }
        }
    }
}
exports.TransverseMercatorUtils = TransverseMercatorUtils;
TransverseMercatorUtils.POLE_EDGE = 1.4844222297453323;
TransverseMercatorUtils.POLE_EDGE_DEG = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);
TransverseMercatorUtils.POLE_RADIUS = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;
TransverseMercatorUtils.POLE_RADIUS_SQ = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);
/**
 * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates
 * and vice versa.
 */
exports.transverseMercatorProjection = new TransverseMercatorProjection(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts":
/*!*******************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlatTileBoundingBoxGenerator = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given
 * TilingScheme.
 */
class FlatTileBoundingBoxGenerator {
    /**
     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given
     * TilingScheme.
     *
     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.
     * @param minElevation - The minimum elevation in meters.
     * @param maxElevation - The maximum elevation in meters.
     */
    constructor(tilingScheme, minElevation = 0, maxElevation = 0) {
        this.tilingScheme = tilingScheme;
        this.minElevation = minElevation;
        this.maxElevation = maxElevation;
        this.m_tilingScheme = tilingScheme;
        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);
        const { min, max } = this.m_worldBox;
        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };
    }
    /**
     * Returns the {@link Projection} of the {@link TilingScheme}.
     */
    get projection() {
        return this.m_tilingScheme.projection;
    }
    /**
     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.
     */
    get subdivisionScheme() {
        return this.m_tilingScheme.subdivisionScheme;
    }
    /**
     * Returns the bounding box in world coordinates of the given {@link TileKey}.
     *
     * Example:
     * ```typescript
     * const worldBounds = new THREE.Box3();
     * generator.getWorldBox(geoBox, worldBounds);
     * console.log(worldBounds.getCenter());
     * ```
     *
     * @param tileKey - The TileKey.
     * @param result - The optional object used to store the resulting bounding box in world
     * coordinates.
     */
    getWorldBox(tileKey, result) {
        const level = tileKey.level;
        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);
        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);
        const sizeX = this.m_worldDimensions.x / levelDimensionX;
        const sizeY = this.m_worldDimensions.y / levelDimensionY;
        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;
        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;
        if (!result) {
            result = new THREE.Box3();
        }
        result.min.x = originX;
        result.min.y = originY;
        result.min.z = this.m_worldBox.min.z;
        result.max.x = originX + sizeX;
        result.max.y = originY + sizeY;
        result.max.z = this.m_worldBox.max.z;
        return result;
    }
    /**
     * Returns the bounding box in geo coordinates for the given {@link TileKey}.
     *
     * Example:
     * ```typescript
     * const geoBox = generator.getGeoBox(worldBounds);
     * console.log(geoBox.center);
     * ```
     *
     * @param tileKey - The {@link TileKey}.
     */
    getGeoBox(tileKey) {
        const worldBox = this.getWorldBox(tileKey);
        return this.projection.unprojectBox(worldBox);
    }
}
exports.FlatTileBoundingBoxGenerator = FlatTileBoundingBoxGenerator;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts":
/*!********************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.halfQuadTreeSubdivisionScheme = void 0;
class HalfQuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY(level) {
        return level === 0 ? 1 : 2;
    }
    getLevelDimensionX(level) {
        return 1 << level;
    }
    getLevelDimensionY(level) {
        return level !== 0 ? 1 << (level - 1) : 1;
    }
}
/**
 * A {@link SubdivisionScheme} used to represent half quadtrees.
 * This particular subdivision scheme is
 * used by the HERE tiling scheme.
 */
exports.halfQuadTreeSubdivisionScheme = new HalfQuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/HereTilingScheme.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/HereTilingScheme.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hereTilingScheme = void 0;
const EquirectangularProjection_1 = __webpack_require__(/*! ../projection/EquirectangularProjection */ "../harp-geoutils/lib/projection/EquirectangularProjection.ts");
const HalfQuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./HalfQuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * {@link TilingScheme} used by most of the data published by HERE.
 *
 * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular
 * projection.
 */
exports.hereTilingScheme = new TilingScheme_1.TilingScheme(HalfQuadTreeSubdivisionScheme_1.halfQuadTreeSubdivisionScheme, EquirectangularProjection_1.normalizedEquirectangularProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/MercatorTilingScheme.ts":
/*!***********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/MercatorTilingScheme.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mercatorTilingScheme = void 0;
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * The {@link TilingScheme} used by the HERE web tiles.
 *
 * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.
 */
exports.mercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.mercatorProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/PolarTilingScheme.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/PolarTilingScheme.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.polarTilingScheme = void 0;
const TransverseMercatorProjection_1 = __webpack_require__(/*! ../projection/TransverseMercatorProjection */ "../harp-geoutils/lib/projection/TransverseMercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * A {@link TilingScheme} featuring quadtree subdivision scheme and
 * transverse Mercator projection.
 */
exports.polarTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, TransverseMercatorProjection_1.transverseMercatorProjection);


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTree.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTree.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuadTree = void 0;
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
/**
 * A class used to represent a quadtree.
 */
class QuadTree {
    /**
     * Constructs a new `QuadTree` for the given {@link TilingScheme}.
     *
     * Example:
     * ```typescript
     * const quadTree = new QuadTree(hereTilingScheme);
     * const geoBox = quadTree.getGeoBox(tileKey);
     * console.log(geoBox.center);
     * ```
     *
     * @param tilingScheme - The TilingScheme used by this `QuadTree`.
     */
    constructor(tilingScheme) {
        this.tilingScheme = tilingScheme;
    }
    /**
     * Visits this `QuadTree` and invoke the given accept method
     * with the current {@link TileKey} and
     * its bounding box in geo coordinates.
     *
     * Example:
     * ```typescript
     * const geoPos = new GeoCoordinates(latitude, longitude);
     * const quadTree = new QuadTree(hereTilingScheme);
     * quadTree.visit((tileKey, geoBox) => {
     *     if (geoBox.contains(geoPos)) {
     *         console.log("tile", tileKey, "contains", geoPos);
     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.
     *     }
     *     return false; // stop visiting the quadtree,
     *                   // the tile's geoBox doesn't contain the given coordinates.
     * });
     * ```
     *
     * @param accept - A function that takes a {@link TileKey}
     * and its bounding box in geo coordinates
     * and returns `true` if the visit of the `QuadTree`
     * should continue; otherwise `false`.
     */
    visit(accept) {
        this.visitTileKey(TileKey_1.TileKey.fromRowColumnLevel(0, 0, 0), accept);
    }
    /**
     * Visits the subtree starting from the given tile.
     *
     * @param tileKey - The root of the subtree that should be visited.
     * @param accept - A function that takes a {@link TileKey}
     *                 and its bounding box in geo coordinates
     *                 and returns `true` if the visit of the
     *                 `QuadTree` should continue; otherwise `false`.
     */
    visitTileKey(tileKey, accept) {
        const geoBox = this.tilingScheme.getGeoBox(tileKey);
        if (!accept(tileKey, geoBox)) {
            return;
        }
        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {
            this.visitTileKey(subTileKey, accept);
        }
    }
}
exports.QuadTree = QuadTree;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts":
/*!****************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.quadTreeSubdivisionScheme = void 0;
class QuadTreeSubdivisionScheme {
    getSubdivisionX() {
        return 2;
    }
    getSubdivisionY() {
        return 2;
    }
    getLevelDimensionX(level) {
        return 1 << level;
    }
    getLevelDimensionY(level) {
        return 1 << level;
    }
}
/**
 * {@link SubdivisionScheme} representing a quadtree.
 */
exports.quadTreeSubdivisionScheme = new QuadTreeSubdivisionScheme();


/***/ }),

/***/ "../harp-geoutils/lib/tiling/SubTiles.ts":
/*!***********************************************!*\
  !*** ../harp-geoutils/lib/tiling/SubTiles.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubTiles = void 0;
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
class SubTiles {
    constructor(tileKey, sizeX, sizeY) {
        this.tileKey = tileKey;
        this.sizeX = sizeX;
        this.sizeY = sizeY;
    }
    [Symbol.iterator]() {
        return this.sizeX === 2 && this.sizeY === 2
            ? SubTiles.ZCurveIterator(this.tileKey)
            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);
    }
}
exports.SubTiles = SubTiles;
(function (SubTiles) {
    function* RowColumnIterator(parentKey, sizeX, sizeY) {
        for (let y = 0; y < sizeY; y++) {
            for (let x = 0; x < sizeX; x++) {
                yield TileKey_1.TileKey.fromRowColumnLevel(parentKey.row * sizeY + y, parentKey.column * sizeX + x, parentKey.level + 1);
            }
        }
    }
    SubTiles.RowColumnIterator = RowColumnIterator;
    function* ZCurveIterator(parentKey) {
        for (let i = 0; i < 4; i++) {
            yield TileKey_1.TileKey.fromRowColumnLevel((parentKey.row << 1) | (i >> 1), (parentKey.column << 1) | (i & 1), parentKey.level + 1);
        }
    }
    SubTiles.ZCurveIterator = ZCurveIterator;
})(SubTiles = exports.SubTiles || (exports.SubTiles = {}));


/***/ }),

/***/ "../harp-geoutils/lib/tiling/SubdivisionScheme.ts":
/*!********************************************************!*\
  !*** ../harp-geoutils/lib/tiling/SubdivisionScheme.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKey.ts":
/*!**********************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKey.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileKey = void 0;
/** @hidden */
const powerOfTwo = [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000,
    0x1000000,
    0x2000000,
    0x4000000,
    0x8000000,
    0x10000000,
    0x20000000,
    0x40000000,
    0x80000000,
    0x100000000,
    0x200000000,
    0x400000000,
    0x800000000,
    0x1000000000,
    0x2000000000,
    0x4000000000,
    0x8000000000,
    0x10000000000,
    0x20000000000,
    0x40000000000,
    0x80000000000,
    0x100000000000,
    0x200000000000,
    0x400000000000,
    0x800000000000,
    0x1000000000000,
    0x2000000000000,
    0x4000000000000,
    0x8000000000000,
    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.
];
/**
 * The `TileKey` instances are used to address a tile in a quadtree.
 *
 * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one
 * single tile. On every level, each tile is divided into four children (therefore the name
 * quadtree).
 *
 * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number
 * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only
 * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles
 * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.
 *
 * A tile key is usually created using [[fromRowColumnLevel]]() method.
 *
 * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not
 * modify the original object.
 *
 * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for
 * easy vertical navigation of the tree. The number of available rows and columns in the tile's
 * level is given with [[rowCount]]() and [[columnCount]]().
 *
 * Tile keys can be created from and converted into various alternative formats:
 *
 *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based
 *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based
 *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation
 *
 * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be
 * represented in the number representation returned by [[mortonCode]]().
 */
class TileKey {
    /**
     * Constructs a new immutable instance of a `TileKey`.
     *
     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.
     *
     * Note - row and column must not be greater than the maximum rows/columns for the given level.
     *
     * @param row - Represents the row in the quadtree.
     * @param column - Represents the column in the quadtree.
     * @param level - Represents the level in the quadtree.
     */
    constructor(row, column, level) {
        this.row = row;
        this.column = column;
        this.level = level;
    }
    /**
     * Creates a tile key.
     *
     * @param row - The requested row. Must be less than 2 to the power of level.
     * @param column - The requested column. Must be less than 2 to the power of level.
     * @param level - The requested level.
     */
    static fromRowColumnLevel(row, column, level) {
        return new TileKey(row, column, level);
    }
    /**
     * Creates a tile key from a quad string.
     *
     * The quad string can be created with [[toQuadKey]].
     *
     * @param quadkey - The quadkey to convert.
     * @returns A new instance of `TileKey`.
     */
    static fromQuadKey(quadkey) {
        const level = quadkey.length;
        let row = 0;
        let column = 0;
        for (let i = 0; i < quadkey.length; ++i) {
            const mask = 1 << i;
            const d = parseInt(quadkey.charAt(level - i - 1), 10);
            if (d & 0x1) {
                column |= mask;
            }
            if (d & 0x2) {
                row |= mask;
            }
        }
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Creates a tile key from a numeric Morton code representation.
     *
     * You can convert a tile key into a numeric Morton code with [[mortonCode]].
     *
     * @param quadKey64 - The Morton code to be converted.
     * @returns A new instance of {@link TileKey}.
     */
    static fromMortonCode(quadKey64) {
        let level = 0;
        let row = 0;
        let column = 0;
        let quadKey = quadKey64;
        while (quadKey > 1) {
            const mask = 1 << level;
            if (quadKey & 0x1) {
                column |= mask;
            }
            if (quadKey & 0x2) {
                row |= mask;
            }
            level++;
            quadKey = (quadKey - (quadKey & 0x3)) / 4;
        }
        const result = TileKey.fromRowColumnLevel(row, column, level);
        result.m_mortonCode = quadKey64;
        return result;
    }
    /**
     * Creates a tile key from a heretile code string.
     *
     * The string can be created with [[toHereTile]].
     *
     * @param quadkey64 - The string representation of the HERE tile key.
     * @returns A new instance of `TileKey`.
     */
    static fromHereTile(quadkey64) {
        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));
        result.m_hereTile = quadkey64;
        return result;
    }
    /**
     * Returns the number of available columns at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level - The level for which to return the number of columns.
     * @returns The available columns at the given level.
     */
    static columnsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the number of available rows at a given level.
     *
     * This is 2 to the power of the level.
     *
     * @param level - The level for which to return the number of rows.
     * @returns The available rows at the given level.
     */
    static rowsAtLevel(level) {
        return Math.pow(2, level);
    }
    /**
     * Returns the closest matching `TileKey` in a cartesian coordinate system.
     *
     * @param level - The level for the tile key.
     * @param coordX - The X coordinate.
     * @param coordY - The Y coordinate.
     * @param totalWidth - The maximum X coordinate.
     * @param totalHeight - The maximum Y coordinate.
     * @returns A new tile key at the given level that includes the given coordinates.
     */
    static atCoords(level, coordX, coordY, totalWidth, totalHeight) {
        return TileKey.fromRowColumnLevel(Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))), Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))), level);
    }
    /**
     * Computes the Morton code of the parent tile key of the given Morton code.
     *
     * Note: The parent key of the root key is the root key itself.
     *
     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].
     * @returns The Morton code of the parent tile.
     */
    static parentMortonCode(mortonCode) {
        return Math.floor(mortonCode / 4);
    }
    /**
     * Returns a tile key representing the parent of the tile addressed by this tile key.
     *
     * Throws an exception is this tile is already the root.
     */
    parent() {
        if (this.level === 0) {
            throw new Error("Cannot get the parent of the root tile key");
        }
        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);
    }
    /**
     * Returns a new tile key at a level that differs from this tile's level by delta.
     *
     * Equivalent to `changedLevelTo(level() + delta)`.
     *
     * Note - root key is returned if `delta` is smaller than the level of this tile key.
     *
     * @param delta - The numeric difference between the current level and the requested level.
     */
    changedLevelBy(delta) {
        const level = Math.max(0, this.level + delta);
        let row = this.row;
        let column = this.column;
        if (delta >= 0) {
            row <<= delta;
            column <<= delta;
        }
        else {
            row >>>= -delta;
            column >>>= -delta;
        }
        return TileKey.fromRowColumnLevel(row, column, level);
    }
    /**
     * Returns a new tile key at the requested level.
     *
     * If the requested level is smaller than the tile's level, then the key of an ancestor of this
     * tile is returned. If the requested level is larger than the tile's level, then the key of
     * first child or grandchild of this tile is returned, for example, the child with the lowest
     * row and column number. If the requested level equals this tile's level, then the tile key
     * itself is returned. If the requested level is negative, the root tile key is returned.
     *
     * @param level - The requested level.
     */
    changedLevelTo(level) {
        return this.changedLevelBy(level - this.level);
    }
    /**
     * Converts the tile key to a numeric code representation.
     *
     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].
     *
     * Note - only levels <= 26 are supported.
     */
    mortonCode() {
        if (this.m_mortonCode === undefined) {
            let column = this.column;
            let row = this.row;
            let result = powerOfTwo[this.level << 1];
            for (let i = 0; i < this.level; ++i) {
                if (column & 0x1) {
                    result += powerOfTwo[2 * i];
                }
                if (row & 0x1) {
                    result += powerOfTwo[2 * i + 1];
                }
                column >>>= 1;
                row >>>= 1;
            }
            this.m_mortonCode = result;
        }
        return this.m_mortonCode;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * The string is a quadkey Morton code representation as a string.
     *
     * You can convert back from a quadkey string with [[fromHereTile]].
     */
    toHereTile() {
        if (this.m_hereTile === undefined) {
            this.m_hereTile = this.mortonCode().toString();
        }
        return this.m_hereTile;
    }
    /**
     * Converts the tile key into a string for using in REST API calls.
     *
     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the
     * base of 4, but without the leading 1, with the following properties:
     *  1. the number of digits equals the level.
     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3
     *     to a quadkey string gives the tiles's children.
     *
     * You can convert back from a quadkey string with [[fromQuadKey]].
     */
    toQuadKey() {
        let result = "";
        for (let i = this.level; i > 0; --i) {
            const mask = 1 << (i - 1);
            const col = (this.column & mask) !== 0;
            const row = (this.row & mask) !== 0;
            if (col && row) {
                result += "3";
            }
            else if (row) {
                result += "2";
            }
            else if (col) {
                result += "1";
            }
            else {
                result += "0";
            }
        }
        return result;
    }
    /**
     * Equality operator.
     *
     * @param qnr - The tile key to compare to.
     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.
     */
    equals(qnr) {
        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub quadkey.
     *
     * @param sub - The sub key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubKey(sub) {
        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? "-" : sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns the absolute quadkey that is constructed from its sub HERE tile key.
     *
     * @param sub - The sub HERE key.
     * @returns The absolute tile key in the quadtree.
     */
    addedSubHereTile(sub) {
        const subQuad = TileKey.fromHereTile(sub);
        const child = this.changedLevelBy(subQuad.level);
        return TileKey.fromRowColumnLevel(child.row + subQuad.row, child.column + subQuad.column, child.level);
    }
    /**
     * Returns a sub quadkey that is relative to its parent.
     *
     * This function can be used to generate sub keys that are relative to a parent that is delta
     * levels up in the quadtree.
     *
     * This function can be used to create shortened keys for quads on lower levels if the parent is
     * known.
     *
     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If
     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.
     *
     * Deltas larger than 16 are not supported.
     *
     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal
     * to 0 and smaller than 16.
     * @returns The quadkey relative to its parent that is `delta` levels up the tree.
     */
    getSubHereTile(delta) {
        const key = this.mortonCode();
        const msb = 1 << (delta * 2);
        const mask = msb - 1;
        const result = (key & mask) | msb;
        return result.toString();
    }
    /**
     * Returns the number of available rows in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    rowCount() {
        return TileKey.rowsAtLevel(this.level);
    }
    /**
     * Returns the number of available columns in the tile's [[level]].
     *
     * This is 2 to the power of the level.
     */
    columnCount() {
        return TileKey.columnsAtLevel(this.level);
    }
}
exports.TileKey = TileKey;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileKeyUtils.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileKeyUtils.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileKeyUtils = exports.powerOfTwo = void 0;
const GeoCoordinates_1 = __webpack_require__(/*! ../coordinates/GeoCoordinates */ "../harp-geoutils/lib/coordinates/GeoCoordinates.ts");
const TileKey_1 = __webpack_require__(/*! ./TileKey */ "../harp-geoutils/lib/tiling/TileKey.ts");
exports.powerOfTwo = (() => {
    let val = 0.5;
    return new Array(53).fill(0).map(() => (val *= 2));
})();
var TileKeyUtils;
(function (TileKeyUtils) {
    function geoCoordinatesToTileKey(tilingScheme, geoPoint, level) {
        const projection = tilingScheme.projection;
        const worldPoint = projection.projectPoint(geoPoint);
        return worldCoordinatesToTileKey(tilingScheme, worldPoint, level);
    }
    TileKeyUtils.geoCoordinatesToTileKey = geoCoordinatesToTileKey;
    function worldCoordinatesToTileKey(tilingScheme, worldPoint, level) {
        const projection = tilingScheme.projection;
        const subdivisionScheme = tilingScheme.subdivisionScheme;
        const cx = subdivisionScheme.getLevelDimensionX(level);
        const cy = subdivisionScheme.getLevelDimensionY(level);
        const { min, max } = projection.worldExtent(0, 0);
        const worldSizeX = max.x - min.x;
        const worldSizeY = max.y - min.y;
        if (worldPoint.x < min.x || worldPoint.x > max.x) {
            return null;
        }
        if (worldPoint.y < min.y || worldPoint.y > max.y) {
            return null;
        }
        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));
        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));
        return TileKey_1.TileKey.fromRowColumnLevel(row, column, level);
    }
    TileKeyUtils.worldCoordinatesToTileKey = worldCoordinatesToTileKey;
    function geoRectangleToTileKeys(tilingScheme, geoBox, level) {
        const wrap = (value, lower, upper) => {
            if (value < lower) {
                return upper - ((lower - value) % (upper - lower));
            }
            return lower + ((value - lower) % (upper - lower));
        };
        const clamp = (x, minVal, maxVal) => {
            return Math.min(Math.max(x, minVal), maxVal);
        };
        // Clamp at the poles and wrap around the international date line.
        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);
        const southWestLatitude = clamp(geoBox.southWest.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);
        const northEastLatitude = clamp(geoBox.northEast.latitudeInRadians, -(Math.PI * 0.5), Math.PI * 0.5);
        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude), level);
        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(tilingScheme, GeoCoordinates_1.GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude), level);
        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);
        if (!minTileKey || !maxTileKey) {
            throw new Error("Invalid coordinates");
        }
        const minColumn = minTileKey.column;
        let maxColumn = maxTileKey.column;
        // wrap around case
        if (southWestLongitude > northEastLongitude) {
            if (maxColumn !== minColumn) {
                maxColumn += columnCount;
            }
            else {
                // do not duplicate
                maxColumn += columnCount - 1;
            }
        }
        const minRow = Math.min(minTileKey.row, maxTileKey.row);
        const maxRow = Math.max(minTileKey.row, maxTileKey.row);
        const keys = new Array();
        for (let row = minRow; row <= maxRow; ++row) {
            for (let column = minColumn; column <= maxColumn; ++column) {
                keys.push(TileKey_1.TileKey.fromRowColumnLevel(row, column % columnCount, level));
            }
        }
        return keys;
    }
    TileKeyUtils.geoRectangleToTileKeys = geoRectangleToTileKeys;
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}
     *                  from which to compute the unique key.
     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset
     * @param bitshift - How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey, offset, bitshift = 4) {
        const shiftedOffset = getShiftedOffset(offset, bitshift);
        return tileKey.mortonCode() + shiftedOffset;
    }
    TileKeyUtils.getKeyForTileKeyAndOffset = getKeyForTileKeyAndOffset;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key - Key to extract offset and morton key.
     * @param bitshift - How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key, bitshift = 4) {
        let offset = 0;
        let mortonCode = key;
        let i = 0;
        // Compute the offset
        for (; i < bitshift; i++) {
            // Note, we use 52, because 2^53-1 is the biggest value, the highest value
            // that can be set is the bit in the 52th position.
            const num = exports.powerOfTwo[52 - i];
            if (mortonCode >= num) {
                mortonCode -= num;
                offset += exports.powerOfTwo[bitshift - 1 - i];
            }
        }
        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset
        offset -= exports.powerOfTwo[bitshift - 1];
        return { offset, mortonCode };
    }
    TileKeyUtils.extractOffsetAndMortonKeyFromKey = extractOffsetAndMortonKeyFromKey;
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey - Key to decompose
     * @param bitshift - Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey, bitshift = 4) {
        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);
        const parentTileKey = TileKey_1.TileKey.fromMortonCode(TileKey_1.TileKey.parentMortonCode(mortonCode));
        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);
    }
    TileKeyUtils.getParentKeyFromKey = getParentKeyFromKey;
    /**
     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and
     * 2^(52-bitshift).
     *
     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really
     * matter, this is primarily used to find a unique id, if there is an offset 10, which is
     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.
     * What can be a problem though is that the cache gets filled up and isn't emptied.
     *
     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set
     * the high bits instead.
     *
     * @param offset - Offset to pack into the high bits.
     * @param offsetBits - How many bits to use to pack the offset.
     */
    function getShiftedOffset(offset, offsetBits = 4) {
        let result = 0;
        const totalOffsetsToStore = exports.powerOfTwo[offsetBits];
        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,
        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -
        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be
        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).
        offset += totalOffsetsToStore / 2;
        while (offset < 0) {
            offset += totalOffsetsToStore;
        }
        while (offset >= totalOffsetsToStore) {
            offset -= totalOffsetsToStore;
        }
        // Offset is now a number between >= 0 and < totalOffsetsToStore
        for (let i = 0; i < offsetBits && offset > 0; i++) {
            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an
            // integer safely.
            if (offset & 0x1) {
                result += exports.powerOfTwo[53 - offsetBits + i];
            }
            offset >>>= 1;
        }
        return result;
    }
})(TileKeyUtils = exports.TileKeyUtils || (exports.TileKeyUtils = {}));


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts":
/*!*******************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TileTreeTraverse.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileTreeTraverse = void 0;
const SubTiles_1 = __webpack_require__(/*! ./SubTiles */ "../harp-geoutils/lib/tiling/SubTiles.ts");
class TileTreeTraverse {
    constructor(subdivisionScheme) {
        this.m_subdivisionScheme = subdivisionScheme;
    }
    subTiles(tileKey) {
        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);
        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);
        return new SubTiles_1.SubTiles(tileKey, divX, divY);
    }
}
exports.TileTreeTraverse = TileTreeTraverse;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/TilingScheme.ts":
/*!***************************************************!*\
  !*** ../harp-geoutils/lib/tiling/TilingScheme.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TilingScheme = void 0;
const FlatTileBoundingBoxGenerator_1 = __webpack_require__(/*! ./FlatTileBoundingBoxGenerator */ "../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts");
const TileKeyUtils_1 = __webpack_require__(/*! ./TileKeyUtils */ "../harp-geoutils/lib/tiling/TileKeyUtils.ts");
const TileTreeTraverse_1 = __webpack_require__(/*! ./TileTreeTraverse */ "../harp-geoutils/lib/tiling/TileTreeTraverse.ts");
/**
 * The `TilingScheme` represents how the data is tiled.
 */
class TilingScheme {
    /**
     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.
     *
     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.
     * @param projection - The projection used by this `TilingScheme`.
     */
    constructor(subdivisionScheme, projection) {
        this.subdivisionScheme = subdivisionScheme;
        this.projection = projection;
        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator_1.FlatTileBoundingBoxGenerator(this);
        this.tileTreeTraverse = new TileTreeTraverse_1.TileTreeTraverse(subdivisionScheme);
    }
    /**
     * Returns the sub tile keys of the given tile.
     *
     * @param tileKey - The {@link TileKey}.
     * @returns The list of the sub tile keys.
     */
    getSubTileKeys(tileKey) {
        return this.tileTreeTraverse.subTiles(tileKey);
    }
    /**
     * Gets the {@link TileKey} from the given geo position and level.
     *
     * @param geoPoint - The position in geo coordinates.
     * @param level - The level of the resulting `TileKey`.
     */
    getTileKey(geoPoint, level) {
        return TileKeyUtils_1.TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);
    }
    /**
     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.
     *
     * @param geoBox - The bounding box in geo coordinates.
     * @param level - The level of the resulting `TileKey`.
     */
    getTileKeys(geoBox, level) {
        return TileKeyUtils_1.TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);
    }
    /**
     * Returns the bounding box in geo coordinates for the given {@link TileKey}.
     *
     * @param tileKey - The `TileKey`.
     */
    getGeoBox(tileKey) {
        return this.boundingBoxGenerator.getGeoBox(tileKey);
    }
    /**
     * Returns the bounding box in world coordinates.
     *
     * @param tileKey - The `TileKey`.
     * @param result - The optional object that will contain the resulting bounding box.
     */
    getWorldBox(tileKey, result) {
        return this.boundingBoxGenerator.getWorldBox(tileKey, result);
    }
}
exports.TilingScheme = TilingScheme;


/***/ }),

/***/ "../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts":
/*!**************************************************************!*\
  !*** ../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webMercatorTilingScheme = void 0;
const MercatorProjection_1 = __webpack_require__(/*! ../projection/MercatorProjection */ "../harp-geoutils/lib/projection/MercatorProjection.ts");
const QuadTreeSubdivisionScheme_1 = __webpack_require__(/*! ./QuadTreeSubdivisionScheme */ "../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts");
const TilingScheme_1 = __webpack_require__(/*! ./TilingScheme */ "../harp-geoutils/lib/tiling/TilingScheme.ts");
/**
 * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.
 */
exports.webMercatorTilingScheme = new TilingScheme_1.TilingScheme(QuadTreeSubdivisionScheme_1.quadTreeSubdivisionScheme, MercatorProjection_1.webMercatorProjection);


/***/ }),

/***/ "../harp-lines/index.ts":
/*!******************************!*\
  !*** ../harp-lines/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./lib/Lines */ "../harp-lines/lib/Lines.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts"), exports);


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionLines.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionLines.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HighPrecisionLine = exports.HighPrecisionWireFrameLine = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision wireframe lines.
 */
class HighPrecisionWireFrameLine extends THREE.Line {
    /**
     * Creates a `HighPrecisionWireFrameLine` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     * @param positions - Array of 2D/3D positions.
     */
    constructor(geometry, material, positions) {
        super(geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
    }
}
exports.HighPrecisionWireFrameLine = HighPrecisionWireFrameLine;
/**
 * Class used to render high-precision lines.
 */
class HighPrecisionLine extends THREE.Mesh {
    /**
     * Creates a `HighPrecisionLine` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     * @param positions - Array of 2D/3D positions.
     */
    constructor(geometry, material, positions) {
        super(geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
    }
}
exports.HighPrecisionLine = HighPrecisionLine;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionPoints.ts":
/*!************************************************!*\
  !*** ../harp-lines/lib/HighPrecisionPoints.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HighPrecisionPoints = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const HighPrecisionUtils_1 = __webpack_require__(/*! ./HighPrecisionUtils */ "../harp-lines/lib/HighPrecisionUtils.ts");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions - Array of 2D/3D positions.
     * @param color - Color of the rendered point.
     * @param opacity - Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;


/***/ }),

/***/ "../harp-lines/lib/HighPrecisionUtils.ts":
/*!***********************************************!*\
  !*** ../harp-lines/lib/HighPrecisionUtils.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HighPrecisionUtils = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const HPL = __webpack_require__(/*! ./HighPrecisionLines */ "../harp-lines/lib/HighPrecisionLines.ts");
const HPP = __webpack_require__(/*! ./HighPrecisionPoints */ "../harp-lines/lib/HighPrecisionPoints.ts");
const TriangulateLines_1 = __webpack_require__(/*! ./TriangulateLines */ "../harp-lines/lib/TriangulateLines.ts");
var HighPrecisionUtils;
(function (HighPrecisionUtils) {
    /**
     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.
     * precision.
     *
     * @param v -
     */
    function doubleToFloatVec(v) {
        return new three_1.Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));
    }
    HighPrecisionUtils.doubleToFloatVec = doubleToFloatVec;
    /**
     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the
     * difference of the double elements and their float counterparts.
     *
     * @param v - Vector3 to convert to float IN-PLACE!
     */
    function makeFloatVec(v) {
        const majorX = Math.fround(v.x);
        const majorY = Math.fround(v.y);
        const majorZ = Math.fround(v.z);
        const minorVec = new three_1.Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);
        v.x = Math.fround(majorX);
        v.y = Math.fround(majorY);
        v.z = Math.fround(majorZ);
        return minorVec;
    }
    HighPrecisionUtils.makeFloatVec = makeFloatVec;
    /**
     * Calculate high-precision camera position used in vertex shader of high-precision materials.
     *
     * @param camera - Camera used to get the high-precision position.
     * @param objectInverseWorldMatrix - Inverse World Matrix of the rendered
     *                                   [[HighPrecisionObject]].
     */
    function createHighPrecisionCameraPos(camera, objectInverseWorldMatrix) {
        const _projScreenMatrix = new three_1.Matrix4().copy(camera.projectionMatrix);
        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);
        const eyePos = new three_1.Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);
        // split the double float vector into hi and lo parts
        const eyePosFloat = doubleToFloatVec(eyePos);
        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));
        return {
            viewProjection: mvp,
            eyePosHi: eyePosFloat,
            eyePosLo
        };
    }
    HighPrecisionUtils.createHighPrecisionCameraPos = createHighPrecisionCameraPos;
    /**
     * Updates the high-precision uniform data of a material used to render a
     * [[HighPrecisionObject]].
     *
     * @param object - [[HighPrecisionObject]] used for rendering.
     * @param camera - Camera used to get the high-precision position.
     * @param shaderMaterial - Material which uniforms will be updated.
     */
    function updateHpUniforms(object, camera, shaderMaterial) {
        const highPrecisionCameraInfo = createHighPrecisionCameraPos(camera, object.matrixWorldInverse);
        const mvp = highPrecisionCameraInfo.viewProjection;
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_mvp &&
                shaderMaterial.uniforms.u_eyepos &&
                shaderMaterial.uniforms.u_eyepos_lowpart) {
                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);
                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(highPrecisionCameraInfo.eyePosHi.toArray());
                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(highPrecisionCameraInfo.eyePosLo.toArray());
            }
            else {
                throw Error("High pecision material has missing uniforms");
            }
        }
        else {
            throw Error("High pecision line has no high precision material");
        }
    }
    HighPrecisionUtils.updateHpUniforms = updateHpUniforms;
    /**
     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].
     *
     * @param positions - Array of positions.
     */
    function createAttributes(positions) {
        if (positions.length > 0) {
            const v = positions[0];
            if (v === undefined || v === null) {
                throw Error("Empty element in positions");
            }
            const positionVec = new Array();
            const positionVecLow = new Array();
            const addHPValue = (...values) => {
                for (const value of values) {
                    const major = Math.fround(value);
                    positionVecLow.push(value - major);
                    positionVec.push(major);
                }
            };
            const addHPVector = (vec) => {
                addHPValue(vec.x, vec.y, vec.z);
            };
            const vAny = v;
            if (vAny.z !== undefined) {
                positions.forEach(vec => {
                    addHPVector(vec);
                });
            }
            else {
                if (positionVec.length % 3 !== 0) {
                    throw Error("Positions must be 3D, not 2D");
                }
                positions.forEach((n) => {
                    addHPValue(n);
                });
            }
            return {
                positionHigh: new three_1.Float32BufferAttribute(positionVec, 3),
                positionLow: new three_1.Float32BufferAttribute(positionVecLow, 3)
            };
        }
        else {
            return {
                positionHigh: new three_1.Float32BufferAttribute([], 3),
                positionLow: new three_1.Float32BufferAttribute([], 3)
            };
        }
    }
    HighPrecisionUtils.createAttributes = createAttributes;
    /**
     * Assembles an interleaved buffer containing the position attribute data for a
     * [[HighPrecisionObject]].
     *
     * @param positions - Array of positions.
     * @param stride - Stride of the elements in the `positions` array.
     * @param positionOffset - Offset into the `positions` array.
     */
    function addInterleavedAttributes3(positions, stride, positionOffset = 0) {
        const newPositions = new Array();
        const end = positions.length;
        for (let i = 0; i < end; i += stride) {
            for (let j = 0; j < positionOffset; j++) {
                newPositions.push(positions[i + j]);
            }
            const x = positions[i + positionOffset];
            const y = positions[i + positionOffset + 1];
            const z = positions[i + positionOffset + 2];
            const majorX = Math.fround(x);
            const minorX = x - majorX;
            const majorY = Math.fround(y);
            const minorY = y - majorY;
            const majorZ = Math.fround(z);
            const minorZ = z - majorZ;
            // insert values in interleaved buffer
            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);
            for (let j = positionOffset + 3; j < stride; j++) {
                newPositions.push(positions[i + j]);
            }
        }
        return newPositions;
    }
    HighPrecisionUtils.addInterleavedAttributes3 = addInterleavedAttributes3;
    /**
     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].
     *
     * @param object - [[HighPrecisionObject]] which position attribute will be set.
     * @param positions - Array of positions.
     */
    function setPositions(object, positions) {
        const attributes = createAttributes(positions);
        object.bufferGeometry.setAttribute("position", attributes.positionHigh);
        object.bufferGeometry.setAttribute("positionLow", attributes.positionLow);
        return attributes.positionHigh.itemSize;
    }
    HighPrecisionUtils.setPositions = setPositions;
    /**
     * Convert positions from `Array<Vector3>` to `Array<number>`.
     *
     * @param positions - Array of positions.
     */
    function convertPositions(positions) {
        if (positions.length <= 0) {
            return { positions: [] };
        }
        const v = positions[0];
        if (v === undefined || v === null) {
            throw Error("Empty element in positions");
        }
        const vAny = v;
        if (vAny.y === undefined && vAny.z === undefined) {
            return { positions: positions };
        }
        const returnPositions = new Array();
        positions.forEach(vec => {
            returnPositions.push(vec.x, vec.y, vec.z);
        });
        return { positions: returnPositions };
    }
    HighPrecisionUtils.convertPositions = convertPositions;
    /**
     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.
     *
     * @param linePositions - Array of 2D/3D positions.
     * @param params - Parameters used to configure the created [[HighPrecisionObject]].
     */
    function createLine(linePositions, params) {
        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;
        const addCircles = params.addCircles !== undefined ? params.addCircles : false;
        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;
        const positions = [];
        const indices = [];
        TriangulateLines_1.triangulateLine(linePositions, lineWidth, positions, indices, addCircles);
        const hpLineGeometry = new three_1.BufferGeometry();
        const hpPositions = addInterleavedAttributes3(positions, 3);
        const buffer = new three_1.InterleavedBuffer(new Float32Array(hpPositions), 6);
        const positionAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 0, false);
        const positionLowAttribute = new three_1.InterleavedBufferAttribute(buffer, 3, 3, false);
        hpLineGeometry.setAttribute("position", positionAttribute);
        hpLineGeometry.setAttribute("positionLow", positionLowAttribute);
        hpLineGeometry.setIndex(new three_1.BufferAttribute(new Uint32Array(indices), 1));
        const hpSolidMaterial = new harp_materials_1.HighPrecisionLineMaterial(params);
        const lineObject = wireFrame
            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)
            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);
        lineObject.setupForRendering();
        return lineObject;
    }
    HighPrecisionUtils.createLine = createLine;
    /**
     * Creates a group of [[HighPrecisionPoints]].
     *
     * @param pointPositions - Array of 2D/3D positions.
     * @param materialParameters - Parameters used to configure the material used to render the
     * created [[HighPrecisionPoints]].
     */
    function createPoints(pointPositions, materialParameters) {
        const indices = [];
        for (let i = 0; i < pointPositions.length; i++) {
            indices.push(indices.length / 3);
        }
        const hpPointsGeometry = new three_1.BufferGeometry();
        const hpPointsMaterial = harp_materials_1.isHighPrecisionPointMaterial(materialParameters)
            ? materialParameters
            : new harp_materials_1.HighPrecisionPointMaterial(materialParameters);
        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);
        setPositions(pointsObject, pointPositions);
        pointsObject.setupForRendering();
        return pointsObject;
    }
    HighPrecisionUtils.createPoints = createPoints;
})(HighPrecisionUtils = exports.HighPrecisionUtils || (exports.HighPrecisionUtils = {}));


/***/ }),

/***/ "../harp-lines/lib/Lines.ts":
/*!**********************************!*\
  !*** ../harp-lines/lib/Lines.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineGroup = exports.createSimpleLineGeometry = exports.createLineGeometry = exports.LineGeometry = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
// Preallocate temp variables used during line generation.
const tmpV = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpTangent0 = new THREE.Vector3();
const tmpTangent1 = new THREE.Vector3();
const tmpBitangent = new THREE.Vector3();
const SEGMENT_OFFSET = 0.1;
/**
 * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].
 */
/** Base line vertex attributes. */
const LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        // The "extrusionCoord" is a vec4 which represents:
        // xy: Extrusion coordinates
        // sign(xy): Extrusion direction
        // z: Line length
        { name: "extrusionCoord", itemSize: 3, offset: 0 },
        { name: "position", itemSize: 3, offset: 3 },
        { name: "tangent", itemSize: 3, offset: 6 },
        // HARP-17373: Original uniform name 'bitangent' due to shader compilation errors with Metal
        // in Safari 15 on MacOS Monterrey and iPadOS 15.
        { name: "biTangent", itemSize: 4, offset: 9 }
    ],
    stride: 13
};
/** Optional normal and uv coordinates. */
const NORMAL_UV_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "uv", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },
        { name: "normal", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }
    ],
    stride: 5
};
/** Base line vertex attributes plus normals and uv coordinates. */
const LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],
    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Declares all the vertex attributes used for rendering a line using the
 * [[HighPrecisionLineMaterial]].
 */
const HP_LINE_VERTEX_ATTRIBUTES = {
    attributes: [
        { name: "extrusionCoord", itemSize: 2, offset: 0 },
        { name: "position", itemSize: 3, offset: 2 },
        { name: "positionLow", itemSize: 3, offset: 5 },
        { name: "tangent", itemSize: 3, offset: 8 },
        // HARP-17373: Original uniform name 'bitangent' due to shader compilation errors with Metal
        // in Safari 15 on MacOS Monterrey and iPadOS 15.
        { name: "biTangent", itemSize: 4, offset: 11 }
    ],
    stride: 15
};
/** High precision line vertex attributes plus normals and uv coordinates. */
const HP_LINE_VERTEX_ATTRIBUTES_NUV = {
    attributes: [
        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,
        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes
    ],
    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride
};
/**
 * Class that holds the vertex and index attributes for a [[Lines]] object.
 */
class LineGeometry {
    constructor() {
        this.vertices = [];
        this.vertexColors = [];
        this.indices = [];
    }
}
exports.LineGeometry = LineGeometry;
function getVertexDescriptor(hasNormalsAndUvs, highPrecision) {
    if (highPrecision) {
        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;
    }
    else {
        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;
    }
}
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param center - Center of the polyline.
 * @param polyline - Array of `numbers` describing a polyline.
 * @param offsets - Array of `numbers` representing line segment offsets.
 * @param uvs - Array of `numbers` representing texture coordinates.
 * @param colors - Array of `numbers` describing a polyline's colors.
 * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.
 * @param highPrecision - If `true` will create high-precision vertex information.
 */
function createLineGeometry(center, polyline, projection, offsets, uvs, colors, geometry = new LineGeometry(), highPrecision = false) {
    if (polyline.length === 0) {
        return geometry;
    }
    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;
    const pointCount = polyline.length / 3;
    const segments = new Array(pointCount);
    const tangents = new Array(polyline.length - 3);
    const baseVertex = geometry.vertices.length / stride;
    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;
    const hasTexCoords = uvs !== undefined && uvs.length > 0;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    harp_utils_1.assert(!hasSegmentOffsets || offsets.length === pointCount);
    harp_utils_1.assert(!hasTexCoords || uvs.length / 2 === pointCount);
    harp_utils_1.assert(!vertexColors || colors.length === polyline.length);
    // Compute segments and tangents.
    let sum = SEGMENT_OFFSET;
    segments[0] = sum;
    for (let i = 0; i < pointCount - 1; ++i) {
        let sqrLength = 0;
        for (let j = 0; j < 3; ++j) {
            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];
            tangents[i * 3 + j] = d;
            sqrLength += d * d;
        }
        const len = Math.sqrt(sqrLength);
        sum = sum + len;
        segments[i + 1] = sum;
    }
    const lineCoverage = hasSegmentOffsets
        ? Math.abs(offsets[offsets.length - 1] - offsets[0])
        : 1.0;
    const lineLength = segments[segments.length - 1] / lineCoverage;
    // Override the segments if offsets are explicitly provided.
    if (hasSegmentOffsets) {
        for (let i = 0; i < pointCount; ++i) {
            segments[i] = offsets[i] * lineLength + SEGMENT_OFFSET;
        }
    }
    // Check if we're working with a closed line.
    let isClosed = true;
    for (let j = 0; j < 3; ++j) {
        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];
    }
    const tmpVertices = [];
    const addVertexPair = (i, T1, T2, segment, extrusionCoord) => {
        tmpVertices.length = 0;
        // Store the segment and extrusionCoord attributes.
        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);
        tmpVertices.push(segment, extrusionCoord * 1, lineLength);
        // Store the position attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            if (!highPrecision) {
                geometry.vertices.push(polyline[i * 3 + j]);
                tmpVertices.push(polyline[i * 3 + j]);
            }
            else {
                const highComp = Math.fround(polyline[i * 3 + j]);
                const lowComp = polyline[i * 3 + j] - highComp;
                geometry.vertices.push(highComp, lowComp);
                tmpVertices.push(highComp, lowComp);
            }
            tmpNormal.setComponent(j, polyline[i * 3 + j]);
        }
        // Store the bitangent attribute (component-dependant).
        for (let j = 0; j < 3; ++j) {
            tmpTangent0.setComponent(j, tangents[T1 + j]);
            tmpTangent1.setComponent(j, tangents[T2 + j]);
        }
        tmpTangent0.normalize();
        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);
        tmpNormal.add(center); // tmpNormal contains world position
        projection.surfaceNormal(tmpNormal, tmpNormal);
        const angle = computeBitangent(tmpNormal, tmpTangent0, tmpTangent1.normalize(), tmpBitangent);
        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);
        if (hasTexCoords) {
            // uvs
            geometry.vertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            tmpVertices.push(uvs[i * 2], uvs[i * 2 + 1]);
            // normals
            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);
        }
        geometry.vertices.push(...tmpVertices);
        // Add vertex colors (if supplied).
        if (vertexColors) {
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
            geometry.vertexColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
        }
    };
    for (let i = 0; i < pointCount; ++i) {
        // Retrieve the per-point tangents.
        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;
        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);
        // Process v0 and v1.
        if (i > 0) {
            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);
        }
        // Process v2 and v3.
        if (i + 1 < pointCount) {
            addVertexPair(i, T1, T2, segments[Math.min(i, segments.length - 1)] * -1, segments[Math.min(i + 1, segments.length - 1)]);
        }
    }
    // Store the triangle indices in the final index buffer.
    for (let i = 0; i < pointCount - 1; ++i) {
        const base = baseVertex + i * 4;
        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);
    }
    return geometry;
}
exports.createLineGeometry = createLineGeometry;
/**
 * Creates a [[LineGeometry]] object out of a polyline.
 *
 * @param polyline - Array of `numbers` describing a polyline.
 * @param colors - Array of `numbers` describing a polyline's colors.
 * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.
 */
function createSimpleLineGeometry(polyline, colors, geometry = new LineGeometry()) {
    if (polyline.length === 0) {
        return geometry;
    }
    const pointCount = polyline.length / 3;
    let index = geometry.vertices.length / 3;
    const vertexColors = colors !== undefined && colors.length && polyline.length;
    for (let i = 0; i < pointCount; ++i, index++) {
        if (i > 0) {
            geometry.indices.push(index);
        }
        if (i < pointCount - 1) {
            geometry.indices.push(index);
        }
        for (let j = 0; j < 3; ++j) {
            geometry.vertices.push(polyline[i * 3 + j]);
            if (vertexColors) {
                geometry.vertexColors.push(colors[i * 3 + j]);
            }
        }
    }
    return geometry;
}
exports.createSimpleLineGeometry = createSimpleLineGeometry;
/**
 * Class used to render groups (or batches) of width-variable lines (in the same tile).
 */
class LineGroup {
    constructor(hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        this.hasNormalsAndUvs = hasNormalsAndUvs;
        this.highPrecision = highPrecision;
        this.isSimple = isSimple;
        this.m_geometry = new LineGeometry();
    }
    /**
     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.
     *
     * @param vertices - Array of vertex attributes.
     * @param colors - Array of vertex colors.
     * @param indices - Array of vertex indices.
     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.
     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.
     * @param highPrecision - If `true` will create high-precision vertex information.
     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.
     */
    static createGeometry(vertices, colors, indices, geometry, hasNormalsAndUvs = false, highPrecision = false, isSimple = false) {
        if (isSimple) {
            geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices), 3));
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
        else {
            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);
            const buffer = new THREE.InterleavedBuffer(new Float32Array(vertices), vertexDescriptor.stride);
            vertexDescriptor.attributes.forEach(descr => {
                const attribute = new THREE.InterleavedBufferAttribute(buffer, descr.itemSize, descr.offset, false);
                geometry.setAttribute(descr.name, attribute);
            });
            if (colors.length === vertices.length) {
                geometry.setAttribute("color", new THREE.BufferAttribute(new Float32Array(colors), 3));
            }
            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));
            return geometry;
        }
    }
    /**
     * Clears the list of line strips.
     */
    clear() {
        this.m_geometry.vertices = [];
        this.m_geometry.vertexColors = [];
        this.m_geometry.indices = [];
    }
    /**
     * Add the given points to this line group.
     *
     * @param center - World center of the provided points.
     * @param points - Sequence of (x,y,z) coordinates.
     * @param offsets - Sequence of line segment offsets.
     * @param uvs - Sequence of (u,v) texture coordinates.
     * @param colors - Sequence of (r,g,b) color components.
     */
    add(center, points, projection, offsets, uvs, colors) {
        if (!this.isSimple) {
            harp_utils_1.assert(!this.hasNormalsAndUvs || uvs !== undefined);
            createLineGeometry(center, points, projection, offsets, uvs, colors, this.m_geometry, this.highPrecision);
        }
        else {
            createSimpleLineGeometry(points, colors, this.m_geometry);
        }
        return this;
    }
    /**
     * Returns the list of vertices.
     */
    get vertices() {
        return this.m_geometry.vertices;
    }
    /**
     * Returns the list of vertex colors.
     */
    get vertexColors() {
        return this.m_geometry.vertexColors;
    }
    /**
     * Returns the list of indices.
     */
    get indices() {
        return this.m_geometry.indices;
    }
    /**
     * Returns the list of [[VertexAttributeDescriptor]]s.
     */
    get vertexAttributes() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;
    }
    /**
     * Returns the vertex attribute stride.
     */
    get stride() {
        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;
    }
    /**
     * Creates a three.js geometry.
     */
    createGeometry(geometry) {
        if (geometry === undefined) {
            geometry = new THREE.BufferGeometry();
        }
        return LineGroup.createGeometry(this.m_geometry.vertices, this.m_geometry.vertexColors, this.m_geometry.indices, geometry, this.hasNormalsAndUvs, this.highPrecision);
    }
}
exports.LineGroup = LineGroup;
function computeBitangent(n, t0, t1, bt) {
    let angle = 0;
    if (!t0.equals(t1)) {
        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));
        if (Number.isNaN(angle)) {
            angle = 0;
        }
    }
    bt.copy(t0).add(t1).normalize().cross(n).normalize();
    return angle;
}


/***/ }),

/***/ "../harp-lines/lib/TriangulateLines.ts":
/*!*********************************************!*\
  !*** ../harp-lines/lib/TriangulateLines.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reconstructLineWidth = exports.reconstructLine = exports.triangulateLine = exports.numCirclePoints = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const UNIT_Z = new THREE.Vector3(0, 0, 1);
const POINTS = [0, 1, 2, 1, 3, 2];
const BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];
const SECTORS_IN_CIRCLE = 8;
const STEP = Math.PI / SECTORS_IN_CIRCLE;
/**
 * Adds a half-circle geometry to original line
 *
 * @param x - The line end X (used as circle center X)
 * @param y - The line end Y (used as circle center Y)
 * @param lineAngle - The cap incline angle
 * @param radius - The cap (circle) radius
 * @param vertices - The input vertex buffer (cap vertices are added there)
 * @param indices - The input index buffer (cap indices are is added there)
 */
function addCircle(x, y, lineAngle, radius, vertices, indices) {
    const baseVertex = vertices.length / 3;
    // Add cap center to vertices directly (it doesn't need rotation)
    vertices.push(x, y, 0);
    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {
        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg
        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);
        indices.push(baseVertex, baseVertex + i + 1, baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1);
    }
}
/**
 * Returns the number of points in circle used for caps.
 *
 * @param lineWidth - Width of line.
 */
function numCirclePoints(lineWidth) {
    return SECTORS_IN_CIRCLE + 1;
}
exports.numCirclePoints = numCirclePoints;
/**
 * Create a triangle mesh from the given polyline.
 *
 * @param points - Sequence of (x,y,z) coordinates.
 * @param width - The width of the extruded line.
 * @param vertices - The output vertex buffer.
 * @param indices - The output index buffer.
 * @param startWithCircle - `true` if the line should start will a circle.
 * @param endWithCircle - `true` if the line should end with a circle.
 */
function triangulateLine(points, width, vertices, indices, startWithCircle = true, endWithCircle = startWithCircle) {
    if (points.length < 3) {
        return;
    }
    // This vector is used for computing cap angle
    const angleVec = new THREE.Vector2();
    if (startWithCircle) {
        // Define lineAngle as (direction - origin) vector angle to X axis
        const lineAngle = points.length !== 3
            ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()
            : 0;
        addCircle(points[0], points[1], lineAngle, width, vertices, indices);
    }
    const baseVertex = vertices.length / 3;
    // bt = Bitangent (i.e. extrusion vector)
    const prevBt = new THREE.Vector3();
    const p = new THREE.Vector3(); // current point
    const n = new THREE.Vector3(); // next point
    const bt = new THREE.Vector3();
    const averageBt = new THREE.Vector3();
    const p0 = new THREE.Vector3();
    const p1 = new THREE.Vector3();
    const p2 = new THREE.Vector3();
    const p3 = new THREE.Vector3();
    const N = points.length / 3;
    let vertexOffset = 0;
    for (let i = 0; i < N; ++i) {
        let useBevel = false;
        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);
        if (i + 1 < N) {
            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);
            bt.copy(n).sub(p).normalize().cross(UNIT_Z);
            averageBt.copy(bt);
            if (i > 0) {
                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));
                useBevel = prevBt.angleTo(bt) > Math.PI / 2;
                if (useBevel) {
                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);
                    p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);
                    p1.copy(prevBt).multiplyScalar(width).add(p);
                    // p2 is used for "miter" connections
                    p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);
                    p3.copy(bt).multiplyScalar(width).add(p);
                }
            }
            if (useBevel) {
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            }
            else {
                p0.copy(averageBt).multiplyScalar(-width).add(p);
                p1.copy(averageBt).multiplyScalar(width).add(p);
                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
            prevBt.copy(bt);
        }
        else {
            p0.copy(prevBt).multiplyScalar(-width).add(p);
            p1.copy(prevBt).multiplyScalar(width).add(p);
            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
        }
        if (i !== N - 1) {
            (useBevel ? BEVEL_POINTS : POINTS).forEach(o => indices.push(baseVertex + vertexOffset + o));
            vertexOffset += useBevel ? 4 : 2;
        }
    }
    if (endWithCircle) {
        const lineAngle = points.length !== 2
            ? angleVec
                .set(points[(N - 3) * 3] - points[(N - 2) * 3], points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1])
                .angle()
            : Math.PI;
        addCircle(points[(N - 2) * 3], points[(N - 2) * 3 + 1], lineAngle, width, vertices, indices);
    }
}
exports.triangulateLine = triangulateLine;
/**
 * Reconstruct the original points of a line from the vertices of the triangulated line.
 *
 * @param inBuffer - Buffer with vertices.
 * @param startOffset - Start index, will differ from `0` if the line has caps.
 * @returns Buffer containing the original points of the triangulated line.
 */
function reconstructLine(inBuffer, startOffset) {
    const outBuffer = new Float32Array(inBuffer.length / 2);
    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {
        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;
        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;
        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;
    }
    return outBuffer;
}
exports.reconstructLine = reconstructLine;
/**
 * Extract the line width from a triangulated line.
 *
 * @param inBuffer - Array of vertex elements of a triangulated line.
 * @param startIndex - Start index, will differ from `0` if the line has caps.
 */
function reconstructLineWidth(inBuffer, startIndex) {
    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];
    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];
    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];
    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;
}
exports.reconstructLineWidth = reconstructLineWidth;


/***/ }),

/***/ "../harp-lrucache/index.ts":
/*!*********************************!*\
  !*** ../harp-lrucache/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * LRU cache.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/LRUCache */ "../harp-lrucache/lib/LRUCache.ts"), exports);


/***/ }),

/***/ "../harp-lrucache/lib/LRUCache.ts":
/*!****************************************!*\
  !*** ../harp-lrucache/lib/LRUCache.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.Entry = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/** @hidden */
class Entry {
    constructor(key, value, size, newer, older) {
        this.key = key;
        this.value = value;
        this.size = size;
        this.newer = newer;
        this.older = older;
    }
}
exports.Entry = Entry;
/**
 * Fixed size cache that evicts its entries in least-recently-used order when it overflows.
 * Modeled after standard JavaScript `Map` otherwise.
 */
class LRUCache {
    /**
     * Creates a new instance of `LRUCache`.
     *
     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached
     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if
     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum
     * number of elements stored.
     *
     * @param cacheCapacity - Number used to configure the maximum cache size, may express
     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].
     * @param sizeFunction - A function determining the size per element.
     */
    constructor(cacheCapacity, sizeFunction = () => 1) {
        this.m_size = 0;
        /**
         * The internal map object that keeps the key-value pairs and their order.
         */
        this.m_map = new Map();
        /**
         * The newest entry, i.e. the most recently used item.
         */
        this.m_newest = null;
        /**
         * The oldest entry, i.e. the least recently used item.
         */
        this.m_oldest = null;
        this.m_capacity = cacheCapacity;
        this.m_sizeFunction = sizeFunction;
    }
    /**
     * Iterates over all items from the most recently used item to the least recently used one.
     *
     * **Note**: Results are undefined if the entire cache is modified during iteration. You may
     * although modify the current element in [[callbackfn]] function.
     *
     * @param callbackfn - The callback to call for each item.
     * @param thisArg - Optional this argument for the callback.
     */
    forEach(callbackfn, thisArg) {
        let entry = this.m_newest;
        while (entry !== null) {
            const older = entry.older;
            callbackfn.call(thisArg, entry.value, entry.key, this);
            entry = older;
        }
    }
    /**
     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.
     *
     * @returns The size of the cache.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache
     * can contain or the total amount of memory that may be consumed by cache if element size
     * function was specified in cache c-tor.
     *
     * @returns The capacity of the cache.
     */
    get capacity() {
        return this.m_capacity;
    }
    /**
     * @deprecated - DO NOT USE. Will be removed in future versions.
     *
     * Returns the internal map object that keeps the key-value pairs and their order.
     *
     * @returns The internal map object.
     */
    get map() {
        // ### TODO - remove me. Cache must not expose its internal object,
        // modifications to it are fatal for the internal state machine.
        return this.m_map;
    }
    /**
     * Returns the newest entry in the cache.
     *
     * @returns Newest entry in the cache.
     */
    get newest() {
        return this.m_newest;
    }
    /**
     * Returns the oldest entry in the cache.
     *
     * Note: Does not promote the oldest item as most recently used item.
     *
     * @returns Oldest entry in the cache.
     */
    get oldest() {
        return this.m_oldest;
    }
    /**
     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,
     * all items will be evicted until the cache shrinks to `newCapacity`.
     *
     * @param newCapacity - The new capacity of this cache.
     */
    setCapacity(newCapacity) {
        this.m_capacity = newCapacity;
        this.evict();
    }
    /**
     * Resets the cache capacity and function used to measure the element size.
     *
     * @param newCapacity - The new capacity masured in units returned from [[sizeMeasure]] funtion.
     * @param sizeMeasure - Function that defines the size of element, if you want to measure
     * number of elements only always return 1 from this function (default), you may also
     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.
     */
    setCapacityAndMeasure(newCapacity, sizeMeasure = () => 1) {
        this.m_capacity = newCapacity;
        this.m_sizeFunction = sizeMeasure;
        this.shrinkToCapacity();
    }
    /**
     * Updates the size of all elements in this cache. If their aggregated size is larger than the
     * capacity, items will be evicted until the cache shrinks to fit the capacity.
     */
    shrinkToCapacity() {
        let size = 0;
        const sizeFunction = this.m_sizeFunction;
        let entry = this.m_newest;
        while (entry !== null) {
            const entrySize = sizeFunction(entry.value);
            entry.size = entrySize;
            size += entrySize;
            entry = entry.older;
        }
        this.m_size = size;
        this.evict();
    }
    /**
     * Inserts or updates a key/value pair in the cache.
     *
     * If the key already existed in the cache, it will be updated and promoted to the most recently
     * used item.
     *
     * If the key didn't exist in the cache, it will be inserted as most recently used item. An
     * eviction of the least recently used item takes place if the cache exceeded its capacity.
     *
     * @param key - The key for the key-value pair to insert or update.
     * @param value - The value for the key-value pair to insert or update.
     */
    set(key, value) {
        const valueSize = this.m_sizeFunction(value);
        let entry = this.m_map.get(key);
        if (entry !== undefined) {
            this.m_size = this.m_size - entry.size + valueSize;
            entry.value = value;
            entry.size = valueSize;
            this.promoteEntry(entry);
            this.evict();
        }
        else {
            if (valueSize > this.m_capacity) {
                return; // single item too big to cache
            }
            entry = new Entry(key, value, valueSize, null, null);
            if (this.m_map.size === 0) {
                this.m_newest = this.m_oldest = entry;
            }
            else {
                harp_utils_1.assert(this.m_newest !== null);
                const newest = this.m_newest;
                entry.older = this.m_newest;
                newest.newer = entry;
                this.m_newest = entry;
            }
            this.m_map.set(key, entry);
            this.m_size += valueSize;
            this.evict();
        }
    }
    /**
     * Looks up key in the cache and returns the associated value.
     *
     * @param key - The key to look up.
     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.
     */
    get(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return undefined;
        }
        this.promoteEntry(entry);
        return entry.value;
    }
    /**
     * Test if a key/value pair is in the cache.
     *
     * @param key - The key to look up.
     * @returns `true` if the key-value pair is in the cache, `false` otherwise.
     */
    has(key) {
        return this.m_map.has(key);
    }
    /**
     * Clears the cache and removes all stored key-value pairs.
     *
     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the
     * eviction callback.
     */
    clear() {
        this.m_newest = this.m_oldest = null;
        this.m_size = 0;
        this.m_map.clear();
    }
    /**
     * Evicts all items from the cache, calling the eviction callback on each item.
     *
     * Use [[clear]] to remove all items without calling the eviction callback.
     */
    evictAll() {
        const cb = this.evictionCallback;
        if (cb !== undefined) {
            this.forEach((value, key) => cb(key, value));
        }
        this.clear();
    }
    /**
     * Evict selected elements from the cache using [[selector]] function.
     *
     * @param selector - The function for selecting elements for eviction.
     * @param thisArg - Optional _this_ object reference.
     */
    evictSelected(selector, thisArg) {
        const cb = this.evictionCallback;
        let entry = this.m_newest;
        while (entry !== null) {
            const entryOlder = entry.older;
            if (selector.call(thisArg, entry.value, entry.key)) {
                if (cb !== undefined) {
                    cb(entry.key, entry.value);
                }
                this.deleteEntry(entry);
                this.m_map.delete(entry.key);
            }
            entry = entryOlder;
        }
    }
    /**
     * Explicitly removes a key-value pair from the cache.
     *
     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.
     *
     * @param key - The key of the key-value pair to delete.
     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.
     */
    delete(key) {
        const entry = this.m_map.get(key);
        if (entry === undefined) {
            return false;
        }
        this.deleteEntry(entry);
        return this.m_map.delete(key);
    }
    evict() {
        while (this.m_oldest !== null && this.m_size > this.m_capacity) {
            const evicted = this.evictOldest();
            if (evicted === undefined) {
                return;
            }
        }
    }
    evictOldest() {
        harp_utils_1.assert(this.m_oldest !== null);
        const oldest = this.m_oldest;
        harp_utils_1.assert(oldest.older === null);
        let itemToRemove = oldest;
        if (this.canEvict !== undefined) {
            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {
                if (itemToRemove.newer === null) {
                    return undefined;
                }
                itemToRemove = itemToRemove.newer;
            }
        }
        if (itemToRemove === oldest) {
            this.m_oldest = itemToRemove.newer;
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = null;
            }
        }
        else {
            if (itemToRemove.newer !== null) {
                harp_utils_1.assert(itemToRemove.newer.older === itemToRemove);
                itemToRemove.newer.older = itemToRemove.older;
                if (itemToRemove.older !== null) {
                    itemToRemove.older.newer = itemToRemove.newer;
                }
            }
            else {
                return undefined;
            }
        }
        const isOk = this.m_map.delete(itemToRemove.key);
        harp_utils_1.assert(isOk === true);
        if (isOk && this.evictionCallback !== undefined) {
            this.evictionCallback(itemToRemove.key, itemToRemove.value);
        }
        this.m_size -= itemToRemove.size;
        return itemToRemove;
    }
    deleteEntry(entry) {
        if (entry === this.m_newest) {
            this.m_newest = entry.older;
        }
        else if (entry.newer) {
            entry.newer.older = entry.older;
        }
        else {
            harp_utils_1.assert(false);
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        else if (entry.older) {
            entry.older.newer = entry.newer;
        }
        else {
            harp_utils_1.assert(false);
        }
        this.m_size -= entry.size;
    }
    promoteEntry(entry) {
        if (entry === this.m_newest) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        if (entry.newer) {
            harp_utils_1.assert(entry.newer.older === entry);
            entry.newer.older = entry.older;
        }
        if (entry.older) {
            harp_utils_1.assert(entry.older.newer === entry);
            entry.older.newer = entry.newer;
        }
        if (entry === this.m_oldest) {
            this.m_oldest = entry.newer;
        }
        // re-link ourselves
        entry.newer = null;
        entry.older = this.m_newest;
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newest !== null);
        const newest = this.m_newest;
        harp_utils_1.assert(newest.newer === null);
        newest.newer = entry;
        this.m_newest = entry;
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ "../harp-map-controls/lib/MapControls.ts":
/*!***********************************************!*\
  !*** ../harp-map-controls/lib/MapControls.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapControls = exports.EventNames = exports.TiltState = void 0;
const geoUtils = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const utils = __webpack_require__(/*! ./Utils */ "../harp-map-controls/lib/Utils.ts");
var State;
(function (State) {
    State[State["NONE"] = 0] = "NONE";
    State[State["PAN"] = 1] = "PAN";
    State[State["ROTATE"] = 2] = "ROTATE";
    State[State["ORBIT"] = 3] = "ORBIT";
    State[State["TOUCH"] = 4] = "TOUCH";
})(State || (State = {}));
var TiltState;
(function (TiltState) {
    TiltState[TiltState["Tilted"] = 0] = "Tilted";
    TiltState[TiltState["Down"] = 1] = "Down";
})(TiltState = exports.TiltState || (exports.TiltState = {}));
/**
 * Map interaction events' names.
 */
var EventNames;
(function (EventNames) {
    EventNames["Update"] = "update";
    EventNames["BeginInteraction"] = "begin-interaction";
    EventNames["EndInteraction"] = "end-interaction";
})(EventNames = exports.EventNames || (exports.EventNames = {}));
// cast needed to workaround wrong three.js typings.
const MAPCONTROL_EVENT = { type: EventNames.Update };
const MAPCONTROL_EVENT_BEGIN_INTERACTION = {
    type: EventNames.BeginInteraction
};
const MAPCONTROL_EVENT_END_INTERACTION = {
    type: EventNames.EndInteraction
};
/**
 * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.
 */
const USER_INPUTS_TO_CONSIDER = 5;
/**
 * The default maximum for the camera tilt. This value avoids seeing the horizon.
 */
const DEFAULT_MAX_TILT_ANGLE = THREE.MathUtils.degToRad(89);
/**
 * Epsilon value to rule out when a number can be considered 0.
 */
const EPSILON = 0.01;
/**
 * Maximum duration between start and end touch events to define a finger tap.
 */
const MAX_TAP_DURATION = 120;
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
class MapControls extends harp_mapview_1.EventDispatcher {
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView - [[MapView]] this controller modifies.
     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of
     * `MapControls` if MapView itself is disposed.
     */
    constructor(mapView, disposeWithMapView = true) {
        super();
        this.mapView = mapView;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset for the rotation then.
         * Default value is `0.1`.
         */
        this.rotationMouseDeltaFactor = 0.1;
        /**
         * This factor will be applied to the delta of the current mouse pointer position and the last
         * mouse pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingMouseDeltaFactor = 0.1 * THREE.MathUtils.DEG2RAD;
        /**
         * This factor will be applied to the delta of the current touch pointer position and the last
         * touch pointer position: The result then will be used as an offset to orbit the camera.
         * Default value is `0.1`.
         */
        this.orbitingTouchDeltaFactor = 0.1 * THREE.MathUtils.DEG2RAD;
        /**
         * Set to `true` to enable input handling through this map control, `false` to disable input
         * handling. Even when disabling input handling, you can manually use the public functions to
         * change the view to the current map.
         */
        this.enabled = true;
        /**
         * Set to `true` to enable zooming through these controls, `false` otherwise.
         */
        this.zoomEnabled = true;
        /**
         * Set to `true` to enable panning through these controls, `false` otherwise.
         */
        this.panEnabled = true;
        /**
         * Set to `true` to enable tilting through these controls, `false` otherwise.
         */
        this.tiltEnabled = true;
        /**
         * Set to `true` to enable rotation through this map control, `false` to disable rotation.
         */
        this.rotateEnabled = true;
        /**
         * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
         */
        this.inertiaEnabled = true;
        /**
         * Inertia damping duration for the zoom, in seconds.
         */
        this.zoomInertiaDampingDuration = 0.6;
        /**
         * Inertia damping duration for the panning, in seconds.
         */
        this.panInertiaDampingDuration = 1.0;
        /**
         * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
         * inertia.
         */
        this.tiltToggleDuration = 0.5;
        /**
         * Camera tilt to the target when tilting from the `toggleTilt` public method.
         */
        this.tiltAngle = Math.PI / 4;
        /**
         * Duration of the animation to reset the camera to looking north, in seconds. Independent of
         * inertia.
         */
        this.northResetAnimationDuration = 1.5;
        /**
         * Zoom level delta when using the UI controls.
         */
        this.zoomLevelDeltaOnControl = 1.0;
        /**
         * Determines the minimum zoom level we can zoom to.
         */
        this.minZoomLevel = 0;
        /**
         * Determines the maximum zoom level we can zoom to.
         */
        this.maxZoomLevel = 20;
        /**
         * Determines the minimum camera height in meter.
         */
        this.minCameraHeight = 3;
        /**
         * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.
         */
        this.zoomLevelDeltaOnDoubleClick = 1.0;
        /**
         * Double click uses the OS delay through the double click event. Tapping is implemented locally
         * here in `MapControls` with this duration setting the maximum delay to define a double tap.
         * The value is in seconds. `300ms` is picked as the default value as jQuery does.
         */
        this.doubleTapTime = 0.3;
        this.m_currentViewDirection = new THREE.Vector3();
        this.m_lastMousePosition = new THREE.Vector2(0, 0);
        this.m_initialMousePosition = new THREE.Vector2(0, 0);
        this.m_mouseDelta = new THREE.Vector2(0, 0);
        this.m_needsRenderLastFrame = true;
        // Internal variables for animating panning (planar + spherical panning).
        this.m_panIsAnimated = false;
        this.m_panDistanceFrameDelta = new THREE.Vector3();
        this.m_panAnimationTime = 0;
        this.m_panAnimationStartTime = 0;
        this.m_lastAveragedPanDistanceOrAngle = 0;
        this.m_currentInertialPanningSpeed = 0;
        this.m_lastPanVector = new THREE.Vector3();
        this.m_rotateGlobeQuaternion = new THREE.Quaternion();
        this.m_lastRotateGlobeAxis = new THREE.Vector3();
        this.m_lastRotateGlobeAngle = 0;
        this.m_lastRotateGlobeFromVector = new THREE.Vector3();
        this.m_recentPanDistancesOrAngles = [
            0,
            0,
            0,
            0,
            0
        ];
        this.m_currentPanDistanceOrAngleIndex = 0;
        // Internal variables for animating zoom.
        this.m_zoomIsAnimated = false;
        this.m_zoomDeltaRequested = 0;
        this.m_zoomTargetNormalizedCoordinates = new THREE.Vector2();
        this.m_zoomAnimationTime = 0;
        this.m_zoomAnimationStartTime = 0;
        this.m_startZoom = 0;
        // Internal variables for animating tilt.
        this.m_tiltIsAnimated = false;
        this.m_tiltRequested = undefined;
        this.m_tiltAnimationTime = 0;
        this.m_tiltAnimationStartTime = 0;
        this.m_startTilt = 0;
        this.m_state = State.NONE;
        this.m_tmpVector2 = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        // Internal variables for animating double tap.
        this.m_tapStartTime = 0;
        this.m_lastSingleTapTime = 0;
        this.m_fingerMoved = false;
        this.m_isDoubleTap = false;
        // Internal variables for animating the movement resetting the north.
        this.m_resetNorthStartTime = 0;
        this.m_resetNorthIsAnimated = false;
        this.m_resetNorthAnimationDuration = 0;
        this.m_currentAzimuth = 0;
        this.m_lastAzimuth = 0;
        this.m_startAzimuth = 0;
        /**
         * Determines the maximum angle the camera can tilt to. It is defined in radians.
         */
        this.m_maxTiltAngle = DEFAULT_MAX_TILT_ANGLE;
        this.m_touchState = {
            touches: [],
            currentRotation: 0,
            initialRotation: 0
        };
        /**
         * Destroy this `MapControls` instance.
         *
         * Unregisters all global event handlers used. This is method should be called when you stop
         * using `MapControls`.
         * @override
         */
        this.dispose = () => {
            // replaced with real code in bindInputEvents
        };
        this.camera = mapView.camera;
        this.domElement = mapView.renderer.domElement;
        this.maxZoomLevel = mapView.maxZoomLevel;
        this.minZoomLevel = mapView.minZoomLevel;
        this.minCameraHeight = mapView.minCameraHeight;
        this.bindInputEvents(this.domElement);
        this.handleZoom = this.handleZoom.bind(this);
        this.handlePan = this.handlePan.bind(this);
        this.tilt = this.tilt.bind(this);
        this.resetNorth = this.resetNorth.bind(this);
        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);
        if (disposeWithMapView) {
            // Catch the disposal of `MapView`.
            mapView.addEventListener(harp_mapview_1.MapViewEventNames.Dispose, () => {
                this.dispose();
            });
        }
    }
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of
     * `MapControls` if MapView itself is disposed.
     */
    static create(mapView, disposeWithMapView = true) {
        return new MapControls(mapView, disposeWithMapView);
    }
    /**
     * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
     * movement the current zoom level will be added or subtracted by this value.
     *
     * The default values are:
     * - `0.2` when `inertiaEnabled` is `false` - this means that every 5th mouse wheel movement
     * you will cross a zoom level.
     * - `0.8`, otherwise.
     */
    get zoomLevelDeltaOnMouseWheel() {
        return this.m_zoomLevelDeltaOnMouseWheel !== undefined
            ? this.m_zoomLevelDeltaOnMouseWheel
            : this.inertiaEnabled
                ? 0.8
                : 0.2;
    }
    /**
     * Set the zoom level delta for a single mouse wheel movement.
     *
     * **Note**: To reverse the zoom direction, you can provide a negative value.
     */
    set zoomLevelDeltaOnMouseWheel(delta) {
        this.m_zoomLevelDeltaOnMouseWheel = delta;
    }
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get attitude() {
        const attitude = harp_mapview_1.MapViewUtils.extractAttitude(this.mapView, this.camera);
        return {
            yaw: THREE.MathUtils.radToDeg(attitude.yaw),
            pitch: THREE.MathUtils.radToDeg(attitude.pitch),
            roll: THREE.MathUtils.radToDeg(attitude.roll)
        };
    }
    /**
     * Reset the camera to looking north, in an orbiting movement around the target point instead
     * of changing the yaw (which would be the camera rotating on itself).
     */
    pointToNorth() {
        // Use pre-calculated target coordinates, otherwise we could call utility method to evaluate
        // geo-coordinates here:
        // targetGeoCoords = MapViewUtils.getTargetCoordinatesFromCamera(camera, projection)
        this.m_startAzimuth =
            Math.PI +
                harp_mapview_1.MapViewUtils.extractSphericalCoordinatesFromLocation(this.mapView, this.camera, this.mapView.target).azimuth;
        // Wrap between -PI and PI.
        this.m_startAzimuth = Math.atan2(Math.sin(this.m_startAzimuth), Math.cos(this.m_startAzimuth));
        if (this.m_startAzimuth === 0) {
            return;
        }
        this.stopExistingAnimations();
        this.m_resetNorthAnimationDuration = this.northResetAnimationDuration;
        this.m_currentAzimuth = this.m_startAzimuth;
        this.m_resetNorthStartTime = performance.now();
        this.resetNorth();
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC - Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC - Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel) {
        harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, targetPositionOnScreenXinNDC, targetPositionOnScreenYinNDC, zoomLevel, this.m_maxTiltAngle);
    }
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel - Zoom level.
     * @param screenTarget - Zoom target on screen.
     */
    setZoomLevel(zoomLevel, screenTarget = { x: 0, y: 0 }) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        // Register the zoom request
        this.m_startZoom = this.currentZoom;
        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_zoomAnimationStartTime = performance.now();
        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);
        this.handleZoom();
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    /**
     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt() {
        if (!this.enabled || !this.tiltEnabled) {
            return;
        }
        this.stopExistingAnimations();
        this.m_startTilt = this.currentTilt;
        const aimTilt = this.m_startTilt < EPSILON;
        this.m_tiltRequested = aimTilt ? this.tiltAngle : 0;
        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;
        this.m_tiltAnimationStartTime = performance.now();
        this.tilt();
    }
    /**
     * Set the camera height.
     */
    set cameraHeight(height) {
        //Set the cameras height according to the given zoom level.
        this.camera.position.setZ(height);
        this.camera.matrixWorldNeedsUpdate = true;
    }
    /**
     * Get the current camera height.
     */
    get cameraHeight() {
        // ### Sync with the way geoviz is computing the zoom level.
        return this.mapView.camera.position.z;
    }
    /**
     * Set camera max tilt angle. The value is clamped between 0 and 89 degrees. In sphere
     * projection, at runtime, the value is also clamped so that the camera does not look above the
     * horizon.
     *
     * @param angle - Angle in degrees.
     */
    set maxTiltAngle(angle) {
        this.m_maxTiltAngle = Math.max(0, Math.min(DEFAULT_MAX_TILT_ANGLE, THREE.MathUtils.degToRad(angle)));
    }
    /**
     * Get the camera max tilt angle in degrees.
     */
    get maxTiltAngle() {
        return THREE.MathUtils.radToDeg(this.m_maxTiltAngle);
    }
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted() {
        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;
    }
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState() {
        if (this.m_tiltState === undefined) {
            this.m_tiltState =
                this.currentTilt < EPSILON || this.m_tiltState === TiltState.Down
                    ? TiltState.Tilted
                    : TiltState.Down;
        }
        return this.m_tiltState;
    }
    set currentZoom(zoom) {
        this.m_currentZoom = zoom;
    }
    get currentZoom() {
        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;
    }
    set currentTilt(tilt) {
        this.m_currentTilt = tilt;
    }
    get currentTilt() {
        return THREE.MathUtils.degToRad(this.mapView.tilt);
    }
    get targetedTilt() {
        return this.m_targetedTilt === undefined
            ? this.m_currentTilt === undefined
                ? this.currentTilt
                : this.m_currentTilt
            : this.m_targetedTilt;
    }
    assignZoomAfterTouchZoomRender() {
        this.m_currentZoom = this.mapView.zoomLevel;
        this.m_targetedZoom = this.mapView.zoomLevel;
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.assignZoomAfterTouchZoomRender);
    }
    stopExistingAnimations() {
        this.stopResetNorth();
        this.stopZoom();
        this.stopPan();
        this.stopTilt();
    }
    resetNorth() {
        const currentTime = performance.now();
        const animationTime = (currentTime - this.m_resetNorthStartTime) / 1000;
        if (this.inertiaEnabled) {
            if (!this.m_resetNorthIsAnimated) {
                this.m_resetNorthIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
            }
            const resetNorthFinished = animationTime > this.m_resetNorthAnimationDuration;
            if (resetNorthFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.stopResetNorth();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_lastAzimuth = this.m_currentAzimuth;
        this.m_currentAzimuth = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startAzimuth, 0, Math.min(1, animationTime / this.m_resetNorthAnimationDuration))
            : 0;
        const deltaAzimuth = this.m_currentAzimuth - this.m_lastAzimuth;
        harp_mapview_1.MapViewUtils.orbitAroundScreenPoint(this.mapView, {
            deltaAzimuth,
            maxTiltAngle: this.m_maxTiltAngle
        });
        this.updateMapView();
    }
    stopResetNorth() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.resetNorth);
        this.m_resetNorthIsAnimated = false;
    }
    tilt() {
        if (this.m_tiltRequested !== undefined) {
            this.m_targetedTilt = Math.max(Math.min(this.m_tiltRequested, this.maxTiltAngle), 0);
            this.m_tiltRequested = undefined;
        }
        // Whether the tilt animation has reached full duration & a final frame is rendered. We need
        // this to know when to stop the tilt (and hence deregister the methon )
        let tiltAnimationFinished = false;
        if (this.inertiaEnabled) {
            if (!this.m_tiltIsAnimated) {
                this.m_tiltIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
            }
            const currentTime = performance.now();
            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;
            const tiltFinished = this.m_tiltAnimationTime >= this.tiltToggleDuration;
            if (tiltFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_tiltAnimationTime = this.tiltToggleDuration;
                    tiltAnimationFinished = true;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.m_currentTilt = this.inertiaEnabled
            ? this.easeOutCubic(this.m_startTilt, this.targetedTilt, Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration))
            : this.targetedTilt;
        const initialTilt = this.currentTilt;
        const deltaTilt = this.m_currentTilt - initialTilt;
        harp_mapview_1.MapViewUtils.orbitAroundScreenPoint(this.mapView, {
            deltaTilt,
            maxTiltAngle: this.m_maxTiltAngle
        });
        this.updateMapView();
        if (tiltAnimationFinished) {
            this.stopTilt();
        }
    }
    stopTilt() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.tilt);
        this.m_tiltIsAnimated = false;
        this.m_targetedTilt = this.m_currentTilt = undefined;
    }
    easeOutCubic(startValue, endValue, time) {
        // https://easings.net/#easeOutCubic
        return startValue + (endValue - startValue) * (1 - Math.pow(1 - time, 3));
    }
    easeOutCirc(startValue, endValue, time) {
        // https://easings.net/#easeOutCirc
        const easing = Math.sqrt(1 - Math.pow(time - 1, 2));
        return startValue + (endValue - startValue) * easing;
    }
    handleZoom() {
        let resetZoomState = false;
        if (this.m_zoomDeltaRequested !== 0) {
            this.m_targetedZoom = Math.max(Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel), this.minZoomLevel);
            this.m_zoomDeltaRequested = 0;
        }
        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {
            if (!this.m_zoomIsAnimated) {
                this.m_zoomIsAnimated = true;
                this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
            }
            const currentTime = performance.now();
            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;
            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;
            if (zoomFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;
                    resetZoomState = true;
                    this.stopZoom();
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
        }
        this.currentZoom =
            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON
                ? this.zoomLevelTargeted
                : this.easeOutCirc(this.m_startZoom, this.zoomLevelTargeted, Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration));
        const success = harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, this.m_zoomTargetNormalizedCoordinates.x, this.m_zoomTargetNormalizedCoordinates.y, this.currentZoom, this.m_maxTiltAngle);
        if (resetZoomState || !success) {
            this.m_targetedZoom = undefined;
            this.m_currentZoom = undefined;
        }
        this.updateMapView();
    }
    stopZoom() {
        this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handleZoom);
        this.m_zoomIsAnimated = false;
    }
    /**
     * Method to flip crpes.
     */
    handlePan() {
        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {
            return;
        }
        if (this.inertiaEnabled && !this.m_panIsAnimated) {
            this.m_panIsAnimated = true;
            this.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
        }
        const applyInertia = this.inertiaEnabled &&
            this.panInertiaDampingDuration > 0 &&
            this.m_state === State.NONE &&
            this.m_lastAveragedPanDistanceOrAngle > 0;
        if (applyInertia) {
            const currentTime = performance.now();
            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;
            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;
            if (panFinished) {
                if (this.m_needsRenderLastFrame) {
                    this.m_needsRenderLastFrame = false;
                    this.m_panAnimationTime = this.panInertiaDampingDuration;
                    this.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.AfterRender, this.handlePan);
                    this.m_panIsAnimated = false;
                }
            }
            else {
                this.m_needsRenderLastFrame = true;
            }
            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;
            this.m_currentInertialPanningSpeed = this.easeOutCubic(this.m_lastAveragedPanDistanceOrAngle, 0, Math.min(1, animationTime));
            if (this.m_currentInertialPanningSpeed === 0) {
                this.m_lastAveragedPanDistanceOrAngle = 0;
            }
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                this.m_panDistanceFrameDelta
                    .copy(this.m_lastPanVector)
                    .setLength(this.m_currentInertialPanningSpeed);
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                this.m_rotateGlobeQuaternion
                    .setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_currentInertialPanningSpeed)
                    .normalize();
            }
        }
        else {
            let panDistanceOrAngle = 0;
            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
                panDistanceOrAngle = this.m_lastPanVector
                    .copy(this.m_panDistanceFrameDelta)
                    .length();
            }
            else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
                panDistanceOrAngle = this.m_lastRotateGlobeAngle;
                this.m_rotateGlobeQuaternion.setFromAxisAngle(this.m_lastRotateGlobeAxis, this.m_lastRotateGlobeAngle);
                this.m_rotateGlobeQuaternion.normalize();
            }
            this.m_currentPanDistanceOrAngleIndex =
                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;
            this.m_recentPanDistancesOrAngles[this.m_currentPanDistanceOrAngleIndex] = panDistanceOrAngle;
            this.m_lastAveragedPanDistanceOrAngle =
                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;
        }
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            harp_mapview_1.MapViewUtils.panCameraAboveFlatMap(this.mapView, this.m_panDistanceFrameDelta.x, this.m_panDistanceFrameDelta.y);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            harp_mapview_1.MapViewUtils.panCameraAroundGlobe(this.mapView, this.m_lastRotateGlobeFromVector, this.m_tmpVector3
                .copy(this.m_lastRotateGlobeFromVector)
                .applyQuaternion(this.m_rotateGlobeQuaternion));
        }
        if (!applyInertia) {
            this.m_panDistanceFrameDelta.set(0, 0, 0);
            this.m_lastRotateGlobeAngle = 0;
        }
        this.updateMapView();
    }
    stopPan() {
        this.m_panDistanceFrameDelta.set(0, 0, 0);
        this.m_lastAveragedPanDistanceOrAngle = 0;
    }
    bindInputEvents(domElement) {
        const onContextMenu = this.contextMenu.bind(this);
        const onMouseDown = this.mouseDown.bind(this);
        const onMouseWheel = this.mouseWheel.bind(this);
        const onTouchStart = this.touchStart.bind(this);
        const onTouchEnd = this.touchEnd.bind(this);
        const onTouchMove = this.touchMove.bind(this);
        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);
        domElement.addEventListener("dblclick", onMouseDoubleClick, false);
        domElement.addEventListener("contextmenu", onContextMenu, false);
        domElement.addEventListener("mousedown", onMouseDown, false);
        domElement.addEventListener("wheel", onMouseWheel, false);
        domElement.addEventListener("touchstart", onTouchStart, false);
        domElement.addEventListener("touchend", onTouchEnd, false);
        domElement.addEventListener("touchmove", onTouchMove, false);
        this.dispose = () => {
            domElement.removeEventListener("dblclick", onMouseDoubleClick, false);
            domElement.removeEventListener("contextmenu", onContextMenu, false);
            domElement.removeEventListener("mousedown", onMouseDown, false);
            domElement.removeEventListener("wheel", onMouseWheel, false);
            domElement.removeEventListener("touchstart", onTouchStart, false);
            domElement.removeEventListener("touchend", onTouchEnd, false);
            domElement.removeEventListener("touchmove", onTouchMove, false);
        };
    }
    updateMapView() {
        this.dispatchEvent(MAPCONTROL_EVENT);
        this.mapView.update();
    }
    mouseDoubleClick(event) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        const mousePos = this.getPointerPosition(event);
        this.zoomOnDoubleClickOrTap(mousePos.x, mousePos.y);
    }
    mouseDown(event) {
        if (this.enabled === false) {
            return;
        }
        if (event.shiftKey) {
            return;
        }
        event.stopPropagation();
        if (this.m_state !== State.NONE) {
            return;
        }
        // Support mac users who press ctrl key when wanting to right click
        if (event.button === 0 && !event.ctrlKey && this.panEnabled) {
            this.m_state = State.PAN;
        }
        else if (event.button === 1) {
            this.m_state = State.ROTATE;
        }
        else if ((event.button === 2 || event.ctrlKey) && this.tiltEnabled) {
            this.m_state = State.ORBIT;
        }
        else {
            return;
        }
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        const mousePos = this.getPointerPosition(event);
        this.m_lastMousePosition.copy(mousePos);
        if (event.altKey === true) {
            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
            this.m_initialMousePosition.copy(utils.calculateNormalizedDeviceCoordinates(mousePos.x, mousePos.y, width, height));
        }
        else {
            harp_mapview_1.CameraUtils.getPrincipalPoint(this.mapView.camera, this.m_initialMousePosition);
        }
        const onMouseMove = this.mouseMove.bind(this);
        const onMouseUp = this.mouseUp.bind(this);
        window.addEventListener("mousemove", onMouseMove, false);
        window.addEventListener("mouseup", onMouseUp, false);
        this.m_cleanupMouseEventListeners = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
        };
    }
    mouseMove(event) {
        if (this.enabled === false) {
            return;
        }
        const mousePos = this.getPointerPosition(event);
        this.m_mouseDelta.set(mousePos.x - this.m_lastMousePosition.x, mousePos.y - this.m_lastMousePosition.y);
        if (this.m_state === State.PAN) {
            const vectors = this.getWorldPositionWithElevation(this.m_lastMousePosition.x, this.m_lastMousePosition.y, mousePos.x, mousePos.y);
            if (vectors === undefined) {
                return;
            }
            const { fromWorld, toWorld } = vectors;
            this.panFromTo(fromWorld, toWorld);
        }
        else if (this.m_state === State.ROTATE) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.rotate(this.mapView, -this.rotationMouseDeltaFactor * this.m_mouseDelta.x, this.rotationMouseDeltaFactor * this.m_mouseDelta.y, this.m_maxTiltAngle);
        }
        else if (this.m_state === State.ORBIT) {
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitAroundScreenPoint(this.mapView, {
                center: this.m_tmpVector2.set(this.m_initialMousePosition.x, this.m_initialMousePosition.y),
                deltaAzimuth: this.orbitingMouseDeltaFactor * this.m_mouseDelta.x,
                deltaTilt: -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y,
                maxTiltAngle: this.m_maxTiltAngle
            });
        }
        this.m_lastMousePosition.set(mousePos.x, mousePos.y);
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    mouseUp(event) {
        if (this.enabled === false) {
            return;
        }
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
        this.m_state = State.NONE;
        if (this.m_cleanupMouseEventListeners) {
            this.m_cleanupMouseEventListeners();
        }
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
    }
    mouseWheel(event) {
        if (!this.enabled || !this.zoomEnabled) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const screenTarget = utils.calculateNormalizedDeviceCoordinates(event.offsetX, event.offsetY, width, height);
        this.setZoomLevel(this.mapView.zoomLevel - this.zoomLevelDeltaOnMouseWheel * Math.sign(event.deltaY), screenTarget);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    updateCurrentRotation() {
        if (this.m_touchState.touches.length < 2 ||
            this.m_touchState.touches[1].currentWorldPosition.length() === 0 ||
            this.m_touchState.touches[0].currentWorldPosition.length() === 0) {
            return;
        }
        let x = 0;
        let y = 0;
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            // Planar uses world space coordinates to return the angle of the vector between the two
            // fingers' locations from the north direction.
            x =
                this.m_touchState.touches[1].currentWorldPosition.x -
                    this.m_touchState.touches[0].currentWorldPosition.x;
            y =
                this.m_touchState.touches[1].currentWorldPosition.y -
                    this.m_touchState.touches[0].currentWorldPosition.y;
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            // Globe uses screen space coordinates, as the 3d coordinate system cannot define a
            // reference rotation scalar for the vector between the two fingers' locations.
            x =
                this.m_touchState.touches[1].currentTouchPoint.x -
                    this.m_touchState.touches[0].currentTouchPoint.x;
            // Below the subtraction is inverted, because the Y coordinate in screen space in HTML
            // has its origin at the top and increases downwards.
            y =
                this.m_touchState.touches[0].currentTouchPoint.y -
                    this.m_touchState.touches[1].currentTouchPoint.y;
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
        this.m_touchState.currentRotation = Math.atan2(y, x);
    }
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    calculatePinchDistanceInWorldSpace() {
        if (this.m_touchState.touches.length < 2) {
            return 0;
        }
        const previousDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[1].initialWorldPosition)
            .length();
        const currentDistance = this.m_tmpVector3
            .subVectors(this.m_touchState.touches[0].currentWorldPosition, this.m_touchState.touches[1].currentWorldPosition)
            .length();
        return currentDistance - previousDistance;
    }
    convertTouchPoint(touch, oldTouchState) {
        // Acquire touch coordinates relative to canvas, this coordinates
        // are then used to calculate NDC values.
        const newTouchPoint = this.getPointerPosition(touch);
        if (oldTouchState !== undefined) {
            const oldTouchPoint = oldTouchState.currentTouchPoint;
            const vectors = this.getWorldPositionWithElevation(oldTouchPoint.x, oldTouchPoint.y, newTouchPoint.x, newTouchPoint.y);
            const toWorld = vectors === undefined ? new THREE.Vector3() : vectors.toWorld;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
        else {
            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
            const to = utils.calculateNormalizedDeviceCoordinates(newTouchPoint.x, newTouchPoint.y, width, height);
            const result = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
            const toWorld = result === null ? new THREE.Vector3() : result;
            // Unless the user is tilting, considering a finger losing the surface as a touchEnd
            // event. Inertia will get triggered.
            if (toWorld.length() === 0 &&
                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)) {
                this.setTouchState([]);
                this.m_state = State.NONE;
                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
                return;
            }
            if (this.m_state !== State.TOUCH) {
                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
            }
            this.m_state = State.TOUCH;
            return {
                currentTouchPoint: newTouchPoint,
                lastTouchPoint: newTouchPoint,
                currentWorldPosition: toWorld,
                initialWorldPosition: toWorld
            };
        }
    }
    setTouchState(touches) {
        this.m_touchState.touches = [];
        // TouchList doesn't conform to iterator interface so we cannot use 'for of'
        for (let i = 0; i < touches.length; ++i) {
            const touchState = this.convertTouchPoint(touches[i]);
            if (touchState !== undefined) {
                this.m_touchState.touches.push(touchState);
            }
        }
        if (this.m_touchState.touches.length !== 0) {
            this.updateCurrentRotation();
            this.m_touchState.initialRotation = this.m_touchState.currentRotation;
        }
    }
    updateTouches(touches) {
        const length = Math.min(touches.length, this.m_touchState.touches.length);
        for (let i = 0; i < length; ++i) {
            const oldTouchState = this.m_touchState.touches[i];
            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);
            if (newTouchState !== undefined && oldTouchState !== undefined) {
                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;
                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;
                this.m_touchState.touches[i] = newTouchState;
            }
        }
    }
    zoomOnDoubleClickOrTap(x, y) {
        if (this.zoomLevelDeltaOnDoubleClick === 0) {
            return;
        }
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);
        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);
    }
    touchStart(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_tapStartTime = performance.now();
        this.m_fingerMoved = false;
        this.m_state = State.TOUCH;
        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);
        this.setTouchState(event.touches);
        this.updateTouches(event.touches);
        event.preventDefault();
        event.stopPropagation();
    }
    touchMove(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_fingerMoved = true;
        this.updateTouches(event.touches);
        if (this.panEnabled &&
            this.m_touchState.touches.length <= 2 &&
            this.m_touchState.touches[0] !== undefined) {
            this.panFromTo(this.m_touchState.touches[0].initialWorldPosition, this.m_touchState.touches[0].currentWorldPosition);
        }
        if (this.m_touchState.touches.length === 2) {
            const touches = this.m_touchState.touches;
            const center = new THREE.Vector2();
            if (this.zoomEnabled === true || this.rotateEnabled === true) {
                const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
                touches.forEach(touch => {
                    const ndcPoint = utils.calculateNormalizedDeviceCoordinates(touch.currentTouchPoint.x, touch.currentTouchPoint.y, width, height);
                    center.add(ndcPoint);
                });
                center.divideScalar(touches.length);
            }
            if (this.zoomEnabled) {
                const pinchDistance = this.calculatePinchDistanceInWorldSpace();
                if (Math.abs(pinchDistance) < EPSILON) {
                    return;
                }
                const newZL = harp_mapview_1.MapViewUtils.calculateZoomLevelFromDistance(this.mapView, this.mapView.targetDistance - pinchDistance);
                harp_mapview_1.MapViewUtils.zoomOnTargetPosition(this.mapView, center.x, center.y, newZL, this.m_maxTiltAngle);
            }
            if (this.rotateEnabled) {
                this.updateCurrentRotation();
                const deltaAzimuth = this.m_touchState.currentRotation - this.m_touchState.initialRotation;
                this.stopExistingAnimations();
                harp_mapview_1.MapViewUtils.orbitAroundScreenPoint(this.mapView, {
                    center: this.m_tmpVector2.set(center.x, center.y),
                    deltaAzimuth,
                    maxTiltAngle: this.m_maxTiltAngle
                });
            }
        }
        // Tilting
        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {
            const firstTouch = this.m_touchState.touches[0];
            const diff = this.m_tmpVector2.subVectors(firstTouch.currentTouchPoint, firstTouch.lastTouchPoint);
            this.stopExistingAnimations();
            harp_mapview_1.MapViewUtils.orbitAroundScreenPoint(this.mapView, {
                deltaAzimuth: this.orbitingTouchDeltaFactor * diff.x,
                deltaTilt: -this.orbitingTouchDeltaFactor * diff.y,
                maxTiltAngle: this.m_maxTiltAngle
            });
        }
        this.m_zoomAnimationStartTime = performance.now();
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    touchEnd(event) {
        if (this.enabled === false) {
            return;
        }
        this.m_state = State.NONE;
        this.handleDoubleTap();
        this.setTouchState(event.touches);
        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);
        this.updateMapView();
        event.preventDefault();
        event.stopPropagation();
    }
    handleDoubleTap() {
        // Continue only if no touchmove happened and zoom's enabled.
        if (this.m_fingerMoved || !this.zoomEnabled) {
            return;
        }
        const now = performance.now();
        const tapDuration = now - this.m_tapStartTime;
        // Continue only if proper tap.
        if (tapDuration > MAX_TAP_DURATION) {
            return;
        }
        // Continue only if this is the second valid tap.
        if (!this.m_isDoubleTap) {
            this.m_isDoubleTap = true;
            this.m_lastSingleTapTime = now;
            return;
        }
        // Continue only if the delay between the two taps is short enough.
        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {
            // If too long, restart double tap validator too.
            this.m_isDoubleTap = false;
            return;
        }
        this.zoomOnDoubleClickOrTap(this.m_touchState.touches[0].currentTouchPoint.x, this.m_touchState.touches[0].currentTouchPoint.y);
        // Prevent a string of X valid taps and only consider pairs.
        this.m_isDoubleTap = false;
    }
    contextMenu(event) {
        event.preventDefault();
    }
    getWorldPositionWithElevation(fromX, fromY, toX, toY) {
        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);
        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);
        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);
        let toWorld;
        let fromWorld;
        let elevationProviderResult;
        if (this.mapView.elevationProvider !== undefined) {
            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);
        }
        if (elevationProviderResult === undefined) {
            fromWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);
        }
        else {
            fromWorld = elevationProviderResult;
            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);
            // We can ensure that points under the mouse stay there by projecting the to point onto
            // a plane with the altitude based on the initial point.
            toWorld = harp_mapview_1.MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y, fromGeoAltitude);
        }
        if (fromWorld === null || toWorld === null) {
            return;
        }
        return { fromWorld, toWorld };
    }
    panFromTo(fromWorld, toWorld) {
        this.stopExistingAnimations();
        // Assign the new animation start time.
        this.m_panAnimationStartTime = performance.now();
        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {
            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);
        }
        else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {
            this.m_lastRotateGlobeFromVector.copy(fromWorld);
            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();
            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);
            // When fromWorld and toWorld are too close, there is a risk of getting an NaN
            // value. The following ensures that the controls don't break.
            if (isNaN(this.m_lastRotateGlobeAngle)) {
                this.m_lastRotateGlobeAngle = 0;
            }
        }
        this.handlePan();
    }
    /**
     * Acquire mouse or touch pointer position relative to canvas for `MouseEvent` or `Touch` event.
     *
     * Function takes into account canvas position in client space (including scrolling) as also
     * canvas scaling factor.
     *
     * @param event - The mouse event.
     * @returns [[THREE.Vector2]] containing _x_, _y_ mouse pointer position.
     */
    getPointerPosition(event) {
        const canvasSize = utils.getWidthAndHeightFromCanvas(this.domElement);
        // Absolute size of a canvas
        const rect = this.domElement.getBoundingClientRect();
        // TODO: Test if scaling is needed and works on HiDPI devices.
        const scaleX = Math.round(rect.width) / canvasSize.width;
        const scaleY = Math.round(rect.height) / canvasSize.height;
        // Scale mouse coordinates after they have, been adjusted to be relative to element.
        return new THREE.Vector2((event.clientX - Math.floor(rect.left)) * scaleX, (event.clientY - Math.floor(rect.top)) * scaleY);
    }
}
exports.MapControls = MapControls;


/***/ }),

/***/ "../harp-map-controls/lib/MapControlsUI.ts":
/*!*************************************************!*\
  !*** ../harp-map-controls/lib/MapControlsUI.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapControlsUI = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
/**
 * Base class to handle UI overlay elements.
 */
class MapControlsUI {
    /**
     * Constructor of the UI.
     *
     * @param controls - Controls referencing a [[MapView]].
     */
    constructor(controls, options = {}) {
        this.controls = controls;
        /**
         * The DOM node containing the UI.
         */
        this.domElement = document.createElement("div");
        this.m_buttonsElement = document.createElement("div");
        /**
         * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.
         */
        this.m_zoomLevelElement = null;
        /**
         * Displays zoom level if [[MapControlsUIOptions.projectionSwitch]] is defined.
         */
        this.m_projectionSwitchElement = null;
        this.m_onMapViewRenderEvent = () => {
            if (this.m_zoomLevelElement === null) {
                return;
            }
            const zoom = this.controls.zoomLevelTargeted.toFixed(1);
            if (this.m_zoomLevelElement.tagName === "INPUT") {
                this.m_zoomLevelElement.value = zoom;
            }
            else {
                this.m_zoomLevelElement.innerHTML = zoom;
            }
        };
        this.m_onWindowClick = (event) => {
            const input = this.m_zoomLevelElement;
            if (!event ||
                !event.target ||
                !event.target.contains ||
                event.target === input ||
                event.target.contains(input)) {
                return;
            }
            input.blur();
        };
        // Empty element to dynamically align the controls vertically, depending on which buttons
        // are enabled. Avoids unreliable style computations in the script.
        const verticalAligner = document.createElement("span");
        verticalAligner.className = "harp-gl_v-align";
        this.domElement.appendChild(verticalAligner);
        // This element will receive the controls and ensure the vertical alignment in the CSS.
        this.m_buttonsElement = document.createElement("div");
        this.m_buttonsElement.className = "harp-gl_v-aligned";
        this.domElement.appendChild(this.m_buttonsElement);
        const zoomInButton = document.createElement("button");
        zoomInButton.innerText = "+";
        zoomInButton.className = "harp-gl_controls_button-top";
        zoomInButton.classList.add("harp-gl_controls-button");
        const zoomOutButton = document.createElement("button");
        zoomOutButton.innerText = "-";
        zoomOutButton.className = "harp-gl_controls_button-bottom";
        zoomOutButton.classList.add("harp-gl_controls-button");
        const tiltButton = document.createElement("button");
        tiltButton.innerText = "3D";
        tiltButton.id = "harp-gl_controls_tilt-button-ui";
        tiltButton.title = "Toggle tilt";
        tiltButton.classList.add("harp-gl_controls-button");
        tiltButton.classList.add("harp-gl_controls_button-bottom");
        const compassButton = document.createElement("button");
        compassButton.id = "harp-gl_controls-button_compass";
        compassButton.title = "Reset North";
        compassButton.classList.add("harp-gl_controls-button");
        compassButton.classList.add("harp-gl_controls_button-top");
        const compass = document.createElement("span");
        compass.id = "harp-gl_controls_compass";
        compassButton.appendChild(compass);
        // Optional zoom level displaying
        if (options.zoomLevel === "show") {
            this.m_zoomLevelElement = document.createElement("div");
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        }
        else if (options.zoomLevel === "input") {
            const input = document.createElement("input");
            input.type = "number";
            input.step = "0.1"; // Avoids messages in the UI on hovering, when a tenth value exists.
            controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
            const updateZoom = (event) => {
                controls.setZoomLevel(parseFloat(input.value));
                event.preventDefault();
            };
            input.addEventListener("blur", updateZoom);
            input.addEventListener("keypress", event => {
                if (event.key === "Enter") {
                    updateZoom(event);
                }
            });
            window.addEventListener("click", this.m_onWindowClick);
            this.m_zoomLevelElement = input;
        }
        if (options.projectionSwitch) {
            const switcher = document.createElement("button");
            switcher.id = "harp-gl_controls_switch_projection";
            switcher.classList.add("harp-gl_controls-button");
            const getTitle = () => {
                return `Switch to ${this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? "flat"
                    : "globe"} projection`;
            };
            switcher.title = getTitle();
            const globeSVG = getGlobeSVG();
            const flatMapSVG = getFlatMapSVG();
            switcher.innerHTML =
                this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                    ? flatMapSVG
                    : globeSVG;
            switcher.addEventListener("click", () => {
                this.controls.mapView.projection =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? harp_geoutils_1.mercatorProjection
                        : harp_geoutils_1.sphereProjection;
                switcher.title = getTitle();
                switcher.innerHTML =
                    this.controls.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
                        ? flatMapSVG
                        : globeSVG;
            });
            this.m_projectionSwitchElement = switcher;
        }
        this.m_buttonsElement.appendChild(zoomInButton);
        if (this.m_zoomLevelElement !== null) {
            this.m_buttonsElement.appendChild(this.m_zoomLevelElement);
        }
        this.m_buttonsElement.appendChild(zoomOutButton);
        this.m_buttonsElement.appendChild(compassButton);
        this.m_buttonsElement.appendChild(tiltButton);
        if (this.m_projectionSwitchElement !== null) {
            this.m_buttonsElement.appendChild(this.m_projectionSwitchElement);
        }
        zoomInButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomInButton.addEventListener("dblclick", event => {
            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers
            // when a zoom button is quickly clicked multiple times.
            event.stopPropagation();
        });
        zoomOutButton.addEventListener("click", event => {
            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;
            controls.setZoomLevel(zoomLevel);
        });
        zoomOutButton.addEventListener("dblclick", event => {
            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers
            // when a zoom button is quickly clicked multiple times.
            event.stopPropagation();
        });
        tiltButton.addEventListener("click", event => {
            controls.toggleTilt();
        });
        compassButton.addEventListener("click", event => {
            controls.pointToNorth();
        });
        controls.mapView.addEventListener(harp_mapview_1.MapViewEventNames.AfterRender, () => {
            compass.style.transform = `rotate(${controls.mapView.heading}deg)`;
        });
        this.domElement.className = "harp-gl_controls";
        if (this.m_zoomLevelElement !== null) {
            this.m_zoomLevelElement.classList.add("harp-gl_controls_zoom-level");
        }
        if (options.disableDefaultStyle !== true) {
            this.initStyle();
            this.domElement.style.cssText = `
                position: absolute;
                right: 5px;
                top: 0;
                height: 100%; /* Vertical alignment is done dynamically, in the rest of the CSS. */
                pointer-events: none; /* Allows to click the map even though height is 100%. */
            `;
        }
        return this;
    }
    get projectionSwitchElement() {
        return this.m_projectionSwitchElement;
    }
    /**
     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method
     * should be called when you stop using [[MapControlsUI]].
     */
    dispose() {
        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === "INPUT") {
            window.removeEventListener("click", this.m_onWindowClick);
        }
        this.controls.mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_onMapViewRenderEvent);
        this.domElement.remove();
    }
    initStyle() {
        if (document.getElementById("here-harp-controls.map-controls-ui-styles") !== null) {
            return;
        }
        const style = document.createElement("style");
        style.id = "here-harp-controls.map-controls-ui-styles";
        style.appendChild(document.createTextNode(getTextStyle()));
        document.head.appendChild(style);
    }
}
exports.MapControlsUI = MapControlsUI;
function getTextStyle() {
    return `
        /* CSS trick to align another div dynamically. */
        .harp-gl_v-align{
            height: 100%;
            display: inline-block;
            vertical-align: middle;
        }
        /* The target element to align vertically with vertical-align. */
        .harp-gl_v-aligned{
            pointer-events: all;
            vertical-align: middle;
            display: inline-block;
        }
        .harp-gl_controls-button {
            display: block;
            background-color: #272d37;
            width: 40px;
            height: 40px;
            font-size: 22px;
            font-weight: bold;
            outline: none;
            margin:0;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            border-radius: 4px;
            box-shadow: 0px 0px 5px 0 hsl(220, 4%, 40%);
            transition: all 0.1s;
            padding: 0 0 1px 1px;
            user-select: none;
            position:relative;
        }
        #harp-gl_controls_tilt-button-ui {
            font-size: 16px;
        }
        .harp-gl_controls-button:active {
            background-color: #37afaa;
            color: #eee;
        }
        .harp-gl_controls-button:focus {
            outline:none;
        }
        .harp-gl_controls_button-top{
            margin-bottom:0;
            border-bottom-right-radius:0;
            border-bottom-left-radius:0;
        }
        .harp-gl_controls_button-bottom{
            margin-top:1px;
            border-top-right-radius:0;
            border-top-left-radius:0;
        }
        .harp-gl_controls_zoom-level {
            display: block;
            background-color: #fff;
            width: 40px;
            height: 20px;
            font-size: 12px;
            font-weight: bold;
            outline: none;
            border: none;
            color: #555;
            opacity: 0.87;
            box-shadow: 0px 0px 4px #aaa;
            padding: 2px 0 0;
            text-align: center;
            user-select: text;
        }
        input.harp-gl_controls_zoom-level::-webkit-outer-spin-button,
        input.harp-gl_controls_zoom-level::-webkit-inner-spin-button {
            /* display: none; <- Crashes Chrome on hover */
            -webkit-appearance: none;
            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */
        }
        input.harp-gl_controls_zoom-level[type=number] {
            -moz-appearance:textfield; /* Firefox */
        }
        #harp-gl_controls-button_compass{
            overflow: hidden;
            margin: 5px 0 0 0;
        }
        #harp-gl_controls_compass{
            pointer-events:none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin:0
        }
        #harp-gl_controls_compass::after{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top: -18px;
            border:solid 3px rgba(0,0,0,0);
            border-bottom:solid 15px #a34f2e;
        }
        #harp-gl_controls_compass::before{
            content: " ";
            position:absolute;
            left:50%;
            margin-left:-3px;
            top:50%;
            margin-top:0px;
            border:solid 3px rgba(0,0,0,0);
            border-top:solid 15px #eee;
        }
        #harp-gl_controls_switch_projection{
            margin-top:5px;
        }
        .harp-gl_controls_switch_svg{
            width: 25px;
            height: 25px;
            stroke: #d4d5d7;
            fill: #d4d5d7;
        }
    `;
}
function getFlatMapSVG() {
    return `
    <svg style="margin-top:5px;" class="harp-gl_controls_switch_svg" width="25" height="25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <rect id="svg_1" stroke-width="2" height="13.51524" width="18.35821" y="5.80349" x="3.21307" fill="none"/>
        <path id="svg_14" d="m9.52018,7.71815l1.2357,-0.0032l-0.61945,1.18258l-0.61625,-1.17938z"/>
        <path id="svg_15" d="m4.11409,7.32396l3.65718,-0.0032l0.28156,2.13991l-2.59042,1.57678l0.50682,1.80203l2.25254,0.8447l-0.90101,2.0836l0.28157,2.25254l-3.26619,-3.04093l0.67576,-2.02728l-0.61945,-1.97097l-1.01364,-3.15356l0.73528,-0.50362z"/>
        <path id="svg_17" d="m13.23688,7.4929l2.02409,-0.0032l0.78839,1.29521l2.47779,-1.35152l2.75936,0.78839l0,1.57678l-0.73208,0.61945l-0.28157,1.97097c0,0 -0.67256,0.8479 -0.72888,0.90422c-0.05631,0.05631 0.28157,1.06996 0.33788,1.18258c0.05631,0.11263 -1.68941,-1.35152 -1.6926,-1.35472c-0.0032,-0.0032 -0.16574,1.29841 -0.16894,1.29521c-0.0032,-0.0032 -1.57358,-1.34832 -1.57678,-1.35152c-0.0032,-0.0032 -0.72888,0.67896 -0.73208,0.67576c-0.0032,-0.0032 -0.8415,-0.67256 -0.8447,-0.67576c-0.0032,-0.0032 0.73528,2.0868 0.79159,2.0868c0.05631,0 -0.50682,3.20987 -0.51002,3.20667c-0.0032,-0.0032 -1.2357,-0.16574 -1.34832,-0.16574c-0.11263,0 -0.95733,-1.52046 -0.90102,-1.57678c0.05631,-0.05631 0,-1.80203 -0.0032,-1.80523c-0.0032,-0.0032 -1.40464,-0.33468 -1.40784,-0.33788c-0.0032,-0.0032 -0.05311,-1.74252 -0.05631,-1.74572c-0.0032,-0.0032 1.18578,-0.8415 1.18258,-0.8447c-0.0032,-0.0032 1.69261,-0.16574 1.74892,-0.16574c0.05631,0 1.2389,-1.06996 1.2357,-1.07316c-0.0032,-0.0032 -1.91146,-0.10943 -1.91466,-0.11263c-0.0032,-0.0032 -1.96777,0.17214 -1.97097,0.16894c-0.0032,-0.0032 1.52366,-3.20667 1.52366,-3.20667z"/>
    </svg>`;
}
function getGlobeSVG() {
    return `
    <svg style="margin-top:5px;" stroke-width="2" class="harp-gl_controls_switch_svg" width="50" height="50" viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg">
        <ellipse ry="9.79855" rx="4.56139" id="svg_6" cy="11.99798" cx="11.99798" fill="none"/>
        <line id="svg_8" y2="8.16866" x2="21.12086" y1="8.16866" x1="3.10044"/>
        <line id="svg_9" y2="16.10887" x2="21.0645" y1="16.10887" x1="3.04409"/>
        <ellipse id="svg_11" ry="9.79855" rx="9.82671" cy="11.94167" cx="12.02614" fill="none"/>
    </svg>`;
}


/***/ }),

/***/ "../harp-map-controls/lib/Utils.ts":
/*!*****************************************!*\
  !*** ../harp-map-controls/lib/Utils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWidthAndHeightFromCanvas = exports.safeParseDecimalInt = exports.azimuthAltitudeToDirection = exports.calculateNormalizedDeviceCoordinates = void 0;
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * Transforms the given point in screen space into NDC space by taking the given screen dimension
 * into account.
 *
 * @param screenCoordinateX - X coordinate in screen space.
 * @param screenCoordinateY - Y coordinate in screen space.
 * @param screenSizeX - Width of the reference screen size.
 * @param screenSizeY - Height of the reference screen size.
 */
function calculateNormalizedDeviceCoordinates(screenCoordinateX, screenCoordinateY, screenSizeX, screenSizeY) {
    return new three_1.Vector2((screenCoordinateX / screenSizeX) * 2 - 1, -((screenCoordinateY / screenSizeY) * 2) + 1);
}
exports.calculateNormalizedDeviceCoordinates = calculateNormalizedDeviceCoordinates;
/**
 * Returns the direction vector that is described by the given azimuth and altitude.
 *
 * @param azimuth - Azimuth in radians.
 * @param altitude - Altitude in radians.
 */
function azimuthAltitudeToDirection(azimuth, altitude) {
    azimuth = azimuth;
    altitude = altitude;
    //Shamelessly copied from Jan ;)
    const result = new three_1.Vector3();
    const cosAltitude = Math.cos(altitude);
    result.setX(Math.sin(azimuth) * cosAltitude);
    result.setY(Math.cos(azimuth) * cosAltitude);
    result.setZ(Math.sin(altitude));
    return result;
}
exports.azimuthAltitudeToDirection = azimuthAltitudeToDirection;
/**
 * Safely parses decimal value into `number`.
 *
 * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings
 * with characters other than digits.
 *
 * @param text - Number as a text to be parsed.
 * @param fallback - Default value, which is returned if `text` doesn't represent a valid number.
 */
function safeParseDecimalInt(text, fallback) {
    if (text === null || text === undefined || text === "") {
        return fallback;
    }
    if (!text.match(integerRe)) {
        return fallback;
    }
    const result = Number.parseInt(text, 10);
    if (isNaN(result)) {
        return fallback;
    }
    return result;
}
exports.safeParseDecimalInt = safeParseDecimalInt;
const integerRe = /^\d+$/;
/**
 * Extracts the CSS width and height of the given canvas if available, or width and height of the
 * canvas otherwise.
 *
 * @param canvas - The canvas.
 */
function getWidthAndHeightFromCanvas(canvas) {
    return {
        //use clientWidth and clientHeight to support HiDPI devices
        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),
        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)
    };
}
exports.getWidthAndHeightFromCanvas = getWidthAndHeightFromCanvas;


/***/ }),

/***/ "../harp-mapview-decoder/index.ts":
/*!****************************************!*\
  !*** ../harp-mapview-decoder/index.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Decoder worker for {@ref MapView}.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/DataProvider */ "../harp-mapview-decoder/lib/DataProvider.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileDataSource */ "../harp-mapview-decoder/lib/TileDataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts"), exports);


/***/ }),

/***/ "../harp-mapview-decoder/lib/DataProvider.ts":
/*!***************************************************!*\
  !*** ../harp-mapview-decoder/lib/DataProvider.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataProvider = void 0;
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const three_1 = __webpack_require__(/*! three */ "three");
/**
 * Interface for all `DataProvider` subclasses.
 *
 * @remarks
 * The `DataProvider` is an abstraction of the tile
 * loader which is only responsible for loading the data of a specific tile,
 * without any relation to displaying or even decoding the data.
 */
class DataProvider extends three_1.EventDispatcher {
    constructor() {
        super(...arguments);
        this.m_clients = new Set();
    }
    /**
     * Registers a client to the data provider.
     *
     * @param client - The client to register.
     * @returns Promise to wait for successful (or failed) connection to the data source.
     */
    register(client) {
        if (this.m_clients.size === 0) {
            this.m_connectPromise = this.connect();
        }
        this.m_clients.add(client);
        return this.m_connectPromise;
    }
    /**
     * Unregisters a client from the data provider.
     *
     * @param client - The client to unregister.
     */
    unregister(client) {
        if (this.m_clients.delete(client) && this.m_clients.size === 0) {
            this.dispose();
        }
    }
}
exports.DataProvider = DataProvider;


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileDataSource.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileDataSource.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileDataSource = exports.TileFactory = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const ThemeLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TileLoader_1 = __webpack_require__(/*! ./TileLoader */ "../harp-mapview-decoder/lib/TileLoader.ts");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource - [[Datasource]] this class belongs to.
     * @param tileKey - Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        const tile = new this.m_modelConstructor(dataSource, tileKey);
        tile.tileLoader = new TileLoader_1.TileLoader(dataSource, tileKey, dataSource.dataProvider(), dataSource.decoder);
        return tile;
    }
}
exports.TileFactory = TileFactory;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory - Factory to create the [[Tile]] instances.
     * @param m_options - Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        var _a, _b;
        super(m_options);
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount, m_options.workerConnectionTimeout);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.useGeometryLoader = true;
        this.cacheable = true;
        this.m_unregisterClearTileCache = (_b = (_a = this.dataProvider()).onDidInvalidate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.mapView.markTilesDirty(this));
    }
    /** @override */
    dispose() {
        var _a;
        (_a = this.m_unregisterClearTileCache) === null || _a === void 0 ? void 0 : _a.call(this);
        this.decoder.dispose();
        this.dataProvider().unregister(this);
    }
    /** @override */
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    /** @override */
    async connect() {
        await Promise.all([this.m_options.dataProvider.register(this), this.m_decoder.connect()]);
        this.m_isReady = true;
        let customOptions = {};
        if (this.m_options.storageLevelOffset !== undefined) {
            customOptions = {
                storageLevelOffset: this.m_options.storageLevelOffset
            };
        }
        this.m_decoder.configure({ languages: this.languages }, customOptions);
    }
    /**
     * @override
     */
    setLanguages(languages) {
        this.languages = languages;
        this.m_decoder.configure({
            languages: this.languages
        });
        this.mapView.clearTileCache(this.name);
    }
    /**
     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.
     *
     * Applies new {@here/harp-datasource-protocol StyleSet} and definitions from theme only
     * if matching styleset (see `styleSetName` property) is found in `theme`.
     * @override
     */
    async setTheme(theme, languages) {
        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.
        theme = await ThemeLoader_1.ThemeLoader.load(theme);
        const styleSet = harp_datasource_protocol_1.getStyles(theme.styles).filter(style => {
            return !style.styleSet || style.styleSet === this.styleSetName;
        });
        if (languages !== undefined) {
            this.languages = languages;
        }
        if (styleSet.length > 0) {
            this.m_decoder.configure({
                styleSet,
                definitions: theme.definitions,
                priorities: theme.priorities,
                labelPriorities: theme.labelPriorities,
                languages
            });
            this.mapView.clearTileCache(this.name);
        }
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    /** @override */
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is
     * initialized with default copyrights, concatenated with copyrights from copyright provider of
     * this data source.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called.
     * @default false.
     * @override
     */
    getTile(tileKey, delayLoad = false) {
        const tile = this.m_tileFactory.create(this, tileKey);
        tile.copyrightInfo = this.m_options.copyrightInfo;
        if (this.m_options.copyrightProvider !== undefined) {
            this.m_options.copyrightProvider
                .getCopyrights(tile.geoBox, tileKey.level)
                .then(copyrightInfo => {
                tile.copyrightInfo =
                    tile.copyrightInfo === undefined
                        ? copyrightInfo
                        : [...tile.copyrightInfo, ...copyrightInfo];
                this.requestUpdate();
            });
        }
        if (!delayLoad) {
            tile.load();
        }
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
}
exports.TileDataSource = TileDataSource;


/***/ }),

/***/ "../harp-mapview-decoder/lib/TileLoader.ts":
/*!*************************************************!*\
  !*** ../harp-mapview-decoder/lib/TileLoader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileInfoLoader = exports.TileLoader = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const ITileLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/ITileLoader */ "../harp-mapview/lib/ITileLoader.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Logger to write to console etc.
 */
const logger = harp_utils_1.LoggerManager.instance.create("TileLoader");
/**
 * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by
 * the [[TileDataSource]].
 */
class TileLoader extends harp_mapview_1.BaseTileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource - The [[DataSource]] the tile belongs to.
     * @param tileKey - The quadtree address of a [[Tile]].
     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.
     * @param tileDecoder - The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].
     */
    constructor(dataSource, tileKey, dataProvider, tileDecoder) {
        super(dataSource, tileKey);
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.dataProvider = dataProvider;
        this.tileDecoder = tileDecoder;
    }
    /**
     * @override
     */
    get priority() {
        return this.m_priority;
    }
    /**
     * @override
     */
    set priority(priority) {
        this.m_priority = priority;
        if (this.requestController !== undefined) {
            this.requestController.priority = priority;
        }
    }
    /**
     * @override
     */
    loadImpl(abortSignal, onDone, onError) {
        this.dataProvider
            .getTile(this.tileKey, abortSignal)
            .then(payload => {
            if (abortSignal.aborted) {
                // safety belt if getTile doesn't really support cancellation tokens
                const err = new Error("Aborted");
                err.name = "AbortError";
                throw err;
            }
            this.onLoaded(payload, onDone, onError);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                return;
            }
            onError(error);
        });
    }
    /**
     * @override
     */
    cancelImpl() {
        if (this.state === ITileLoader_1.TileLoaderState.Decoding && this.requestController) {
            // we should cancel any decodes already in progress!
            this.requestController.abort();
            this.requestController = undefined;
        }
    }
    /**
     * Start decoding the payload.
     */
    startDecodeTile(onDone, onError) {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = ITileLoader_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)
            .then(decodedTile => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.onDecoded(decodedTile, onDone);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            onError(error);
        });
    }
    /**
     * Called when binary data has been loaded. The loading state is now progressing to decoding.
     *
     * @param payload - Binary data in form of [[ArrayBufferLike]], or any object.
     */
    onLoaded(payload, onDone, onError) {
        this.state = ITileLoader_1.TileLoaderState.Loaded;
        this.payload = payload;
        const byteLength = payload.byteLength;
        if (byteLength === 0 ||
            (payload.constructor === Object && Object.keys(payload).length === 0)) {
            // Object is empty
            this.onDecoded({
                geometries: [],
                techniques: []
            }, onDone);
            return;
        }
        // TBD: we might suspend decode if tile is not visible ... ?
        this.startDecodeTile(onDone, onError);
    }
    /**
     * Called when the decoding is finished, and the [[DecodedTile]] has been created.
     *
     * @param decodedTile - The [[DecodedTile]].
     */
    onDecoded(decodedTile, onDone) {
        this.decodedTile = decodedTile;
        onDone(ITileLoader_1.TileLoaderState.Ready);
    }
}
exports.TileLoader = TileLoader;
/**
 * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta
 * data, not the tile data itself.
 */
class TileInfoLoader extends TileLoader {
    /** @override */
    startDecodeTile(onDone, onError) {
        const payload = this.payload;
        if (payload === undefined) {
            logger.error("TileInfoLoader#startDecodeTile: Cannot decode without payload");
            return;
        }
        this.state = ITileLoader_1.TileLoaderState.Decoding;
        this.payload = undefined;
        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode
        // attempts
        const requestController = new harp_datasource_protocol_1.RequestController(this.priority);
        this.requestController = requestController;
        const dataSource = this.dataSource;
        this.tileDecoder
            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)
            .then(tileInfo => {
            if (requestController.signal.aborted) {
                // our flow is cancelled, silently return
                return;
            }
            this.tileInfo = tileInfo;
            onDone(ITileLoader_1.TileLoaderState.Ready);
        })
            .catch(error => {
            // Handle abort messages from fetch and also our own.
            if (error.name === "AbortError" || error.message === "AbortError: Aborted") {
                // our flow is cancelled, silently return
                return;
            }
            onError(error);
        });
    }
}
exports.TileInfoLoader = TileInfoLoader;


/***/ }),

/***/ "../harp-mapview/index.ts":
/*!********************************!*\
  !*** ../harp-mapview/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Functionality needed to render a map.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/BaseTileLoader */ "../harp-mapview/lib/BaseTileLoader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/BoundsGenerator */ "../harp-mapview/lib/BoundsGenerator.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/CameraUtils */ "../harp-mapview/lib/CameraUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ColorCache */ "../harp-mapview/lib/ColorCache.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/composing */ "../harp-mapview/lib/composing/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightElementHandler */ "../harp-mapview/lib/copyrights/CopyrightElementHandler.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightProvider */ "../harp-mapview/lib/copyrights/CopyrightProvider.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/CopyrightCoverageProvider */ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/copyrights/UrlCopyrightProvider */ "../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DataSource */ "../harp-mapview/lib/DataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/EventDispatcher */ "../harp-mapview/lib/EventDispatcher.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/FixedClipPlanesEvaluator */ "../harp-mapview/lib/FixedClipPlanesEvaluator.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/FovCalculation */ "../harp-mapview/lib/FovCalculation.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/PolarTileDataSource */ "../harp-mapview/lib/PolarTileDataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DisplacementMap */ "../harp-mapview/lib/DisplacementMap.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ElevationProvider */ "../harp-mapview/lib/ElevationProvider.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ITileLoader */ "../harp-mapview/lib/ITileLoader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/Image */ "../harp-mapview/lib/image/Image.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/ImageCache */ "../harp-mapview/lib/image/ImageCache.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapAnchors */ "../harp-mapview/lib/MapAnchors.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapView */ "../harp-mapview/lib/MapView.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewAtmosphere */ "../harp-mapview/lib/MapViewAtmosphere.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewFog */ "../harp-mapview/lib/MapViewFog.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/PickHandler */ "../harp-mapview/lib/PickHandler.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Statistics */ "../harp-mapview/lib/Statistics.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextElement */ "../harp-mapview/lib/text/TextElement.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/text/TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TextureLoader */ "../harp-mapview/lib/TextureLoader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Tile */ "../harp-mapview/lib/Tile.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/geometry/TileDataAccessor */ "../harp-mapview/lib/geometry/TileDataAccessor.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/geometry/TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Utils */ "../harp-mapview/lib/Utils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts"), exports);


/***/ }),

/***/ "../harp-mapview/lib/AnimatedExtrusionHandler.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/AnimatedExtrusionHandler.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnimatedExtrusionHandler = exports.AnimatedExtrusionState = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Animation states for extrusion effect
 */
var AnimatedExtrusionState;
(function (AnimatedExtrusionState) {
    AnimatedExtrusionState[AnimatedExtrusionState["None"] = 0] = "None";
    AnimatedExtrusionState[AnimatedExtrusionState["Started"] = 1] = "Started";
    AnimatedExtrusionState[AnimatedExtrusionState["Finished"] = 2] = "Finished";
})(AnimatedExtrusionState = exports.AnimatedExtrusionState || (exports.AnimatedExtrusionState = {}));
const DEFAULT_EXTRUSION_DURATION = 750; // milliseconds
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Handles animated extrusion effect of the buildings in {@link MapView}.
 */
class AnimatedExtrusionHandler {
    /**
     * Creates an {@link AnimatedExtrusionHandler} in {@link MapView}.
     *
     * @param m_mapView - Instance of {@link MapView} on which the animation will run.
     */
    constructor(m_mapView) {
        this.m_mapView = m_mapView;
        /**
         * Animate the extrusion of the buildings if set to `true`.
         */
        this.enabled = true;
        /**
         * Duration of the building's extrusion in milliseconds
         */
        this.duration = DEFAULT_EXTRUSION_DURATION;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_forceEnabled = false;
        this.m_dataSourceMap = new Map();
        this.m_state = AnimatedExtrusionState.None;
        this.m_startTime = -1;
    }
    /**
     * Returns whether the extrusion animation is force enabled or not.
     */
    get forceEnabled() {
        return this.m_forceEnabled;
    }
    /**
     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`
     * values from [[extrudedPolygonTechnique]] will be ignored and
     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used
     */
    set forceEnabled(force) {
        this.m_forceEnabled = force;
        this.duration = DEFAULT_EXTRUSION_DURATION;
    }
    /**
     * Gets min zoom level at which extruded animation is enabled.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * Sets the extrusion animation properties obtained from a given technique.
     * @internal
     * @param technique - The technique where the extrusion animation properties are defined.
     * @param env - The environment used to evaluate technique properties.
     * @returns True if the technique has animation enabled (or animation is forced), false
     * otherwise.
     */
    setAnimationProperties(technique, env) {
        if (!harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
            return false;
        }
        if (technique.hasOwnProperty("minZoomLevel")) {
            this.m_minZoomLevel = technique.minZoomLevel;
        }
        if (this.forceEnabled) {
            return this.enabled;
        }
        if (technique.animateExtrusionDuration !== undefined) {
            this.duration = technique.animateExtrusionDuration;
        }
        const animateExtrusionValue = harp_datasource_protocol_1.getPropertyValue(technique.animateExtrusion, env);
        if (animateExtrusionValue === null) {
            return this.enabled;
        }
        return typeof animateExtrusionValue === "boolean"
            ? animateExtrusionValue
            : typeof animateExtrusionValue === "number"
                ? animateExtrusionValue !== 0
                : false;
    }
    /**
     * Updates the extrusion animation for every frame.
     * @internal
     */
    update(zoomLevel) {
        const extrusionVisible = this.m_dataSourceMap.size > 0 && zoomLevel >= this.m_minZoomLevel;
        if (this.m_state === AnimatedExtrusionState.None && extrusionVisible) {
            this.m_state = AnimatedExtrusionState.Started;
        }
        else if (this.m_state !== AnimatedExtrusionState.None && !extrusionVisible) {
            this.resetAnimation(true);
        }
        this.animateExtrusion();
    }
    /**
     * Adds a tile to be animated.
     * @internal
     * @param tile - The tile to be animated.
     * @param materials - Extruded materials belonging to the tile.
     */
    add(tile, materials) {
        tile.addDisposeCallback(this.removeTile.bind(this));
        let animated = false;
        if (this.m_state !== AnimatedExtrusionState.None) {
            animated = this.skipAnimation(tile);
            if (animated) {
                // Set extrusion ratio to 1 if the tile skips the animation.
                this.setTileExtrusionRatio(materials, 1);
            }
            else if (this.m_state === AnimatedExtrusionState.Finished) {
                // Otherwise, if animation was finished, restart animation but leave already
                //  animated tiles untouched.
                this.resetAnimation(false);
            }
        }
        this.getOrCreateTileMap(tile.dataSource).set(tile.tileKey.mortonCode(), {
            materials,
            animated
        });
    }
    /**
     * Is `true` if there's any extrusion animation ongoing.
     */
    get isAnimating() {
        return (this.m_state !== AnimatedExtrusionState.Finished &&
            this.m_state !== AnimatedExtrusionState.None);
    }
    getTileMap(dataSource, create = false) {
        return this.m_dataSourceMap.get(dataSource);
    }
    getOrCreateTileMap(dataSource) {
        let tileMap = this.m_dataSourceMap.get(dataSource);
        if (!tileMap) {
            tileMap = new Map();
            this.m_dataSourceMap.set(dataSource, tileMap);
        }
        return tileMap;
    }
    skipAnimation(tile) {
        return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);
    }
    wasAnyAncestorAnimated(tile) {
        var _a, _b;
        const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);
        const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);
        const levelsUp = Math.min(distanceToMinLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp);
        const tileMap = this.getTileMap(tile.dataSource);
        if (!tileMap) {
            return false;
        }
        let lastTileKey = tile.tileKey;
        for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {
            lastTileKey = lastTileKey.parent();
            if ((_b = (_a = tileMap.get(lastTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {
                return true;
            }
        }
        return false;
    }
    wasAnyDescendantAnimated(tile) {
        var _a, _b;
        const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;
        const levelsDown = Math.min(distanceToMaxLevel, this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown);
        const tileMap = this.getTileMap(tile.dataSource);
        if (!tileMap) {
            return false;
        }
        const tilingScheme = tile.dataSource.getTilingScheme();
        let nextTileKeys = [tile.tileKey];
        let childTileKeys = [];
        for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {
            childTileKeys.length = 0;
            for (const tileKey of nextTileKeys) {
                for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                    if ((_b = (_a = tileMap.get(childTileKey.mortonCode())) === null || _a === void 0 ? void 0 : _a.animated) !== null && _b !== void 0 ? _b : false) {
                        return true;
                    }
                    childTileKeys.push(childTileKey);
                }
            }
            // swap
            [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];
        }
        return false;
    }
    removeTile(tile) {
        const tileMap = this.getTileMap(tile.dataSource);
        if (!tileMap) {
            return;
        }
        tileMap.delete(tile.tileKey.mortonCode());
        // Remove tile map if it's empty. That way, counting the number of data sources in the
        // map is enough to know if there's any tile.
        if (tileMap.size === 0) {
            this.m_dataSourceMap.delete(tile.dataSource);
        }
    }
    animateExtrusion() {
        if (this.m_state !== AnimatedExtrusionState.Started) {
            return;
        }
        const currentTime = Date.now();
        if (this.m_startTime < 0) {
            this.m_startTime = currentTime;
        }
        const duration = this.duration;
        const timeProgress = Math.min(currentTime - this.m_startTime, duration);
        const extrusionRatio = harp_utils_1.MathUtils.easeInOutCubic(harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN, harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX, timeProgress / duration);
        this.setExtrusionRatio(extrusionRatio);
        if (timeProgress >= duration) {
            this.m_state = AnimatedExtrusionState.Finished;
        }
        this.m_mapView.update();
    }
    resetAnimation(resetTiles) {
        this.m_state = AnimatedExtrusionState.None;
        this.m_startTime = -1;
        if (resetTiles) {
            this.m_dataSourceMap.forEach(tileMap => {
                tileMap.forEach(state => {
                    state.animated = false;
                });
            });
        }
    }
    setExtrusionRatio(value) {
        this.m_dataSourceMap.forEach(tileMap => {
            tileMap.forEach(state => {
                if (!state.animated) {
                    this.setTileExtrusionRatio(state.materials, value);
                    if (value >= 1) {
                        state.animated = true;
                    }
                }
            });
        });
    }
    setTileExtrusionRatio(materials, value) {
        materials.forEach(material => {
            material.extrusionRatio = value;
        });
    }
}
exports.AnimatedExtrusionHandler = AnimatedExtrusionHandler;


/***/ }),

/***/ "../harp-mapview/lib/BackgroundDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/BackgroundDataSource.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackgroundDataSource = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "../harp-mapview/lib/DataSource.ts");
const AddGroundPlane_1 = __webpack_require__(/*! ./geometry/AddGroundPlane */ "../harp-mapview/lib/geometry/AddGroundPlane.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
/**
 * Provides background geometry for all tiles.
 */
class BackgroundDataSource extends DataSource_1.DataSource {
    constructor() {
        super({ name: "background" });
        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;
        this.cacheable = true;
        this.addGroundPlane = true;
        this.enablePicking = false;
    }
    updateStorageLevelOffset() {
        let storageLevelOffset;
        this.mapView.dataSources.forEach(ds => {
            if (ds === this) {
                return;
            }
            const tilingScheme = ds.getTilingScheme();
            if (tilingScheme === this.m_tilingScheme) {
                storageLevelOffset =
                    storageLevelOffset === undefined
                        ? ds.storageLevelOffset
                        : Math.max(storageLevelOffset, ds.storageLevelOffset);
            }
        });
        if (storageLevelOffset === undefined) {
            storageLevelOffset = 0;
        }
        if (storageLevelOffset !== this.storageLevelOffset) {
            this.storageLevelOffset = storageLevelOffset;
            this.mapView.clearTileCache(this.name);
        }
    }
    /** @override */
    async setTheme(theme, languages) {
        this.mapView.clearTileCache(this.name);
    }
    setTilingScheme(tilingScheme) {
        const newScheme = tilingScheme !== null && tilingScheme !== void 0 ? tilingScheme : BackgroundDataSource.DEFAULT_TILING_SCHEME;
        if (newScheme === this.m_tilingScheme) {
            return;
        }
        this.m_tilingScheme = newScheme;
        this.updateStorageLevelOffset();
        this.mapView.clearTileCache(this.name);
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        tile.forceHasGeometry(true);
        AddGroundPlane_1.addGroundPlane(tile, BackgroundDataSource.GROUND_RENDER_ORDER);
        return tile;
    }
}
exports.BackgroundDataSource = BackgroundDataSource;
BackgroundDataSource.GROUND_RENDER_ORDER = Number.MIN_SAFE_INTEGER;
BackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;


/***/ }),

/***/ "../harp-mapview/lib/BaseTileLoader.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/BaseTileLoader.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseTileLoader = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const ITileLoader_1 = __webpack_require__(/*! ./ITileLoader */ "../harp-mapview/lib/ITileLoader.ts");
const logger = harp_utils_1.LoggerManager.instance.create("BaseTileLoader");
/**
 * @internal
 * Base class for tile loaders that provides state handling, request abortion and a load promise.
 */
class BaseTileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource - The [[DataSource]] the tile belongs to.
     * @param tileKey - The quadtree address of a [[Tile]].
     */
    constructor(dataSource, tileKey) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        this.state = ITileLoader_1.TileLoaderState.Initialized;
        this.m_priority = 0;
        /**
         * The abort controller notifying the [[DataProvider]] to cancel loading.
         */
        this.loadAbortController = new AbortController();
    }
    /**
     * @override
     */
    get priority() {
        return this.m_priority;
    }
    /**
     * @override
     */
    set priority(value) {
        this.m_priority = value;
    }
    /**
     * @override
     */
    loadAndDecode() {
        switch (this.state) {
            case ITileLoader_1.TileLoaderState.Loading:
            case ITileLoader_1.TileLoaderState.Loaded:
            case ITileLoader_1.TileLoaderState.Decoding:
                // tile is already loading
                return this.donePromise;
            case ITileLoader_1.TileLoaderState.Ready:
            case ITileLoader_1.TileLoaderState.Failed:
            case ITileLoader_1.TileLoaderState.Initialized:
            case ITileLoader_1.TileLoaderState.Canceled:
                // restart loading
                this.load();
                return this.donePromise;
        }
    }
    /**
     * @override
     */
    waitSettled() {
        if (!this.donePromise) {
            return Promise.resolve(this.state);
        }
        return this.donePromise;
    }
    /**
     * @override
     */
    cancel() {
        if (this.state === ITileLoader_1.TileLoaderState.Loading) {
            this.loadAbortController.abort();
            this.loadAbortController = new AbortController();
        }
        this.cancelImpl();
        this.onDone(ITileLoader_1.TileLoaderState.Canceled);
    }
    /**
     * @override
     */
    get isFinished() {
        return (this.state === ITileLoader_1.TileLoaderState.Ready ||
            this.state === ITileLoader_1.TileLoaderState.Canceled ||
            this.state === ITileLoader_1.TileLoaderState.Failed);
    }
    /**
     * Called on load cancelation, may be overriden to extend behaviour.
     */
    cancelImpl() { }
    /**
     * Start loading. Only call if loading did not start yet.
     */
    load() {
        this.loadImpl(this.loadAbortController.signal, this.onDone.bind(this), this.onError.bind(this));
        if (this.donePromise === undefined) {
            this.donePromise = new Promise((resolve, reject) => {
                this.resolveDonePromise = resolve;
                this.rejectedDonePromise = reject;
            });
        }
        this.state = ITileLoader_1.TileLoaderState.Loading;
    }
    /**
     * Called when loading and decoding has finished successfully. Resolves loading promise if the
     * state is Ready, otherwise it rejects the promise with the supplied state.
     *
     * @param doneState - The latest state of loading.
     */
    onDone(doneState) {
        if (this.resolveDonePromise && doneState === ITileLoader_1.TileLoaderState.Ready) {
            this.resolveDonePromise(doneState);
        }
        else if (this.rejectedDonePromise) {
            this.rejectedDonePromise(doneState);
        }
        this.resolveDonePromise = undefined;
        this.rejectedDonePromise = undefined;
        this.donePromise = undefined;
        this.state = doneState;
    }
    /**
     * Called when loading or decoding has finished with an error.
     *
     * @param error - Error object describing the failing.
     */
    onError(error) {
        if (this.state === ITileLoader_1.TileLoaderState.Canceled) {
            // If we're canceled, we should simply ignore any state transitions and errors from
            // underlying load/decode ops.
            return;
        }
        const dataSource = this.dataSource;
        logger.error(`[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`, error);
        this.error = error;
        this.onDone(ITileLoader_1.TileLoaderState.Failed);
    }
}
exports.BaseTileLoader = BaseTileLoader;


/***/ }),

/***/ "../harp-mapview/lib/BoundsGenerator.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/BoundsGenerator.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoundsGenerator = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const PlaneViewBounds_1 = __webpack_require__(/*! ./PlaneViewBounds */ "../harp-mapview/lib/PlaneViewBounds.ts");
const SphereViewBounds_1 = __webpack_require__(/*! ./SphereViewBounds */ "../harp-mapview/lib/SphereViewBounds.ts");
/**
 * Generates Bounds for a camera view and a projection
 *
 * @internal
 */
class BoundsGenerator {
    constructor(m_view) {
        this.m_view = m_view;
        this.createViewBounds();
    }
    /**
     * Generates a {@link @here/harp-geoutils#GeoPolygon} covering the visible map.
     * The coordinates are sorted to ccw winding, so a polygon could be drawn with them.
     * @returns The GeoPolygon with the view bounds or undefined if world is not in view.
     */
    generate() {
        if (this.m_view.projection !== this.m_viewBounds.projection) {
            this.createViewBounds();
        }
        return this.m_viewBounds.generate();
    }
    createViewBounds() {
        this.m_viewBounds =
            this.m_view.projection.type === harp_geoutils_1.ProjectionType.Planar
                ? new PlaneViewBounds_1.PlaneViewBounds(this.m_view.camera, this.m_view.projection, this.m_view)
                : new SphereViewBounds_1.SphereViewBounds(this.m_view.camera, this.m_view.projection);
    }
}
exports.BoundsGenerator = BoundsGenerator;


/***/ }),

/***/ "../harp-mapview/lib/CameraMovementDetector.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/CameraMovementDetector.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraMovementDetector = void 0;
const three_1 = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * The default value for camera movement throttling, in milliseconds.
 */
const DEFAULT_THROTTLING_TIMEOUT = 300;
/**
 * The `CameraMovementDetector` class checks for changes in camera position and orientation, to
 * detect continuous movements without the animation mode activated in {@link MapView}. If the
 * interaction is not continuous enough, you can use a throttling timer to reduce the number of
 * callbacks.
 */
class CameraMovementDetector {
    /**
     * Initializes the detector with timeout value and callbacks. {@link MapView} also provides
     * events for client code to be notified when these cues occur.
     *
     * @param m_throttlingTimeout - The delay, in milliseconds, between the last user interaction
     * detected and the call to `m_movementFinishedFunc`; the default is `300`.
     * @param m_movementStartedFunc - Callback function, called when the user starts interacting.
     * @param m_movementFinishedFunc - Callback function, called when the user stops interacting.
     */
    constructor(m_throttlingTimeout, m_movementStartedFunc, m_movementFinishedFunc) {
        this.m_throttlingTimeout = m_throttlingTimeout;
        this.m_movementStartedFunc = m_movementStartedFunc;
        this.m_movementFinishedFunc = m_movementFinishedFunc;
        this.m_lastCameraPos = new three_1.Vector3();
        this.m_newCameraPos = new three_1.Vector3();
        this.m_throttlingTimerId = undefined;
        this.m_movementDetectorDeadline = 0;
        this.onDeadlineTimer = () => {
            this.m_throttlingTimerId = undefined;
            const now = performance.now();
            if (now >= this.m_movementDetectorDeadline) {
                this.movementFinished();
            }
            else {
                this.startMovementFinishedTimer(now);
            }
        };
        if (this.m_throttlingTimeout === undefined) {
            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;
        }
    }
    /**
     * Checks if the camera has moved since the last time it was checked. The
     * `m_movementStartedFunc` is called when a movement starts. If no movement
     * is detected, a timer for `m_movementFinishedFunc` starts.
     *
     * @param mapView - [[Mapview]]'s position and camera are checked for modifications.
     */
    checkCameraMoved(mapView, now) {
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        if (this.m_lastAttitude === undefined) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
            return false;
        }
        const cameraMoved = !this.m_lastCameraPos.equals(newCameraPos) ||
            newAttitude.yaw !== this.m_lastAttitude.yaw ||
            newAttitude.pitch !== this.m_lastAttitude.pitch ||
            newAttitude.roll !== this.m_lastAttitude.roll;
        if (cameraMoved) {
            this.m_lastCameraPos.copy(newCameraPos);
            this.m_lastAttitude = newAttitude;
        }
        if (cameraMoved !== this.m_cameraMovedLastFrame) {
            if (cameraMoved) {
                this.movementStarted();
            }
            this.m_cameraMovedLastFrame = cameraMoved;
        }
        if (cameraMoved) {
            // Start timer
            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout;
            this.startMovementFinishedTimer(now);
        }
        return this.m_cameraMovedLastFrame;
    }
    /**
     * Reset the saved camera position. Next time checkCameraMoved is called, it will return
     * `false`.
     */
    clear(mapView) {
        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);
        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);
        const newAttitude = Utils_1.MapViewUtils.extractAttitude(mapView, mapView.camera);
        this.m_lastAttitude = newAttitude;
    }
    /**
     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.
     */
    forceMoved() {
        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);
    }
    /**
     * Returns `true` if the camera of this {@link MapView} is currently moving. In this case the
     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.
     */
    get cameraIsMoving() {
        return this.m_throttlingTimerId !== undefined;
    }
    /**
     * Disposes resources and kills the throttling timer.
     */
    dispose() {
        this.removeMovementFinishedTimer();
        this.m_movementStartedFunc = undefined;
        this.m_movementFinishedFunc = undefined;
    }
    /**
     * Returns `true` if the camera has moved in the last frame.
     */
    get cameraMovedLastFrame() {
        return this.m_cameraMovedLastFrame === true;
    }
    movementStarted() {
        if (this.m_movementStartedFunc !== undefined) {
            this.m_movementStartedFunc();
        }
    }
    movementFinished() {
        this.removeMovementFinishedTimer();
        if (this.m_movementFinishedFunc !== undefined) {
            this.m_movementFinishedFunc();
        }
    }
    startMovementFinishedTimer(now) {
        if (this.m_throttlingTimerId === undefined) {
            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);
            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime);
        }
    }
    removeMovementFinishedTimer() {
        if (this.m_throttlingTimerId !== undefined) {
            clearTimeout(this.m_throttlingTimerId);
            this.m_throttlingTimerId = undefined;
        }
    }
}
exports.CameraMovementDetector = CameraMovementDetector;


/***/ }),

/***/ "../harp-mapview/lib/CameraUtils.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/CameraUtils.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CameraUtils = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const FovCalculation_1 = __webpack_require__(/*! ./FovCalculation */ "../harp-mapview/lib/FovCalculation.ts");
// In centered projections the principal point is at NDC origin, splitting vertical and horizontal
// fovs in two equal halves.
function isCenteredProjection(principalPoint) {
    return principalPoint.x === 0 && principalPoint.y === 0;
}
/**
 * Computes the fov on the positive side of NDC x or y dimension (i.e. either right or top fov).
 * @param focalLength - Focal length in pixels. It must be larger than 0.
 * @param ppOffset - Principal point NDC offset either in y or x dimension.
 * @param viewportSide - Viewport height or width in pixels, must be same dimension as ppOffset.
 * @returns side fov in radians.
 */
function computePosSideFov(focalLength, ppOffset, viewportSide) {
    // see diagram in computeFocalLengthFromFov().
    harp_utils_1.assert(focalLength > 0, "Focal length must be larger than 0");
    return Math.atan(((1 - ppOffset) * viewportSide * 0.5) / focalLength);
}
/**
 * Computes the vertical or horizontal fov.
 * @param focalLength - Focal length in pixels. It must be larger than 0.
 * @param ppOffset - Principal point NDC offset in y (vertical fov) or x dimension (horizontal fov).
 * @param viewportSide - Viewport height or width in pixels, must be same dimension as ppOffset.
 * @returns vertical or horizontal fov in radians.
 */
function computeFov(focalLength, ppOffset, viewportSide) {
    harp_utils_1.assert(focalLength > 0, "Focal length must be larger than 0");
    // For uncentered fov, compute the two fov sides separately. The fov on the negative NDC
    // side is computed in the same way as that for the positive side but flipping the offset sign.
    return ppOffset === 0
        ? 2 * Math.atan((0.5 * viewportSide) / focalLength)
        : computePosSideFov(focalLength, ppOffset, viewportSide) +
            computePosSideFov(focalLength, -ppOffset, viewportSide);
}
function getFovs(camera) {
    return camera.userData.fovs;
}
/**
 * Saves camera vertical fov and focal length. For off-center projections, saves side fovs as well.
 */
function setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov) {
    const viewportWidth = viewportHeight * camera.aspect;
    let hFov = computeFov(focalLength, ppalPoint.x, viewportWidth);
    if (hFov < FovCalculation_1.MIN_FOV_RAD || hFov > FovCalculation_1.MAX_FOV_RAD) {
        // Invalid horizontal fov, clamp and compute again focal length and vertical fov.
        hFov = THREE.MathUtils.clamp(hFov, FovCalculation_1.MIN_FOV_RAD, FovCalculation_1.MAX_FOV_RAD);
        const focalLength = computeFocalLengthFromFov(hFov, viewportWidth, ppalPoint.x);
        verticalFov = computeFov(focalLength, ppalPoint.y, viewportHeight);
    }
    camera.fov = THREE.MathUtils.radToDeg(verticalFov);
    if (isCenteredProjection(ppalPoint)) {
        delete camera.userData.fovs;
    }
    else {
        const width = viewportHeight * camera.aspect;
        camera.userData.fovs = {
            top: computePosSideFov(focalLength, ppalPoint.y, viewportHeight),
            right: computePosSideFov(focalLength, ppalPoint.x, width),
            horizontal: hFov
        };
    }
    camera.userData.focalLength = focalLength;
}
/**
 * Computes a camera's focal length from vertical fov and viewport height or horizontal fov and
 * viewport width.
 * @beta
 *
 * @param fov - Vertical or horizontal field of view in radians.
 * @param viewportSide - Viewport height if fov is vertical, otherwise viewport width.
 * @param ppOffset - Principal point offset in y direction if fov is vertical,
 * otherwise in x direction.
 * @returns focal length in pixels.
 */
function computeFocalLengthFromFov(fov, viewportSide, ppOffset) {
    //               C <- Projection center
    //              /|-_
    //             / |  -_                      pfov = fov along positive NDC side (tfov or rfov)
    //            /  |    -_                    nfov = fov along negative NDC side (bfov or lfov)
    //           /   |      -_
    //          /    |        -_
    //         /pfov |  nfov    -_
    //        /      |            -_
    //       /       |              -_
    //    a /        |focal length(f) -_ b
    //     /         |                  -_
    //    /          |  Principal point   -_
    //   /           | /      (pp)          -_
    // A/____________P________________________-_B  Viewport
    //  <------------><------------------------>
    //  (1-ppOff)*s/2      (1+ppOff)*s/2
    //  <-------------------------------------->
    //     s = viewportSide (height or width)
    //
    // Diagram of fov splitting (potentially asymmetric) along a viewport side (height or width).
    // For viewport height, fov is split into top (tfov) and bottom (bfov) fovs. For width, it's
    // split into right fov (rfov) and left fov (lfov).
    // Case 1. Symmetric fov split. Principal point is centered (centered projection):
    const halfSide = viewportSide / 2;
    const ppCentered = ppOffset === 0;
    if (ppCentered) {
        return halfSide / Math.tan(fov / 2);
    }
    // Case 2. Asymmetric fov split. Off-center perspective projection:
    const eps = 1e-6;
    const ppOffsetSq = ppOffset ** 2;
    if (Math.abs(fov - Math.PI / 2) < eps) {
        // Case 2a. Special case for (close to) right angle fov, tangent approaches infinity:
        // 3 right triangles: ACB, APC, BPC. Use pythagorean theorem on each to get 3 equations:
        // a^2 = f^2 + (1-ppOff)*s/2
        // b^2 = f^2 + (1+ppOff)*s/2
        // h^2 = a^2 + b^2
        // Substitute a^2 and b^2 in third equation and solve for f to get:
        // f = (s/2) * sqrt(1-ppOff^2)
        return halfSide * Math.sqrt(1 - ppOffsetSq);
    }
    // Case 2b. General asymmetric fov case:
    // (1)   tan(pfov) = (1-ppOff)*s / (2*f)
    // (2)   tan(nfov) = (1+ppOff)*s / (2*f)
    // Use formula for the tan of the sum of two angles:
    // (3)   tan(fov) = tan(pfov+nfov) = (tan(pfov) + tan(nfov)) / (1 - (tan(pfov) * tan(nfov)))
    // Substitute (1) and (2) in (3) and solve for f to get a quadratic equation:
    // 4*(tan(fov))^2 - 4*s*f - tan(fov)(1-ppOff^2)*s^2 = 0 , solving for f:
    // f = (s/2) * (1 +/- sqrt(1 + tan(fov)(1-ppOff^2)^2)) / tan(fov)
    // ppOff (principal point offset) is in [-1,1], so there's two real solutions (radicant is >=1)
    // and we choose the positive solution on each case:
    // a) tan(fov) > 0, fov in (0,pi/2) -> f = (s/2) * (1 + sqrt(1 + tan(fov)^2(1-ppOff^2))) / tan(fov)
    // b) tan(fov) < 0, fov in (pi/2,pi) -> f = (s/2) * (1 - sqrt(1 + tan(fov)^2(1-ppOff^2))) / tan(fov)
    const tanFov = Math.tan(fov);
    const sign = Math.sign(tanFov);
    const sqrt = Math.sqrt(1 + tanFov ** 2 * (1 - ppOffsetSq));
    const f = (halfSide * (1 + sign * sqrt)) / tanFov;
    harp_utils_1.assert(f >= 0, "Focal length must be larger than 0");
    return f;
}
var CameraUtils;
(function (CameraUtils) {
    /**
     * Returns the camera's focal length.
     * @beta
     *
     * @param camera - The camera.
     * @returns The focal length in pixels or `undefined` if not set.
     */
    function getFocalLength(camera) {
        var _a;
        return (_a = camera.userData) === null || _a === void 0 ? void 0 : _a.focalLength;
    }
    CameraUtils.getFocalLength = getFocalLength;
    /**
     * Sets a camera's focal length.
     * @remarks The camera's vertical fov will be updated to achieve the given viewport height.
     * @beta
     *
     * @param camera
     * @param focalLength - Focal length in pixels. It must be larger than 0.
     * @param viewportHeight - Viewport height in pixels, used to compute vertical fov.
     * @returns The new camera's focal length in pixels.
     */
    function setFocalLength(camera, focalLength, viewportHeight) {
        const ppalPoint = getPrincipalPoint(camera);
        const vFov = computeFov(focalLength, ppalPoint.y, viewportHeight);
        if (vFov < FovCalculation_1.MIN_FOV_RAD || vFov > FovCalculation_1.MAX_FOV_RAD) {
            // Invalid vertical fov, clamp and compute again focal length.
            setVerticalFov(camera, vFov, viewportHeight);
        }
        else {
            setCameraParams(camera, ppalPoint, focalLength, viewportHeight, vFov);
        }
        // focal length might change in setCameraParams due to horizontal fov restrictions.
        return getFocalLength(camera);
    }
    CameraUtils.setFocalLength = setFocalLength;
    /**
     * Returns the camera's vertical field of view.
     * @param camera - The camera.
     * @returns The vertical fov in radians.
     */
    function getVerticalFov(camera) {
        return THREE.MathUtils.degToRad(camera.fov);
    }
    CameraUtils.getVerticalFov = getVerticalFov;
    /**
     * Sets a camera's vertical fov.
     * @remarks The camera's focal length will be updated to achieve the given viewport height.
     * @beta
     *
     * @param camera
     * @param verticalFov - Vertical field of view in radians. It'll be clamped to
     *                      [{@link MIN_FOV_RAD}, {@link MAX_FOV_RAD}].
     * @param viewportHeight - Viewport height in pixels, used to compute focal length.
     * @returns The new camera's vertical fov in radians.
     */
    function setVerticalFov(camera, verticalFov, viewportHeight) {
        verticalFov = THREE.MathUtils.clamp(verticalFov, FovCalculation_1.MIN_FOV_RAD, FovCalculation_1.MAX_FOV_RAD);
        const ppalPoint = getPrincipalPoint(camera);
        const focalLength = computeFocalLengthFromFov(verticalFov, viewportHeight, ppalPoint.y);
        setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov);
        // vertical fov might change in setCameraParams due to horizontal fov restrictions.
        return getVerticalFov(camera);
    }
    CameraUtils.setVerticalFov = setVerticalFov;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     * @beta
     *
     * @param focalLength - Focal length in pixels (see {@link setVerticalFov})
     * @param distance - Object distance in world space.
     * @param worldSize - Object size in world space.
     * @return object size in screen space.
     */
    function convertWorldToScreenSize(focalLength, distance, worldSize) {
        return (focalLength * worldSize) / distance;
    }
    CameraUtils.convertWorldToScreenSize = convertWorldToScreenSize;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     * @beta
     *
     * @param focalLength - Focal length in pixels (see {@link setVerticalFov})
     * @param distance - Object distance in world space.
     * @param screenSize - Object size in screen space.
     * @return object size in world space.
     */
    function convertScreenToWorldSize(focalLength, distance, screenSize) {
        return (distance * screenSize) / focalLength;
    }
    CameraUtils.convertScreenToWorldSize = convertScreenToWorldSize;
    /**
     * Returns the camera's principal point (intersection of principal ray and image plane)
     * in NDC coordinates.
     * @beta
     * @see https://en.wikipedia.org/wiki/Pinhole_camera_model
     * @remarks This point coincides with the principal vanishing point. By default it's located at
     * the image center (NDC coords [0,0]), and the resulting projection is centered or symmetric.
     * But it may be offset (@see THREE.PerspectiveCamera.setViewOffset) for some use cases such as
     * multiview setups (e.g. stereoscopic rendering), resulting in an asymmetric perspective
     * projection.
     * @param camera - The camera.
     * @param result - Optional vector where the principal point coordinates will be copied.
     * @returns A vector containing the principal point NDC coordinates.
     */
    function getPrincipalPoint(camera, result = new THREE.Vector2()) {
        result.x = -camera.projectionMatrix.elements[8];
        result.y = -camera.projectionMatrix.elements[9];
        return result;
    }
    CameraUtils.getPrincipalPoint = getPrincipalPoint;
    /**
     * Sets the camera's principal point (intersection of principal ray and image plane)
     * in NDC coordinates.
     * @beta
     * @see {@link getPrincipalPoint}
     * @param camera - The camera.
     * @param ndcCoords - The principal point's NDC coordinates, each coordinate can have values in
     * the open interval (-1,1).
     */
    function setPrincipalPoint(camera, ndcCoords) {
        // We only need to set to proper elements in the projection matrix:
        // camera.projectionMatrix.elements[8] = -ndcCoords.x
        // camera.projectionMatrix.elements[9] = -ndcCoords.y
        // However, this can't be done directly, otherwise it'd be overwritten on the next call to
        // camera.updateProjectionMatrix(). The only way to set the principal point is through a
        // THREE.js camera method for multi-view setup, see:
        // https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.setViewOffset
        const height = 1;
        const width = camera.aspect;
        // Principal point splits fov in two angles that must be strictly less than 90 degrees
        // (each one belongs to a right triangle). Setting the principal point at the edges (-1 or
        // 1) would make it impossible to achieve an fov >= 90. Thus, clamp the principal point
        // coordinates to values slightly smaller than 1.
        const maxNdcCoord = 1 - 1e-6;
        camera.setViewOffset(width, height, (-THREE.MathUtils.clamp(ndcCoords.x, -maxNdcCoord, maxNdcCoord) * width) / 2, (THREE.MathUtils.clamp(ndcCoords.y, -maxNdcCoord, maxNdcCoord) * height) / 2, width, height);
    }
    CameraUtils.setPrincipalPoint = setPrincipalPoint;
    /**
     * Returns the camera's horizontal field of view.
     * @param camera - The camera.
     * @returns The horizontal fov in radians.
     */
    function getHorizontalFov(camera) {
        var _a, _b;
        // If horizontal fov is not stored in camera, assume centered projection and compute
        // it from the vertical fov.
        return ((_b = (_a = getFovs(camera)) === null || _a === void 0 ? void 0 : _a.horizontal) !== null && _b !== void 0 ? _b : 2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * camera.aspect));
    }
    CameraUtils.getHorizontalFov = getHorizontalFov;
    /**
     * Returns top fov angle for a given perspective camera.
     * @beta
     * @remarks In symmetric projections, the principal point coincides with the image center, and
     * the vertical and horizontal FOVs are each split at that point in two equal halves.
     * However, in asymmetric projections the principal point is not at the image center, and thus
     * each fov is split unevenly in two parts:
     *
     *    Symmetric projection        Asymmetric projection
     * -------------------------   --------------------------
     * |           ^           |   |       ^                |
     * |           |           |   |       |tFov            |
     * |           |tFov       |   | lFov  v      rFov      |
     * |           |           |   |<----->x<-------------->|
     * |    lFov   v   rFov    |   |  ppal ^ point          |
     * |<--------->x<--------->|   |       |    o           |
     * | ppal point=img center |   |       | img center     |
     * |           ^           |   |       |                |
     * |           |bFov       |   |       |bFov            |
     * |           |           |   |       |                |
     * |           v           |   |       v                |
     * -------------------------   --------------------------
     *
     * @param camera - The camera.
     * @returns The top fov angle in radians.
     */
    function getTopFov(camera) {
        var _a, _b;
        return (_b = (_a = getFovs(camera)) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : THREE.MathUtils.degToRad(camera.fov / 2);
    }
    CameraUtils.getTopFov = getTopFov;
    /**
     * Returns bottom fov angle for a given perspective camera.
     * @see {@link CameraUtils.getTopFov}
     * @beta
     * @param camera - The camera.
     * @returns The bottom fov angle in radians.
     */
    function getBottomFov(camera) {
        return THREE.MathUtils.degToRad(camera.fov) - getTopFov(camera);
    }
    CameraUtils.getBottomFov = getBottomFov;
    /**
     * Returns right fov angle for a given perspective camera.
     * @see {@link CameraUtils.getTopFov}
     * @beta
     * @param camera - The camera.
     * @returns The right fov angle in radians.
     */
    function getRightFov(camera) {
        var _a, _b;
        return (_b = (_a = getFovs(camera)) === null || _a === void 0 ? void 0 : _a.right) !== null && _b !== void 0 ? _b : getHorizontalFov(camera) / 2;
    }
    CameraUtils.getRightFov = getRightFov;
    /**
     * Returns left fov angle for a given perspective camera.
     * @see {@link CameraUtils.getTopFov}
     * @beta
     * @param camera - The camera.
     * @returns The left fov angle in radians.
     */
    function getLeftFov(camera) {
        var _a;
        return ((_a = getFovs(camera)) === null || _a === void 0 ? void 0 : _a.right) !== undefined
            ? getHorizontalFov(camera) - getRightFov(camera)
            : getHorizontalFov(camera) / 2;
    }
    CameraUtils.getLeftFov = getLeftFov;
})(CameraUtils = exports.CameraUtils || (exports.CameraUtils = {}));


/***/ }),

/***/ "../harp-mapview/lib/ClipPlanesEvaluator.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ClipPlanesEvaluator.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDefaultClipPlanesEvaluator = exports.TiltViewClipPlanesEvaluator = exports.TopViewClipPlanesEvaluator = exports.ElevationBasedClipPlanesEvaluator = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const CameraUtils_1 = __webpack_require__(/*! ./CameraUtils */ "../harp-mapview/lib/CameraUtils.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const epsilon = 0.000001;
var SphericalProj;
(function (SphericalProj) {
    const tmpVectors = [new THREE.Vector3(), new THREE.Vector3()];
    const raycaster = new THREE.Raycaster();
    const sphere = new THREE.Sphere(new THREE.Vector3(), harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
    /**
     * Calculate the horizon distance from a point above a sphere's surface.
     *
     * @remarks
     * Returns zero if point is below surface or only very slightly above surface of sphere.
     * @see https://en.wikipedia.org/wiki/Horizon#Derivation
     * @param d - Distance from point to center of sphere.
     * @param r - Radius of sphere.
     */
    function getHorizonDistance(d, r) {
        // There may be situations when maximum elevation still remains below sea level
        // (elevation < 0) or it is negligible (elevation ~ epsilon)
        return d - r < epsilon ? 0 : Math.sqrt(d * d - r * r);
    }
    /**
     * Calculate furthest visible distance from camera position projected on eye direction.
     *
     * @remarks
     * Furthest visible distance is assumed to be distance from camera to horizon
     * plus distance from elevated geometry to horizon(so that high objects behind horizon
     * remain visible).
     * @see https://en.wikipedia.org/wiki/Horizon#Objects_above_the_horizon
     * @param camera - The camera.
     * @param d - Distance from camera to origin.
     * @param minR - Min sphere radius.
     * @param maxR - Max sphere radius.
     */
    function getFarDistanceFromElevatedHorizon(camera, d, minR, maxR) {
        //                              F
        //                         far +_
        //         , - ~ ~ ~ - ,      +  <_
        //     , '               ' , +     <_ E
        //   ,           .          +,    . '
        //  ,            .   maxR  + , '   /
        // ,             .     ,  '    ,  /
        // ,             . O '   +     , / te
        // ,             | .    +      ,/
        //  ,            |   . minR   ,/
        //   ,           |     +.    ,/
        //     ,         |    +   , '/
        //       ' -_, _ | _ ,  '  / T (Tangent point = Horizon)
        //     near      |  +     /
        //             d | +    / t
        //               | +   /
        //               |+  /
        //               C /---> up
        //
        // CF: Forward (look-at) vector.
        // OC: Normal at camera
        // OCF: Angle between camera normal and forward vector.
        const t = getHorizonDistance(d, minR);
        // Because we would like to see elevated geometry that may be visible beyond
        // the tangent point on ground surface, we need to extend viewing distance along
        // the tangent line by te (see graph above).
        const te = getHorizonDistance(maxR, minR);
        const normalToTanAngle = Math.asin(minR / d); // Angle OCT
        // Angle between fwd vector (CF) and tangent (CT) in camera's up direction: FCT (= FCE)
        const fwdToTanAngle = Math.abs(normalToTanAngle - SphericalProj.getNormalToFwdAngle(camera));
        // Project CE vector(length t + te) onto fwd vector (CF) to get far distance.
        // |CF| = cos(FCE) * |CE| (angle CFE is the projection right angle).
        const far = Math.cos(fwdToTanAngle) * (t + te);
        return far;
    }
    SphericalProj.getFarDistanceFromElevatedHorizon = getFarDistanceFromElevatedHorizon;
    /**
     * Calculate distance to the nearest point where the near plane is tangent to the sphere,
     * projected onto the camera forward vector.
     * @param camera - The camera.
     * @param bottomFov - Angle from camera forward vector to frustum bottom plane.
     * @param R - The sphere radius.
     * @returns The tangent point distance if the point is visible, otherwise `undefined`.
     */
    function getProjNearPlaneTanDistance(camera, bottomFov, R) {
        //                                                          ,^;;;;;;;;;;;;;;;;-
        //                                                      ^^^^:                `;^^^:
        //                          near plane              `++^                          '++^
        //                              ,                 :?;                                `*?'
        //                              +;              :\"                                     ^\-
        //                               {-           `/:                                         *>
        //                                }`  :^^^^` :/                                            '{`
        //                               ;\N^^'     :|                                              `}`
        //              fwdDir     ';^^^;` ,|      :(                                                 }`
        // up                  :^^^^,   90 *>     }                                                  '}
        //  ^            :^^^^,              ('   \'                                                   (-
        //  |      `;^^^;`                    }   }                                                     }
        //  | ,^^^^:                          `}  }                                                     }
        // CAM<--------------------------------{$?&-------------------------O                           {
        //    \ ';;;;;;;:`                      ^^}                  :^^^^,                             }
        //     \        `;;;;;;;;,               (%            -^^^^;`                                 `}
        //      \               `:;;;;;;;'        @, 90  '^^^^;`                                      (-
        //       \       camToTanVec     ';;;;;;;TAN`:^^^^"   -R*fwdDir                               ,{
        //        \                              `:}@-                                               `}
        //         \                                *$                                              `}`
        //   Bottom frustum plane                    }$`                                           "(
        //                                            }{^                                        `\;
        //                                            `}"|:                                     >|`
        //                                             '( ,*+`                               '**`
        //                                              ;|   ^++-                         :+>:
        //                                               ;      ;^^^;`               -;^^^,
        //                                                          `;;;;;;;;;;;;;;;;"
        const fwdDir = camera.getWorldDirection(tmpVectors[0]);
        const camToTanVec = tmpVectors[1].copy(fwdDir).multiplyScalar(-R).sub(camera.position);
        const near = camToTanVec.dot(fwdDir);
        const cosTanDirToFwdDir = near / camToTanVec.length();
        // Tangent point visible if angle from fwdDir to tangent is less than to frustum bottom.
        return cosTanDirToFwdDir > Math.cos(bottomFov) ? near : undefined;
    }
    SphericalProj.getProjNearPlaneTanDistance = getProjNearPlaneTanDistance;
    /**
     * Calculate the distance to the intersection of a given ray with the sphere,
     * projected onto the camera forward vector.
     * @param camera - The camera.
     * @param ndcDir - Ray direction in NDC coordinates.
     * @param R - The sphere radius.
     * @returns Intersection distance or `undefined` if there's no intersection.
     */
    function getProjSphereIntersectionDistance(camera, ndcDir, R) {
        raycaster.setFromCamera(ndcDir, camera);
        sphere.radius = R;
        const intersection = raycaster.ray.intersectSphere(sphere, tmpVectors[0]);
        return intersection !== null
            ? intersection.sub(camera.position).dot(camera.getWorldDirection(tmpVectors[1]))
            : undefined;
    }
    SphericalProj.getProjSphereIntersectionDistance = getProjSphereIntersectionDistance;
    /**
     * Calculate angle between forward vector and surface normal at camera position.
     * @param camera - The camera.
     * @returns The angle in radians.
     */
    function getNormalToFwdAngle(camera) {
        const camToOriginDir = tmpVectors[0].copy(camera.position).negate().normalize();
        const cosAngle = camToOriginDir.dot(camera.getWorldDirection(tmpVectors[1]));
        return Math.acos(THREE.MathUtils.clamp(cosAngle, -1.0, 1.0));
    }
    SphericalProj.getNormalToFwdAngle = getNormalToFwdAngle;
})(SphericalProj || (SphericalProj = {}));
/**
 * Abstract evaluator class that adds support for elevation constraints.
 *
 * @remarks
 * Classes derived from this should implement algorithms that takes into account rendered
 * features height (elevations), such as ground plane is no more flat (or spherical), but
 * contains geometry that should be overlapped by frustum planes.
 */
class ElevationBasedClipPlanesEvaluator {
    constructor(maxElevation, minElevation) {
        harp_utils_1.assert(maxElevation >= minElevation);
        this.m_minElevation = minElevation;
        this.m_maxElevation = maxElevation;
    }
    /**
     * Set maximum elevation above sea level to be rendered.
     *
     * @remarks
     * @param elevation - the elevation (altitude) value in world units (meters).
     * @note If you set this exactly to the maximum rendered feature height (altitude above
     * the sea, you may notice some flickering or even polygons disappearing related to rounding
     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little
     * bit offset to your assumed maximum elevation.
     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values
     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and
     * [[EarthConstant.MAX_ELEVATION]] respectively.
     * @see minElevation for more information about precision and rounding errors.
     */
    set maxElevation(elevation) {
        this.m_maxElevation = elevation;
        // Min elevation should be at least equal or smaller to max elevation.
        this.m_minElevation = Math.min(elevation, this.m_minElevation);
    }
    /**
     * Get maximum elevation to be covered by camera frustum.
     */
    get maxElevation() {
        return this.m_maxElevation;
    }
    /**
     * Set minimum elevation to be rendered, values beneath the sea level are negative.
     *
     * @remarks
     * @param elevation - the minimum elevation (depression) in world units (meters).
     * @note If you set this parameter to zero you may not see any features rendered if they are
     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to
     * -100m and rendered features lays exactly in such depression, you may notice that problem.
     * The errors usually come from projection precision loss and depth buffer nature (significant
     * precision loss closer to far plane). Thus is such cases either increase the margin (if you
     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].
     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes
     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is
     * the highest point our planet.
     * @see https://developer.nvidia.com/content/depth-precision-visualized
     */
    set minElevation(elevation) {
        this.m_minElevation = elevation;
        // Max elevation should be at least equal or bigger than min elevation.
        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);
    }
    /**
     * Get minimum elevation to be covered by camera frustum.
     */
    get minElevation() {
        return this.m_minElevation;
    }
}
exports.ElevationBasedClipPlanesEvaluator = ElevationBasedClipPlanesEvaluator;
/**
 * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.
 *
 * @deprecated Default evaluator {@link TiltViewClipPlanesEvaluator} supports top-down views.
 *
 * @remarks
 * This evaluator supports both planar and spherical projections, although it behavior is
 * slightly different in each case. General algorithm sets near plane and far plane close
 * to ground level, but taking into account maximum and minimum elevation of features on the ground.
 *
 * @note This evaluator supports only cameras which are always looking down the ground surface
 * (top-down view) along surface normal and does not preserve correct clip planes when
 * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera
 * settings.
 */
class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {
    /**
     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea
     * level as also minimum near plane and maximum far plane distance constraints.
     *
     * @remarks
     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near
     * and far planes to avoid flickering.
     * @param maxElevation - defines near plane offset from the ground in the surface normal
     * direction, positive values allows to render elevated terrain features (mountains,
     * buildings). Defaults to Burj Khalifa building height.
     * @param minElevation - defines far plane offset from the ground surface, negative values moves
     * far plane below the ground level (use it to render depressions). Default zero - sea level.
     * @param nearMin - minimum allowable near plane distance from camera, must be bigger than zero.
     * @param nearFarMarginRatio - minimum distance between near and far plane, as a ratio of
     * average near/far plane distance, it have to be significantly bigger than zero (especially if
     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when
     * rendering, or even render empty scene if frustum planes are almost equal.
     * @param farMaxRatio - maximum ratio between ground and far plane distance, allows to limit
     * viewing distance at overall. Have to be bigger than 1.0.
     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation
     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],
     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires
     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes
     * anyway.
     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and
     * minimum renderable elevation respectively along the surface normal, when camera is
     * constantly looking downwards (top-down view). If you need {@link ClipPlanesEvaluator} for
     * cameras that support tilt or yaw please use {@link TiltViewClipPlanesEvaluator}.
     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,
     * the algorithm used there estimates distance to point on tangent where line from camera
     * touches the sphere horizon and there is no reason to clamp it.
     */
    constructor(maxElevation = harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT, minElevation = 0, nearMin = 1.0, nearFarMarginRatio = 0.05, farMaxRatio = 6.0) {
        super(maxElevation, minElevation);
        this.nearMin = nearMin;
        this.nearFarMarginRatio = nearFarMarginRatio;
        this.farMaxRatio = farMaxRatio;
        /**
         * Helper for reducing number of objects created at runtime.
         */
        this.m_tmpVectors = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        /**
         * Helper object for reducing performance impact.
         */
        this.m_tmpQuaternion = new THREE.Quaternion();
        harp_utils_1.assert(nearMin > 0);
        harp_utils_1.assert(nearFarMarginRatio >= 0);
        harp_utils_1.assert(farMaxRatio > 1.0);
        const nearFarMargin = nearFarMarginRatio * nearMin;
        this.m_minimumViewRange = {
            near: nearMin,
            far: nearMin + nearFarMargin,
            minimum: this.nearMin,
            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)
        };
    }
    /** @override */
    evaluateClipPlanes(camera, projection, elevationProvider) {
        harp_utils_1.assert(camera instanceof THREE.PerspectiveCamera, "Unsupported camera type.");
        const persCamera = camera;
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            return this.evaluateDistanceSphericalProj(persCamera, projection, elevationProvider);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            return this.evaluateDistancePlanarProj(persCamera, projection, elevationProvider);
        }
        harp_utils_1.assert(false, "Unsupported projection type");
        return Object.assign({}, this.minimumViewRange);
    }
    /**
     * Get minimum view range that is possible to achieve with current evaluator settings.
     * @note This value will not change after evaluator is constructed.
     */
    get minimumViewRange() {
        return this.m_minimumViewRange;
    }
    evaluateDistancePlanarProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        let nearPlane = this.nearMin;
        let farPlane = this.nearMin * this.farMaxRatio;
        // Calculate distance to closest point on the ground.
        const groundDistance = projection.groundDistance(camera.position);
        const farMax = groundDistance * this.farMaxRatio;
        // We could at least try to keep margins along the eye vector (center of the view) in
        // tact with pitch angle changes, but this does not solve all tilt angle problems,
        // rather use more sophisticated evaluator.
        nearPlane = groundDistance - this.maxElevation;
        farPlane = groundDistance - this.minElevation;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.min(farPlane, farMax);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: Math.max(farMax, farPlane)
        };
        return viewRanges;
    }
    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        // The near plane calculus is quite straight forward and works the same as for planar
        // projections. We simply search for the closest point of the ground just above
        // the camera, then we apply margin (elevation) to it along the sphere surface normal:
        const cameraAltitude = projection.groundDistance(camera.position);
        let nearPlane = cameraAltitude - this.maxElevation;
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const d = Math.max(epsilon, camera.position.length());
        // This solution computes near and far plane for a set up where
        // the camera is looking at the center of the scene.
        // The far plane distance calculus requires finding the sphere tangent line that is
        // co-linear with (goes thru) camera position, such tangent creates right angle
        // with sphere diameter where it touches its surface (point T). Given that sphere is
        // always at world origin and camera orbits around it we have (see
        // #getTangentBasedFarPlane):
        // angle(OTC) = 90
        // sin(OCT) = sin(alpha) = r / d
        // alpha = asin(r / d)
        const alpha = Math.asin(r / d);
        // If alpha it bigger than half fov angle, our visibility limit is set by tangent
        // line, otherwise we need to find top (or right) plane intersection with sphere,
        // which is definitely closer than the tangent point mentioned above.
        // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:
        let halfFovAngle = THREE.MathUtils.degToRad(camera.fov / 2);
        // If width > height, then we have to compute the horizontal FOV.
        if (camera.aspect > 1) {
            halfFovAngle = Utils_1.MapViewUtils.calculateHorizontalFovByVerticalFov(halfFovAngle * 2, camera.aspect);
        }
        const maxR = r + this.maxElevation;
        const farTangent = SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
        let farPlane = halfFovAngle > alpha
            ? farTangent
            : this.getFovBasedFarPlane(camera, d, r, 2 * halfFovAngle, projection);
        // In extreme cases the largest depression assumed may be further than tangent
        // based far plane distance, take it into account
        const farMin = cameraAltitude - this.minElevation;
        const farMax = cameraAltitude * this.farMaxRatio;
        // Apply the constraints.
        nearPlane = Math.max(nearPlane, this.nearMin);
        farPlane = Math.max(farPlane, farMin);
        // Apply margins
        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;
        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);
        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);
        const viewRanges = {
            near: nearPlane,
            far: farPlane,
            minimum: this.nearMin,
            maximum: farMax
        };
        return viewRanges;
    }
    getFovBasedFarPlane(camera, d, r, fovAngle, projection) {
        // Find intersection point that is closer to tangent point.
        //
        //         , - ~ ~ ~ - ,
        //     , '               ' ,
        //   ,           .           ,
        //  ,            .     r     ,' T1
        // ,             .     ,  '  / ,
        // ,             . O.'  a   /  ,
        // ,             | .  `  . /   ,
        //  ,            |   .  r / TA,
        //   ,           |    .  /   ,
        //     ,         |     ./  ,'_____ far
        //       ' -_, _ | _ , /' T0
        //     near      |    /
        //               |   / t
        //             d | /
        //               |/
        //               C
        //
        // See:
        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
        // Vector from camera to world center
        const dVec = camera.position;
        // Extract camera X, Y, Z orientation axes into tmp vectors array.
        camera.matrixWorld.extractBasis(this.m_tmpVectors[0], this.m_tmpVectors[1], this.m_tmpVectors[2]);
        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.
        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);
        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).
        const cameraFwdVec = this.m_tmpVectors[2];
        // Apply quaternion to forward vector, creating intersection vector, which is
        // parallel to top or right frustum plane (depending on the aspect ratio).
        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);
        // Calculate camera to origin vector projection onto frustum plane (top or right).
        // This gives us the length of CTA segment:
        const cta = dVec.dot(tVec);
        // If it is negative, it means that the dVec and the tVec points in
        // opposite directions - there is no intersection - or intersection could
        // potentially be behind the intersection ray's origin (camera position).
        if (cta < 0) {
            // Intersection points are behind camera, camera looks in wrong direction.
            const groundDistance = projection.groundDistance(camera.position);
            // Setup far plane to maximum distance.
            return groundDistance * this.farMaxRatio;
        }
        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|
        // segment from it to get far plane distance.
        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to
        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:
        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta
        // a^2 = d^2 - cta^2
        const a2 = dVec.dot(dVec) - cta * cta;
        // Note that if a is greater than sphere radius the ray misses the sphere and
        // thus there is no intersection at all.
        const r2 = r * r;
        harp_utils_1.assert(a2 <= r2, "Please use this evaluator only for top view camera poses.");
        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle
        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is
        // equal to |T1TA|, and |OT0| segment is simply sphere radius.
        // In order to find |T0TA| length we again use Pythagorean theorem, which says:
        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a
        // |T0TA|^2 = r^2 - a^2
        const tota = Math.sqrt(r2 - a2);
        // Finally our far plane (intersection point) is defined as:
        return cta - tota;
    }
}
exports.TopViewClipPlanesEvaluator = TopViewClipPlanesEvaluator;
/**
 * Evaluates camera clipping planes taking into account ground distance and camera tilt (pitch)
 * angle (angle between look-at vector and ground surface normal).
 */
class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {
    constructor() {
        super(...arguments);
        this.m_tmpV2 = new THREE.Vector2();
    }
    /** @override */
    evaluateDistancePlanarProj(camera, projection, elevationProvider) {
        // Find intersections of top/bottom frustum side's medians with the ground plane, taking
        // into account min/max elevations.Top side intersection distance determines the far
        // distance (it's further away than bottom intersection on tilted views), and bottom side
        // intersection distance determines the near distance.
        //   
        //   C
        //   |\
        //   |.\ .
        //   | . \  . t
        // z |  .  \   .c2
        //   |  c1.  \e ___. max elev
        //   |     .   \      .
        //___|a___D1.____\E1_____.D2______ g
        //   C1      .     \ __. min elev
        //            .      \.E2
        //          b  .    .
        //              . .
        //               .
        // Where:
        // - C gives the camera position.
        // - z is the height of the camera above the ground.
        // - z1 == z2 == z, for perspective camera all planes origin its the same
        // - a is a right angle.
        // - e is the look at vector of the camera.
        // - t and b are the frustum planes of the camera (top and bottom respectively).
        // - angle between c1 to c2 is the fov.
        // - c1, c2 - vectors from camera to the ground along frustum planes.
        // - angles between c1 and e or e and c2 splits fov on equal halves.
        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.
        // - angle between z and e is the pitch of the camera.
        // - angle between g and e is the tilt angle.
        // - g is the ground/world surface
        //
        // The intersection distances to be found are |c1| (bottom plane) and |c2| (top plane).
        harp_utils_1.assert(projection.type !== harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        const halfPiLimit = Math.PI / 2 - epsilon;
        const z = projection.groundDistance(camera.position);
        const cameraTilt = Utils_1.MapViewUtils.extractCameraTilt(camera, projection);
        // Angles between top/bottom plane and eye vector. For centered projections both are equal
        // to half of the vertical fov.
        const topFov = CameraUtils_1.CameraUtils.getTopFov(camera);
        const bottomFov = CameraUtils_1.CameraUtils.getBottomFov(camera);
        // Angle between z and c2
        const topAngle = THREE.MathUtils.clamp(cameraTilt + topFov, -halfPiLimit, halfPiLimit);
        // Angle between z and c1
        const bottomAngle = THREE.MathUtils.clamp(cameraTilt - bottomFov, -halfPiLimit, halfPiLimit);
        // Compute |c2|. This will determine the far distance (top intersection is further away than
        // bottom intersection on tilted views), so take the furthest distance possible, i.e.the
        // distance to the min elevation.
        // cos(topAngle) = (z2 - minElev) / |c2|
        // |c2| = (z2 - minElev) / cos(topAngle)
        const topDist = Math.max(0, (z - this.minElevation) / Math.cos(topAngle));
        // Compute |c1|. This will determine the near distance, so take the nearest distance
        // possible, i.e.the distance to the max elevation.
        const bottomDist = Math.max(0, (z - this.maxElevation) / Math.cos(bottomAngle));
        // Project intersection distances onto the eye vector.
        // cos(halfFov) = near / bottomDist
        // near = cos(halfFov) * bottomDist
        viewRanges.near = bottomDist * Math.cos(bottomFov);
        // cos(halfFov) = far / topDist
        // far = cos(halfFov) * topDist
        viewRanges.far = topDist * Math.cos(topFov);
        return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
    }
    /** @override */
    evaluateDistanceSphericalProj(camera, projection, elevationProvider) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const viewRanges = Object.assign({}, this.minimumViewRange);
        viewRanges.near = this.computeNearDistSphericalProj(camera, projection);
        viewRanges.far = this.computeFarDistSphericalProj(camera, projection);
        return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);
    }
    computeNearDistSphericalProj(camera, projection) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        // Default near plane approximation.
        const defaultNear = projection.groundDistance(camera.position) - this.maxElevation;
        const cameraBelowMaxElevation = defaultNear <= 0;
        if (cameraBelowMaxElevation) {
            // Near distance will be adjusted by constraints later.
            return 0;
        }
        const maxR = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS + this.maxElevation;
        // Angles between bottom plane and eye vector. For centered projections it's equal to half
        // of the vertical fov.
        const bottomFov = CameraUtils_1.CameraUtils.getBottomFov(camera);
        // First, use the distance of the near plane's tangent point to the sphere.
        const nearPlaneTanDist = SphericalProj.getProjNearPlaneTanDistance(camera, bottomFov, maxR);
        if (nearPlaneTanDist !== undefined) {
            return nearPlaneTanDist;
        }
        // If near plan tangent is not visible, use the distance to the closest frustum intersection
        // with the sphere. If principal point has a y offset <= 0, bottom frustum intersection
        // is at same distance or closer than top intersection, otherwise both need to be checked.
        // At least one of the sides must intersect, if not the near plane tangent must have been
        // visible.
        CameraUtils_1.CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
        const checkTopIntersection = this.m_tmpV2.y > 0;
        const bottomDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, -1), maxR);
        const topDist = checkTopIntersection
            ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.setComponent(1, 1), maxR)
            : Infinity;
        const near = Math.min(bottomDist !== null && bottomDist !== void 0 ? bottomDist : Infinity, topDist !== null && topDist !== void 0 ? topDist : Infinity);
        harp_utils_1.assert(near !== Infinity, "No reference point for near distance found");
        return near !== null && near !== void 0 ? near : defaultNear;
    }
    computeFarDistSphericalProj(camera, projection) {
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const r = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const minR = r + this.minElevation;
        const maxR = r + this.maxElevation;
        const d = camera.position.length();
        // If all frustum edges intersect the world, use as far distance the distance to the
        // farthest intersection projected on eye vector. If principal point has a y offset <= 0,
        // top frustum intersection is at same distance or farther than bottom intersection,
        // otherwise both need to be checked.
        CameraUtils_1.CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);
        const isRightIntersectionFarther = this.m_tmpV2.x <= 0.0;
        const ndcX = isRightIntersectionFarther ? 1 : -1;
        const checkBottomIntersection = this.m_tmpV2.y > 0;
        const topDist = SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, 1), minR);
        const bottomDist = checkBottomIntersection
            ? SphericalProj.getProjSphereIntersectionDistance(camera, this.m_tmpV2.set(ndcX, -1), minR)
            : 0;
        const largestDist = Math.max(topDist !== null && topDist !== void 0 ? topDist : Infinity, bottomDist !== null && bottomDist !== void 0 ? bottomDist : Infinity);
        if (largestDist !== Infinity) {
            return largestDist;
        }
        // If any frustum edge does not intersect (i.e horizon is visible in that viewport corner),
        // use the horizon distance at the maximum elevation.
        return SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);
    }
    applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider) {
        // Compute the focus point (target) distance for current camera and projection setup,
        // in a same way the MapView component does.
        const { distance } = Utils_1.MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider);
        // Apply the constraints.
        const farMin = projection.groundDistance(camera.position) - this.minElevation;
        const farMax = distance * this.farMaxRatio;
        viewRanges.near = Math.max(viewRanges.near, this.nearMin);
        viewRanges.far = THREE.MathUtils.clamp(viewRanges.far, farMin, farMax);
        // Apply margins.
        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;
        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);
        viewRanges.far = Math.max(viewRanges.far + nearFarMargin / 2, viewRanges.near + nearFarMargin);
        // Set minimum and maximum view range.
        viewRanges.minimum = this.nearMin;
        viewRanges.maximum = farMax;
        return viewRanges;
    }
}
exports.TiltViewClipPlanesEvaluator = TiltViewClipPlanesEvaluator;
/**
 * Creates default {@link ClipPlanesEvaluator}.
 * @internal
 */
const createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();
exports.createDefaultClipPlanesEvaluator = createDefaultClipPlanesEvaluator;


/***/ }),

/***/ "../harp-mapview/lib/ColorCache.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/ColorCache.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorCache = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Use `ColorCache` to reuse a color specified by name and save allocation as well as
 * setup time.
 *
 * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.
 */
class ColorCache {
    constructor() {
        this.m_map = new Map();
    }
    /**
     * Return instance of `ColorCache`.
     */
    static get instance() {
        return this.m_instance;
    }
    /**
     * Returns the color for the given `colorCode`. This function may reuse a previously generated
     * color, so you cannot modify the contents of the color.
     *
     * @param colorCode - ThreeJS color code or name. You must provide a valid color code or name,
     * as this function does not do any validation.
     */
    getColor(colorCode) {
        if (typeof colorCode === "number") {
            colorCode = "#" + colorCode.toString(16).padStart(6, "0");
        }
        let color = this.m_map.get(colorCode);
        if (color !== undefined) {
            return color;
        }
        color = new THREE.Color(colorCode);
        this.m_map.set(colorCode, color);
        return color;
    }
    /**
     * Returns the number of elements in the cache.
     */
    get size() {
        return this.m_map.size;
    }
    /**
     * Clears the cache. Only references to the THREE.Color are removed from the cache.
     * Consequently, clearing the cache does not cause any negative visual impact.
     */
    clear() {
        this.m_map.clear();
    }
}
exports.ColorCache = ColorCache;
ColorCache.m_instance = new ColorCache();


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentDecoderFacade.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentDecoderFacade.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConcurrentDecoderFacade = void 0;
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedDecoder_1 = __webpack_require__(/*! ./WorkerBasedDecoder */ "../harp-mapview/lib/WorkerBasedDecoder.ts");
/**
 * Default concurrent decoder helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to {@link WorkerBasedDecoder}s for data sources.
 */
class ConcurrentDecoderFacade {
    /**
     * Returns a {@link WorkerBasedDecoder} instance.
     *
     * @param decoderServiceType - The name of the decoder service type.
     * @param scriptUrl - The optional URL with the workers' script.
     * @param workerCount - The number of web workers to use.
     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.
     */
    static getTileDecoder(decoderServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
        return new WorkerBasedDecoder_1.WorkerBasedDecoder(workerSet, decoderServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl - The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount - The number of web workers to use.
     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.
     */
    static getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            const workerConnectionTimeoutInMs = workerConnectionTimeout !== undefined ? workerConnectionTimeout * 1000 : undefined;
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount !== null && workerCount !== void 0 ? workerCount : this.defaultWorkerCount,
                workerConnectionTimeout: workerConnectionTimeoutInMs
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
    /**
     * Destroys this [[ConcurrentDecoderFacade]] if all of the [[ConcurrentWorkerSet]]s are
     * terminated.
     */
    static destroyIfTerminated() {
        let allWorkerSetsTerminated = true;
        Object.keys(this.workerSets).forEach(name => {
            if (!this.workerSets[name].terminated) {
                allWorkerSetsTerminated = false;
            }
        });
        if (allWorkerSetsTerminated) {
            ConcurrentDecoderFacade.destroy();
        }
    }
}
exports.ConcurrentDecoderFacade = ConcurrentDecoderFacade;
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and decoders.
 */
ConcurrentDecoderFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentDecoderFacade.defaultWorkerCount = undefined;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentDecoderFacade.workerSets = {};


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentTilerFacade.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentTilerFacade.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConcurrentTilerFacade = void 0;
const ConcurrentWorkerSet_1 = __webpack_require__(/*! ./ConcurrentWorkerSet */ "../harp-mapview/lib/ConcurrentWorkerSet.ts");
const WorkerBasedTiler_1 = __webpack_require__(/*! ./WorkerBasedTiler */ "../harp-mapview/lib/WorkerBasedTiler.ts");
/**
 * Default concurrent tiler helper.
 *
 * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle
 * requested. Provides easy access to {@link WorkerBasedTiler}s for data sources.
 */
class ConcurrentTilerFacade {
    /**
     * Returns a {@link WorkerBasedTiler} instance.
     *
     * @param tilerServiceType - The name of the tiler service type.
     * @param scriptUrl - The optional URL with the workers' script.
     * @param workerCount - The number of web workers to use.
     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.
     */
    static getTiler(tilerServiceType, scriptUrl, workerCount, workerConnectionTimeout) {
        const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);
        return new WorkerBasedTiler_1.WorkerBasedTiler(workerSet, tilerServiceType);
    }
    /**
     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.
     *
     * @param scriptUrl - The optional URL with the workers' script. If not specified,
     * the function uses [[defaultScriptUrl]] instead.
     * @param workerCount - The number of web workers to use.
     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.
     */
    static getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout) {
        if (scriptUrl === undefined) {
            scriptUrl = this.defaultScriptUrl;
        }
        let workerSet = this.workerSets[scriptUrl];
        if (workerSet === undefined) {
            const workerConnectionTimeoutInMs = workerConnectionTimeout !== undefined ? workerConnectionTimeout * 1000 : undefined;
            workerSet = new ConcurrentWorkerSet_1.ConcurrentWorkerSet({
                scriptUrl,
                workerCount: workerCount !== null && workerCount !== void 0 ? workerCount : this.defaultWorkerCount,
                workerConnectionTimeout: workerConnectionTimeoutInMs
            });
            this.workerSets[scriptUrl] = workerSet;
        }
        return workerSet;
    }
    /**
     * Destroys a [[ConcurrentWorkerSet]] instance.
     *
     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].
     */
    static destroyWorkerSet(scriptUrl) {
        const workerSet = this.workerSets[scriptUrl];
        if (workerSet !== undefined) {
            workerSet.destroy();
            delete this.workerSets[scriptUrl];
        }
    }
    /**
     * Destroys all managed [[ConcurrentWorkerSet]]s.
     */
    static destroy() {
        Object.keys(this.workerSets).forEach(name => {
            this.workerSets[name].destroy();
        });
        this.workerSets = {};
    }
    /**
     * Destroys this [[ConcurrentTilerFacade]] if all of the [[ConcurrentWorkerSet]]s are
     * terminated.
     */
    static destroyIfTerminated() {
        let allWorkerSetsTerminated = true;
        Object.keys(this.workerSets).forEach(name => {
            if (!this.workerSets[name].terminated) {
                allWorkerSetsTerminated = false;
            }
        });
        if (allWorkerSetsTerminated) {
            ConcurrentTilerFacade.destroy();
        }
    }
}
exports.ConcurrentTilerFacade = ConcurrentTilerFacade;
/**
 * The URL containing a script to fall back (default) to when looking for worker sets
 * and tilers.
 */
ConcurrentTilerFacade.defaultScriptUrl = "./decoder.bundle.js";
/**
 * The default number of workers.
 */
ConcurrentTilerFacade.defaultWorkerCount = 1;
/**
 * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.
 */
ConcurrentTilerFacade.workerSets = {};


/***/ }),

/***/ "../harp-mapview/lib/ConcurrentWorkerSet.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/ConcurrentWorkerSet.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConcurrentWorkerSet = exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = exports.isLoggingMessage = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const WorkerLoader_1 = __webpack_require__(/*! ./workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const logger = harp_utils_1.LoggerManager.instance.create("ConcurrentWorkerSet");
function isLoggingMessage(message) {
    return message && typeof message.level === "number" && message.type === harp_utils_1.WORKERCHANNEL_MSG_TYPE;
}
exports.isLoggingMessage = isLoggingMessage;
/**
 * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.
 */
const DEFAULT_WORKER_COUNT = 2;
/**
 * The default timeout for first message from worker.
 *
 * @see {@link WorkerLoader.startWorker}
 */
exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;
/**
 * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances
 * running in Web Workers.
 *
 * Starts and manages a certain number of web workers and provides a means to communicate
 * with them using various communication schemes, such as:
 *  - [[addEventListener]] : receive a unidirectional messages
 *  - [[broadcastMessage]] : send unidirectional broadcast message
 *  - [[invokeRequest]] : send a request that waits for a response, with load balancing
 *  - [[postMessage]] : send a unidirectional message, with load balancing
 *
 * The request queue holds all requests before they are stuffed into the event queue, allows for
 * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage
 * when they return their previous result, or if they are idle. When they are idle, they are stored
 * in m_availableWorkers.
 */
class ConcurrentWorkerSet {
    /**
     * Creates a new `ConcurrentWorkerSet`.
     *
     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided
     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in
     * `navigator.hardwareConcurrency` is used instead.
     *
     * The worker set is implicitly started when constructed.
     */
    constructor(m_options) {
        this.m_options = m_options;
        this.m_workerChannelLogger = harp_utils_1.LoggerManager.instance.create("WorkerChannel");
        this.m_eventListeners = new Map();
        this.m_workers = new Array();
        // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce
        // memory consumption in idle workers.
        this.m_availableWorkers = new Array();
        this.m_workerPromises = new Array();
        this.m_readyPromises = new Map();
        this.m_requests = new Map();
        this.m_workerRequestQueue = [];
        this.m_nextMessageId = 0;
        this.m_stopped = true;
        this.m_referenceCount = 0;
        /**
         * Handles messages received from workers. This method is protected so that the message
         * reception can be simulated through an extended class, to avoid relying on real workers.
         *
         * @param workerId - The workerId of the web worker.
         * @param event - The event to dispatch.
         */
        this.onWorkerMessage = (workerId, event) => {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isResponseMessage(event.data)) {
                const response = event.data;
                if (response.messageId === null) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);
                    return;
                }
                const entry = this.m_requests.get(response.messageId);
                if (entry === undefined) {
                    logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`);
                    return;
                }
                if (workerId >= 0 && workerId < this.m_workers.length) {
                    const worker = this.m_workers[workerId];
                    this.m_availableWorkers.push(worker);
                    // Check if any new work has been put into the queue.
                    this.checkWorkerRequestQueue();
                }
                else {
                    logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);
                }
                if (response.errorMessage !== undefined) {
                    const error = new Error(response.errorMessage);
                    if (response.errorStack !== undefined) {
                        error.stack = response.errorStack;
                    }
                    entry.resolver(error);
                }
                else {
                    entry.resolver(undefined, response.response);
                }
            }
            else if (harp_datasource_protocol_1.WorkerServiceProtocol.isInitializedMessage(event.data)) {
                const readyPromise = this.getReadyPromise(event.data.service);
                if (++readyPromise.count === this.m_workerPromises.length) {
                    readyPromise.resolve();
                }
            }
            else if (isLoggingMessage(event.data)) {
                switch (event.data.level) {
                    case harp_utils_1.LogLevel.Trace:
                        this.m_workerChannelLogger.trace(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Debug:
                        this.m_workerChannelLogger.debug(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Log:
                        this.m_workerChannelLogger.log(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Info:
                        this.m_workerChannelLogger.info(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Warn:
                        this.m_workerChannelLogger.warn(...event.data.message);
                        break;
                    case harp_utils_1.LogLevel.Error:
                        this.m_workerChannelLogger.error(...event.data.message);
                        break;
                }
            }
            else {
                this.eventHandler(event);
            }
        };
        this.start();
    }
    /**
     * Adds an external reference and increments the internal reference counter by one.
     *
     * To implement a reference-count based automatic resource cleanup, use this function with
     * [[removeReference]].
     */
    addReference() {
        this.m_referenceCount += 1;
        if (this.m_referenceCount === 1 && this.m_stopped) {
            this.start();
        }
    }
    /**
     * Decrements the internal reference counter by 1.
     *
     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the
     * resources.
     *
     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.
     */
    removeReference() {
        this.m_referenceCount -= 1;
        if (this.m_referenceCount === 0) {
            this.destroy();
        }
    }
    /**
     * Starts workers.
     *
     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.
     *
     * Note: The worker set is implicitly started on construction - no need to call [[start]] on
     * fresh instance.
     *
     * @param options - optional, new worker set options
     */
    start(options) {
        if (options !== undefined) {
            this.m_options = options;
        }
        if (!this.m_stopped) {
            throw new Error("ConcurrentWorker set already started");
        }
        this.m_workerCount = harp_utils_1.getOptionValue(this.m_options.workerCount, typeof navigator !== "undefined" && navigator.hardwareConcurrency !== undefined
            ? // We need to have at least one worker
                THREE.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2)
            : undefined, DEFAULT_WORKER_COUNT);
        // Initialize the workers. The workers now have an ID to identify specific workers and
        // handle their busy state.
        const timeout = harp_utils_1.getOptionValue(this.m_options.workerConnectionTimeout, exports.DEFAULT_WORKER_INITIALIZATION_TIMEOUT);
        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {
            const workerPromise = WorkerLoader_1.WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(worker => {
                const listener = (evt) => {
                    this.onWorkerMessage(workerId, evt);
                };
                worker.addEventListener("message", listener);
                this.m_workers.push(worker);
                this.m_availableWorkers.push(worker);
                return {
                    worker,
                    listener
                };
            });
            this.m_workerPromises.push(workerPromise);
        }
        this.m_stopped = false;
    }
    /**
     * The number of workers started for this worker set. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.m_workerCount;
    }
    /**
     * Stops workers.
     *
     * Waits for all pending requests to be finished and stops all workers.
     *
     * Use [[start]] to start this worker again.
     *
     * @returns `Promise` that resolves when all workers are destroyed.
     */
    async stop() {
        this.m_stopped = true;
        await this.waitForAllResponses().then(() => {
            this.terminateWorkers();
        });
    }
    /**
     * Destroys all workers immediately.
     *
     * Resolves all pending request promises with a `worker destroyed` error.
     *
     * Use [[start]] to start this worker again.
     */
    destroy() {
        this.m_stopped = true;
        // respond with all pending request
        this.m_requests.forEach(entry => {
            entry.resolver(new Error("worker destroyed"));
        });
        this.m_requests.clear();
        this.m_workerRequestQueue = [];
        this.terminateWorkers();
        // clean other stuff
        this.m_eventListeners.clear();
    }
    /**
     * Is `true` if the workers have been terminated.
     */
    get terminated() {
        return this.m_workers.length === 0;
    }
    /**
     * Waits for `service` to be initialized in all workers.
     *
     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that
     * it has started successfully. This method resolves when all workers in a set have
     * `service` initialized.
     *
     * Promise is rejected if any of worker fails to start.
     *
     * @param serviceId - The service identifier.
     */
    async connect(serviceId) {
        this.ensureStarted();
        await Promise.all(this.m_workerPromises);
        return await this.getReadyPromise(serviceId).promise;
    }
    /**
     * Registers an event listener for events that originated in a web worker, for a given
     * `serviceId`. You can only set one event listener per `serviceId`.
     *
     * @param serviceId - The service to listen to.
     * @param callback - The callback to invoke for matching events.
     */
    addEventListener(serviceId, callback) {
        this.m_eventListeners.set(serviceId, callback);
    }
    /**
     * Removes a previously set event listener for the given `serviceId`.
     *
     * @param serviceId - The service from which to remove the event listeners.
     */
    removeEventListener(serviceId) {
        this.m_eventListeners.delete(serviceId);
    }
    /**
     * Invokes a request that expects a response from a random worker.
     *
     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from
     * workers. Use this function when interfacing with "RPC-like" calls to services.
     *
     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.
     * @param request - The request to process.
     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.
     * @param requestController - An optional [[RequestController]] to store state of cancelling.
     *
     * @returns A `Promise` that resolves with a response from the service.
     */
    invokeRequest(serviceId, request, transferList, requestController) {
        this.ensureStarted();
        const messageId = this.m_nextMessageId++;
        let resolver;
        const promise = new Promise((resolve, reject) => {
            resolver = (error, response) => {
                this.m_requests.delete(messageId);
                if (error !== undefined) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            };
        });
        this.m_requests.set(messageId, {
            promise,
            resolver: resolver
        });
        const message = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
            messageId,
            request
        };
        this.postRequestMessage(message, transferList, requestController);
        return promise;
    }
    /**
     * Invokes a request that expects responses from all workers.
     *
     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching
     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers
     * before proceeding (like synchronous worker service creation).
     *
     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.
     * @param request - The request to process.
     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.
     *
     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified
     * order).
     */
    broadcastRequest(serviceId, request, transferList) {
        const promises = [];
        for (const worker of this.m_workers) {
            const messageId = this.m_nextMessageId++;
            let resolver;
            const promise = new Promise((resolve, reject) => {
                resolver = (error, response) => {
                    this.m_requests.delete(messageId);
                    if (error !== undefined) {
                        reject(error);
                    }
                    else {
                        resolve(response);
                    }
                };
            });
            promises.push(promise);
            this.m_requests.set(messageId, {
                promise,
                resolver: resolver
            });
            const message = {
                service: serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Request,
                messageId,
                request
            };
            if (transferList !== undefined) {
                worker.postMessage(message, transferList);
            }
            else {
                worker.postMessage(message);
            }
        }
        return Promise.all(promises);
    }
    /**
     * Posts a message to all workers.
     *
     * @param message - The message to send.
     * @param buffers - Optional buffers to transfer to the workers.
     */
    broadcastMessage(message, buffers) {
        this.ensureStarted();
        if (buffers !== undefined) {
            this.m_workers.forEach(worker => worker.postMessage(message, buffers));
        }
        else {
            this.m_workers.forEach(worker => worker.postMessage(message));
        }
    }
    /**
     * The size of the request queue for debugging and profiling.
     */
    get requestQueueSize() {
        return this.m_workerRequestQueue.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numWorkers() {
        return this.m_workers.length;
    }
    /**
     * The number of workers for debugging and profiling.
     */
    get numIdleWorkers() {
        return this.m_availableWorkers.length;
    }
    /**
     * Subclasses must call this function when a worker emits an event.
     *
     * @param event - The event to dispatch.
     */
    eventHandler(event) {
        if (typeof event.data.type !== "string") {
            return; // not an event generated by us, ignore.
        }
        this.dispatchEvent(event.data.type, event);
    }
    /**
     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is
     * available, the request is put into a queue.
     *
     * @param message - The message to send.
     * @param buffers - Optional buffers to transfer to the worker.
     * @param requestController - An optional [[RequestController]] to store state of cancelling.
     */
    postRequestMessage(message, buffers, requestController) {
        this.ensureStarted();
        if (this.m_workers.length === 0) {
            throw new Error("ConcurrentWorkerSet#postMessage: no workers started");
        }
        // Check if the requestController has received the abort signal, in which case the request
        // is ignored.
        if (requestController !== undefined && requestController.signal.aborted) {
            const entry = this.m_requests.get(message.messageId);
            if (entry === undefined) {
                logger.error(`[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`);
                return;
            }
            const err = new Error("Aborted");
            err.name = "AbortError";
            entry.resolver(err, undefined);
            return;
        }
        if (this.m_availableWorkers.length > 0) {
            const worker = this.m_availableWorkers.pop();
            if (buffers !== undefined) {
                worker.postMessage(message, buffers);
            }
            else {
                worker.postMessage(message);
            }
        }
        else {
            // We need a priority to keep sorting stable, so we have to add a RequestController.
            if (requestController === undefined) {
                requestController = new harp_datasource_protocol_1.RequestController(0);
            }
            if (requestController.priority === 0) {
                // If the requests do not get a priority, they should keep their sorting order.
                requestController.priority = -this.m_nextMessageId;
            }
            this.m_workerRequestQueue.unshift({
                message,
                buffers,
                requestController
            });
        }
    }
    ensureStarted() {
        if (this.m_stopped) {
            throw new Error("ConcurrentWorkerSet stopped");
        }
    }
    async waitForAllResponses() {
        const promises = new Array();
        this.m_requests.forEach(entry => {
            promises.push(entry.promise);
        });
        await Promise.all(promises);
    }
    dispatchEvent(id, message) {
        const callback = this.m_eventListeners.get(id);
        if (callback === undefined) {
            return;
        } // unknown event, ignore.
        callback(message);
    }
    terminateWorkers() {
        // terminate all workers
        this.m_workerPromises.forEach(workerPromise => {
            workerPromise.then(workerEntry => {
                if (workerEntry === undefined) {
                    return;
                }
                workerEntry.worker.removeEventListener("message", workerEntry.listener);
                workerEntry.worker.terminate();
            });
        });
        this.m_workers = [];
        this.m_workerPromises = [];
        this.m_availableWorkers = [];
        this.m_readyPromises.clear();
    }
    getReadyPromise(id) {
        const readyPromise = this.m_readyPromises.get(id);
        if (readyPromise !== undefined) {
            return readyPromise;
        }
        const newPromise = {
            count: 0,
            promise: undefined,
            resolve: () => {
                /* placeholder */
            },
            reject: (error) => {
                newPromise.error = error;
            },
            error: undefined
        };
        newPromise.promise = new Promise((resolve, reject) => {
            const that = newPromise;
            if (that.error !== undefined) {
                reject(that.error);
            }
            else if (that.count === this.m_workerPromises.length) {
                resolve();
            }
            that.resolve = resolve;
            that.reject = reject;
        });
        this.m_readyPromises.set(id, newPromise);
        return newPromise;
    }
    /**
     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,
     * they will be executed with postRequestMessage. The requests in the queue are sorted before
     * the request with the highest priority is selected for processing.
     */
    checkWorkerRequestQueue() {
        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {
            return;
        }
        this.m_workerRequestQueue.sort((a, b) => {
            return a.requestController.priority - b.requestController.priority;
        });
        // Get the request with the highest priority and send it (again).
        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {
            const request = this.m_workerRequestQueue.pop();
            this.postRequestMessage(request.message, request.buffers, request.requestController);
        }
    }
}
exports.ConcurrentWorkerSet = ConcurrentWorkerSet;


/***/ }),

/***/ "../harp-mapview/lib/DataSource.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/DataSource.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataSource = void 0;
const ExprPool_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ExprPool */ "../harp-datasource-protocol/lib/ExprPool.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("DataSource");
/**
 * Derive a class from `DataSource` to contribute data and geometries to the {@link MapView}.
 */
class DataSource extends THREE.EventDispatcher {
    /**
     * Constructs a new `DataSource`.
     *
     * @param options - The options to create the data source.
     */
    constructor(options = {}) {
        super();
        /**
         * Keep the update event here to avoid a global reference to the datasource (and thus prevent garbage collection).
         */
        this.UPDATE_EVENT = { type: "update" };
        /**
         * Set to `true` if this `DataSource` is enabled; `false` otherwise.
         */
        this.enabled = true;
        /**
         * Set to `true` if the {@link MapView} can cache tiles produced by this `DataSource`.
         */
        this.cacheable = false;
        /**
         * Set to `true` if the loader should be used to get the tile contents.
         */
        this.useGeometryLoader = false;
        /**
         * Whether the datasource should have a ground plane (this plane covers the tile entirely and
         * has the minimum possible renderOrder), this can be required in some cases when fallback
         * parent tiles need to be covered by the children, otherwise the content will overlap.
         * Default is false
         */
        this.addGroundPlane = false;
        /**
         * The minimum zoom level at which data is available.
         */
        this.minDataLevel = 1;
        /**
         * The maximum zoom level at which data is available.
         */
        this.maxDataLevel = 20;
        /**
         * The minimum zoom level at which {@link DataSource} is displayed.
         */
        this.minDisplayLevel = 1;
        /**
         * The maximum zoom level at which {@link DataSource} is displayed.
         */
        this.maxDisplayLevel = 20;
        this.allowOverlappingTiles = true;
        this.enablePicking = true;
        /**
         * Overrides the default rendering order of this `DataSource`.
         *
         * @remarks
         * When `dataSourceOrder` is defined, all the objects created by this `DataSource`
         * will be rendered on top of the objects created by other `DataSource`s with
         * lower `dataSourceOrder` values.
         *
         * @defaultValue undefined
         */
        this.dataSourceOrder = 0;
        /**
         * @internal
         * @hidden
         */
        this.exprPool = new ExprPool_1.ExprPool();
        /**
         * Current value of [[maxGeometryHeight]] property.
         */
        this.m_maxGeometryHeight = 0;
        /**
         * Current value of [[minGeometryHeight]] property.
         */
        this.m_minGeometryHeight = 0;
        /**
         * Storage level offset applied to this `DataSource`.
         */
        this.m_storageLevelOffset = 0;
        this.m_featureStateMap = new Map();
        let { name } = options;
        const { styleSetName, languages, minZoomLevel, maxZoomLevel, minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset, allowOverlappingTiles, enablePicking, minGeometryHeight, maxGeometryHeight, dataSourceOrder } = options;
        if (name === undefined || name.length === 0) {
            name = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;
        }
        this.name = name;
        this.styleSetName = styleSetName;
        if (languages !== undefined) {
            this.languages = languages;
        }
        if (minDataLevel !== undefined) {
            this.minDataLevel = minDataLevel;
        }
        if (maxDataLevel !== undefined) {
            this.maxDataLevel = maxDataLevel;
        }
        if (minZoomLevel !== undefined) {
            this.minZoomLevel = minZoomLevel;
        }
        if (maxZoomLevel !== undefined) {
            this.maxZoomLevel = maxZoomLevel;
        }
        if (minDisplayLevel !== undefined) {
            this.minDisplayLevel = minDisplayLevel;
        }
        if (maxDisplayLevel !== undefined) {
            this.maxDisplayLevel = maxDisplayLevel;
        }
        if (storageLevelOffset !== undefined) {
            this.m_storageLevelOffset = storageLevelOffset;
        }
        if (allowOverlappingTiles !== undefined) {
            this.allowOverlappingTiles = allowOverlappingTiles;
        }
        if (enablePicking !== undefined) {
            this.enablePicking = enablePicking;
        }
        if (minGeometryHeight !== undefined) {
            this.minGeometryHeight = minGeometryHeight;
        }
        if (maxGeometryHeight !== undefined) {
            this.maxGeometryHeight = maxGeometryHeight;
        }
        if (dataSourceOrder) {
            this.dataSourceOrder = dataSourceOrder;
        }
    }
    /**
     * Gets the state of the given feature id.
     *
     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.
     */
    getFeatureState(featureId) {
        return this.m_featureStateMap.get(featureId);
    }
    /**
     * Clears the state of all the features of this {@link DataSource}.
     */
    clearFeatureState() {
        this.m_featureStateMap.clear();
    }
    /**
     * Sets the state of the given feature id.
     *
     * ```typescript
     * dataSource.setFeatureState(featureId, { enabled: true });
     * ```
     *
     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.
     * @param state - The new state of the feature.
     */
    setFeatureState(featureId, state) {
        this.m_featureStateMap.set(featureId, state);
    }
    /**
     * Removes the state associated to the given feature.
     *
     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.
     */
    removeFeatureState(featureId) {
        this.m_featureStateMap.delete(featureId);
    }
    /**
     * Returns the name of the [[StyleSet]] to use for the decoding.
     */
    get styleSetName() {
        return this.m_styleSetName;
    }
    /**
     * Sets the name of the [[StyleSet]] to use for the decoding.
     * If this {@link DataSource} is already
     * attached to a {@link MapView}, this setter then reapplies
     * [[StyleSet]] with this name found in
     * {@link MapView}s theme.
     */
    set styleSetName(styleSetName) {
        if (styleSetName !== this.m_styleSetName) {
            this.m_styleSetName = styleSetName;
            this.clearCache();
            this.requestUpdate();
        }
    }
    /**
     * Destroys this `DataSource`.
     */
    dispose() {
        // to be overloaded by subclasses
    }
    /**
     * Purges all the caching done by this `DataSource`
     */
    clearCache() {
        // to be overloaded by subclasses
    }
    /**
     * Boolean which says whether a {@link DataSource} produces
     * tiles that fully cover the tile, i.e.
     * tiles underneath are completely hidden. Must be
     * overridden for {@link DataSource}'s that don't
     * have a ground plane, but which still fully
     * cover the tile, e.g. web tiles.
     */
    isFullyCovering() {
        return this.addGroundPlane;
    }
    /**
     * Returns `true` if this `DataSource` is ready
     * and the {@link MapView} can invoke `getTile()` to
     * start requesting data.
     */
    ready() {
        return true;
    }
    /**
     * The {@link MapView} that is holding this `DataSource`.
     */
    get mapView() {
        if (this.m_mapView === undefined) {
            throw new Error("This DataSource was not added to MapView");
        }
        return this.m_mapView;
    }
    /**
     * The {@link @here/harp-geoutils#Projection} used by
     * the {@link MapView} that is holding this `DataSource`.
     *
     * An `Error` is thrown if you call this method
     * before this `DataSource` has been added
     * to a {@link MapView}.
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * This method is called when the `DataSource` is added to a {@link MapView}. Override this
     * method to provide any custom initialization, such as, to establish a network connection,
     * or to initialize complex data structures.
     */
    async connect() {
        // to be overloaded by subclasses
    }
    /**
     * This method is called when this `DataSource` is added to a {@link MapView}.
     *
     * Overrides of this method must invoke the definition of the super class.
     *
     * @param mapView - The instance of the {@link MapView}.
     */
    attach(mapView) {
        this.m_mapView = mapView;
    }
    /**
     * This method is called when this `DataSource` is removed from a {@link MapView}.
     *
     * Overrides of this method must invoke the definition of the super class.
     *
     * @param mapView - The instance of the {@link MapView}.
     */
    detach(mapView) {
        harp_utils_1.assert(this.m_mapView === mapView);
        this.m_mapView = undefined;
    }
    /**
     * @return Whether this `DataSource` is detached from the `MapView`
     */
    isDetached() {
        return this.m_mapView === undefined;
    }
    /**
     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.
     *
     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update
     * its tiles' geometry.
     *
     * @param theme - The Theme to be applied
     * @param languages - optional: The languages in priority order to be applied
     *
     * @deprecated use setTheme( Theme ) and setLanguages(string[]) instead
     */
    async setTheme(theme, languages) {
        // to be overwritten by subclasses
    }
    /**
     * Used to configure the languages used by the `DataSource` according to priority;
     * the first language in the array has the highest priority.
     *
     * @param languages - An array of ISO 639-1 language codes.
     */
    setLanguages(languages) {
        this.languages = languages;
        // to be overloaded by subclasses
    }
    /**
     * Used to express different country point of view (political view).
     *
     * @note Set to `undefined` (or empty string) if you want to reset to default point of view.
     * @param pov - The country code which point of view should be presented in lower-case
     * ISO 3166-1 alpha-2 format.
     */
    setPoliticalView(pov) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by {@link MapView} before the
     * tile needs to be updated, for example after
     * a theme change.
     *
     * @param tile - The {@link Tile} to update.
     */
    updateTile(tile) {
        // to be overloaded by subclasses
    }
    /**
     * This method is called by the {@link MapView} to determine if the content of the surrounding
     * tiles must be preloaded.
     *
     * @returns `true` if the {@link MapView} should try to preload tiles surrounding the visible
     * tiles; `false` otherwise. The default is `false`.
     */
    shouldPreloadTiles() {
        return false;
    }
    /**
     * The minimum zoom level at which data is available or displayed at
     * (depending on {@link DataSource} subclass).
     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.
     */
    get minZoomLevel() {
        logger.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.");
        return this.minDataLevel;
    }
    set minZoomLevel(level) {
        logger.warn("DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.");
        this.minDataLevel = level;
    }
    /**
     * The maximum zoom level at which data is available or displayed at
     * (depending on {@link DataSource} subclass).
     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.
     */
    get maxZoomLevel() {
        logger.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
        return this.maxDataLevel;
    }
    set maxZoomLevel(level) {
        logger.warn("DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.");
        this.maxDataLevel = level;
    }
    /**
     * Maximum geometry height above ground level this `DataSource` can produce.
     *
     * Used in first stage of frustum culling before
     * {@link Tile.maxGeometryHeight} data is available.
     *
     * @default 0.
     */
    get maxGeometryHeight() {
        return this.m_maxGeometryHeight;
    }
    set maxGeometryHeight(value) {
        this.m_maxGeometryHeight = value;
    }
    /**
     * Minimum geometry height below ground level this `DataSource` can produce. A negative number
     * specifies a value below ground level.
     *
     * Used in first stage of frustum culling before
     * {@link Tile.minGeometryHeight} data is available.
     *
     * @default 0.
     */
    get minGeometryHeight() {
        return this.m_minGeometryHeight;
    }
    set minGeometryHeight(value) {
        this.m_minGeometryHeight = value;
    }
    /**
     * The difference between storage level and display level of tile.
     *
     * Storage level offset is a value applied (added) to current zoom level giving
     * a final tile level being displayed. This way we may differentiate current
     * zoom level from the storage level that is displayed, giving fine grained
     * control over the tiles being decoded an displayed.
     */
    get storageLevelOffset() {
        return this.m_storageLevelOffset;
    }
    /**
     * Setup the relative offset between storage level and display level of tile.
     *
     * @param levelOffset - Difference between zoom level and display level.
     */
    set storageLevelOffset(levelOffset) {
        this.m_storageLevelOffset = levelOffset;
    }
    /**
     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources
     * supporting this feature.
     *
     * @param value - True to enable, false to disable.
     */
    setEnableElevationOverlay(enable) {
        // to be overloaded by subclasses
    }
    /**
     * Computes the data zoom level to use.
     *
     * @param zoomLevel - The zoom level of the {@link MapView}.
     * @returns The data zoom level to use.
     */
    getDataZoomLevel(zoomLevel) {
        return THREE.MathUtils.clamp(zoomLevel + this.m_storageLevelOffset, this.minDataLevel, this.maxDataLevel);
    }
    /**
     * Returns `true` if {@link DataSource} should be displayed for the zoom level.
     * @param zoomLevel - The zoom level of the {@link MapView}.
     */
    isVisible(zoomLevel) {
        return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;
    }
    /**
     * Returns `true` if {@link DataSource} can load tile with
     * given {@link @here/harp-geoutils#TileKey} and zoom level.
     *
     * @param zoomLevel - The zoom level of the {@link MapView}.
     * @param tileKey - The unique identifier for a map tile.
     * @returns `true` if the tile for the given {@link @here/harp-geoutils#TileKey} can be loaded.
     */
    canGetTile(zoomLevel, tileKey) {
        return tileKey.level <= zoomLevel;
    }
    /**
     * Returns `true` if {@link MapView} should traverse tiles
     * further with given {@link @here/harp-geoutils#TileKey} and
     * zoom level.
     *
     * @param zoomLevel - The zoom level of the {@link MapView}.
     * @param tileKey - The unique identifier for a map tile.
     * @returns `true` if the subtiles of the given {@link @here/harp-geoutils#TileKey} should be
     * checked for collisions.
     */
    shouldSubdivide(zoomLevel, tileKey) {
        return tileKey.level <= zoomLevel;
    }
    /**
     * Returns `true` if {@link MapView} should render the text
     * elements with the given {@link @here/harp-geoutils#TileKey} and
     * zoom level.
     *
     * @remarks
     * This is an additional check for the tiles that are already selected for rendering so the
     * default implementation returns `true`.
     *
     * @param zoomLevel - The zoom level.
     * @param tileKey - The unique identifier for a map tile.
     * @returns `true` if the text elements created for the
     *          given {@link @here/harp-geoutils#TileKey} should be rendered.
     */
    shouldRenderText(zoomLevel, tileKey) {
        return true;
    }
    /**
     * Sends a request to the {@link MapView} to redraw the scene.
     */
    requestUpdate() {
        this.dispatchEvent(this.UPDATE_EVENT);
    }
}
exports.DataSource = DataSource;
/**
 * A counter to generate unique names for each `DataSource`, if no name is provided in the
 * constructor.
 */
DataSource.uniqueNameCounter = 0;


/***/ }),

/***/ "../harp-mapview/lib/DebugContext.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DebugContext.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debugContext = exports.DebugContext = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const isNode = typeof window === "undefined";
/**
 * A `DebugOption` is a pair that consists of an option value and an array of change listeners.
 * Listeners are called up when setting the option's value.
 */
class DebugOption extends THREE.EventDispatcher {
    /**
     * Constructs the `DebugOption`.
     *
     * @param value - The value of the option.
     */
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Updates the value of a given option.
     *
     * @param value - The new value for the option.
     * @param name - The name of the option to set.
     */
    set(value, name) {
        this.value = value;
        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });
    }
}
DebugOption.SET_EVENT_TYPE = "set";
/**
 * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their
 * names.
 */
class DebugContext {
    /**
     * Builds a `DebugContext`.
     */
    constructor() {
        this.m_optionsMap = new Map();
        // If we have a `window` object, we store the context in it to make it available in the
        // console.
        if (!isNode && typeof window !== "undefined" && window) {
            const debugInfo = window;
            debugInfo.__debugContext = this;
        }
    }
    /**
     * Sets the value of an option. Calls change listeners of that option, even if the value has
     * not been changed. The change listeners provided here are not called during this set
     * operation.
     *
     * @param name - Name of the option.
     * @param value - Value of the option.
     */
    setValue(name, value) {
        let opt = this.m_optionsMap.get(name);
        if (!opt) {
            opt = new DebugOption(value);
            this.m_optionsMap.set(name, opt);
        }
        else {
            opt.set(value, name);
        }
    }
    /**
     * Gets the option value.
     *
     * @param name - Name of option.
     */
    getValue(name) {
        const opt = this.m_optionsMap.get(name);
        return opt ? opt.value : undefined;
    }
    /**
     * Determines if the option is registered.
     *
     * @param name - Name of option.
     */
    hasOption(name) {
        return this.m_optionsMap.get(name) !== undefined;
    }
    /**
     * Adds a listener to a debug option.
     *
     * @param name - Name of the option that requires a listener.
     * @param listener - The listener function to add.
     */
    addEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Checks for a listener in a debug option.
     *
     * @param name - Name of the option to check for.
     * @param listener - The listener function to check for.
     */
    hasEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Removes a listener from a debug option.
     *
     * @param name - Name of the option from which to remove a listener.
     * @param listener - The listener function to remove.
     */
    removeEventListener(name, listener) {
        const opt = this.m_optionsMap.get(name);
        if (opt) {
            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);
        }
        else {
            throw Error("Unknown option: " + name);
        }
    }
    /**
     * Provides access to the options map. This method is useful for creating an automatic
     * browser GUI.
     */
    get options() {
        return this.m_optionsMap;
    }
    /**
     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API
     * to remove all event listeners.
     */
    clear() {
        this.m_optionsMap.forEach(option => {
            option.set(undefined, "");
        });
    }
}
exports.DebugContext = DebugContext;
exports.debugContext = new DebugContext();


/***/ }),

/***/ "../harp-mapview/lib/DecodedTileHelpers.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/DecodedTileHelpers.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2018-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateColorProperty = exports.applyBaseColorToMaterial = exports.applySecondaryColorToMaterial = exports.evaluateBaseColorProperty = exports.buildMetricValueEvaluator = exports.getMaterialConstructor = exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = exports.buildObject = exports.usesObject3D = exports.getBufferAttribute = exports.createMaterial = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const TechniqueDescriptors_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/TechniqueDescriptors */ "../harp-datasource-protocol/lib/TechniqueDescriptors.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DisplacedMesh_1 = __webpack_require__(/*! ./geometry/DisplacedMesh */ "../harp-mapview/lib/geometry/DisplacedMesh.ts");
const SolidLineMesh_1 = __webpack_require__(/*! ./geometry/SolidLineMesh */ "../harp-mapview/lib/geometry/SolidLineMesh.ts");
const MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ "../harp-mapview/lib/MapMaterialAdapter.ts");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const logger = harp_utils_1.LoggerManager.instance.create("DecodedTileHelpers");
function createTextureFromURL(url, onLoad, onError, isObjectURL) {
    const texture = new THREE.TextureLoader().load(url, onLoad, undefined, // onProgress
    onError);
    if (isObjectURL) {
        // Remove object URL on dispose to avoid memory leaks.
        texture.addEventListener("dispose", () => {
            URL.revokeObjectURL(url);
        });
    }
}
function createTextureFromRawImage(textureBuffer, onLoad, onError) {
    const properties = textureBuffer.dataTextureProperties;
    if (properties) {
        const textureDataType = properties.type
            ? ThemeHelpers_1.toTextureDataType(properties.type)
            : undefined;
        const buffer = getTextureBuffer(textureBuffer.buffer, textureDataType);
        const texture = new THREE.DataTexture(buffer, properties.width, properties.height, properties.format ? ThemeHelpers_1.toPixelFormat(properties.format) : undefined, textureDataType);
        onLoad(texture);
    }
    else {
        onError("no data texture properties provided.");
    }
}
function initTextureProperties(texture, properties) {
    if (!properties) {
        return;
    }
    if (properties.wrapS !== undefined) {
        texture.wrapS = ThemeHelpers_1.toWrappingMode(properties.wrapS);
    }
    if (properties.wrapT !== undefined) {
        texture.wrapT = ThemeHelpers_1.toWrappingMode(properties.wrapT);
    }
    if (properties.magFilter !== undefined) {
        texture.magFilter = ThemeHelpers_1.toTextureFilter(properties.magFilter);
    }
    if (properties.minFilter !== undefined) {
        texture.minFilter = ThemeHelpers_1.toTextureFilter(properties.minFilter);
    }
    if (properties.flipY !== undefined) {
        texture.flipY = properties.flipY;
    }
    if (properties.repeatU !== undefined) {
        texture.repeat.x = properties.repeatU;
    }
    if (properties.repeatV !== undefined) {
        texture.repeat.y = properties.repeatV;
    }
}
function createTexture(material, texturePropertyName, options) {
    const technique = options.technique;
    let textureProperty = technique[texturePropertyName];
    if (textureProperty === undefined) {
        return undefined;
    }
    const texturePromise = new Promise((resolve, reject) => {
        const onLoad = (texture) => {
            const properties = technique[texturePropertyName + "Properties"];
            initTextureProperties(texture, properties);
            material[texturePropertyName] = texture;
            material.needsUpdate = true;
            resolve(texture);
        };
        const onError = (error) => {
            logger.error("#createMaterial: Failed to load texture: ", error);
            reject(error);
        };
        if (harp_datasource_protocol_1.Expr.isExpr(textureProperty)) {
            textureProperty = harp_datasource_protocol_1.getPropertyValue(textureProperty, options.env);
            if (!textureProperty) {
                // Expression may evaluate to a valid texture at any time, create a fake texture to
                // avoid shader recompilation.
                onLoad(new THREE.Texture());
                return;
            }
        }
        if (typeof textureProperty === "string") {
            createTextureFromURL(textureProperty, onLoad, onError, false);
        }
        else if (harp_datasource_protocol_1.isTextureBuffer(textureProperty)) {
            if (textureProperty.type === "image/raw") {
                createTextureFromRawImage(textureProperty, onLoad, onError);
            }
            else {
                const textureBlob = new Blob([textureProperty.buffer], {
                    type: textureProperty.type
                });
                createTextureFromURL(URL.createObjectURL(textureBlob), onLoad, onError, true);
            }
        }
        else if (typeof textureProperty === "object" &&
            (textureProperty.nodeName === "IMG" || textureProperty.nodeName === "CANVAS")) {
            onLoad(new THREE.CanvasTexture(textureProperty));
        }
    });
    return texturePromise;
}
/**
 * Create a material, depending on the rendering technique provided in the options.
 *
 * @param rendererCapabilities - The capabilities of the renderer that will use the material.
 * @param options - The material options the subsequent functions need.
 * @param onTextureCreated - Optional callback for each texture created for the material, getting
 * a promise that will be resolved once the texture is loaded. Texture is not uploaded to GPU.
 *
 * @returns new material instance that matches `technique.name`.
 *
 * @internal
 */
function createMaterial(rendererCapabilities, options, onTextureCreated) {
    const technique = options.technique;
    const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);
    const settings = {};
    if (Constructor === undefined) {
        return undefined;
    }
    if (Constructor.prototype instanceof harp_materials_1.RawShaderMaterial) {
        settings.rendererCapabilities = rendererCapabilities;
        if (Constructor !== harp_materials_1.HighPrecisionLineMaterial) {
            settings.fog = options.fog;
        }
    }
    if (options.shadowsEnabled === true && technique.name === "fill") {
        settings.removeDiffuseLight = true;
    }
    const material = new Constructor(settings);
    if (technique.id !== undefined) {
        material.name = technique.id;
    }
    if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
        material.flatShading = true;
    }
    material.depthTest = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;
    if (harp_datasource_protocol_1.supportsTextures(technique)) {
        harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName) => {
            const texturePromise = createTexture(material, texturePropertyName, options);
            if (texturePromise) {
                onTextureCreated === null || onTextureCreated === void 0 ? void 0 : onTextureCreated(texturePromise);
            }
        });
    }
    if (harp_datasource_protocol_1.isShaderTechnique(technique)) {
        // Special case for ShaderTechnique.
        applyShaderTechniqueToMaterial(technique, material);
    }
    else {
        MapMaterialAdapter_1.MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));
    }
    return material;
}
exports.createMaterial = createMaterial;
/**
 * Returns a [[THREE.BufferAttribute]] created from a provided
 * {@link @here/harp-datasource-protocol#BufferAttribute} object.
 *
 * @param attribute - BufferAttribute a WebGL compliant buffer
 * @internal
 */
function getBufferAttribute(attribute) {
    switch (attribute.type) {
        case "float":
            return new THREE.BufferAttribute(new Float32Array(attribute.buffer), attribute.itemCount);
        case "uint8":
            return new THREE.BufferAttribute(new Uint8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint16":
            return new THREE.BufferAttribute(new Uint16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "uint32":
            return new THREE.BufferAttribute(new Uint32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int8":
            return new THREE.BufferAttribute(new Int8Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int16":
            return new THREE.BufferAttribute(new Int16Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        case "int32":
            return new THREE.BufferAttribute(new Int32Array(attribute.buffer), attribute.itemCount, attribute.normalized);
        default:
            throw new Error(`unsupported buffer of type ${attribute.type}`);
    } // switch
}
exports.getBufferAttribute = getBufferAttribute;
/**
 * Determines if a technique uses THREE.Object3D instances.
 * @param technique - The technique to check.
 * @returns true if technique uses THREE.Object3D, false otherwise.
 * @internal
 */
function usesObject3D(technique) {
    const name = technique.name;
    return (name !== undefined &&
        name !== "text" &&
        name !== "labeled-icon" &&
        name !== "line-marker" &&
        name !== "label-rejection-line");
}
exports.usesObject3D = usesObject3D;
/**
 * Builds the object associated with the given technique.
 *
 * @param technique - The technique.
 * @param geometry - The object's geometry.
 * @param material - The object's material.
 * @param tile - The tile where the object is located.
 * @param elevationEnabled - True if elevation is enabled, false otherwise.
 *
 * @internal
 */
function buildObject(technique, geometry, material, tile, elevationEnabled) {
    harp_utils_1.assert(technique.name !== undefined);
    switch (technique.name) {
        case "extruded-line":
        case "standard":
        case "extruded-polygon":
        case "fill":
            return elevationEnabled
                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                }))
                : new THREE.Mesh(geometry, material);
        case "terrain":
            return new THREE.Mesh(geometry, material);
        case "dashed-line":
        case "solid-line":
            return elevationEnabled
                ? new DisplacedMesh_1.DisplacedMesh(geometry, material, () => ({
                    min: tile.elevationRange.minElevation,
                    max: tile.elevationRange.maxElevation
                }), SolidLineMesh_1.SolidLineMesh.raycast)
                : new SolidLineMesh_1.SolidLineMesh(geometry, material);
        case "circles":
            return new MapViewPoints_1.Circles(geometry, material);
        case "squares":
            return new MapViewPoints_1.Squares(geometry, material);
        case "line":
            return new THREE.LineSegments(geometry, material);
        case "segments":
            return new THREE.LineSegments(geometry, material);
        case "shader": {
            harp_utils_1.assert(harp_datasource_protocol_1.isShaderTechnique(technique), "Invalid technique");
            switch (technique.primitive) {
                case "line":
                    return new THREE.Line(geometry, material);
                case "segments":
                    return new THREE.LineSegments(geometry, material);
                case "point":
                    return new THREE.Points(geometry, material);
                case "mesh":
                    return new THREE.Mesh(geometry, material);
            }
        }
    }
    harp_utils_1.assert(false, "Invalid technique");
    return new THREE.Object3D();
}
exports.buildObject = buildObject;
/**
 * Non material properties of `BaseTechnique`.
 * @internal
 */
exports.BASE_TECHNIQUE_NON_MATERIAL_PROPS = ["name", "id", "renderOrder", "transient"];
/**
 * Returns a `MaterialConstructor` basing on provided technique object.
 *
 * @param technique - `Technique` object which the material will be based on.
 * @param shadowsEnabled - Whether the material can accept shadows, this is required for some
 *                         techniques to decide which material to create.
 *
 * @internal
 */
function getMaterialConstructor(technique, shadowsEnabled) {
    if (technique.name === undefined) {
        return undefined;
    }
    switch (technique.name) {
        case "extruded-line":
            if (!harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                throw new Error("Invalid extruded-line technique");
            }
            return technique.shading === "standard"
                ? harp_materials_1.MapMeshStandardMaterial
                : harp_materials_1.MapMeshBasicMaterial;
        case "standard":
        case "terrain":
        case "extruded-polygon":
            return harp_materials_1.MapMeshStandardMaterial;
        case "dashed-line":
        case "solid-line":
            return harp_materials_1.SolidLineMaterial;
        case "fill":
            return shadowsEnabled ? harp_materials_1.MapMeshStandardMaterial : harp_materials_1.MapMeshBasicMaterial;
        case "squares":
            return THREE.PointsMaterial;
        case "circles":
            return harp_materials_1.CirclePointsMaterial;
        case "line":
        case "segments":
            return THREE.LineBasicMaterial;
        case "shader":
            return THREE.ShaderMaterial;
        case "text":
        case "labeled-icon":
        case "line-marker":
        case "label-rejection-line":
            return undefined;
    }
}
exports.getMaterialConstructor = getMaterialConstructor;
/**
 * Styled properties of main material (created by [[createMaterial]]) managed by
 * [[MapObjectAdapter]].
 */
function getMainMaterialStyledProps(technique) {
    var _a;
    const automaticAttributes = TechniqueDescriptors_1.getTechniqueAutomaticAttrs(technique);
    switch (technique.name) {
        case "dashed-line":
        case "solid-line": {
            const baseProps = harp_utils_1.pick(technique, automaticAttributes);
            baseProps.lineWidth = buildMetricValueEvaluator((_a = technique.lineWidth) !== null && _a !== void 0 ? _a : 0, // Compatibility: `undefined` lineWidth means hidden.
            technique.metricUnit);
            baseProps.outlineWidth = buildMetricValueEvaluator(technique.outlineWidth, technique.metricUnit);
            baseProps.dashSize = buildMetricValueEvaluator(technique.dashSize, technique.metricUnit);
            baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, technique.metricUnit);
            baseProps.offset = buildMetricValueEvaluator(technique.offset, technique.metricUnit);
            return baseProps;
        }
        case "fill":
            return harp_utils_1.pick(technique, automaticAttributes);
        case "standard":
        case "terrain":
        case "extruded-polygon": {
            const baseProps = harp_utils_1.pick(technique, automaticAttributes);
            if (technique.vertexColors !== true) {
                baseProps.color = technique.color;
            }
            return baseProps;
        }
        case "circles":
        case "squares":
            return harp_utils_1.pick(technique, automaticAttributes);
        case "extruded-line":
            return harp_utils_1.pick(technique, [
                "color",
                "wireframe",
                "transparent",
                "opacity",
                "polygonOffset",
                "polygonOffsetFactor",
                "polygonOffsetUnits",
                ...automaticAttributes
            ]);
        case "line":
        case "segments":
            return harp_utils_1.pick(technique, automaticAttributes);
        default:
            return {};
    }
}
/**
 * Convert metric style property to expression that accounts {@link MapView.pixelToWorld} if
 * `metricUnit === 'Pixel'`.
 * @internal
 */
function buildMetricValueEvaluator(value, metricUnit) {
    if (value === undefined || value === null) {
        return value;
    }
    if (typeof value === "string") {
        if (value.endsWith("px")) {
            metricUnit = "Pixel";
            value = Number.parseFloat(value);
        }
        else if (value.endsWith("m")) {
            value = Number.parseFloat(value);
        }
    }
    if (metricUnit === "Pixel") {
        return (context) => {
            var _a;
            const pixelToWorld = (_a = context.env.lookup("$pixelToMeters")) !== null && _a !== void 0 ? _a : 1;
            const evaluated = harp_datasource_protocol_1.getPropertyValue(value, context.env);
            return pixelToWorld * evaluated;
        };
    }
    else {
        return value;
    }
}
exports.buildMetricValueEvaluator = buildMetricValueEvaluator;
/**
 * Allows to easy parse/encode technique's base color property value as number coded color.
 *
 * @remarks
 * Function takes care about property parsing, interpolation and encoding if neccessary.
 *
 * @see ColorUtils
 * @param technique - the technique where we search for base (transparency) color value
 * @param env - {@link @here/harp-datasource-protocol#Env} instance
 *              used to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of `Technique`
 * @returns `number` encoded color value (in custom #TTRRGGBB) format or `undefined` if
 * base color property is not defined in the technique passed.
 *
 * @internal
 */
function evaluateBaseColorProperty(technique, env) {
    const baseColorProp = getBaseColorProp(technique);
    if (baseColorProp !== undefined) {
        return evaluateColorProperty(baseColorProp, env);
    }
    return undefined;
}
exports.evaluateBaseColorProperty = evaluateBaseColorProperty;
/**
 * Apply `ShaderTechnique` parameters to material.
 *
 * @param technique - the `ShaderTechnique` which requires special handling
 * @param material - material to which technique will be applied
 *
 * @internal
 */
function applyShaderTechniqueToMaterial(technique, material) {
    if (technique.transparent) {
        harp_materials_1.enableBlending(material);
    }
    else {
        harp_materials_1.disableBlending(material);
    }
    // The shader technique takes the argument from its `params' member.
    const params = technique.params;
    // Remove base color and transparency properties from the processed set.
    const baseColorPropName = getBaseColorPropName(technique);
    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;
    const props = Object.getOwnPropertyNames(params).filter(propertyName => {
        // Omit base color and related transparency attributes if its defined in technique
        if (baseColorPropName === propertyName ||
            (hasBaseColor && harp_datasource_protocol_1.TRANSPARENCY_PROPERTY_KEYS.includes(propertyName))) {
            return false;
        }
        const prop = propertyName;
        if (prop === "name") {
            // skip reserved property names
            return false;
        }
        return true;
    });
    // Apply all technique properties omitting base color and transparency attributes.
    props.forEach(propertyName => {
        // TODO: Check if properties values should not be interpolated, possible bug in old code!
        // This behavior is kept in the new version too, level is set to undefined.
        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);
    });
    if (hasBaseColor) {
        const propColor = baseColorPropName;
        // Finally apply base color and related properties to material (opacity, transparent)
        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);
    }
}
/**
 * Apply single and generic technique property to corresponding material parameter.
 *
 * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it
 * does not provide constructor that would take [[string]] or [[number]] values.
 *
 * @param material - target material
 * @param propertyName - material and technique parameter name (or index) that is to be transferred
 * @param techniqueAttrValue - technique property value which will be applied to material attribute
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of [[Technique]]
 */
function applyTechniquePropertyToMaterial(material, propertyName, techniqueAttrValue, env) {
    const m = material;
    if (m[propertyName] instanceof THREE.Color) {
        applySecondaryColorToMaterial(material[propertyName], techniqueAttrValue, env);
    }
    else {
        const value = evaluateProperty(techniqueAttrValue, env);
        if (value !== null) {
            m[propertyName] = value;
        }
    }
}
/**
 * Apply technique color to material taking special care with transparent (RGBA) colors.
 *
 * @remarks
 * @note This function is intended to be used with secondary, triary etc. technique colors,
 * not the base ones that may contain transparency information. Such colors should be processed
 * with [[applyTechniqueBaseColorToMaterial]] function.
 *
 * @param technique - an technique the applied color comes from
 * @param material - the material to which color is applied
 * @param prop - technique property (color) name
 * @param value - color value
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of `Technique`.
 *
 * @internal
 */
function applySecondaryColorToMaterial(materialColor, techniqueColor, env) {
    let value = evaluateColorProperty(techniqueColor, env);
    if (value === undefined) {
        return;
    }
    if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(value)) {
        logger.warn("Used RGBA value for technique color without transparency support!");
        // Just for clarity remove transparency component, even if that would be ignored
        // by THREE.Color.setHex() function.
        value = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(value);
    }
    materialColor.setHex(value);
}
exports.applySecondaryColorToMaterial = applySecondaryColorToMaterial;
/**
 * Apply technique base color (transparency support) to material with modifying material opacity.
 *
 * @remarks
 * This method applies main (or base) technique color with transparency support to the corresponding
 * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__
 * attributes.
 *
 * @note Transparent colors should be processed as the very last technique attributes,
 * since their effect on material properties like [[THREE.Material.opacity]] and
 * [[THREE.Material.transparent]] could be overridden by corresponding technique params.
 *
 * @param technique - an technique the applied color comes from
 * @param material - the material to which color is applied
 * @param prop - technique property (color) name
 * @param value - color value in custom number format
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 *
 * @internal
 */
function applyBaseColorToMaterial(material, materialColor, technique, techniqueColor, env) {
    const colorValue = evaluateColorProperty(techniqueColor, env);
    if (colorValue === undefined) {
        return;
    }
    const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(colorValue);
    // Override material opacity and blending by mixing technique defined opacity
    // with main color transparency
    const tech = technique;
    let opacity = a;
    if (tech.opacity !== undefined) {
        opacity *= evaluateProperty(tech.opacity, env);
    }
    opacity = THREE.MathUtils.clamp(opacity, 0, 1);
    if (material instanceof harp_materials_1.RawShaderMaterial) {
        material.setOpacity(opacity);
    }
    else {
        material.opacity = opacity;
    }
    materialColor.setRGB(r, g, b);
    const opaque = opacity >= 1.0;
    if (!opaque) {
        harp_materials_1.enableBlending(material);
    }
    else {
        harp_materials_1.disableBlending(material);
    }
}
exports.applyBaseColorToMaterial = applyBaseColorToMaterial;
/**
 * Calculates the value of the technique defined property.
 *
 * Function takes care about property interpolation (when @param `env` is set) as also parsing
 * string encoded numbers.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value - the value of color property defined in technique
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 */
function evaluateProperty(value, env) {
    if (env !== undefined && harp_datasource_protocol_1.Expr.isExpr(value)) {
        value = harp_datasource_protocol_1.getPropertyValue(value, env);
    }
    return value;
}
/**
 * Calculates the numerical value of the technique defined color property.
 *
 * @remarks
 * Function takes care about color interpolation (when @param `env is set) as also parsing
 * string encoded colors.
 *
 * @note Use with care, because function does not recognize property type.
 * @param value - the value of color property defined in technique
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate
 *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]
 * @internal
 */
function evaluateColorProperty(value, env) {
    value = evaluateProperty(value, env);
    if (value === undefined || value === null) {
        return undefined;
    }
    if (typeof value === "number") {
        return value;
    }
    if (typeof value === "string") {
        const parsed = harp_datasource_protocol_1.parseStringEncodedColor(value);
        if (parsed !== undefined) {
            return parsed;
        }
    }
    logger.error(`Unsupported color format: '${value}'`);
    return undefined;
}
exports.evaluateColorProperty = evaluateColorProperty;
/**
 * Allows to access base color property value for given technique.
 *
 * The color value may be encoded in [[number]], [[string]] or even as
 * [[InterpolateProperty]].
 *
 * @param technique - The techniqe where we seach for base color property.
 * @returns The value of technique color used to apply transparency.
 */
function getBaseColorProp(technique) {
    const baseColorPropName = getBaseColorPropName(technique);
    if (baseColorPropName !== undefined) {
        if (!harp_datasource_protocol_1.isShaderTechnique(technique)) {
            const propColor = baseColorPropName;
            return technique[propColor];
        }
        else {
            const params = technique.params;
            const propColor = baseColorPropName;
            return params[propColor];
        }
    }
    return undefined;
}
function getBaseColorPropName(technique) {
    var _a;
    return (_a = TechniqueDescriptors_1.getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrTransparencyColor;
}
function getTextureBuffer(buffer, textureDataType) {
    if (textureDataType === undefined) {
        return new Uint8Array(buffer);
    }
    switch (textureDataType) {
        case THREE.UnsignedByteType:
            return new Uint8Array(buffer);
        case THREE.ByteType:
            return new Int8Array(buffer);
        case THREE.ShortType:
            return new Int16Array(buffer);
        case THREE.UnsignedShortType:
            return new Uint16Array(buffer);
        case THREE.IntType:
            return new Int32Array(buffer);
        case THREE.UnsignedIntType:
            return new Uint32Array(buffer);
        case THREE.FloatType:
            return new Float32Array(buffer);
        case THREE.HalfFloatType:
            return new Uint16Array(buffer);
    }
    throw new Error("Unsupported texture data type");
}


/***/ }),

/***/ "../harp-mapview/lib/DepthPrePass.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/DepthPrePass.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setDepthPrePassStencil = exports.createDepthPrePassMesh = exports.isDepthPrePassMesh = exports.createDepthPrePassMaterial = exports.isRenderDepthPrePassEnabled = exports.DEPTH_PRE_PASS_STENCIL_MASK = void 0;
const ColorUtils_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/ColorUtils */ "../harp-datasource-protocol/lib/ColorUtils.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
/**
 * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position
 * from rendering color.
 * @internal
 */
exports.DEPTH_PRE_PASS_STENCIL_MASK = 0x01;
/**
 * Render order offset for the depth pre-pass to ensure that it's rendered first.
 */
const DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;
/**
 * Check if technique requires (and not disables) use of depth prepass.
 *
 * @remarks
 * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly
 * disabled by `enableDepthPrePass` option.
 *
 * @param technique - `BaseStandardTechnique` instance to be checked
 * @param env - {@link @here/harp-datasource-protocol#Env} instance used
 *              to evaluate {@link @here/harp-datasource-protocol#Expr}
 *              based properties of `Technique`
 *
 * @internal
 */
function isRenderDepthPrePassEnabled(technique, env) {
    // Depth pass explicitly disabled
    if (technique.enableDepthPrePass === false) {
        return false;
    }
    let transparent = technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;
    // If not opaque then check if transparency may be modified via alpha in base color.
    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,
    // will always produce some transparency effect.
    if (!transparent) {
        // We do not support switching depth pass during alpha interpolation, ignore zoom level
        // when calculating base color value.
        const color = DecodedTileHelpers_1.evaluateBaseColorProperty(technique, env);
        if (color !== undefined) {
            const alpha = ColorUtils_1.ColorUtils.getAlphaFromHex(color);
            transparent = alpha > 0.0 && alpha < 1.0;
        }
    }
    return transparent;
}
exports.isRenderDepthPrePassEnabled = isRenderDepthPrePassEnabled;
/**
 * Creates material for depth prepass.
 *
 * @remarks
 * Creates material that writes only to the z-buffer. Updates the original material instance, to
 * support depth prepass.
 *
 * @param baseMaterial - The base material of mesh that is updated to work with depth prepass
 *     and then used. This parameter is a template for depth prepass material that is returned.
 * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.
 *
 * @internal
 */
function createDepthPrePassMaterial(baseMaterial) {
    baseMaterial.depthWrite = false;
    baseMaterial.depthFunc = THREE.EqualDepth;
    baseMaterial.colorWrite = true;
    harp_materials_1.enforceBlending(baseMaterial);
    const depthPassMaterial = baseMaterial.clone();
    depthPassMaterial.isDepthPrepassMaterial = true;
    depthPassMaterial.depthWrite = true;
    depthPassMaterial.depthTest = true;
    depthPassMaterial.depthFunc = THREE.LessDepth;
    depthPassMaterial.colorWrite = false;
    depthPassMaterial.opacity = 1.0;
    depthPassMaterial.blending = THREE.NoBlending;
    return depthPassMaterial;
}
exports.createDepthPrePassMaterial = createDepthPrePassMaterial;
/**
 * Checks if a given object is a depth prepass mesh.
 *
 * @param object - The object to check whether it's a depth prepass mesh.
 * @returns `true` if the object is a depth prepass mesh, `false` otherwise.
 *
 * @internal
 */
function isDepthPrePassMesh(object) {
    if (object.isMesh !== true) {
        return false;
    }
    const mesh = object;
    return mesh.material instanceof Array
        ? mesh.material.every(material => material.isDepthPrepassMaterial === true)
        : mesh.material.isDepthPrepassMaterial === true;
}
exports.isDepthPrePassMesh = isDepthPrePassMesh;
/**
 * Clones a given mesh to render it in the depth prepass with another material.
 *
 * @remarks
 * Both the original
 * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass
 * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to
 * support the depth prepass. This method is usable only if the material of this mesh has an
 * opacity value in the range `(0,1)`.
 *
 * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh
 * to ensure that it's rendered first.
 *
 * @param mesh - original mesh
 * @returns `Mesh` depth pre pass
 *
 * @internal
 */
function createDepthPrePassMesh(mesh) {
    const originalGeometry = mesh.geometry;
    if (!(originalGeometry instanceof THREE.BufferGeometry)) {
        throw new Error("#createDepthPassMesh only BufferGeometry is supported");
    }
    const positionAttribute = originalGeometry.getAttribute("position");
    if (!positionAttribute) {
        throw new Error("#createDepthPassMesh position attribute not found");
    }
    const depthPassGeometry = new THREE.BufferGeometry();
    depthPassGeometry.setAttribute("position", positionAttribute);
    const uvAttribute = originalGeometry.getAttribute("uv");
    if (uvAttribute) {
        depthPassGeometry.setAttribute("uv", uvAttribute);
    }
    const normalAttribute = originalGeometry.getAttribute("normal");
    if (normalAttribute) {
        depthPassGeometry.setAttribute("normal", normalAttribute);
    }
    const extrusionAxisAttribute = originalGeometry.getAttribute("extrusionAxis");
    if (extrusionAxisAttribute) {
        depthPassGeometry.setAttribute("extrusionAxis", extrusionAxisAttribute);
    }
    if (originalGeometry.index) {
        depthPassGeometry.setIndex(originalGeometry.index);
    }
    for (const group of originalGeometry.groups) {
        const { start, count, materialIndex } = group;
        depthPassGeometry.addGroup(start, count, materialIndex);
    }
    const depthPassMaterial = mesh.material instanceof Array
        ? mesh.material.map(createDepthPrePassMaterial)
        : createDepthPrePassMaterial(mesh.material);
    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);
    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;
    return depthPassMesh;
}
exports.createDepthPrePassMesh = createDepthPrePassMesh;
/**
 * Sets up all the needed stencil logic needed for the depth pre-pass.
 *
 * @remarks
 * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have
 * coplanar triangles inside the same mesh.
 *
 * @param depthMesh - Mesh created by `createDepthPrePassMesh`.
 * @param colorMesh - Original mesh.
 * @internal
 */
function setDepthPrePassStencil(depthMesh, colorMesh) {
    function setupDepthMaterialStencil(depthMeshMaterial) {
        // Set up depth mesh stencil logic.
        // Set the depth pre-pass stencil bit for all processed fragments. We use
        // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass
        // the stencil test and write the correct depth value.
        const depthMaterial = depthMeshMaterial;
        depthMaterial.stencilWrite = true;
        depthMaterial.stencilFail = THREE.KeepStencilOp;
        depthMaterial.stencilZFail = THREE.KeepStencilOp;
        depthMaterial.stencilZPass = THREE.ReplaceStencilOp;
        depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;
        depthMaterial.stencilRef = 0xff;
        depthMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
    }
    function setupColorMaterialStencil(colorMeshMaterial) {
        // Set up color mesh stencil logic.
        // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is
        // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position
        // from rendering color again.
        const colorMaterial = colorMeshMaterial;
        colorMaterial.stencilWrite = true;
        colorMaterial.stencilFail = THREE.KeepStencilOp;
        colorMaterial.stencilZFail = THREE.KeepStencilOp;
        colorMaterial.stencilZPass = THREE.ZeroStencilOp;
        colorMaterial.stencilFunc = THREE.EqualStencilFunc;
        colorMaterial.stencilRef = 0xff;
        colorMaterial.stencilFuncMask = exports.DEPTH_PRE_PASS_STENCIL_MASK;
    }
    if (depthMesh.material instanceof Array) {
        depthMesh.material.map(setupDepthMaterialStencil);
    }
    else {
        setupDepthMaterialStencil(depthMesh.material);
    }
    if (colorMesh.material instanceof Array) {
        colorMesh.material.map(setupColorMaterialStencil);
    }
    else {
        setupColorMaterialStencil(colorMesh.material);
    }
}
exports.setDepthPrePassStencil = setDepthPrePassStencil;


/***/ }),

/***/ "../harp-mapview/lib/DisplacementMap.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/DisplacementMap.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-mapview/lib/ElevationProvider.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/ElevationProvider.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-mapview/lib/ElevationRangeSource.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/ElevationRangeSource.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CalculationStatus = void 0;
/**
 * Status of the elevation range calculation.
 */
var CalculationStatus;
(function (CalculationStatus) {
    // Calculated approximately. A more precise result may be available later.
    CalculationStatus[CalculationStatus["PendingApproximate"] = 0] = "PendingApproximate";
    // Calculation completed. The result is final, won't improve upon retrying.
    CalculationStatus[CalculationStatus["FinalPrecise"] = 1] = "FinalPrecise";
})(CalculationStatus = exports.CalculationStatus || (exports.CalculationStatus = {}));


/***/ }),

/***/ "../harp-mapview/lib/EventDispatcher.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/EventDispatcher.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventDispatcher = void 0;
/**
 * JavaScript events for custom objects. Stores all listeners to allow removing all listeners for
 * housekeeping.
 *
 * Will be replaced by `THREE.EventDispatcher` once https://github.com/mrdoob/three.js/pull/19844
 * is released.
 */
class EventDispatcher {
    constructor() {
        this.m_listeners = new Map();
    }
    /**
     * Destroy this `EventDispatcher` instance.
     *
     * Unregister all event handlers used. This is method should be called when you stop
     * using `EventDispatcher`.
     */
    dispose() {
        this.removeAllEventListeners();
    }
    /**
     * Checks if listener is added to an event type.
     *
     * @param type - The type of event to listen to.
     * @param listener - The function that gets called when the event is fired.
     */
    hasEventListener(type, listener) {
        const listeners = this.m_listeners.get(type);
        if (listeners === undefined) {
            return false;
        }
        return listener !== undefined ? listeners.includes(listener) : true;
    }
    /**
     * Add a new event listener to the event type.
     *
     * @param type - The type of event to listen to.
     * @param listener - The function that gets called when the event is fired.
     */
    addEventListener(type, listener) {
        let listeners = this.m_listeners.get(type);
        if (listeners === undefined) {
            listeners = [];
            this.m_listeners.set(type, listeners);
        }
        if (!listeners.includes(listener)) {
            listeners.push(listener);
        }
    }
    /**
     * Remove the listener from the event type.
     *
     * @param type - The type of event to listen to.
     * @param listener - The function that gets called when the event is fired. If the value is
     * `undefined`, all listeners will be removed.
     */
    removeEventListener(type, listener) {
        const listeners = this.m_listeners.get(type);
        if (listeners === undefined) {
            return;
        }
        if (listener === undefined) {
            this.m_listeners.delete(type);
        }
        else {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
                if (listeners.length === 0) {
                    this.m_listeners.delete(type);
                }
            }
        }
    }
    /**
     * Remove all event listeners for housekeeping.
     */
    removeAllEventListeners() {
        const events = Array.from(this.m_listeners.keys());
        for (const event of events) {
            this.removeEventListener(event);
        }
    }
    /**
     * Retrieve the registered event types.
     *
     * @returns Array of event types.
     */
    get eventTypes() {
        return Array.from(this.m_listeners.keys());
    }
    /**
     * Retrieve the registered listeners to the specified event.
     *
     * @param type - The type of event to listen to.
     * @returns Array of event listeners.
     */
    listeners(type) {
        return this.m_listeners.get(type);
    }
    /**
     * Dispatch the event to the registered listeners.
     *
     * @param event - The event to dispatch.
     */
    dispatchEvent(event) {
        const listeners = this.m_listeners.get(event.type);
        if (listeners !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listeners.slice(0);
            for (let i = 0, l = array.length; i < l; i++) {
                array[i].call(this, event);
            }
        }
    }
}
exports.EventDispatcher = EventDispatcher;


/***/ }),

/***/ "../harp-mapview/lib/FixedClipPlanesEvaluator.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/FixedClipPlanesEvaluator.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedClipPlanesEvaluator = void 0;
/**
 * Provides the most basic evaluation concept giving fixed values with some constraints.
 */
class FixedClipPlanesEvaluator {
    constructor(minNear = 1, minFarOffset = 10) {
        this.minNear = minNear;
        this.minFarOffset = minFarOffset;
        this.minFar = minNear + minFarOffset;
        this.m_nearPlane = minNear;
        this.m_farPlane = this.minFar;
    }
    get nearPlane() {
        return this.m_nearPlane;
    }
    set nearPlane(fixedNear) {
        this.invalidatePlanes(fixedNear, this.m_farPlane);
    }
    get farPlane() {
        return this.m_farPlane;
    }
    set farPlane(fixedFar) {
        this.invalidatePlanes(this.m_nearPlane, fixedFar);
    }
    set minElevation(elevation) { }
    get minElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    set maxElevation(elevation) { }
    get maxElevation() {
        // This evaluator does not support elevation so its always set to 0.
        return 0;
    }
    /** @override */
    evaluateClipPlanes(camera, projection, elevationProvider) {
        // We do not need to perform actual evaluation cause results are precomputed and
        // kept stable until somebody changes the properties.
        const viewRanges = {
            near: this.m_nearPlane,
            far: this.m_farPlane,
            minimum: this.minNear,
            maximum: this.m_farPlane
        };
        return viewRanges;
    }
    invalidatePlanes(near, far) {
        // When clamping prefer to extend far plane at about minimum distance, giving
        // near distance setup priority over far.
        const nearDist = Math.max(this.minNear, near);
        const farDist = Math.max(this.minFar, far, nearDist + this.minFarOffset);
        this.m_nearPlane = nearDist;
        this.m_farPlane = farDist;
    }
}
exports.FixedClipPlanesEvaluator = FixedClipPlanesEvaluator;


/***/ }),

/***/ "../harp-mapview/lib/FovCalculation.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/FovCalculation.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_FOV_RAD = exports.MIN_FOV_RAD = exports.MAX_FOV_DEG = exports.MIN_FOV_DEG = exports.DEFAULT_FOV_CALCULATION = void 0;
const THREE = __webpack_require__(/*! three */ "three");
exports.DEFAULT_FOV_CALCULATION = { type: "dynamic", fov: 40 };
exports.MIN_FOV_DEG = 10;
exports.MAX_FOV_DEG = 140;
exports.MIN_FOV_RAD = THREE.MathUtils.degToRad(exports.MIN_FOV_DEG);
exports.MAX_FOV_RAD = THREE.MathUtils.degToRad(exports.MAX_FOV_DEG);


/***/ }),

/***/ "../harp-mapview/lib/FrustumIntersection.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/FrustumIntersection.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrustumIntersection = exports.TileKeyEntry = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ElevationRangeSource_1 = __webpack_require__(/*! ./ElevationRangeSource */ "../harp-mapview/lib/ElevationRangeSource.ts");
const MapTileCuller_1 = __webpack_require__(/*! ./MapTileCuller */ "../harp-mapview/lib/MapTileCuller.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];
const tmpVector4 = new THREE.Vector4();
/**
 * Represents a unique TileKey and the area it takes up on screen.
 *
 * Note, in certain tiling projections, it is possible to have an offset, which represents a tile
 * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which
 * don't require it.
 */
class TileKeyEntry {
    constructor(tileKey, area, offset = 0, elevationRange, distance = 0) {
        this.tileKey = tileKey;
        this.area = area;
        this.offset = offset;
        this.elevationRange = elevationRange;
        this.distance = distance;
    }
}
exports.TileKeyEntry = TileKeyEntry;
function getGeoBox(tilingScheme, childTileKey, offset) {
    const geoBox = tilingScheme.getGeoBox(childTileKey);
    const longitudeOffset = 360.0 * offset;
    geoBox.northEast.longitude += longitudeOffset;
    geoBox.southWest.longitude += longitudeOffset;
    return geoBox;
}
/**
 * Computes the tiles intersected by the frustum defined by the current camera setup.
 */
class FrustumIntersection {
    constructor(m_camera, mapView, m_extendedFrustumCulling, m_tileWrappingEnabled, m_enableMixedLod, m_tilePixelSize = 256) {
        this.m_camera = m_camera;
        this.mapView = mapView;
        this.m_extendedFrustumCulling = m_extendedFrustumCulling;
        this.m_tileWrappingEnabled = m_tileWrappingEnabled;
        this.m_enableMixedLod = m_enableMixedLod;
        this.m_tilePixelSize = m_tilePixelSize;
        this.m_frustum = new THREE.Frustum();
        // used to project global coordinates into camera local coordinates
        this.m_viewProjectionMatrix = new THREE.Matrix4();
        this.m_rootTileKeys = [];
        this.m_tileKeyEntries = new Map();
        this.m_mapTileCuller = new MapTileCuller_1.MapTileCuller(m_camera);
    }
    /**
     * Return camera used for generating frustum.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * Return projection used to convert geo coordinates to world coordinates.
     */
    get projection() {
        return this.mapView.projection;
    }
    /**
     * Updates the frustum to match the current camera setup.
     */
    updateFrustum(projectionMatrixOverride) {
        this.m_viewProjectionMatrix.multiplyMatrices(projectionMatrixOverride !== undefined
            ? projectionMatrixOverride
            : this.m_camera.projectionMatrix, this.m_camera.matrixWorldInverse);
        this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);
        if (this.m_extendedFrustumCulling) {
            this.m_mapTileCuller.setup();
        }
        this.computeRequiredInitialRootTileKeys(this.m_camera.position);
    }
    /**
     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].
     *
     * @param tilingScheme - The tiling scheme used to generate the tiles.
     * @param elevationRangeSource - Source of elevation range data if any.
     * @param zoomLevels - A list of zoom levels to render.
     * @param dataSources - A list of data sources to render.
     * @returns The computation result, see [[FrustumIntersection.Result]].
     */
    compute(tilingScheme, elevationRangeSource, zoomLevels, dataSources) {
        this.m_tileKeyEntries.clear();
        // Compute target tile area in clip space size.
        // A tile should take up roughly 256x256 pixels on screen in accordance to
        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].
        harp_utils_1.assert(this.mapView.viewportHeight !== 0);
        const targetTileArea = Math.pow(this.m_tilePixelSize / this.mapView.viewportHeight, 2);
        const useElevationRangeSource = elevationRangeSource !== undefined &&
            elevationRangeSource.getTilingScheme() === tilingScheme;
        const obbIntersections = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical || useElevationRangeSource;
        const uniqueZoomLevels = new Set(zoomLevels);
        // Gather the minimum and maximum geometry heights of all datasources to enlarge the
        // bounding boxes of tiles for visibility tests.
        let minGeometryHeight = 0;
        let maxGeometryHeight = 0;
        dataSources.forEach(dataSource => {
            minGeometryHeight = Math.min(minGeometryHeight, dataSource.minGeometryHeight);
            maxGeometryHeight = Math.max(maxGeometryHeight, dataSource.maxGeometryHeight);
        });
        const cache = {
            calculationFinal: true,
            tileBounds: obbIntersections ? new harp_geoutils_1.OrientedBox3() : new THREE.Box3()
        };
        // create tile key map per zoom level
        for (const zoomLevel of uniqueZoomLevels) {
            this.m_tileKeyEntries.set(zoomLevel, new Map());
        }
        for (const tileEntry of this.m_rootTileKeys) {
            const tileKey = tileEntry.tileKey;
            const offset = tileEntry.offset;
            // We even check the root tiles against the frustum b/c it can happen that
            // computeRequiredInitialRootTileKeys is producing false positives.
            const tileKeyEntry = this.getTileKeyEntry(tileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : undefined);
            if (tileKeyEntry !== undefined) {
                for (const zoomLevel of uniqueZoomLevels) {
                    const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                    tileKeyEntries.set(harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset), tileKeyEntry);
                }
            }
        }
        const workList = [...this.m_rootTileKeys.values()];
        while (workList.length > 0) {
            const tileEntry = workList.pop();
            if (tileEntry === undefined) {
                break;
            }
            // Stop subdivision if hightest visible level is reached
            const tileKey = tileEntry.tileKey;
            const offset = tileEntry.offset;
            const subdivide = dataSources.some((ds, i) => ds.shouldSubdivide(zoomLevels[i], tileKey));
            if (!subdivide) {
                continue;
            }
            // Stop subdivision if area of tile is too small(mixed LOD only)
            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {
                continue;
            }
            const tileKeyAndOffset = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset);
            // delete parent tile key from applicable zoom levels
            for (const zoomLevel of uniqueZoomLevels) {
                if (tileKey.level >= zoomLevel) {
                    continue;
                }
                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel);
                tileKeyEntries.delete(tileKeyAndOffset);
            }
            for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {
                const subTileEntry = this.getTileKeyEntry(subTileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, useElevationRangeSource ? elevationRangeSource : undefined);
                if (subTileEntry !== undefined) {
                    // insert sub tile entry into tile entries map per zoom level
                    for (const zoomLevel of uniqueZoomLevels) {
                        if (subTileEntry.tileKey.level > zoomLevel) {
                            continue;
                        }
                        const subTileKeyAndOffset = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(subTileKey, offset);
                        this.m_tileKeyEntries
                            .get(zoomLevel)
                            .set(subTileKeyAndOffset, subTileEntry);
                    }
                    workList.push(subTileEntry);
                }
            }
        }
        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal: cache.calculationFinal };
    }
    getTileKeyEntry(tileKey, offset, tilingScheme, cache, minGeometryHeight, maxGeometryHeight, elevationRangeSource) {
        var _a, _b;
        const geoBox = getGeoBox(tilingScheme, tileKey, offset);
        // For tiles without elevation range source, default 0 (getGeoBox always
        // returns box with altitude min/max equal to zero) will be propagated as
        // min and max elevation, these tiles most probably contains features that
        // lays directly on the ground surface.
        if (elevationRangeSource !== undefined) {
            const range = elevationRangeSource.getElevationRange(tileKey);
            geoBox.southWest.altitude = range.minElevation;
            geoBox.northEast.altitude = range.maxElevation;
            cache.calculationFinal =
                cache.calculationFinal &&
                    range.calculationStatus === ElevationRangeSource_1.CalculationStatus.FinalPrecise;
        }
        // Enlarge the bounding boxes of tiles with min/max geometry height for visibility tests.
        geoBox.southWest.altitude = ((_a = geoBox.southWest.altitude) !== null && _a !== void 0 ? _a : 0) + minGeometryHeight;
        geoBox.northEast.altitude = ((_b = geoBox.northEast.altitude) !== null && _b !== void 0 ? _b : 0) + maxGeometryHeight;
        this.mapView.projection.projectBox(geoBox, cache.tileBounds);
        const { area, distance } = this.computeTileAreaAndDistance(cache.tileBounds);
        if (area > 0) {
            return new TileKeyEntry(tileKey, area, offset, {
                minElevation: geoBox.southWest.altitude,
                maxElevation: geoBox.northEast.altitude
            }, distance);
        }
        return undefined;
    }
    /**
     * Estimate screen space area of tile and distance to center of tile
     * @param tileBounds - The bounding volume of a tile
     * @return Area estimate and distance to tile center in clip space
     */
    computeTileAreaAndDistance(tileBounds) {
        if (tileBounds instanceof THREE.Box3) {
            if ((this.m_extendedFrustumCulling &&
                !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||
                !this.m_frustum.intersectsBox(tileBounds)) {
                return {
                    area: 0,
                    distance: Infinity
                };
            }
        }
        else if (!tileBounds.intersects(this.m_frustum)) {
            return {
                area: 0,
                distance: Infinity
            };
        }
        // Project tile bounds center
        const center = tileBounds.getCenter(tmpVectors3[0]);
        const projectedPoint = tmpVector4
            .set(center.x, center.y, center.z, 1.0)
            .applyMatrix4(this.m_viewProjectionMatrix);
        // Estimate objects screen space size with diagonal of bounds
        // Dividing by w projects object size to screen space
        const size = tileBounds.getSize(tmpVectors3[1]);
        const objectSize = (0.5 * size.length()) / projectedPoint.w;
        return {
            area: objectSize * objectSize,
            //Dividing by w means we loose information for whether the point is behind the camera
            //(i.e. it is in front of the near plane) or beyond the far plane, hence we first clamp
            //to [-1, 1] range, before doing the division.
            distance: projectedPoint.z <= -projectedPoint.w
                ? -1
                : projectedPoint.z >= projectedPoint.w
                    ? 1
                    : projectedPoint.z / projectedPoint.w
        };
    }
    /**
     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0
     * and have an offset (see {@link Tile}) based on:
     * - the current position [[worldCenter]].
     * - the height of the camera above the world.
     * - the field of view of the camera (the maximum value between the horizontal / vertical
     *   values)
     * - the tilt of the camera (because we see more tiles when tilted).
     *
     * @param worldCenter - The center of the camera in world space.
     */
    computeRequiredInitialRootTileKeys(worldCenter) {
        this.m_rootTileKeys = [];
        const rootTileKey = harp_geoutils_1.TileKey.fromRowColumnLevel(0, 0, 0);
        const tileWrappingEnabled = this.mapView.projection.type === harp_geoutils_1.ProjectionType.Planar;
        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0));
            return;
        }
        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);
        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);
        // This algorithm computes the number of offsets we need to test. The following diagram may
        // help explain the algorithm below.
        //
        //   |
        //   |.\ .
        //   | . \  .
        // z |  .  \   .c2
        //   |  c1.  \b    .
        //   |     .   \      .
        //___|a___d1.____\e______.d2______f
        //
        // Where:
        // -  is the camera
        // - z is the height of the camera above the ground.
        // - a is a right angle.
        // - b is the look at vector of the camera.
        // - c1 and c2 are the frustum planes of the camera.
        // - c1 to c2 is the fov.
        // - d1 and d2 are the intersection points of the frustum with the world plane.
        // - e is the tilt/pitch of the camera.
        // - f is the world
        //
        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it
        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).
        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with
        // a->e.
        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of
        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because
        // we need the angle between e,  and d2) and using trigonometry, result is therefore:
        // (tan(a->d2) * z).
        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).
        const camera = this.m_camera;
        const cameraPitch = Utils_1.MapViewUtils.extractAttitude(this.mapView, camera).pitch;
        // Ensure that the aspect is >= 1.
        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;
        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.
        const totalAngleRad = THREE.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;
        // Length a->d2
        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;
        // Length a->e
        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;
        // Length e -> d2
        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;
        const worldLeftPoint = new THREE.Vector3(worldCenter.x - worldLengthHorizontal, worldCenter.y, worldCenter.z);
        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);
        // We multiply by SQRT2 because we need to account for a rotated view (in which case there
        // are more tiles that can be seen).
        const offsetRange = THREE.MathUtils.clamp(Math.ceil(Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2), 0, 
        // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift
        // value which is used currently in the VisibleTileSet methods) hence we can have a
        // maximum range of 7 (because 2*7+1 = 15).
        7);
        for (let offset = -offsetRange + startOffset; offset <= offsetRange + startOffset; offset++) {
            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset));
        }
    }
}
exports.FrustumIntersection = FrustumIntersection;


/***/ }),

/***/ "../harp-mapview/lib/ITileLoader.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/ITileLoader.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileLoaderState = void 0;
/**
 * The state the {@link ITileLoader}.
 */
var TileLoaderState;
(function (TileLoaderState) {
    TileLoaderState[TileLoaderState["Initialized"] = 0] = "Initialized";
    TileLoaderState[TileLoaderState["Loading"] = 1] = "Loading";
    TileLoaderState[TileLoaderState["Loaded"] = 2] = "Loaded";
    TileLoaderState[TileLoaderState["Decoding"] = 3] = "Decoding";
    TileLoaderState[TileLoaderState["Ready"] = 4] = "Ready";
    TileLoaderState[TileLoaderState["Canceled"] = 5] = "Canceled";
    TileLoaderState[TileLoaderState["Failed"] = 6] = "Failed";
})(TileLoaderState = exports.TileLoaderState || (exports.TileLoaderState = {}));


/***/ }),

/***/ "../harp-mapview/lib/MapAnchors.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/MapAnchors.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapAnchors = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Container holding [[MapAnchor]] objects.
 */
class MapAnchors {
    constructor() {
        this.m_anchors = [];
        this.m_priorities = [];
    }
    /**
     * All currently added [[MapAnchor]]s.
     */
    get children() {
        return this.m_anchors;
    }
    /**
     * Add a [[MapAnchor]].
     * @param mapAnchor [[MapAnchor]] instance to add.
     */
    add(mapAnchor) {
        this.m_anchors.push(mapAnchor);
    }
    /**
     * Remove a [[MapAnchor]].
     * @param mapAnchor - [[MapAnchor]] instance to remove.
     *
     * @note This method is potentially slow when removing a lot of anchors.
     * [[clear]]ing and [[add]]ing anchors should be considered in that case.
     */
    remove(mapAnchor) {
        const index = this.m_anchors.findIndex(element => element === mapAnchor);
        if (index > -1) {
            this.m_anchors.splice(index, 1);
        }
    }
    /**
     * Remove all [[MapAnchor]]s.
     */
    clear() {
        this.m_anchors.length = 0;
    }
    setPriorities(priorities) {
        this.m_priorities = priorities;
    }
    /**
     * Update the map anchors.
     * @param projection - Current projection
     * @param cameraPosition - Current camera position
     * @param rootNode - Node where normal anchors will be inserted.
     * @param overlayRootNode - Node where overlay anchors will be insterted.
     * @param priorities - Optional theme priority list
     *
     * @internal
     * @hidden
     */
    update(projection, cameraPosition, rootNode, overlayRootNode) {
        const worldPosition = new THREE.Vector3();
        this.m_anchors.forEach((mapAnchor) => {
            var _a;
            if (mapAnchor.styleSet !== undefined) {
                const priority = (_a = this.m_priorities) === null || _a === void 0 ? void 0 : _a.findIndex(entry => entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category);
                if (priority !== undefined && priority !== -1) {
                    mapAnchor.renderOrder = (priority + 1) * 10;
                }
            }
            const anchor = mapAnchor.geoPosition !== undefined ? mapAnchor.geoPosition : mapAnchor.anchor;
            if (anchor !== undefined) {
                if (harp_geoutils_1.isVector3Like(anchor)) {
                    worldPosition.set(anchor.x, anchor.y, anchor.z);
                }
                else if (harp_geoutils_1.isGeoCoordinatesLike(anchor)) {
                    projection.projectPoint(anchor, worldPosition);
                }
                mapAnchor.position.copy(worldPosition).sub(cameraPosition);
            }
            if (mapAnchor.overlay === true) {
                overlayRootNode.add(mapAnchor);
            }
            else {
                rootNode.add(mapAnchor);
            }
        });
    }
}
exports.MapAnchors = MapAnchors;


/***/ }),

/***/ "../harp-mapview/lib/MapMaterialAdapter.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/MapMaterialAdapter.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapMaterialAdapter = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
function isTextureProperty(propertyName) {
    return harp_datasource_protocol_1.TEXTURE_PROPERTY_KEYS.includes(propertyName);
}
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.
 *
 * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.
 */
class MapMaterialAdapter {
    constructor(material, styledProperties) {
        this.m_lastUpdateFrameNumber = -1;
        this.tmpColor = new THREE.Color();
        this.material = material;
        this.styledProperties = styledProperties;
        this.currentStyledProperties = {};
        this.m_dynamicProperties = [];
        for (const propName in styledProperties) {
            if (!styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const propDefinition = styledProperties[propName];
            if (harp_datasource_protocol_1.Expr.isExpr(propDefinition) || typeof propDefinition === "function") {
                this.m_dynamicProperties.push([propName, propDefinition]);
            }
            else {
                this.currentStyledProperties[propName] = propDefinition;
            }
        }
        this.setupStaticProperties();
    }
    /**
     * Resolve `MapMaterialAdapter` associated with `material`.
     */
    static get(material) {
        var _a;
        const mapAdapter = (_a = material.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter;
        if (mapAdapter instanceof MapMaterialAdapter) {
            return mapAdapter;
        }
        else if (mapAdapter !== undefined) {
            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains
            // stylesed etc, this can be done to rebuild previously saved scene
            return undefined;
        }
        else {
            return undefined;
        }
    }
    static install(objData) {
        if (!objData.material.userData) {
            objData.material.userData = {};
        }
        return (objData.material.userData.mapAdapter = objData);
    }
    static create(material, styledProperties) {
        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));
    }
    static ensureUpdated(material, context) {
        var _a, _b;
        return (_b = (_a = MapMaterialAdapter.get(material)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { styledProperties: this.styledProperties };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates dynamically styled properties of material by evaluating scene dependent expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateDynamicProperties(context);
    }
    /**
     * Applies static properties to target material.
     */
    setupStaticProperties() {
        var _a, _b;
        let updateBaseColor = false;
        for (const propName in this.styledProperties) {
            if (!this.styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const currentValue = this.currentStyledProperties[propName];
            if (currentValue === undefined || currentValue === null) {
                continue;
            }
            if (propName === "color" || propName === "opacity") {
                updateBaseColor = true;
            }
            else if (!isTextureProperty(propName)) {
                // Static textures are already set in the material during tile construction.
                this.applyMaterialGenericProp(propName, currentValue);
            }
        }
        if (updateBaseColor) {
            const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
            const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
            this.applyMaterialBaseColor(color, opacity);
        }
    }
    /**
     * Applies static properties to target material.
     */
    updateDynamicProperties(context) {
        var _a, _b;
        let somethingChanged = false;
        if (this.m_dynamicProperties.length > 0) {
            let updateBaseColor = false;
            for (const [propName, propDefinition] of this.m_dynamicProperties) {
                const newValue = harp_datasource_protocol_1.Expr.isExpr(propDefinition)
                    ? harp_datasource_protocol_1.getPropertyValue(propDefinition, context.env)
                    : propDefinition(context);
                if (newValue === this.currentStyledProperties[propName]) {
                    continue;
                }
                this.currentStyledProperties[propName] = newValue;
                // `color` and `opacity` are special properties to support RGBA
                if (propName === "color" || propName === "opacity") {
                    updateBaseColor = true;
                }
                else if (isTextureProperty(propName)) {
                    this.applyMaterialTextureProp(propName, newValue);
                    somethingChanged = true;
                }
                else {
                    this.applyMaterialGenericProp(propName, newValue);
                    somethingChanged = true;
                }
            }
            if (updateBaseColor) {
                const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
                const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
                this.applyMaterialBaseColor(color, opacity);
                somethingChanged = true;
            }
        }
        return somethingChanged;
    }
    applyMaterialTextureProp(propName, value) {
        const m = this.material;
        // Wait until the texture is loaded for the first time on tile creation, that way,
        // the old texture properties can be copied to the new texture.
        if (!m[propName] || value === null) {
            return;
        }
        const oldTexture = m[propName];
        let newTexture;
        if (typeof value === "string") {
            newTexture = new THREE.TextureLoader().load(value, (texture) => {
                m[propName] = texture;
            });
        }
        else if (typeof value === "object") {
            const element = value;
            const isImage = element.nodeName === "IMG";
            const isCanvas = element.nodeName === "CANVAS";
            if (isImage || isCanvas) {
                newTexture = new THREE.CanvasTexture(element);
                if (isImage && !element.complete) {
                    const onLoad = () => {
                        m[propName] = newTexture;
                        element.removeEventListener("load", onLoad);
                    };
                    element.addEventListener("load", onLoad);
                }
                else {
                    m[propName] = newTexture;
                }
            }
        }
        if (newTexture) {
            newTexture.wrapS = oldTexture.wrapS;
            newTexture.wrapT = oldTexture.wrapT;
            newTexture.magFilter = oldTexture.magFilter;
            newTexture.minFilter = oldTexture.minFilter;
            newTexture.flipY = oldTexture.flipY;
            newTexture.repeat = oldTexture.repeat;
        }
    }
    applyMaterialGenericProp(propName, value) {
        const m = this.material;
        if (m[propName] instanceof THREE.Color) {
            let colorValue = value;
            if (typeof colorValue !== "number") {
                const parsed = DecodedTileHelpers_1.evaluateColorProperty(colorValue);
                if (parsed === undefined) {
                    return;
                }
                colorValue = parsed;
            }
            const rgbValue = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(colorValue);
            this.tmpColor.set(rgbValue);
            // We set the value, i.e. using =, as opposed to setting the color directly using set
            // because the material may be a custom material with a setter.
            value = this.tmpColor;
        }
        m[propName] = value;
    }
    applyMaterialBaseColor(color, opacity) {
        if (typeof color !== "number") {
            const parsed = DecodedTileHelpers_1.evaluateColorProperty(color);
            if (parsed === undefined) {
                return;
            }
            color = parsed;
        }
        const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(color !== null && color !== void 0 ? color : 0xff0000);
        const actualOpacity = a * THREE.MathUtils.clamp(opacity !== null && opacity !== void 0 ? opacity : 1, 0, 1);
        if (this.material instanceof harp_materials_1.RawShaderMaterial) {
            this.material.setOpacity(actualOpacity);
        }
        else {
            this.material.opacity = actualOpacity;
        }
        this.material.color.setRGB(r, g, b);
        const opaque = actualOpacity >= 1.0;
        if (!opaque) {
            harp_materials_1.enableBlending(this.material);
        }
        else {
            harp_materials_1.disableBlending(this.material);
        }
    }
}
exports.MapMaterialAdapter = MapMaterialAdapter;


/***/ }),

/***/ "../harp-mapview/lib/MapObjectAdapter.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/MapObjectAdapter.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapObjectAdapter = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const MapMaterialAdapter_1 = __webpack_require__(/*! ./MapMaterialAdapter */ "../harp-mapview/lib/MapMaterialAdapter.ts");
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.
 *
 * `MapObjectAdapter` is registered in `usedData.mapAdapter` property of `THREE.Object3D`.
 */
class MapObjectAdapter {
    constructor(object, params) {
        var _a;
        this.m_lastUpdateFrameNumber = -1;
        this.m_notCompletlyTransparent = true;
        this.object = object;
        this.technique = params.technique;
        this.kind = params.kind;
        this.dataSource = params.dataSource;
        this.m_pickability = (_a = params.pickability) !== null && _a !== void 0 ? _a : harp_datasource_protocol_1.Pickability.onlyVisible;
        this.m_notCompletlyTransparent = this.getObjectMaterials().some(material => material.opacity > 0);
        this.level = params.level;
    }
    /**
     * Resolve `MapObjectAdapter` associated with `object`.
     */
    static get(object) {
        var _a;
        return ((_a = object.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter) instanceof MapObjectAdapter
            ? object.userData.mapAdapter
            : undefined;
    }
    static install(objData) {
        if (!objData.object.userData) {
            objData.object.userData = {};
        }
        return (objData.object.userData.mapAdapter = objData);
    }
    static create(object, params) {
        return MapObjectAdapter.install(new MapObjectAdapter(object, params));
    }
    static ensureUpdated(object, context) {
        var _a, _b;
        return (_b = (_a = MapObjectAdapter.get(object)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { kind: this.kind, technique: this.technique };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates object and attachments like materials to current state by evaluating scene dependent
     * expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateMaterials(context);
    }
    /**
     * Whether underlying `THREE.Object3D` is actually visible in scene.
     */
    isVisible() {
        return this.object.visible && this.m_notCompletlyTransparent;
    }
    /**
     * Whether underlying `THREE.Object3D` should be pickable by {@link PickHandler}.
     */
    isPickable() {
        // An object is pickable only if it's visible and Pickabilty.onlyVisible or
        //  Pickabililty.all set.
        return ((this.pickability === harp_datasource_protocol_1.Pickability.onlyVisible && this.isVisible()) ||
            this.m_pickability === harp_datasource_protocol_1.Pickability.all);
    }
    get pickability() {
        return this.m_pickability;
    }
    updateMaterials(context) {
        let somethingChanged = false;
        const materials = this.getObjectMaterials();
        for (const material of materials) {
            const changed = MapMaterialAdapter_1.MapMaterialAdapter.ensureUpdated(material, context);
            somethingChanged = somethingChanged || changed;
        }
        if (somethingChanged) {
            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);
        }
        return somethingChanged;
    }
    getObjectMaterials() {
        const object = this.object;
        return Array.isArray(object.material)
            ? object.material
            : object.material !== undefined
                ? [object.material]
                : [];
    }
}
exports.MapObjectAdapter = MapObjectAdapter;


/***/ }),

/***/ "../harp-mapview/lib/MapTileCuller.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapTileCuller.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapTileCuller = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Second step tile culling: Do additional check for intersection of box and frustum by checking if
 * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of
 * the standard frustum test, which excludes many cases where the large terrain tiles straddle the
 * planes of the frustum.
 *
 * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
 */
class MapTileCuller {
    /**
     * Constructs a `MapTileCuller`.
     *
     * @param m_camera - A `THREE.Camera`.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_globalFrustumMin = new THREE.Vector3();
        this.m_globalFrustumMax = new THREE.Vector3();
        this.m_frustumCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
    }
    /**
     * Sets up culling and computes frustum corners. You mus call this function before the culling
     * starts.
     */
    setup() {
        const frustumCorners = this.getFrustumCorners();
        const matrix = this.m_camera.matrixWorld;
        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (const frustumCorner of frustumCorners) {
            frustumCorner.applyMatrix4(matrix);
            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);
            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);
            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);
            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);
            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);
            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);
        }
    }
    /**
     * Checks if the tile's bounding box intersects with the current view's frustum.
     *
     * @param tileBounds - The bounding box for the tile.
     */
    frustumIntersectsTileBox(tileBounds) {
        const globalFrustumMin = this.m_globalFrustumMin;
        const globalFrustumMax = this.m_globalFrustumMax;
        if (globalFrustumMax.x < tileBounds.min.x ||
            globalFrustumMax.y < tileBounds.min.y ||
            globalFrustumMax.z < tileBounds.min.z ||
            globalFrustumMin.x > tileBounds.max.x ||
            globalFrustumMin.y > tileBounds.max.y ||
            globalFrustumMin.z > tileBounds.max.z) {
            return false;
        }
        return true;
    }
    /**
     * Returns the eight corners of the frustum.
     */
    getFrustumCorners() {
        const frustumCorners = this.m_frustumCorners;
        const invProjMatrix = this.m_camera.projectionMatrixInverse;
        let cornerIndex = 0;
        function addPoint(x, y, z) {
            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);
        }
        const w = 1;
        const h = 1;
        const n = -1;
        const f = 1;
        // near
        addPoint(-w, -h, n);
        addPoint(w, -h, n);
        addPoint(-w, h, n);
        addPoint(w, h, n);
        // far
        addPoint(-w, -h, f);
        addPoint(w, -h, f);
        addPoint(-w, h, f);
        addPoint(w, h, f);
        return frustumCorners;
    }
}
exports.MapTileCuller = MapTileCuller;


/***/ }),

/***/ "../harp-mapview/lib/MapView.ts":
/*!**************************************!*\
  !*** ../harp-mapview/lib/MapView.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapView = exports.MapViewPowerPreference = exports.MapViewEventNames = exports.TileTaskGroups = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const AnimatedExtrusionHandler_1 = __webpack_require__(/*! ./AnimatedExtrusionHandler */ "../harp-mapview/lib/AnimatedExtrusionHandler.ts");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const CameraMovementDetector_1 = __webpack_require__(/*! ./CameraMovementDetector */ "../harp-mapview/lib/CameraMovementDetector.ts");
const CameraUtils_1 = __webpack_require__(/*! ./CameraUtils */ "../harp-mapview/lib/CameraUtils.ts");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts");
const composing_1 = __webpack_require__(/*! ./composing */ "../harp-mapview/lib/composing/index.ts");
const ConcurrentDecoderFacade_1 = __webpack_require__(/*! ./ConcurrentDecoderFacade */ "../harp-mapview/lib/ConcurrentDecoderFacade.ts");
const ConcurrentTilerFacade_1 = __webpack_require__(/*! ./ConcurrentTilerFacade */ "../harp-mapview/lib/ConcurrentTilerFacade.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./copyrights/CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "../harp-mapview/lib/EventDispatcher.ts");
const FovCalculation_1 = __webpack_require__(/*! ./FovCalculation */ "../harp-mapview/lib/FovCalculation.ts");
const FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ "../harp-mapview/lib/FrustumIntersection.ts");
const overlayOnElevation_1 = __webpack_require__(/*! ./geometry/overlayOnElevation */ "../harp-mapview/lib/geometry/overlayOnElevation.ts");
const TileGeometryManager_1 = __webpack_require__(/*! ./geometry/TileGeometryManager */ "../harp-mapview/lib/geometry/TileGeometryManager.ts");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts");
const MapAnchors_1 = __webpack_require__(/*! ./MapAnchors */ "../harp-mapview/lib/MapAnchors.ts");
const MapViewEnvironment_1 = __webpack_require__(/*! ./MapViewEnvironment */ "../harp-mapview/lib/MapViewEnvironment.ts");
const MapViewTaskScheduler_1 = __webpack_require__(/*! ./MapViewTaskScheduler */ "../harp-mapview/lib/MapViewTaskScheduler.ts");
const MapViewThemeManager_1 = __webpack_require__(/*! ./MapViewThemeManager */ "../harp-mapview/lib/MapViewThemeManager.ts");
const PickHandler_1 = __webpack_require__(/*! ./PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const PoiManager_1 = __webpack_require__(/*! ./poi/PoiManager */ "../harp-mapview/lib/poi/PoiManager.ts");
const PoiTableManager_1 = __webpack_require__(/*! ./poi/PoiTableManager */ "../harp-mapview/lib/poi/PoiTableManager.ts");
const PolarTileDataSource_1 = __webpack_require__(/*! ./PolarTileDataSource */ "../harp-mapview/lib/PolarTileDataSource.ts");
const ScreenProjector_1 = __webpack_require__(/*! ./ScreenProjector */ "../harp-mapview/lib/ScreenProjector.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const MapViewState_1 = __webpack_require__(/*! ./text/MapViewState */ "../harp-mapview/lib/text/MapViewState.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ./text/TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const TileObjectsRenderer_1 = __webpack_require__(/*! ./TileObjectsRenderer */ "../harp-mapview/lib/TileObjectsRenderer.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const VisibleTileSet_1 = __webpack_require__(/*! ./VisibleTileSet */ "../harp-mapview/lib/VisibleTileSet.ts");
// Cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
if (isProduction) {
    // In production: silence logging below error.
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Error);
}
else {
    // In dev: silence logging below log (silences "debug" and "trace" levels).
    harp_utils_1.LoggerManager.instance.setLogLevelForAll(harp_utils_1.LogLevel.Log);
}
var TileTaskGroups;
(function (TileTaskGroups) {
    TileTaskGroups["FETCH_AND_DECODE"] = "fetch";
    //DECODE = "decode",
    TileTaskGroups["CREATE"] = "create";
    //UPLOAD = "upload"
})(TileTaskGroups = exports.TileTaskGroups || (exports.TileTaskGroups = {}));
var MapViewEventNames;
(function (MapViewEventNames) {
    /** Called before this `MapView` starts to render a new frame. */
    MapViewEventNames["Update"] = "update";
    /** Called when the WebGL canvas is resized. */
    MapViewEventNames["Resize"] = "resize";
    /** Called when the frame is about to be rendered. */
    MapViewEventNames["Render"] = "render";
    /** Called after a frame has been rendered. */
    MapViewEventNames["AfterRender"] = "didrender";
    /** Called after the first frame has been rendered. */
    MapViewEventNames["FirstFrame"] = "first-render";
    /**
     * Called when the rendered frame was complete, i.e. all the necessary tiles and resources
     * are loaded and rendered.
     */
    MapViewEventNames["FrameComplete"] = "frame-complete";
    /** Called when the theme has been loaded with the internal {@link ThemeLoader}. */
    MapViewEventNames["ThemeLoaded"] = "theme-loaded";
    /** Called when the animation mode has started. */
    MapViewEventNames["AnimationStarted"] = "animation-started";
    /** Called when the animation mode has stopped. */
    MapViewEventNames["AnimationFinished"] = "animation-finished";
    /** Called when a camera interaction has been detected. */
    MapViewEventNames["MovementStarted"] = "movement-started";
    /** Called when a camera interaction has been stopped. */
    MapViewEventNames["MovementFinished"] = "movement-finished";
    /** Called when a data source has been connected or failed to connect. */
    MapViewEventNames["DataSourceConnect"] = "datasource-connect";
    /** Emitted when copyright info of rendered map has been changed. */
    MapViewEventNames["CopyrightChanged"] = "copyright-changed";
    /** Called when the WebGL context is lost. */
    MapViewEventNames["ContextLost"] = "webglcontext-lost";
    /** Called when the WebGL context is restored. */
    MapViewEventNames["ContextRestored"] = "webglcontext-restored";
    /** Called when camera position has been changed. */
    MapViewEventNames["CameraPositionChanged"] = "camera-changed";
    /** Called when dispose has been called, before any cleanup is done. */
    MapViewEventNames["Dispose"] = "dispose";
})(MapViewEventNames = exports.MapViewEventNames || (exports.MapViewEventNames = {}));
const logger = harp_utils_1.LoggerManager.instance.create("MapView");
const DEFAULT_CAM_NEAR_PLANE = 0.1;
const DEFAULT_CAM_FAR_PLANE = 4000000;
const DEFAULT_MIN_ZOOM_LEVEL = 1;
/**
 * Default maximum zoom level.
 */
const DEFAULT_MAX_ZOOM_LEVEL = 20;
/**
 * Default minimum camera height.
 */
const DEFAULT_MIN_CAMERA_HEIGHT = 20;
/**
 * Style set used by {@link PolarTileDataSource} by default.
 */
const DEFAULT_POLAR_STYLE_SET_NAME = "polar";
const cache = {
    vector2: [new THREE.Vector2()],
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    rayCaster: new THREE.Raycaster(),
    groundPlane: new THREE.Plane(),
    groundSphere: new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS),
    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],
    transform: [
        {
            position: new THREE.Vector3(),
            xAxis: new THREE.Vector3(),
            yAxis: new THREE.Vector3(),
            zAxis: new THREE.Vector3()
        }
    ],
    color: new THREE.Color()
};
/**
 * Hint for the WebGL implementation on which power mode to prefer.
 *
 * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12
 */
var MapViewPowerPreference;
(function (MapViewPowerPreference) {
    /** Default value. */
    MapViewPowerPreference["Default"] = "default";
    /** Lower power mode, used to conserve energy. */
    MapViewPowerPreference["LowPower"] = "low-power";
    /** Maximum performance. */
    MapViewPowerPreference["HighPerformance"] = "high-performance";
})(MapViewPowerPreference = exports.MapViewPowerPreference || (exports.MapViewPowerPreference = {}));
/**
 * Default settings used by {@link MapView} collected in one place.
 * @internal
 */
const MapViewDefaults = {
    projection: harp_geoutils_1.mercatorProjection,
    addBackgroundDatasource: true,
    maxVisibleDataSourceTiles: 100,
    extendedFrustumCulling: true,
    tileCacheSize: 200,
    resourceComputationType: VisibleTileSet_1.ResourceComputationType.EstimationInMb,
    quadTreeSearchDistanceUp: 3,
    quadTreeSearchDistanceDown: 2,
    pixelRatio: typeof window !== "undefined" && window.devicePixelRatio !== undefined
        ? window.devicePixelRatio
        : 1.0,
    target: new harp_geoutils_1.GeoCoordinates(25, 0),
    zoomLevel: 5,
    tilt: 0,
    heading: 0,
    theme: {},
    maxTilesPerFrame: 0
};
/**
 * The core class of the library to call in order to create a map visualization. It needs to be
 * linked to datasources.
 */
class MapView extends EventDispatcher_1.EventDispatcher {
    /**
     * Constructs a new `MapView` with the given options or canvas element.
     *
     * @param options - The `MapView` options or the HTML canvas element used to display the map.
     */
    constructor(options) {
        var _a, _b;
        super();
        /**
         * Keep the events here to avoid a global reference to MapView (and thus prevent garbage collection).
         */
        this.UPDATE_EVENT = { type: MapViewEventNames.Update };
        this.RENDER_EVENT = { type: MapViewEventNames.Render };
        this.DID_RENDER_EVENT = { type: MapViewEventNames.AfterRender };
        this.FIRST_FRAME_EVENT = { type: MapViewEventNames.FirstFrame };
        this.FRAME_COMPLETE_EVENT = {
            type: MapViewEventNames.FrameComplete
        };
        this.THEME_LOADED_EVENT = {
            type: MapViewEventNames.ThemeLoaded
        };
        this.ANIMATION_STARTED_EVENT = {
            type: MapViewEventNames.AnimationStarted
        };
        this.ANIMATION_FINISHED_EVENT = {
            type: MapViewEventNames.AnimationFinished
        };
        this.MOVEMENT_STARTED_EVENT = {
            type: MapViewEventNames.MovementStarted
        };
        this.MOVEMENT_FINISHED_EVENT = {
            type: MapViewEventNames.MovementFinished
        };
        this.CONTEXT_LOST_EVENT = {
            type: MapViewEventNames.ContextLost
        };
        this.CONTEXT_RESTORED_EVENT = {
            type: MapViewEventNames.ContextRestored
        };
        this.COPYRIGHT_CHANGED_EVENT = {
            type: MapViewEventNames.CopyrightChanged
        };
        this.DISPOSE_EVENT = { type: MapViewEventNames.Dispose };
        this.m_renderLabels = true;
        this.m_visibleTileSetLock = false;
        this.m_tileWrappingEnabled = true;
        this.m_zoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_minZoomLevel = DEFAULT_MIN_ZOOM_LEVEL;
        this.m_maxZoomLevel = DEFAULT_MAX_ZOOM_LEVEL;
        this.m_minCameraHeight = DEFAULT_MIN_CAMERA_HEIGHT;
        /**
         * Relative to eye camera.
         *
         * This camera is internal camera used to improve precision
         * when rendering geometries.
         */
        this.m_rteCamera = new THREE.PerspectiveCamera();
        this.m_yaw = 0;
        this.m_pitch = 0;
        this.m_roll = 0;
        this.m_targetDistance = 0;
        this.m_targetGeoPos = harp_geoutils_1.GeoCoordinates.fromObject(MapViewDefaults.target);
        // Focus point world coords may be calculated after setting projection, use dummy value here.
        this.m_targetWorldPos = new THREE.Vector3();
        this.m_viewRanges = {
            near: DEFAULT_CAM_NEAR_PLANE,
            far: DEFAULT_CAM_FAR_PLANE,
            minimum: DEFAULT_CAM_NEAR_PLANE,
            maximum: DEFAULT_CAM_FAR_PLANE
        };
        /** Default scene for map objects and map anchors */
        this.m_scene = new THREE.Scene();
        /** Separate scene for overlay map anchors */
        this.m_overlayScene = new THREE.Scene();
        /** Root node of [[m_scene]] that gets cleared every frame. */
        this.m_sceneRoot = new THREE.Object3D();
        /** Root node of [[m_overlayScene]] that gets cleared every frame. */
        this.m_overlaySceneRoot = new THREE.Object3D();
        this.m_mapAnchors = new MapAnchors_1.MapAnchors();
        this.m_animationCount = 0;
        this.m_drawing = false;
        this.m_updatePending = false;
        this.m_frameNumber = 0;
        this.m_forceCameraAspect = undefined;
        // type any as it returns different types depending on the environment
        this.m_taskSchedulerTimeout = undefined;
        //
        // sources
        //
        this.m_tileDataSources = [];
        this.m_connectedDataSources = new Set();
        this.m_failedDataSources = new Set();
        this.m_enablePolarDataSource = true;
        // gestures
        this.m_raycaster = new THREE.Raycaster();
        this.m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));
        this.m_sphere = new THREE.Sphere(undefined, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        this.m_firstFrameRendered = false;
        this.m_firstFrameComplete = false;
        this.m_userImageCache = new MapViewImageCache_1.MapViewImageCache();
        this.m_env = new harp_datasource_protocol_1.MapEnv({});
        this.m_poiManager = new PoiManager_1.PoiManager(this);
        this.m_poiTableManager = new PoiTableManager_1.PoiTableManager(this);
        this.m_lastTileIds = "";
        this.m_copyrightInfo = [];
        // `true` if dispose() has been called on `MapView`.
        this.m_disposed = false;
        /**
         * Default handler for webglcontextlost event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextLost = (event) => {
            this.dispatchEvent(this.CONTEXT_LOST_EVENT);
            logger.warn("WebGL context lost", event);
        };
        /**
         * Default handler for webglcontextrestored event.
         *
         * Note: The renderer `this.m_renderer` may not be initialized when this function is called.
         */
        this.onWebGLContextRestored = (event) => {
            this.dispatchEvent(this.CONTEXT_RESTORED_EVENT);
            if (this.m_renderer !== undefined) {
                this.textElementsRenderer.restoreRenderers(this.m_renderer);
                this.getTheme().then(theme => {
                    this.m_sceneEnvironment.updateClearColor(theme.clearColor, theme.clearAlpha);
                    this.update();
                });
            }
            logger.warn("WebGL context restored", event);
        };
        // make a copy to avoid unwanted changes to the original options.
        this.m_options = Object.assign({}, options);
        this.m_uriResolver = this.m_options.uriResolver;
        if (this.m_options.minZoomLevel !== undefined) {
            this.m_minZoomLevel = this.m_options.minZoomLevel;
        }
        if (this.m_options.maxZoomLevel !== undefined) {
            this.m_maxZoomLevel = this.m_options.maxZoomLevel;
        }
        if (this.m_options.minCameraHeight !== undefined) {
            this.m_minCameraHeight = this.m_options.minCameraHeight;
        }
        if (this.m_options.maxBounds !== undefined) {
            this.m_geoMaxBounds = this.m_options.maxBounds;
        }
        if (this.m_options.decoderUrl !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver
                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)
                : this.m_options.decoderUrl;
        }
        if (this.m_options.decoderCount !== undefined) {
            ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;
        }
        this.m_visibleTileSetOptions = Object.assign(Object.assign({}, MapViewDefaults), { clipPlanesEvaluator: options.clipPlanesEvaluator !== undefined
                ? options.clipPlanesEvaluator
                : ClipPlanesEvaluator_1.createDefaultClipPlanesEvaluator() });
        if (options.projection !== undefined) {
            this.m_visibleTileSetOptions.projection = options.projection;
        }
        if (options.extendedFrustumCulling !== undefined) {
            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;
        }
        if (options.maxVisibleDataSourceTiles !== undefined) {
            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =
                options.maxVisibleDataSourceTiles;
        }
        if (options.tileCacheSize !== undefined) {
            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;
        }
        if (options.resourceComputationType !== undefined) {
            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;
        }
        if (options.quadTreeSearchDistanceUp !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =
                options.quadTreeSearchDistanceUp;
        }
        if (options.quadTreeSearchDistanceDown !== undefined) {
            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =
                options.quadTreeSearchDistanceDown;
        }
        if (options.enablePolarDataSource !== undefined) {
            this.m_enablePolarDataSource = options.enablePolarDataSource;
        }
        this.m_pixelRatio = options.pixelRatio;
        this.m_options.maxFps = (_a = this.m_options.maxFps) !== null && _a !== void 0 ? _a : 0;
        this.m_options.enableStatistics = this.m_options.enableStatistics === true;
        this.m_languages = this.m_options.languages;
        this.m_politicalView = this.m_options.politicalView;
        this.handleRequestAnimationFrame = this.renderLoop.bind(this);
        if (this.m_options.tileWrappingEnabled !== undefined) {
            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;
        }
        // Initialization of the stats
        this.setupStats(this.m_options.enableStatistics);
        this.canvas.addEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.addEventListener("webglcontextrestored", this.onWebGLContextRestored);
        // Initialization of the renderer, enable backward compatibility with three.js <= 0.117
        this.m_renderer = new ((_b = THREE.WebGL1Renderer) !== null && _b !== void 0 ? _b : THREE.WebGLRenderer)({
            canvas: this.canvas,
            context: this.m_options.context,
            antialias: this.nativeWebglAntialiasEnabled,
            alpha: this.m_options.alpha,
            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,
            powerPreference: this.m_options.powerPreference === undefined
                ? MapViewPowerPreference.Default
                : this.m_options.powerPreference
        });
        this.m_renderer.autoClear = false;
        this.m_renderer.debug.checkShaderErrors = !isProduction;
        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info
        // When using several WebGLRenderer#render calls per frame, it is the only way to get
        // correct rendering data from ThreeJS.
        this.m_renderer.info.autoReset = false;
        this.m_tileObjectRenderer = new TileObjectsRenderer_1.TileObjectRenderer(this.m_env, this.m_renderer);
        this.setupRenderer(this.m_tileObjectRenderer);
        this.m_options.fovCalculation =
            this.m_options.fovCalculation === undefined
                ? FovCalculation_1.DEFAULT_FOV_CALCULATION
                : this.m_options.fovCalculation;
        this.m_options.fovCalculation.fov = THREE.MathUtils.clamp(this.m_options.fovCalculation.fov, FovCalculation_1.MIN_FOV_DEG, FovCalculation_1.MAX_FOV_DEG);
        // Initialization of mCamera and mVisibleTiles
        const { width, height } = this.getCanvasClientSize();
        const aspect = width / height;
        this.m_camera = new THREE.PerspectiveCamera(this.m_options.fovCalculation.fov, aspect, DEFAULT_CAM_NEAR_PLANE, DEFAULT_CAM_FAR_PLANE);
        this.m_camera.up.set(0, 0, 1);
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);
        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.
        this.m_screenProjector = new ScreenProjector_1.ScreenProjector(this.m_camera);
        // Scheduler must be initialized before VisibleTileSet.
        this.m_taskScheduler = new MapViewTaskScheduler_1.MapViewTaskScheduler(this.maxFps);
        this.m_tileGeometryManager = new TileGeometryManager_1.TileGeometryManager(this);
        if (options.enableMixedLod !== undefined) {
            this.m_enableMixedLod = options.enableMixedLod;
        }
        if (options.lodMinTilePixelSize !== undefined) {
            this.m_lodMinTilePixelSize = options.lodMinTilePixelSize;
        }
        // this.m_visibleTiles is set in createVisibleTileSet, set it here again only to let tsc
        // know the member is set in the constructor.
        this.m_visibleTiles = this.createVisibleTileSet();
        this.m_sceneEnvironment = new MapViewEnvironment_1.MapViewEnvironment(this, options);
        // setup camera with initial position
        this.setupCamera();
        this.m_pickHandler = new PickHandler_1.PickHandler(this, this.m_rteCamera, this.m_options.enablePickTechnique === true);
        this.m_movementDetector = new CameraMovementDetector_1.CameraMovementDetector(this.m_options.movementThrottleTimeout, () => this.movementStarted(), () => this.movementFinished());
        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;
        this.mapRenderingManager = new composing_1.MapRenderingManager(width, height, this.m_options.dynamicPixelRatio, mapPassAntialiasSettings);
        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler_1.AnimatedExtrusionHandler(this);
        if (this.m_enablePolarDataSource) {
            const styleSetName = options.polarStyleSetName !== undefined
                ? options.polarStyleSetName
                : DEFAULT_POLAR_STYLE_SET_NAME;
            this.m_polarDataSource = new PolarTileDataSource_1.PolarTileDataSource({
                styleSetName,
                geometryLevelOffset: options.polarGeometryLevelOffset
            });
            this.updatePolarDataSource();
        }
        this.m_taskScheduler.addEventListener(MapViewEventNames.Update, () => {
            this.update();
        });
        if (options.throttlingEnabled !== undefined) {
            this.m_taskScheduler.throttlingEnabled = options.throttlingEnabled;
        }
        this.m_themeManager = new MapViewThemeManager_1.MapViewThemeManager(this, this.m_uriResolver);
        // will initialize with an empty theme and updated when theme is loaded and set
        this.m_textElementsRenderer = this.createTextRenderer();
        this.setTheme(harp_utils_1.getOptionValue(this.m_options.theme, MapViewDefaults.theme));
        this.update();
    }
    /**
     * @returns The lights configured by the theme, this is just a convenience method, because the
     * lights can still be accessed by traversing the children of the [[scene]].
     */
    get lights() {
        return this.m_sceneEnvironment.lights;
    }
    get taskQueue() {
        return this.m_taskScheduler.taskQueue;
    }
    /**
     * @returns Whether label rendering is enabled.
     */
    get renderLabels() {
        return this.m_renderLabels;
    }
    /**
     * Enables or disables rendering of labels.
     * @param value - `true` to enable labels `false` to disable them.
     */
    set renderLabels(value) {
        this.m_renderLabels = value;
    }
    /**
     * @returns Whether adding of new labels during interaction is enabled.
     */
    get delayLabelsUntilMovementFinished() {
        return this.textElementsRenderer.delayLabelsUntilMovementFinished;
    }
    /**
     * Enables or disables adding of  new labels during interaction. Has no influence on already
     * placed labels
     * @param value - `true` to enable adding `false` to disable them.
     */
    set delayLabelsUntilMovementFinished(value) {
        this.textElementsRenderer.delayLabelsUntilMovementFinished = value;
    }
    /**
     * @hidden
     * The {@link TextElementsRenderer} select the visible {@link TextElement}s and renders them.
     */
    get textElementsRenderer() {
        return this.m_textElementsRenderer;
    }
    /**
     * @hidden
     * The {@link CameraMovementDetector} detects camera movements. Made available for performance
     * measurements.
     */
    get cameraMovementDetector() {
        return this.m_movementDetector;
    }
    /**
     * The {@link AnimatedExtrusionHandler} controls animated extrusion effect
     * of the extruded objects in the {@link Tile}
     */
    get animatedExtrusionHandler() {
        return this.m_animatedExtrusionHandler;
    }
    /**
     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of
     * specified [[GeometryKind]]s.
     * @deprecated
     */
    get tileGeometryManager() {
        return this.m_tileGeometryManager;
    }
    get enableMixedLod() {
        return this.m_enableMixedLod;
    }
    set enableMixedLod(enableMixedLod) {
        // Skip unnecessary update
        if (this.m_enableMixedLod === enableMixedLod) {
            return;
        }
        this.m_enableMixedLod = enableMixedLod;
        this.createVisibleTileSet();
        this.update();
    }
    get tileWrappingEnabled() {
        return this.m_tileWrappingEnabled;
    }
    set tileWrappingEnabled(enabled) {
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            logger.warn("Setting this with spherical projection has no affect. Was this intended?");
            return;
        }
        if (enabled !== this.m_tileWrappingEnabled) {
            this.m_tileWrappingEnabled = enabled;
            this.createVisibleTileSet();
        }
        this.update();
    }
    /**
     * Disposes this `MapView`.
     * @override
     *
     * @param freeContext - `true` to force ThreeJS to loose the context. Supply `false` to keep
     * the context for further use.
     *
     * @remarks
     * This function cleans the resources that are managed manually including those that exist in
     * shared caches.
     *
     * Note: This function does not try to clean objects that can be disposed off easily by
     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full
     * cleanup, you must ensure that all references to this `MapView` are removed.
     */
    dispose(freeContext = true) {
        // Enforce listeners that we are about to dispose.
        this.DISPOSE_EVENT.time = Date.now();
        this.dispatchEvent(this.DISPOSE_EVENT);
        this.m_disposed = true;
        if (this.m_movementFinishedUpdateTimerId) {
            clearTimeout(this.m_movementFinishedUpdateTimerId);
            this.m_movementFinishedUpdateTimerId = undefined;
        }
        if (this.m_animationFrameHandle !== undefined) {
            cancelAnimationFrame(this.m_animationFrameHandle);
            this.m_animationFrameHandle = undefined;
        }
        this.canvas.removeEventListener("webglcontextlost", this.onWebGLContextLost);
        this.canvas.removeEventListener("webglcontextrestored", this.onWebGLContextRestored);
        for (const dataSource of this.m_tileDataSources) {
            dataSource.dispose();
        }
        this.m_visibleTiles.clearTileCache();
        this.m_textElementsRenderer.clearRenderStates();
        this.m_renderer.dispose();
        if (freeContext) {
            // See for a discussion of using this call to force freeing the context:
            //   https://github.com/mrdoob/three.js/pull/17588
            // The patch to call forceContextLoss() upon WebGLRenderer.dispose() had been merged,
            // but has been reverted later:
            //   https://github.com/mrdoob/three.js/pull/19022
            this.m_renderer.forceContextLoss();
        }
        this.m_themeManager.dispose();
        this.m_tileGeometryManager.clear();
        this.m_movementDetector.dispose();
        // Destroy the facade if the there are no workers active anymore.
        ConcurrentDecoderFacade_1.ConcurrentDecoderFacade.destroyIfTerminated();
        ConcurrentTilerFacade_1.ConcurrentTilerFacade.destroyIfTerminated();
        this.m_taskScheduler.clearQueuedTasks();
        // Remove all event handlers.
        super.dispose();
    }
    /**
     * Is `true` if dispose() as been called on `MapView`.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_visibleTiles.resourceComputationType;
    }
    set resourceComputationType(value) {
        this.m_visibleTiles.resourceComputationType = value;
    }
    /**
     * Returns the cache size.
     */
    getCacheSize() {
        return this.m_visibleTiles.getDataSourceCacheSize();
    }
    /**
     * Sets the cache size in number of tiles.
     *
     * @param size - The cache size in tiles.
     * @param numVisibleTiles - The number of tiles visible, which is size/2 by default.
     */
    setCacheSize(size, numVisibleTiles) {
        this.m_visibleTiles.setDataSourceCacheSize(size);
        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;
        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));
        this.m_themeManager.updateCache();
        this.m_textElementsRenderer.invalidateCache();
        this.update();
    }
    /**
     * Specifies whether extended frustum culling is enabled or disabled.
     */
    get extendedFrustumCulling() {
        return this.m_options.extendedFrustumCulling !== undefined
            ? this.m_visibleTileSetOptions.extendedFrustumCulling
            : true;
    }
    /**
     * Enable of disable extended frustum culling.
     */
    set extendedFrustumCulling(value) {
        this.m_visibleTileSetOptions.extendedFrustumCulling = value;
    }
    /**
     * Returns the status of frustum culling after each update.
     */
    get lockVisibleTileSet() {
        return this.m_visibleTileSetLock;
    }
    /**
     * Enable of disable frustum culling after each update.
     */
    set lockVisibleTileSet(value) {
        this.m_visibleTileSetLock = value;
    }
    /**
     * Gets the optional camera used to render the scene.
     */
    get pointOfView() {
        return this.m_pointOfView;
    }
    /**
     * Sets the optional camera used to render the scene.
     */
    set pointOfView(pointOfView) {
        this.m_pointOfView = pointOfView;
        this.update();
    }
    /**
     * Loads a post effects definition file.
     *
     * @param postEffectsFile - File URL describing the post effects.
     */
    loadPostEffects(postEffectsFile) {
        fetch(postEffectsFile)
            .then(response => response.json())
            .then((postEffects) => {
            this.m_postEffects = postEffects;
            this.setPostEffects();
        });
    }
    /**
     * The abstraction of the {@link MapRenderingManager} API for post effects.
     */
    get postEffects() {
        return this.m_postEffects;
    }
    set postEffects(postEffects) {
        this.m_postEffects = postEffects;
        this.setPostEffects();
    }
    /**
     * Gets the current `Theme` used by this `MapView` to style map elements.
     * @deprecated
     */
    get theme() {
        return this.m_themeManager.theme;
    }
    /**
     * Changes the `Theme` used by this `MapView` to style map elements.
     * @deprecated use MapView.setTheme instead
     */
    set theme(theme) {
        this.setTheme(theme);
    }
    /**
     * Changes the `Theme`used by this `MapView`to style map elements.
     */
    async setTheme(theme) {
        const newTheme = await this.m_themeManager.setTheme(theme);
        this.THEME_LOADED_EVENT.time = Date.now();
        this.dispatchEvent(this.THEME_LOADED_EVENT);
        this.update();
        return newTheme;
    }
    /**
     * Returns the currently set `Theme` as a `Promise` as it might be still loading/updating.
     */
    async getTheme() {
        return await this.m_themeManager.getTheme();
    }
    /**
     * {@link @here/harp-utils#UriResolver} used to resolve application/deployment
     * specific `URI`s into actual `URLs` that can be loaded with `fetch`.
     */
    get uriResolver() {
        return this.m_uriResolver;
    }
    /**
     * Gets the value of the forced custom camera aspect.
     * Every time a frame is rendered, `MapView` resets the camera aspect.
     *
     * You can disable this behavior by setting the value to `undefined`.
     */
    get forceCameraAspect() {
        return this.m_forceCameraAspect;
    }
    /**
     * Sets the custom forced camera aspect ratio to use while rendering.
     */
    set forceCameraAspect(aspect) {
        this.m_forceCameraAspect = aspect;
    }
    /**
     * Lists the ISO 639-1 language codes for DataSources to use.
     */
    get languages() {
        return this.m_languages;
    }
    /**
     * Sets the list of ISO 639-1 language codes for DataSources to use.
     */
    set languages(languages) {
        this.m_languages = languages;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setLanguages(this.m_languages);
        });
        this.update();
    }
    /**
     * Get currently presented political point of view - the country code.
     *
     * @note Country code is stored in lower-case ISO 3166-1 alpha-2 standard.
     * @return Country code or undefined if default
     * (majorly accepted) point of view is used.
     */
    get politicalView() {
        return this.m_politicalView;
    }
    /**
     * Set the political view (country code) to be used when rendering disputed features (borders).
     *
     * @note Country code should be encoded in lower-case ISO 3166-1 alpha-2 standard.
     * @param pov - The code of the country which point of view should be presented,
     * if `undefined` or empty string is set then "defacto" or most widely accepted point of view
     * will be presented.
     */
    set politicalView(pov) {
        if (this.m_politicalView === pov) {
            return;
        }
        this.m_politicalView = pov;
        this.m_tileDataSources.forEach((dataSource) => {
            dataSource.setPoliticalView(pov);
        });
    }
    get copyrightInfo() {
        return this.m_copyrightInfo;
    }
    /**
     * @hidden
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_textElementsRenderer.disableFading = disable;
    }
    get disableFading() {
        return this.m_textElementsRenderer.disableFading;
    }
    /**
     * @hidden
     * Return current frame number.
     */
    get frameNumber() {
        return this.m_frameNumber;
    }
    /**
     * @hidden
     * Reset the frame number to 0.
     */
    resetFrameNumber() {
        this.m_frameNumber = 0;
        this.m_previousFrameTimeStamp = undefined;
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    addEventListener(type, listener) {
        super.addEventListener(type, listener);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    removeEventListener(type, listener) {
        super.removeEventListener(type, listener);
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get canvas() {
        return this.m_options.canvas;
    }
    /**
     * The HTML canvas element used by this `MapView`.
     */
    get collisionDebugCanvas() {
        return this.m_collisionDebugCanvas;
    }
    /**
     * The THREE.js scene used by this `MapView`.
     */
    get scene() {
        return this.m_scene;
    }
    /**
     * The THREE.js overlay scene
     */
    get overlayScene() {
        return this.m_overlayScene;
    }
    /**
     * The MapViewEnvironment used by this `MapView`.
     * @internal
     */
    get sceneEnvironment() {
        return this.m_sceneEnvironment;
    }
    /**
     * The THREE.js camera used by this `MapView` to render the main scene.
     *
     * @remarks
     * When modifying the camera all derived properties like:
     * - {@link MapView.target}
     * - {@link MapView.zoomLevel}
     * - {@link MapView.tilt}
     * - {@link MapView.heading}
     * could change.
     * These properties are cached internally and will only be updated in the next animation frame.
     * FIXME: Unfortunately THREE.js is not dispatching any events when camera properties change
     * so we should have an API for enforcing update of cached values.
     */
    get camera() {
        return this.m_camera;
    }
    /**
     * The THREE.js `WebGLRenderer` used by this scene.
     */
    get renderer() {
        return this.m_renderer;
    }
    /**
     * The color used to clear the view.
     */
    get clearColor() {
        const rendererClearColor = this.m_renderer.getClearColor(cache.color);
        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
    }
    /**
     * The color used to clear the view.
     */
    set clearColor(color) {
        this.m_renderer.setClearColor(color);
    }
    /**
     * The alpha used to clear the view.
     */
    get clearAlpha() {
        const rendererClearAlpha = this.m_renderer.getClearAlpha();
        return rendererClearAlpha !== undefined ? rendererClearAlpha : 0;
    }
    /**
     * The alpha used to clear the view.
     */
    set clearAlpha(alpha) {
        this.m_renderer.setClearAlpha(alpha);
    }
    /**
     * The projection used to project geo coordinates to world coordinates.
     */
    get projection() {
        return this.m_visibleTileSetOptions.projection;
    }
    /**
     * Changes the projection at run time.
     *
     * @param projection - The {@link @here/harp-geoutils#Projection} instance to use.
     */
    set projection(projection) {
        // Remember tilt and heading before setting the projection.
        const tilt = this.tilt;
        const heading = this.heading;
        this.m_visibleTileSetOptions.projection = projection;
        this.updatePolarDataSource();
        this.clearTileCache();
        this.textElementsRenderer.clearRenderStates();
        this.m_visibleTiles = this.createVisibleTileSet();
        // Set geo max bounds to compute world bounds with new projection.
        this.geoMaxBounds = this.geoMaxBounds;
        this.lookAtImpl({ tilt, heading });
    }
    /**
     * Get camera clipping planes evaluator used.
     */
    get clipPlanesEvaluator() {
        return this.m_visibleTileSetOptions.clipPlanesEvaluator;
    }
    /**
     * Changes the clip planes evaluator at run time.
     */
    set clipPlanesEvaluator(clipPlanesEvaluator) {
        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;
    }
    /**
     * The distance (in pixels) between the screen and the camera.
     * @deprecated Use {@link CameraUtils.getFocalLength}
     */
    get focalLength() {
        var _a;
        const focalLength = (_a = CameraUtils_1.CameraUtils.getFocalLength(this.m_camera)) !== null && _a !== void 0 ? _a : 0;
        return focalLength;
    }
    /**
     * Get geo coordinates of camera focus (target) point.
     *
     * @remarks
     * This point is not necessarily on the ground, i.e.:
     *  - if the tilt is high and projection is {@link @here/harp-geoutils#sphereProjection}`
     *  - if the camera was modified directly and is not pointing to the ground.
     * In any case the projection of the target point will be in the center of the screen.
     *
     * @returns geo coordinates of the camera focus point.
     */
    get target() {
        return this.m_targetGeoPos;
    }
    /** @internal
     * Get world coordinates of camera focus point.
     *
     * @remarks
     * @note The focus point coordinates are updated with each camera update so you don't need
     * to re-calculate it, although if the camera started looking to the void, the last focus
     * point is stored.
     *
     * @returns world coordinates of the camera focus point.
     */
    get worldTarget() {
        return this.m_targetWorldPos;
    }
    /** @internal
     * Get distance from camera to the point of focus in world units.
     *
     * @note If camera does not point to any ground anymore the last focus point distance is
     * then returned.
     *
     * @returns Last known focus point distance.
     */
    get targetDistance() {
        return this.m_targetDistance;
    }
    /**
     * Get object describing frustum planes distances and min/max visibility range for actual
     * camera setup.
     *
     * @remarks
     * Near and far plane distance are self explanatory while minimum and maximum visibility range
     * describes the extreme near/far planes distances that may be achieved with current camera
     * settings, meaning at current zoom level (ground distance) and any possible orientation.
     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines
     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change
     * whenever zoom level changes. Distance is measured in world units which may be approximately
     * equal to meters, but this depends on the distortion related to projection type used.
     * @internal
     */
    get viewRanges() {
        return this.m_viewRanges;
    }
    /**
     * The position in geo coordinates of the center of the scene.
     * @internal
     */
    get geoCenter() {
        return this.projection.unprojectPoint(this.m_camera.position).normalized();
    }
    /**
     * The position in geo coordinates of the center of the scene.
     *
     * @remarks
     * Longitude values outside of -180 and +180 are acceptable.
     */
    set geoCenter(geoCenter) {
        if (geoCenter.altitude !== undefined) {
            this.projection.projectPoint(geoCenter, this.m_camera.position);
        }
        else {
            // Preserve the current altitude
            const altitude = this.geoCenter.altitude;
            this.projection.projectPoint(new harp_geoutils_1.GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude), this.m_camera.position);
        }
        this.update();
    }
    /**
     * The node in this MapView's scene containing the user {@link MapAnchor}s.
     *
     * @remarks
     * All (first level) children of this node will be positioned in world space according to the
     * [[MapAnchor.geoPosition]].
     * Deeper level children can be used to position custom objects relative to the anchor node.
     */
    get mapAnchors() {
        return this.m_mapAnchors;
    }
    /**
     * The position in world coordinates of the center of the scene.
     */
    get worldCenter() {
        return this.m_camera.position;
    }
    /**
     * Get the [[PickHandler]] for this `mapView`.
     */
    get pickHandler() {
        return this.m_pickHandler;
    }
    /**
     * @internal
     * Get the {@link ImageCache} that belongs to this `MapView`.
     *
     * Images stored in this cache are primarily used for POIs (icons) and they are used with the
     * current theme. Although images can be explicitly added and removed from the cache, it is
     * advised not to remove images from this cache. If an image that is part of client code
     * should be removed at any point other than changing the theme, the {@link useImageCache}
     * should be used instead.
     */
    get imageCache() {
        return this.m_themeManager.imageCache;
    }
    /**
     * Get the {@link ImageCache} for user images that belongs to this `MapView`.
     *
     * Images added to this cache can be removed if no longer required.
     */
    get userImageCache() {
        return this.m_userImageCache;
    }
    /**
     * @hidden
     * @internal
     * Get the {@link PoiManager} that belongs to this `MapView`.
     */
    get poiManager() {
        return this.m_poiManager;
    }
    /**
     * @hidden
     * Get the array of {@link PoiTableManager} that belongs to this `MapView`.
     */
    get poiTableManager() {
        return this.m_poiTableManager;
    }
    /**
     * The minimum camera height in meters.
     */
    get minCameraHeight() {
        return this.m_minCameraHeight;
    }
    /**
     * The minimum zoom level.
     */
    get minZoomLevel() {
        return this.m_minZoomLevel;
    }
    /**
     * The minimum zoom level.
     */
    set minZoomLevel(zoomLevel) {
        this.m_minZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The maximum zoom level. Default is 14.
     */
    get maxZoomLevel() {
        return this.m_maxZoomLevel;
    }
    /**
     * The maximum zoom level.
     */
    set maxZoomLevel(zoomLevel) {
        this.m_maxZoomLevel = zoomLevel;
        this.update();
    }
    /**
     * The view's maximum bounds in geo coordinates if any.
     */
    get geoMaxBounds() {
        return this.m_geoMaxBounds;
    }
    /**
     * Sets or clears the view's maximum bounds in geo coordinates.
     *
     * @remarks
     * If set, the view will be
     * constrained to the given geo bounds.
     */
    set geoMaxBounds(bounds) {
        this.m_geoMaxBounds = bounds;
        this.m_worldMaxBounds = this.m_geoMaxBounds
            ? this.projection.projectBox(this.m_geoMaxBounds, this.projection.type === harp_geoutils_1.ProjectionType.Planar
                ? new THREE.Box3()
                : new harp_geoutils_1.OrientedBox3())
            : undefined;
    }
    /**
     * @hidden
     * @internal
     * The view's maximum bounds in world coordinates if any.
     */
    get worldMaxBounds() {
        return this.m_worldMaxBounds;
    }
    /**
     * Returns the zoom level for the given camera setup.
     */
    get zoomLevel() {
        return this.m_zoomLevel;
    }
    set zoomLevel(zoomLevel) {
        this.lookAtImpl({ zoomLevel });
    }
    /**
     * Returns tilt angle in degrees.
     */
    get tilt() {
        return THREE.MathUtils.radToDeg(this.m_pitch);
    }
    /**
     * Set the tilt angle of the map.
     * @param tilt -: New tilt angle in degrees.
     */
    set tilt(tilt) {
        this.lookAtImpl({ tilt });
    }
    /**
     * Returns heading angle in degrees.
     */
    get heading() {
        return -THREE.MathUtils.radToDeg(this.m_yaw);
    }
    /**
     * Set the heading angle of the map.
     * @param heading -: New heading angle in degrees.
     */
    set heading(heading) {
        this.lookAtImpl({ heading });
    }
    /**
     * Environment used to evaluate dynamic scene expressions.
     */
    get env() {
        return this.m_env;
    }
    /**
     * Returns the storage level for the given camera setup.
     * @remarks
     * Actual storage level of the rendered data also depends
     * on {@link DataSource.storageLevelOffset}.
     */
    get storageLevel() {
        return THREE.MathUtils.clamp(Math.floor(this.m_zoomLevel), this.m_minZoomLevel, this.m_maxZoomLevel);
    }
    /**
     * Returns height of the viewport in pixels.
     */
    get viewportHeight() {
        return this.canvas.height;
    }
    /**
     * Returns `true` if the native WebGL antialiasing is enabled.
     *
     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.
     */
    get nativeWebglAntialiasEnabled() {
        return this.m_options.enableNativeWebglAntialias === undefined
            ? this.pixelRatio < 2.0
            : this.m_options.enableNativeWebglAntialias;
    }
    /**
     * Returns {@link DataSource}s displayed by this `MapView`.
     */
    get dataSources() {
        return this.m_tileDataSources;
    }
    /**
     * Set's the way in which the fov is calculated on the map view.
     *
     * @remarks
     * Note, for this to take visual effect, the map should be rendered
     * after calling this function.
     * @param fovCalculation - How the FOV is calculated.
     */
    setFovCalculation(fovCalculation) {
        this.m_options.fovCalculation = fovCalculation;
        this.updateCameras();
    }
    /**
     * Returns the unique {@link DataSource} matching the given name.
     */
    getDataSourceByName(dataSourceName) {
        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);
    }
    /**
     * Returns the array of {@link DataSource}s referring to the same [[StyleSet]].
     */
    getDataSourcesByStyleSetName(styleSetName) {
        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);
    }
    /**
     * Returns true if the specified {@link DataSource} is enabled.
     */
    isDataSourceEnabled(dataSource) {
        return (dataSource.enabled &&
            dataSource.ready() &&
            this.m_connectedDataSources.has(dataSource.name) &&
            dataSource.isVisible(this.zoomLevel));
    }
    /**
     * Adds a new {@link DataSource} to this `MapView`.
     *
     * @remarks
     * `MapView` needs at least one {@link DataSource} to display something.
     * @param dataSource - The data source.
     */
    async addDataSource(dataSource) {
        var _a, _b;
        const twinDataSource = this.getDataSourceByName(dataSource.name);
        if (twinDataSource !== undefined) {
            throw new Error(`A DataSource with the name "${dataSource.name}" already exists in this MapView.`);
        }
        dataSource.attach(this);
        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);
        const conflictingDataSource = this.m_tileDataSources.find(ds => ds.addGroundPlane === true && !(ds instanceof BackgroundDataSource_1.BackgroundDataSource));
        if (dataSource.addGroundPlane === true && conflictingDataSource !== undefined) {
            // eslint-disable-next-line no-console
            console.warn(`The DataSources ${dataSource.name} and ${conflictingDataSource.name} both have a ground plane added, this will cause problems with the fallback logic, see HARP-14728 & HARP-15488.`);
        }
        this.m_tileDataSources.push(dataSource);
        (_a = this.m_sceneEnvironment) === null || _a === void 0 ? void 0 : _a.updateBackgroundDataSource();
        try {
            await dataSource.connect();
            const alreadyRemoved = !this.m_tileDataSources.includes(dataSource);
            if (alreadyRemoved) {
                return;
            }
            dataSource.addEventListener(MapViewEventNames.Update, () => {
                this.update();
            });
            const theme = await this.getTheme();
            dataSource.setLanguages(this.m_languages);
            if (theme !== undefined && theme.styles !== undefined) {
                await dataSource.setTheme(theme);
            }
            this.m_connectedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name
            });
            this.update();
        }
        catch (error) {
            // error is a string if a promise was rejected.
            logger.error(`Failed to connect to datasource ${dataSource.name}: ${(_b = error.message) !== null && _b !== void 0 ? _b : error}`);
            this.m_failedDataSources.add(dataSource.name);
            this.dispatchEvent({
                type: MapViewEventNames.DataSourceConnect,
                dataSourceName: dataSource.name,
                error
            });
        }
    }
    /**
     * Removes {@link DataSource} from this `MapView`.
     *
     * @param dataSource - The data source to be removed
     */
    removeDataSource(dataSource) {
        const dsIndex = this.m_tileDataSources.indexOf(dataSource);
        if (dsIndex === -1) {
            return;
        }
        dataSource.detach(this);
        this.m_visibleTiles.removeDataSource(dataSource);
        this.m_tileDataSources.splice(dsIndex, 1);
        this.m_connectedDataSources.delete(dataSource.name);
        this.m_failedDataSources.delete(dataSource.name);
        this.m_sceneEnvironment.updateBackgroundDataSource();
        this.update();
    }
    /**
     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.
     */
    get visibleTileSet() {
        return this.m_visibleTiles;
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    addOverlayText(textElements) {
        this.m_textElementsRenderer.addOverlayText(textElements);
        this.update();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    clearOverlayText() {
        this.m_textElementsRenderer.clearOverlayText();
    }
    lookAt(targetOrParams, distance, tiltDeg, headingDeg) {
        if (harp_geoutils_1.isGeoCoordinatesLike(targetOrParams)) {
            const zoomLevel = distance !== undefined
                ? Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, distance)
                : undefined;
            const params = {
                target: targetOrParams,
                zoomLevel,
                tilt: tiltDeg,
                heading: headingDeg
            };
            this.lookAtImpl(params);
        }
        else if (typeof targetOrParams === "object") {
            this.lookAtImpl(targetOrParams);
        }
    }
    /**
     * Moves the camera to the specified {@link @here/harp-geoutils#GeoCoordinates},
     * sets the desired `zoomLevel` and
     * adjusts the yaw and pitch.
     *
     * @remarks
     * The pitch of the camera is
     * always curbed so that the camera cannot
     * look above the horizon. This paradigm is necessary
     * in {@link @here/harp-map-controls#MapControls}, where the center of
     * the screen is used for the orbiting interaction (3 fingers / right mouse button).
     *
     * @param geoPos - Geolocation to move the camera to.
     * @param zoomLevel - Desired zoom level.
     * @param yawDeg - Camera yaw in degrees, counter-clockwise (as opposed to heading), starting
     * north.
     * @param pitchDeg - Camera pitch in degrees.
     * @deprecated Use {@link (MapView.lookAt:WITH_PARAMS)} instead.
     */
    setCameraGeolocationAndZoom(geoPos, zoomLevel, yawDeg = 0, pitchDeg = 0) {
        this.geoCenter = geoPos;
        let limitedPitch = Math.min(Utils_1.MapViewUtils.MAX_TILT_DEG, pitchDeg);
        if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            const maxPitchRadWithCurvature = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS /
                (Utils_1.MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +
                    harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS));
            const maxPitchDegWithCurvature = THREE.MathUtils.radToDeg(maxPitchRadWithCurvature);
            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);
        }
        Utils_1.MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);
        Utils_1.MapViewUtils.setRotation(this, yawDeg, limitedPitch);
        this.update();
    }
    /**
     * Updates the value of a dynamic property.
     *
     * @remarks
     * Property names starting with a `$`-sign are reserved and any attempt to change their value
     * will result in an error.
     *
     * Themes can access dynamic properties using the `Expr` operator `["dynamic-properties"]`,
     * for example:
     *
     *   `["get", "property name", ["dynamic-properties"]]`
     *
     * @param name - The name of the property.
     * @param value - The value of the property.
     */
    setDynamicProperty(name, value) {
        if (name.startsWith("$")) {
            throw new Error(`failed to update the value of the dynamic property '${name}'`);
        }
        this.m_env.entries[name] = value;
        this.update();
    }
    /**
     * Removes the given dynamic property from this {@link MapView}.
     *
     * @remarks
     * Property names starting with a `$`-sign are reserved and any attempt to change their value
     * will result in an error.
     *
     * @param name - The name of the property to remove.
     */
    removeDynamicProperty(name) {
        if (name.startsWith("$")) {
            throw new Error(`failed to remove the dynamic property '${name}'`);
        }
        delete this.m_env.entries[name];
        this.update();
    }
    /**
     * Returns `true` if this `MapView` is constantly redrawing the scene.
     */
    get animating() {
        return this.m_animationCount > 0;
    }
    /**
     * Begin animating the scene.
     */
    beginAnimation() {
        if (this.m_animationCount++ === 0) {
            this.update();
            this.ANIMATION_STARTED_EVENT.time = Date.now();
            this.dispatchEvent(this.ANIMATION_STARTED_EVENT);
        }
    }
    /**
     * Stop animating the scene.
     */
    endAnimation() {
        if (this.m_animationCount > 0) {
            --this.m_animationCount;
        }
        if (this.m_animationCount === 0) {
            this.ANIMATION_FINISHED_EVENT.time = Date.now();
            this.dispatchEvent(this.ANIMATION_FINISHED_EVENT);
        }
    }
    /**
     * Returns `true` if the camera moved in the last frame.
     */
    get cameraIsMoving() {
        return this.m_movementDetector.cameraIsMoving;
    }
    /**
     * Returns `true` if the current frame will immediately be followed by another frame.
     * @deprecated This should only be used for the internal handling of the render loop,
     * if you use your own RenderLoop use {@link MapView::renderSync} in combination with
     * {@link MapViewEventNames.FrameComplete}
     **/
    get isDynamicFrame() {
        return (!this.m_visibleTiles.allVisibleTilesLoaded ||
            this.m_themeManager.isUpdating() ||
            this.cameraIsMoving ||
            this.animating ||
            this.m_updatePending ||
            this.m_animatedExtrusionHandler.isAnimating ||
            this.m_textElementsRenderer.isUpdatePending ||
            this.m_textElementsRenderer.loading);
    }
    /**
     * Returns the ratio between a pixel and a world unit for the current camera (in the center of
     * the camera projection).
     */
    get pixelToWorld() {
        if (this.m_pixelToWorld === undefined) {
            // At this point fov calculation should be always defined.
            harp_utils_1.assert(this.m_options.fovCalculation !== undefined);
            // NOTE: Look at distance is the distance to camera focus (and pivot) point.
            // In screen space this point is located in the center of canvas.
            // Given that zoom level is not modified (clamped by camera pitch), the following
            // formulas are all equivalent:
            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);
            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);
            // Here we may use precalculated target distance (once pre frame):
            const lookAtDistance = this.m_targetDistance;
            const focalLength = CameraUtils_1.CameraUtils.getFocalLength(this.m_camera);
            harp_utils_1.assert(focalLength !== undefined);
            // Find world space object size that corresponds to one pixel on screen.
            this.m_pixelToWorld = CameraUtils_1.CameraUtils.convertScreenToWorldSize(focalLength, lookAtDistance, 1);
        }
        return this.m_pixelToWorld;
    }
    /**
     * Returns the ratio between a world and a pixel unit for the current camera (in the center of
     * the camera projection).
     */
    get worldToPixel() {
        return 1.0 / this.pixelToWorld;
    }
    get pixelRatio() {
        if (this.m_pixelRatio !== undefined) {
            return this.m_pixelRatio;
        }
        return typeof window !== "undefined" && window.devicePixelRatio !== undefined
            ? window.devicePixelRatio
            : 1.0;
    }
    /**
     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens
     * (HiDPI).
     *
     * @remarks
     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value
     * of `1.0` will disable the use of HiDPI on all devices.
     *
     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)
     * they may appear in the wrong size now. To ensure proper display of data, a call to
     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.
     *
     * @memberof MapView
     */
    set pixelRatio(pixelRatio) {
        this.m_pixelRatio = pixelRatio;
        if (this.renderer.getPixelRatio() !== this.pixelRatio) {
            this.renderer.setPixelRatio(this.pixelRatio);
        }
    }
    /**
     * Maximum FPS (Frames Per Second).
     *
     * @remarks
     * If VSync in enabled, the specified number may not be
     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate
     * divided by an integer number.
     *
     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`
     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of
     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.
     */
    set maxFps(value) {
        this.m_options.maxFps = value;
        this.m_taskScheduler.maxFps = value;
    }
    get maxFps() {
        //this cannot be undefined, as it is defaulting to 0 in the constructor
        return this.m_options.maxFps;
    }
    /**
     * PixelRatio ratio for rendering when the camera is moving or an animation is running.
     *
     * @remarks
     * Useful when rendering on high resolution displays with low performance GPUs
     * that may be fill-rate-limited.
     *
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. Values between 0.5 and
     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger
     * than `window.devicePixelRatio`.
     *
     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`
     * defined, visual artifacts may occur, especially with thin lines..
     *
     * @note The resolution of icons and text labels is not affected.
     *
     * @default `undefined`
     */
    set dynamicPixelRatio(ratio) {
        this.mapRenderingManager.lowResPixelRatio = ratio;
    }
    get dynamicPixelRatio() {
        return this.mapRenderingManager.lowResPixelRatio;
    }
    /**
     * Returns the screen position of the given geo or world position.
     *
     * @param pos - The position as a {@link @here/harp-geoutils#GeoCoordLike} or
     * {@link https://threejs.org/docs/#api/en/math/Vector3 | THREE.Vector3} world position.
     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or
     * `undefined`.
     */
    getScreenPosition(pos) {
        if (harp_geoutils_1.isVector3Like(pos)) {
            cache.vector3[0].copy(pos);
        }
        else {
            this.projection.projectPoint(harp_geoutils_1.GeoCoordinates.fromObject(pos), cache.vector3[0]);
        }
        const p = this.m_screenProjector.project(cache.vector3[0]);
        if (p !== undefined) {
            const { width, height } = this.getCanvasClientSize();
            p.x = p.x + width / 2;
            p.y = height - (p.y + height / 2);
        }
        return p;
    }
    /**
     * Returns the world space position from the given screen position.
     *
     * @remarks
     * If `fallback !== true` the return value can be `null`, in case the camera has a high tilt
     * and the given `(x, y)` value is not intersecting the ground plane.
     * If `fallback === true` the return value will always exist but it might not be on the earth
     * surface.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     * @param fallback - Whether to compute a fallback position if the earth surface is not hit.
     */
    getWorldPositionAt(x, y, fallback) {
        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);
        const worldPos = this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])
            : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);
        if (worldPos === null && fallback === true) {
            // Fall back to the far plane
            const cosAlpha = this.m_camera
                .getWorldDirection(cache.vector3[0])
                .dot(this.m_raycaster.ray.direction);
            return cache.vector3[0]
                .copy(this.m_raycaster.ray.direction)
                .multiplyScalar(this.m_camera.far / cosAlpha)
                .add(this.m_camera.position);
        }
        return worldPos;
    }
    getGeoCoordinatesAt(x, y, fallback) {
        const worldPosition = this.getWorldPositionAt(x, y, fallback);
        if (!worldPosition) {
            return null;
        }
        const geoPos = this.projection.unprojectPoint(worldPosition);
        if (!this.tileWrappingEnabled && this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // When the map is not wrapped we clamp the longitude
            geoPos.longitude = THREE.MathUtils.clamp(geoPos.longitude, -180, 180);
        }
        return geoPos;
    }
    /**
     * Returns the normalized screen coordinates from the given pixel position.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     */
    getNormalizedScreenCoordinates(x, y) {
        // use clientWidth and clientHeight as it does not apply the pixelRatio and
        // therefore supports also HiDPI devices
        const { width, height } = this.getCanvasClientSize();
        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);
    }
    /**
     * Do a raycast on all objects in the scene. Useful for picking.
     *
     * @remarks
     * Limited to objects that THREE.js can raycast, the solid lines
     * that get their geometry in the shader cannot be tested
     * for intersection.
     *
     * Note, if a {@link DataSource} adds an [[Object3D]]
     * to a {@link Tile}, it will be only pickable once
     * {@link MapView.render} has been called, this is because
     * {@link MapView.render} method creates the
     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.
     * This method will not test for intersection custom objects added to the scene by for
     * example calling directly the [[scene.add]] method from THREE.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     * @param parameters - The intersection test behaviour may be adjusted by providing an instance
     * of {@link IntersectParams}.
     * @returns The list of intersection results.
     */
    intersectMapObjects(x, y, parameters) {
        return this.m_pickHandler.intersectMapObjects(x, y, parameters);
    }
    /**
     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.
     *
     * @param width - The new width.
     * @param height - The new height.
     */
    resize(width, height) {
        this.m_renderer.setSize(width, height, false);
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        if (this.mapRenderingManager !== undefined) {
            this.mapRenderingManager.setSize(width, height);
        }
        if (this.collisionDebugCanvas !== undefined) {
            this.collisionDebugCanvas.width = width;
            this.collisionDebugCanvas.height = height;
        }
        this.updateCameras();
        this.update();
        this.dispatchEvent({
            type: MapViewEventNames.Resize,
            size: {
                width,
                height
            }
        });
    }
    /**
     * Redraws scene immediately
     *
     * @remarks
     * @note Before using this method, set `synchronousRendering` to `true`
     * in the {@link MapViewOptions}
     *
     * @param frameStartTime - Optional timestamp for start of frame.
     * Default: [[PerformanceTimer.now()]]
     */
    renderSync(frameStartTime) {
        if (frameStartTime === undefined) {
            frameStartTime = harp_utils_1.PerformanceTimer.now();
        }
        this.render(frameStartTime);
    }
    /**
     * Requests a redraw of the scene.
     */
    update() {
        if (this.disposed) {
            logger.warn("update(): MapView has been disposed of.");
            return;
        }
        this.dispatchEvent(this.UPDATE_EVENT);
        // Skip if update is already in progress
        if (this.m_updatePending) {
            return;
        }
        // Set update flag
        this.m_updatePending = true;
        this.startRenderLoop();
    }
    /**
     * Returns `true` if an update has already been requested, such that after a currently rendering
     * frame, the next frame will be rendered immediately.
     */
    get updatePending() {
        return this.m_updatePending;
    }
    /**
     * Requests a redraw of the scene.
     * @deprecated Use the [[update]] method instead.
     */
    requestUpdateIfNeeded() {
        this.update();
    }
    /**
     * Clear the tile cache.
     *
     * @remarks
     * Remove the {@link Tile} objects created by cacheable
     * {@link DataSource}s. If a {@link DataSource} name is
     * provided, this method restricts the eviction the {@link DataSource} with the given name.
     *
     * @param dataSourceName - The name of the {@link DataSource}.
     * @param filter Optional tile filter
     */
    clearTileCache(dataSourceName, filter) {
        if (this.m_visibleTiles === undefined) {
            // This method is called in the shadowsEnabled function, which is initialized in the
            // setupRenderer function,
            return;
        }
        if (dataSourceName !== undefined) {
            const dataSource = this.getDataSourceByName(dataSourceName);
            if (dataSource) {
                this.m_visibleTiles.clearTileCache(dataSource, filter);
                dataSource.clearCache();
            }
        }
        else {
            this.m_visibleTiles.clearTileCache(undefined, filter);
            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());
        }
        if (this.m_elevationProvider !== undefined) {
            this.m_elevationProvider.clearCache();
        }
    }
    /**
     * Apply visitor to all visible tiles.
     *
     * @param fun - Visitor function
     */
    forEachVisibleTile(fun) {
        this.m_visibleTiles.forEachVisibleTile(fun);
    }
    /**
     * Apply a visitor function to all tiles in the cache.
     *
     * @param visitor - Visitor function
     */
    forEachCachedTile(visitor) {
        this.m_visibleTiles.forEachCachedTile(visitor);
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     * @remarks
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance
     * are processed. If `undefined`, tiles from all {@link DataSource}s are processed.
     * @param filter Optional tile filter
     */
    markTilesDirty(dataSource, filter) {
        this.m_visibleTiles.markTilesDirty(dataSource, filter);
        this.update();
    }
    /**
     * Sets the DataSource which contains the elevations, the elevation range source, and the
     * elevation provider.
     *
     * @remarks
     * Only a single elevation source is possible per {@link MapView}.
     * If the terrain-datasource is merged with this repository, we could internally construct
     * the {@link ElevationRangeSource} and the {@link ElevationProvider}
     * and access would be granted to
     * the application when it asks for it, to simplify the API.
     *
     * @param elevationSource - The datasource containing the terrain tiles.
     * @param elevationRangeSource - Allows access to the elevation min / max per tile.
     * @param elevationProvider - Allows access to the elevation at a given location or a ray
     *      from the camera.
     */
    async setElevationSource(elevationSource, elevationRangeSource, elevationProvider) {
        // Remove previous elevation source if present
        if (this.m_elevationSource && this.m_elevationSource !== elevationSource) {
            this.removeDataSource(this.m_elevationSource);
        }
        // Add as datasource if it was not added before
        const isPresent = this.m_tileDataSources.includes(elevationSource);
        if (!isPresent) {
            await this.addDataSource(elevationSource);
        }
        this.m_elevationSource = elevationSource;
        this.m_elevationRangeSource = elevationRangeSource;
        if (!this.m_elevationRangeSource.ready()) {
            await this.m_elevationRangeSource.connect();
        }
        this.m_elevationProvider = elevationProvider;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(true);
        });
        this.m_tileGeometryManager.setTileUpdateCallback((tile) => {
            overlayOnElevation_1.overlayOnElevation(tile);
        });
        this.clearTileCache();
    }
    /**
     * Clears any elevation sources and provider previously set.
     * @param elevationSource - The datasource to be cleared.
     */
    clearElevationSource(elevationSource) {
        this.removeDataSource(elevationSource);
        this.m_elevationSource = undefined;
        this.m_elevationRangeSource = undefined;
        this.m_elevationProvider = undefined;
        this.dataSources.forEach(dataSource => {
            dataSource.setEnableElevationOverlay(false);
        });
        this.m_tileGeometryManager.setTileUpdateCallback(undefined);
        this.clearTileCache();
    }
    /**
     * Public access to {@link MapViewFog} allowing to toggle it by setting its `enabled` property.
     */
    get fog() {
        return this.m_sceneEnvironment.fog;
    }
    setPostEffects() {
        // First clear all the effects, then enable them from what is specified.
        this.mapRenderingManager.bloom.enabled = false;
        this.mapRenderingManager.outline.enabled = false;
        this.mapRenderingManager.vignette.enabled = false;
        this.mapRenderingManager.sepia.enabled = false;
        if (this.m_postEffects !== undefined) {
            if (this.m_postEffects.bloom !== undefined) {
                this.mapRenderingManager.bloom = this.m_postEffects.bloom;
            }
            if (this.m_postEffects.outline !== undefined) {
                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;
                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);
            }
            if (this.m_postEffects.vignette !== undefined) {
                this.mapRenderingManager.vignette = this.m_postEffects.vignette;
            }
            if (this.m_postEffects.sepia !== undefined) {
                this.mapRenderingManager.sepia = this.m_postEffects.sepia;
            }
        }
    }
    /**
     * Returns the elevation provider.
     */
    get elevationProvider() {
        return this.m_elevationProvider;
    }
    /**
     * @beta
     */
    get throttlingEnabled() {
        return this.m_taskScheduler.throttlingEnabled === true;
    }
    /**
     * @beta
     */
    set throttlingEnabled(enabled) {
        this.m_taskScheduler.throttlingEnabled = enabled;
    }
    get shadowsEnabled() {
        return this.m_options.enableShadows === true;
    }
    set shadowsEnabled(enabled) {
        // shadowMap is undefined if we are testing (three.js always set it to be defined).
        if (this.m_renderer.shadowMap === undefined ||
            enabled === this.m_renderer.shadowMap.enabled) {
            return;
        }
        this.m_options.enableShadows = enabled;
        // There is a bug in three.js where this doesn't currently work once enabled.
        this.m_renderer.shadowMap.enabled = enabled;
        // TODO: Make this configurable. Note, there is currently issues when using the
        // VSMShadowMap type, this should be investigated if this type is requested.
        this.m_renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.clearTileCache();
    }
    extractAttitude() {
        const camera = this.m_camera;
        const projection = this.projection;
        const cameraPos = cache.vector3[1];
        const transform = cache.transform[0];
        const tangentSpaceMatrix = cache.matrix4[1];
        // 1. Build the matrix of the tangent space of the camera.
        cameraPos.setFromMatrixPosition(camera.matrixWorld); // Ensure using world position.
        projection.localTangentSpace(this.m_targetGeoPos, transform);
        tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.
        cache.matrix4[0].copy(tangentSpaceMatrix).invert().multiply(camera.matrixWorld);
        transform.xAxis.setFromMatrixColumn(cache.matrix4[0], 0);
        transform.yAxis.setFromMatrixColumn(cache.matrix4[0], 1);
        transform.zAxis.setFromMatrixColumn(cache.matrix4[0], 2);
        // 3. Deduce orientation from the base axes.
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // Decompose rotation matrix into Z0 X Z1 Euler angles.
        const epsilon = 1e-10;
        const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));
        if (d < 1.0 - epsilon) {
            if (d > -1.0 + epsilon) {
                yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);
                pitch = Math.acos(transform.zAxis.z);
                roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);
            }
            else {
                // Looking bottom-up with space.z.z == -1.0
                yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);
                pitch = 180;
                roll = 0;
            }
        }
        else {
            // Looking top-down with space.z.z == 1.0
            yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);
            pitch = 0.0;
            roll = 0.0;
        }
        return {
            yaw,
            pitch,
            roll
        };
    }
    lookAtImpl(params) {
        const tilt = Math.min(harp_utils_1.getOptionValue(params.tilt, this.tilt), Utils_1.MapViewUtils.MAX_TILT_DEG);
        const heading = harp_utils_1.getOptionValue(params.heading, this.heading);
        const distance = params.zoomLevel !== undefined
            ? Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, THREE.MathUtils.clamp(params.zoomLevel, this.m_minZoomLevel, this.m_maxZoomLevel))
            : params.distance !== undefined
                ? params.distance
                : this.m_targetDistance;
        let target;
        if (params.bounds !== undefined) {
            let geoPoints;
            if (params.bounds instanceof harp_geoutils_1.GeoBox) {
                target = params.target
                    ? harp_geoutils_1.GeoCoordinates.fromObject(params.target)
                    : params.bounds.center;
                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(params.bounds);
            }
            else if (params.bounds instanceof harp_geoutils_1.GeoPolygon) {
                target = params.bounds.getCentroid();
                geoPoints = params.bounds.coordinates;
            }
            else if (harp_geoutils_1.isGeoBoxExtentLike(params.bounds)) {
                target = params.target ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;
                const box = harp_geoutils_1.GeoBox.fromCenterAndExtents(target, params.bounds);
                geoPoints = Utils_1.MapViewUtils.geoBoxToGeoPoints(box);
            }
            else if (Array.isArray(params.bounds)) {
                geoPoints = params.bounds;
                if (params.target !== undefined) {
                    target = harp_geoutils_1.GeoCoordinates.fromObject(params.target);
                }
            }
            else {
                throw Error("#lookAt: Invalid 'bounds' value");
            }
            if (
            // if the points are created from the corners of the geoBox don't cluster them
            !(params.bounds instanceof harp_geoutils_1.GeoBox || params.bounds instanceof harp_geoutils_1.GeoPolygon) &&
                this.m_tileWrappingEnabled &&
                this.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                // In flat projection, with wrap around enabled, we should detect clusters of
                // points around  anti-meridian and possible move some points to sibling worlds.
                //
                // Here, we fit points into minimal geo box taking world wrapping into account.
                geoPoints = Utils_1.MapViewUtils.wrapGeoPointsToScreen(geoPoints, target);
            }
            const worldPoints = geoPoints.map(point => this.projection.projectPoint(harp_geoutils_1.GeoCoordinates.fromObject(point), new THREE.Vector3()));
            const worldTarget = new THREE.Vector3();
            if (target === undefined) {
                const box = new THREE.Box3().setFromPoints(worldPoints);
                box.getCenter(worldTarget);
                this.projection.scalePointToSurface(worldTarget);
                target = this.projection.unprojectPoint(worldTarget);
            }
            else {
                this.projection.projectPoint(target, worldTarget);
            }
            if (params.zoomLevel !== undefined || params.distance !== undefined) {
                return this.lookAtImpl({
                    tilt,
                    heading,
                    distance,
                    target
                });
            }
            return this.lookAtImpl(Utils_1.MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {
                tilt,
                heading,
                minDistance: Utils_1.MapViewUtils.calculateDistanceFromZoomLevel(this, this.maxZoomLevel),
                projection: this.projection,
                camera: this.camera
            }));
        }
        target =
            params.target !== undefined ? harp_geoutils_1.GeoCoordinates.fromObject(params.target) : this.target;
        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.
        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put
        // the camera on the target, so the tilt can be passed to getRotation as a pitch.
        Utils_1.MapViewUtils.getCameraRotationAtTarget(this.projection, target, -heading, tilt, this.camera.quaternion);
        Utils_1.MapViewUtils.getCameraPositionFromTargetCoordinates(target, distance, -heading, tilt, this.projection, this.camera.position);
        this.camera.updateMatrixWorld(true);
        // Make sure to update all properties that are accessible via API (e.g. zoomlevel) b/c
        // otherwise they would be updated as recently as in the next animation frame.
        this.updateLookAtSettings();
        this.update();
    }
    /**
     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise
     */
    updatePolarDataSource() {
        const dataSource = this.m_polarDataSource;
        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {
            const twinDataSource = this.getDataSourceByName(dataSource.name);
            if (this.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
                if (twinDataSource === undefined) {
                    this.addDataSource(dataSource);
                }
            }
            else {
                if (twinDataSource !== undefined) {
                    this.removeDataSource(dataSource);
                }
            }
        }
    }
    /**
     * Updates the camera and the projections and resets the screen collisions,
     * note, setupCamera must be called before this is called.
     *
     * @remarks
     * @param viewRanges - optional parameter that supplies new view ranges, most importantly
     * near/far clipping planes distance. If parameter is not provided view ranges will be
     * calculated from [[ClipPlaneEvaluator]] used in {@link VisibleTileSet}.
     */
    updateCameras(viewRanges) {
        var _a;
        // Update look at settings first, so that other components (e.g. ClipPlanesEvaluator) get
        // the up to date tilt, targetDistance, ...
        this.m_camera.updateMatrixWorld(false);
        this.updateLookAtSettings();
        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);
        this.m_camera.aspect =
            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;
        this.setFovOnCamera(this.m_options.fovCalculation, height);
        // When calculating clip planes account for the highest building on the earth,
        // multiplying its height by projection scaling factor. This approach assumes
        // constantHeight property of extruded polygon technique is set as default false,
        // otherwise the near plane margins will be bigger then required, but still correct.
        const projectionScale = this.projection.getScaleFactor(this.camera.position);
        const maxGeometryHeightScaled = projectionScale *
            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);
        const minGeometryHeightScaled = projectionScale *
            this.m_tileDataSources.reduce((r, ds) => Math.min(r, ds.minGeometryHeight), 0);
        // Copy all properties from new view ranges to our readonly object.
        // This allows to keep all view ranges references valid and keeps up-to-date
        // information within them. Works the same as copping all properties one-by-one.
        Object.assign(this.m_viewRanges, viewRanges === undefined
            ? this.m_visibleTiles.updateClipPlanes(maxGeometryHeightScaled, minGeometryHeightScaled)
            : viewRanges);
        this.m_camera.near = this.m_viewRanges.near;
        this.m_camera.far = this.m_viewRanges.far;
        this.m_camera.updateProjectionMatrix();
        // Update the "relative to eye" camera. Copy the public camera parameters
        // and place the "relative to eye" at the world's origin.
        this.m_rteCamera.copy(this.m_camera);
        this.m_rteCamera.position.setScalar(0);
        this.m_rteCamera.updateMatrixWorld(true);
        (_a = this.m_textElementsRenderer) === null || _a === void 0 ? void 0 : _a.updateCamera();
        this.m_screenProjector.update(this.camera, width, height);
        this.m_pixelToWorld = undefined;
        this.m_sceneEnvironment.update();
    }
    /**
     * Derive the look at settings (i.e. target, zoom, ...) from the current camera.
     */
    updateLookAtSettings() {
        let { target, distance, final } = Utils_1.MapViewUtils.getTargetAndDistance(this.projection, this.camera, this.elevationProvider);
        if (!final) {
            this.update();
        }
        if (this.geoMaxBounds) {
            ({ target, distance } = Utils_1.MapViewUtils.constrainTargetAndDistanceToViewBounds(target, distance, this));
        }
        this.m_targetWorldPos.copy(target);
        this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);
        this.m_targetDistance = distance;
        this.m_zoomLevel = Utils_1.MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);
        const { yaw, pitch, roll } = this.extractAttitude();
        this.m_yaw = yaw;
        this.m_pitch = pitch;
        this.m_roll = roll;
    }
    /**
     * Update `Env` instance used for style `Expr` evaluations.
     */
    updateEnv() {
        this.m_env.entries.$zoom = this.m_zoomLevel;
        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely
        // used in our styles.
        this.m_env.entries.$pixelToMeters = this.pixelToWorld;
        this.m_env.entries.$frameNumber = this.m_frameNumber;
    }
    /**
     * Transfer the NDC point to view space.
     * @param vector - Vector to transform.
     * @param result - Result to place calculation.
     */
    ndcToView(vector, result) {
        result
            .set(vector.x, vector.y, vector.z)
            .applyMatrix4(this.camera.projectionMatrixInverse)
            // Make sure to apply rotation, hence use the rte camera
            .applyMatrix4(this.m_rteCamera.matrixWorld);
        return result;
    }
    /**
     * Render loop callback that should only be called by [[requestAnimationFrame]].
     * Will trigger [[requestAnimationFrame]] again if updates are pending or  animation is running.
     * @param frameStartTime - The start time of the current frame
     */
    renderLoop(frameStartTime) {
        // Render loop shouldn't run when synchronous rendering is enabled or if `MapView` has been
        // disposed of.
        if (this.m_options.synchronousRendering === true || this.disposed) {
            return;
        }
        if (this.maxFps === 0) {
            // Render with max fps
            this.render(frameStartTime);
        }
        else {
            // Limit fps by skipping frames
            // Magic ingredient to compensate time flux.
            const fudgeTimeInMs = 3;
            const frameInterval = 1000 / this.maxFps;
            const previousFrameTime = this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;
            const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;
            if (frameStartTime >= targetTime) {
                this.render(frameStartTime);
            }
        }
        // Continue rendering if update is pending or animation is running
        if (this.isDynamicFrame) {
            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
        }
        else {
            // Stop rendering if no update is pending
            this.m_animationFrameHandle = undefined;
        }
    }
    /**
     * Start render loop if not already running.
     */
    startRenderLoop() {
        if (this.m_animationFrameHandle !== undefined || this.m_options.synchronousRendering) {
            return;
        }
        this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);
    }
    /**
     * Returns the list of the enabled data sources.
     */
    getEnabledTileDataSources() {
        // ### build this list once decoders && datasources are ready
        const enabledDataSources = [];
        for (const dataSource of this.m_tileDataSources) {
            if (this.isDataSourceEnabled(dataSource)) {
                enabledDataSources.push(dataSource);
            }
        }
        return enabledDataSources;
    }
    /**
     * Renders the current frame.
     */
    render(frameStartTime) {
        if (this.m_drawing) {
            return;
        }
        if (this.disposed) {
            logger.warn("render(): MapView has been disposed of.");
            return;
        }
        this.RENDER_EVENT.time = frameStartTime;
        this.dispatchEvent(this.RENDER_EVENT);
        this.m_tileObjectRenderer.prepareRender();
        ++this.m_frameNumber;
        let currentFrameEvent;
        const stats = Statistics_1.PerformanceStatistics.instance;
        const gatherStatistics = stats.enabled;
        if (gatherStatistics) {
            currentFrameEvent = stats.currentFrame;
            if (this.m_previousFrameTimeStamp !== undefined) {
                // In contrast to fullFrameTime we also measure the application code
                // for the FPS. This means FPS != 1000 / fullFrameTime.
                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;
                currentFrameEvent.setValue("render.fps", 1000 / timeSincePreviousFrame);
            }
            // We store the last frame statistics at the beginning of the next frame b/c additional
            // work (i.e. geometry creation) is done outside of the animation frame but still needs
            // to be added to the `fullFrameTime` (see [[TileGeometryLoader]]).
            stats.storeAndClearFrameInfo();
            currentFrameEvent = currentFrameEvent;
            currentFrameEvent.setValue("renderCount.frameNumber", this.m_frameNumber);
        }
        this.m_previousFrameTimeStamp = frameStartTime;
        let setupTime;
        let cullTime;
        let textPlacementTime;
        let drawTime;
        let textDrawTime;
        let endTime;
        this.m_renderer.info.reset();
        this.m_updatePending = false;
        this.m_thisFrameTilesChanged = undefined;
        this.m_drawing = true;
        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {
            this.m_renderer.setPixelRatio(this.pixelRatio);
        }
        this.updateCameras();
        this.updateEnv();
        this.m_renderer.clear();
        // clear the scenes
        this.m_sceneRoot.children.length = 0;
        this.m_overlaySceneRoot.children.length = 0;
        if (gatherStatistics) {
            setupTime = harp_utils_1.PerformanceTimer.now();
        }
        // TBD: Update renderList only any of its params (camera, etc...) has changed.
        if (!this.lockVisibleTileSet) {
            const viewRangesStatus = this.m_visibleTiles.updateRenderList(this.storageLevel, Math.floor(this.zoomLevel), this.getEnabledTileDataSources(), this.m_frameNumber, this.m_elevationRangeSource);
            // View ranges has changed due to features (with elevation) that affects clip planes
            // positioning, update cameras with new clip planes positions.
            if (viewRangesStatus.viewRangesChanged) {
                this.updateCameras(viewRangesStatus.viewRanges);
            }
        }
        if (gatherStatistics) {
            cullTime = harp_utils_1.PerformanceTimer.now();
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        // no need to check everything if we're not going to create text renderer.
        renderList.forEach(({ zoomLevel, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                this.m_tileObjectRenderer.render(tile, zoomLevel, this.zoomLevel, this.m_camera.position, this.m_sceneRoot);
                //We know that rendered tiles are visible (in the view frustum), so we update the
                //frame number, note we don't do this for the visibleTiles because some may still be
                //loading (and therefore aren't visible in the sense of being seen on the screen).
                //Note also, this number isn't currently used anywhere so should be considered to be
                //removed in the future (though could be good for debugging purposes).
                tile.frameNumLastVisible = this.m_frameNumber;
            });
        });
        this.m_mapAnchors.update(this.projection, this.camera.position, this.m_sceneRoot, this.m_overlaySceneRoot);
        this.m_animatedExtrusionHandler.update(this.zoomLevel);
        if (currentFrameEvent !== undefined) {
            // Make sure the counters all have a value.
            currentFrameEvent.addValue("renderCount.numTilesRendered", 0);
            currentFrameEvent.addValue("renderCount.numTilesVisible", 0);
            currentFrameEvent.addValue("renderCount.numTilesLoading", 0);
            // Increment the counters for all data sources.
            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {
                currentFrameEvent.addValue("renderCount.numTilesRendered", renderedTiles.size);
                currentFrameEvent.addValue("renderCount.numTilesVisible", visibleTiles.length);
                currentFrameEvent.addValue("renderCount.numTilesLoading", numTilesLoading);
            });
        }
        if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {
            //FIXME: Shouldn't we use target here?
            const { latitude, longitude, altitude } = this.geoCenter;
            this.dispatchEvent({
                type: MapViewEventNames.CameraPositionChanged,
                latitude,
                longitude,
                altitude,
                // FIXME: Can we remove yaw, pitch and roll
                yaw: this.m_yaw,
                pitch: this.m_pitch,
                roll: this.m_roll,
                tilt: this.tilt,
                heading: this.heading,
                zoom: this.zoomLevel
            });
        }
        // The camera used to render the scene.
        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;
        if (this.renderLabels && !this.m_pointOfView) {
            this.m_textElementsRenderer.placeText(renderList, frameStartTime);
        }
        if (gatherStatistics) {
            textPlacementTime = harp_utils_1.PerformanceTimer.now();
        }
        this.mapRenderingManager.render(this.m_renderer, this.m_scene, camera, !this.isDynamicFrame);
        if (gatherStatistics) {
            drawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (this.renderLabels && !this.m_pointOfView) {
            this.m_textElementsRenderer.renderText(this.m_viewRanges.maximum);
        }
        if (this.m_overlaySceneRoot.children.length > 0) {
            this.m_renderer.render(this.m_overlayScene, camera);
        }
        if (gatherStatistics) {
            textDrawTime = harp_utils_1.PerformanceTimer.now();
        }
        if (!this.m_firstFrameRendered) {
            this.m_firstFrameRendered = true;
            if (gatherStatistics) {
                stats.appResults.set("firstFrame", frameStartTime);
            }
            this.FIRST_FRAME_EVENT.time = frameStartTime;
            this.dispatchEvent(this.FIRST_FRAME_EVENT);
        }
        this.m_visibleTiles.disposePendingTiles();
        this.m_drawing = false;
        this.checkCopyrightUpdates();
        // do this post paint therefore use a Timeout, if it has not been executed cancel and
        // create a new one
        if (this.m_taskSchedulerTimeout !== undefined) {
            clearTimeout(this.m_taskSchedulerTimeout);
        }
        this.m_taskSchedulerTimeout = setTimeout(() => {
            this.m_taskSchedulerTimeout = undefined;
            this.m_taskScheduler.processPending(frameStartTime);
        }, 0);
        if (currentFrameEvent !== undefined) {
            endTime = harp_utils_1.PerformanceTimer.now();
            const frameRenderTime = endTime - frameStartTime;
            currentFrameEvent.setValue("render.setupTime", setupTime - frameStartTime);
            currentFrameEvent.setValue("render.cullTime", cullTime - setupTime);
            currentFrameEvent.setValue("render.textPlacementTime", textPlacementTime - cullTime);
            currentFrameEvent.setValue("render.drawTime", drawTime - textPlacementTime);
            currentFrameEvent.setValue("render.textDrawTime", textDrawTime - drawTime);
            currentFrameEvent.setValue("render.cleanupTime", endTime - textDrawTime);
            currentFrameEvent.setValue("render.frameRenderTime", frameRenderTime);
            // Initialize the fullFrameTime with the frameRenderTime If we also create geometry in
            // this frame, this number will be increased in the TileGeometryLoader.
            currentFrameEvent.setValue("render.fullFrameTime", frameRenderTime);
            currentFrameEvent.setValue("render.geometryCreationTime", 0);
            // Add THREE.js statistics
            stats.addWebGLInfo(this.m_renderer.info);
            // Add memory statistics
            // FIXME:
            // This will only measure the memory of the rendering and not of the geometry creation.
            // Assuming the garbage collector is not kicking in immediately we will at least see
            // the geometry creation memory consumption accounted in the next frame.
            stats.addMemoryInfo();
        }
        this.DID_RENDER_EVENT.time = frameStartTime;
        this.dispatchEvent(this.DID_RENDER_EVENT);
        // After completely rendering this frame, it is checked if this frame was the first complete
        // frame, with no more tiles, geometry and labels waiting to be added, and no animation
        // running. The initial placement of text in this render call may have changed the loading
        // state of the TextElementsRenderer, so this has to be checked again.
        // HARP-10919: Fading is currently ignored by the frame complete event.
        if (!this.isDynamicFrame) {
            if (this.m_firstFrameComplete === false) {
                this.m_firstFrameComplete = true;
                if (gatherStatistics) {
                    stats.appResults.set("firstFrameComplete", frameStartTime);
                }
            }
            this.FRAME_COMPLETE_EVENT.time = frameStartTime;
            this.dispatchEvent(this.FRAME_COMPLETE_EVENT);
        }
    }
    setupCamera() {
        harp_utils_1.assert(this.m_visibleTiles !== undefined);
        this.m_options.target = harp_geoutils_1.GeoCoordinates.fromObject(harp_utils_1.getOptionValue(this.m_options.target, MapViewDefaults.target));
        // ensure that look at target has height of 0
        this.m_options.target.altitude = 0;
        this.m_options.tilt = harp_utils_1.getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);
        this.m_options.heading = harp_utils_1.getOptionValue(this.m_options.heading, MapViewDefaults.heading);
        this.m_options.zoomLevel = harp_utils_1.getOptionValue(this.m_options.zoomLevel, MapViewDefaults.zoomLevel);
        this.lookAtImpl(this.m_options);
        // ### move & customize
        const { width, height } = this.getCanvasClientSize();
        this.resize(width, height);
    }
    createVisibleTileSet() {
        harp_utils_1.assert(this.m_tileGeometryManager !== undefined);
        if (this.m_visibleTiles) {
            // Dispose of all resources before the old instance is replaced.
            this.m_visibleTiles.clearTileCache();
            this.m_visibleTiles.disposePendingTiles();
        }
        const enableMixedLod = this.m_enableMixedLod === undefined
            ? this.projection.type === harp_geoutils_1.ProjectionType.Spherical
            : this.m_enableMixedLod;
        this.m_visibleTiles = new VisibleTileSet_1.VisibleTileSet(new FrustumIntersection_1.FrustumIntersection(this.m_camera, this, this.m_visibleTileSetOptions.extendedFrustumCulling, this.m_tileWrappingEnabled, enableMixedLod, this.m_lodMinTilePixelSize), this.m_tileGeometryManager, this.m_visibleTileSetOptions, this.taskQueue);
        return this.m_visibleTiles;
    }
    movementStarted() {
        this.m_textElementsRenderer.movementStarted();
        this.MOVEMENT_STARTED_EVENT.time = Date.now();
        this.dispatchEvent(this.MOVEMENT_STARTED_EVENT);
    }
    movementFinished() {
        this.m_textElementsRenderer.movementFinished();
        this.MOVEMENT_FINISHED_EVENT.time = Date.now();
        this.dispatchEvent(this.MOVEMENT_FINISHED_EVENT);
        // render at the next possible time.
        if (!this.animating) {
            if (this.m_movementFinishedUpdateTimerId !== undefined) {
                clearTimeout(this.m_movementFinishedUpdateTimerId);
            }
            this.m_movementFinishedUpdateTimerId = setTimeout(() => {
                this.m_movementFinishedUpdateTimerId = undefined;
                this.update();
            }, 0);
        }
    }
    /**
     * Check if the set of visible tiles changed since the last frame.
     *
     * May be called multiple times per frame.
     *
     * Equality is computed by creating a string containing the IDs of the tiles.
     */
    checkIfTilesChanged() {
        if (this.m_thisFrameTilesChanged !== undefined) {
            return this.m_thisFrameTilesChanged;
        }
        const renderList = this.m_visibleTiles.dataSourceTileList;
        const tileIdList = [];
        tileIdList.length = 0;
        renderList.forEach(({ dataSource, renderedTiles }) => {
            renderedTiles.forEach(tile => {
                tileIdList.push(dataSource.name + "-" + tile.tileKey.mortonCode());
            });
        });
        tileIdList.sort();
        const newTileIds = tileIdList.join("#");
        if (newTileIds !== this.m_lastTileIds) {
            this.m_lastTileIds = newTileIds;
            this.m_thisFrameTilesChanged = true;
        }
        else {
            this.m_thisFrameTilesChanged = false;
        }
        return this.m_thisFrameTilesChanged;
    }
    checkCopyrightUpdates() {
        if (!this.checkIfTilesChanged()) {
            return;
        }
        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();
        if (newCopyrightInfo === this.m_copyrightInfo) {
            return;
        }
        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {
            let allEqual = true;
            for (let i = 0; i < newCopyrightInfo.length; i++) {
                const a = newCopyrightInfo[i];
                const b = this.m_copyrightInfo[i];
                if (a.label !== b.label) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return;
            }
        }
        this.m_copyrightInfo = newCopyrightInfo;
        this.dispatchEvent(this.COPYRIGHT_CHANGED_EVENT);
    }
    getRenderedTilesCopyrightInfo() {
        let result = [];
        for (const tileList of this.m_visibleTiles.dataSourceTileList) {
            for (const tile of tileList.renderedTiles.values()) {
                const tileCopyrightInfo = tile.copyrightInfo;
                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {
                    continue;
                }
                result = CopyrightInfo_1.CopyrightInfo.mergeArrays(result, tileCopyrightInfo);
            }
        }
        return result;
    }
    setupStats(enable) {
        new Statistics_1.PerformanceStatistics(enable, 1000);
    }
    setupRenderer(tileObjectRenderer) {
        var _a;
        this.m_scene.add(this.m_sceneRoot);
        this.m_overlayScene.add(this.m_overlaySceneRoot);
        this.shadowsEnabled = (_a = this.m_options.enableShadows) !== null && _a !== void 0 ? _a : false;
        tileObjectRenderer.setupRenderer();
    }
    createTextRenderer() {
        return new TextElementsRenderer_1.TextElementsRenderer(new MapViewState_1.MapViewState(this, this.checkIfTilesChanged.bind(this)), this.m_screenProjector, this.m_poiManager, this.m_renderer, [this.imageCache, this.userImageCache], this.m_options);
    }
    /**
     * @internal
     * @param fontCatalogs
     * @param textStyles
     * @param defaultTextStyle
     */
    async resetTextRenderer(fontCatalogs, textStyles, defaultTextStyle) {
        await this.m_textElementsRenderer.updateFontCatalogs(fontCatalogs);
        await this.m_textElementsRenderer.updateTextStyles(textStyles, defaultTextStyle);
        this.update();
    }
    /**
     * Sets the field of view calculation, and applies it immediately to the camera.
     *
     * @param fovCalculation - How to calculate the FOV
     * @param height - Viewport height.
     */
    setFovOnCamera(fovCalculation, height) {
        const fovRad = THREE.MathUtils.degToRad(fovCalculation.fov);
        if (fovCalculation.type === "fixed") {
            CameraUtils_1.CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
            return;
        }
        let focalLength = CameraUtils_1.CameraUtils.getFocalLength(this.m_camera);
        if (focalLength === undefined) {
            CameraUtils_1.CameraUtils.setVerticalFov(this.m_camera, fovRad, height);
            focalLength = CameraUtils_1.CameraUtils.getFocalLength(this.m_camera);
        }
        CameraUtils_1.CameraUtils.setFocalLength(this.m_camera, focalLength, height);
    }
    /**
     * Get canvas client size in css/client pixels.
     *
     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by
     * calculating it from actual canvas size and current pixel ratio.
     */
    getCanvasClientSize() {
        const { clientWidth, clientHeight } = this.canvas;
        if (clientWidth === 0 ||
            clientHeight === 0 ||
            typeof clientWidth !== "number" ||
            typeof clientHeight !== "number") {
            const pixelRatio = this.m_renderer.getPixelRatio();
            return {
                width: Math.round(this.canvas.width / pixelRatio),
                height: Math.round(this.canvas.height / pixelRatio)
            };
        }
        else {
            return { width: clientWidth, height: clientHeight };
        }
    }
}
exports.MapView = MapView;


/***/ }),

/***/ "../harp-mapview/lib/MapViewAtmosphere.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/MapViewAtmosphere.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewAtmosphere = exports.AtmosphereLightMode = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const ClipPlanesEvaluator_1 = __webpack_require__(/*! ./ClipPlanesEvaluator */ "../harp-mapview/lib/ClipPlanesEvaluator.ts");
/**
 * Atmosphere effect variants.
 */
var AtmosphereVariant;
(function (AtmosphereVariant) {
    AtmosphereVariant[AtmosphereVariant["Ground"] = 1] = "Ground";
    AtmosphereVariant[AtmosphereVariant["Sky"] = 2] = "Sky";
    AtmosphereVariant[AtmosphereVariant["SkyAndGround"] = 3] = "SkyAndGround";
})(AtmosphereVariant || (AtmosphereVariant = {}));
/**
 * Atmosphere shader variants.
 */
var AtmosphereShadingVariant;
(function (AtmosphereShadingVariant) {
    AtmosphereShadingVariant[AtmosphereShadingVariant["ScatteringShader"] = 0] = "ScatteringShader";
    AtmosphereShadingVariant[AtmosphereShadingVariant["SimpleColor"] = 1] = "SimpleColor";
    AtmosphereShadingVariant[AtmosphereShadingVariant["Wireframe"] = 2] = "Wireframe";
})(AtmosphereShadingVariant || (AtmosphereShadingVariant = {}));
/**
 * Lists light modes.
 */
var AtmosphereLightMode;
(function (AtmosphereLightMode) {
    AtmosphereLightMode[AtmosphereLightMode["LightOverhead"] = 0] = "LightOverhead";
    AtmosphereLightMode[AtmosphereLightMode["LightDynamic"] = 1] = "LightDynamic";
})(AtmosphereLightMode = exports.AtmosphereLightMode || (exports.AtmosphereLightMode = {}));
/**
 * Maximum altitude that atmosphere reaches as the percent of the Earth radius.
 */
const SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;
/**
 * Maximum altitude that ground atmosphere is visible as the percent of the Earth radius.
 */
const GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 0.0001;
/**
 * Utility cache for holding temporary values.
 */
const cache = {
    clipPlanes: { near: 0, far: 0 }
};
/**
 * Class that provides {@link MapView}'s atmospheric scattering effect.
 */
class MapViewAtmosphere {
    /**
     * Creates and adds `Atmosphere` effects to the scene.
     *
     * @note Currently works only with globe projection.
     *
     * @param m_mapAnchors - The {@link MapAnchors} instance where the effect will be added.
     * @param m_sceneCamera - The camera used to render entire scene.
     * @param m_projection - The geo-projection used to transform geo coordinates to
     *                       cartesian space.
     * @param m_rendererCapabilities The capabilities of the WebGL renderer.
     * @param m_updateCallback - The optional callback to that should be called whenever atmosphere
     * configuration changes, may be used to inform related components (`MapView`) to redraw.
     * @param m_atmosphereVariant - The optional atmosphere configuration variant enum
     * [[AtmosphereVariant]], which denotes where the atmosphere scattering effect should be
     * applied, it may be ground or sky atmosphere only or most realistic for both, which is
     * chosen by default.
     * @param m_materialVariant - The optional material variant to be used, mainly for
     * testing and tweaking purposes.
     */
    constructor(m_mapAnchors, m_sceneCamera, m_projection, m_rendererCapabilities, m_updateCallback, m_atmosphereVariant = AtmosphereVariant.SkyAndGround, m_materialVariant = AtmosphereShadingVariant.ScatteringShader) {
        this.m_mapAnchors = m_mapAnchors;
        this.m_sceneCamera = m_sceneCamera;
        this.m_projection = m_projection;
        this.m_rendererCapabilities = m_rendererCapabilities;
        this.m_updateCallback = m_updateCallback;
        this.m_atmosphereVariant = m_atmosphereVariant;
        this.m_materialVariant = m_materialVariant;
        this.m_enabled = true;
        this.m_clipPlanesEvaluator = new ClipPlanesEvaluator_1.TiltViewClipPlanesEvaluator(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR, 0, 1.0, 0.05, 10000000.0);
        // TODO: Support for Theme definition should be added.
        //private m_cachedTheme: Theme = { styles: {} };
        this.m_lightDirection = new THREE.Vector3(0.0, 1.0, 0.0);
        if (this.m_atmosphereVariant & AtmosphereVariant.Sky) {
            this.createSkyGeometry();
        }
        if (this.m_atmosphereVariant & AtmosphereVariant.Ground) {
            this.createGroundGeometry();
        }
        this.addToMapAnchors(this.m_mapAnchors);
    }
    /**
     * Check if map anchors have already atmosphere effect added.
     *
     * @param mapAnchors - MapAnchors to check.
     */
    static isPresent(mapAnchors) {
        for (const mapAnchor of mapAnchors.children) {
            if (mapAnchor.name === MapViewAtmosphere.SkyAtmosphereUserName ||
                mapAnchor.name === MapViewAtmosphere.GroundAtmosphereUserName) {
                return true;
            }
        }
        return false;
    }
    get skyMesh() {
        return this.m_skyMesh;
    }
    get groundMesh() {
        return this.m_groundMesh;
    }
    /**
     * Allows to enable/disable the atmosphere effect, regardless of the theme settings.
     *
     * Use this method to change the setup in runtime without defining corresponding theme setup.
     *
     * @param enable - A boolean that specifies whether the atmosphere should be enabled or
     *                 disabled.
     */
    set enabled(enable) {
        // Check already disposed.
        if (this.disposed) {
            return;
        }
        if (this.m_enabled === enable) {
            return;
        }
        this.m_enabled = enable;
        const isAdded = MapViewAtmosphere.isPresent(this.m_mapAnchors);
        if (enable && !isAdded) {
            this.addToMapAnchors(this.m_mapAnchors);
        }
        else if (!enable && isAdded) {
            this.removeFromMapAnchors(this.m_mapAnchors);
        }
    }
    /**
     * Returns the current atmosphere status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    set lightMode(lightMode) {
        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
            return;
        }
        const dynamicLight = lightMode === AtmosphereLightMode.LightDynamic;
        if (this.m_groundMaterial !== undefined) {
            const groundMat = this.m_groundMaterial;
            groundMat.setDynamicLighting(dynamicLight);
        }
        if (this.m_skyMaterial !== undefined) {
            const skyMat = this.m_skyMaterial;
            skyMat.setDynamicLighting(dynamicLight);
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        var _a, _b, _c, _d;
        // Unlink from scene and mapview anchors
        if (this.enabled) {
            this.enabled = false;
        }
        (_a = this.m_skyMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this.m_groundMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
        (_c = this.m_skyGeometry) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = this.m_groundGeometry) === null || _d === void 0 ? void 0 : _d.dispose();
        // After disposal we may no longer enable effect.
        this.m_skyGeometry = undefined;
        this.m_groundGeometry = undefined;
        this.m_skyMaterial = undefined;
        this.m_groundMaterial = undefined;
        this.m_skyMesh = undefined;
        this.m_groundMesh = undefined;
    }
    /**
     * Sets the atmosphere depending on the
     * {@link @here/harp-datasource-protocol#Theme} instance provided.
     *
     * This function is called when a theme is loaded. Atmosphere is added only if the theme
     * contains a atmosphere definition with a:
     * - `color` property, used to set the atmosphere color.
     *
     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.
     */
    reset(theme) {
        //this.m_cachedTheme = theme;
    }
    get disposed() {
        return this.m_skyMesh === undefined && this.m_groundMesh === undefined;
    }
    /**
     * Handles atmosphere effect adding.
     */
    addToMapAnchors(mapAnchors) {
        harp_utils_1.assert(!MapViewAtmosphere.isPresent(mapAnchors), "Atmosphere already added");
        if (this.m_skyMesh !== undefined) {
            mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));
        }
        if (this.m_groundMesh !== undefined) {
            mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));
        }
        // Request an update once the anchor is added to {@link MapView}.
        if (this.m_updateCallback) {
            this.m_updateCallback();
        }
    }
    /**
     * Handles atmosphere effect removal.
     */
    removeFromMapAnchors(mapAnchors) {
        if (!MapViewAtmosphere.isPresent(mapAnchors)) {
            return;
        }
        let update = false;
        if (this.m_skyMesh !== undefined) {
            mapAnchors.remove(this.m_skyMesh);
            update = true;
        }
        if (this.m_groundMesh !== undefined) {
            mapAnchors.remove(this.m_groundMesh);
            update = true;
        }
        if (update && this.m_updateCallback) {
            this.m_updateCallback();
        }
    }
    createSkyGeometry() {
        switch (this.m_projection.type) {
            case harp_geoutils_1.ProjectionType.Spherical:
                this.m_skyGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                break;
            default: {
                this.m_skyGeometry = new THREE.PlaneGeometry(200, 200);
                break;
            }
        }
        this.m_skyGeometry.translate(0, 0, 0);
        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {
            this.m_skyMaterial = new harp_materials_1.SkyAtmosphereMaterial({
                rendererCapabilities: this.m_rendererCapabilities
            });
        }
        else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {
            this.m_skyMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(0xc4f8ed),
                opacity: 0.4,
                transparent: false,
                depthTest: true,
                depthWrite: false,
                side: THREE.BackSide,
                blending: THREE.NormalBlending,
                fog: false
            });
        }
        else {
            this.m_skyMaterial = new THREE.MeshStandardMaterial({
                color: 0x7fffff,
                depthTest: false,
                depthWrite: false,
                normalScale: new THREE.Vector2(-1, -1),
                side: THREE.BackSide,
                wireframe: true
            });
        }
        this.m_skyMesh = new THREE.Mesh(this.m_skyGeometry, this.m_skyMaterial);
        // Assign custom name so sky object may be easily recognized withing the scene.
        this.m_skyMesh.name = MapViewAtmosphere.SkyAtmosphereUserName;
        this.setupSkyForRendering();
    }
    createGroundGeometry() {
        switch (this.m_projection.type) {
            case harp_geoutils_1.ProjectionType.Spherical:
                this.m_groundGeometry = new THREE.SphereGeometry(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR), 256, 256);
                break;
            default: {
                this.m_groundGeometry = new THREE.PlaneGeometry(200, 200);
                break;
            }
        }
        this.m_groundGeometry.translate(0, 0, 0);
        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {
            this.m_groundMaterial = new harp_materials_1.GroundAtmosphereMaterial({
                rendererCapabilities: this.m_rendererCapabilities
            });
        }
        else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {
            this.m_groundMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(0x00c5ff),
                opacity: 0.4,
                transparent: true,
                depthTest: false,
                depthWrite: false,
                side: THREE.FrontSide,
                blending: THREE.NormalBlending,
                fog: false
            });
        }
        else {
            this.m_groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x11899a,
                depthTest: true,
                depthWrite: false,
                side: THREE.FrontSide,
                wireframe: true
            });
        }
        this.m_groundMesh = new THREE.Mesh(this.m_groundGeometry, this.m_groundMaterial);
        // Assign name so object may be recognized withing the scene.
        this.m_groundMesh.name = MapViewAtmosphere.GroundAtmosphereUserName;
        this.setupGroundForRendering();
    }
    setupSkyForRendering() {
        if (this.m_skyMesh === undefined) {
            return;
        }
        // Depending on material variant we need to update uniforms or only
        // update camera near/far planes cause camera need to see further then
        // actual earth geometry.
        let onBeforeCallback;
        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
            // Setup only further clip planes before rendering.
            onBeforeCallback = (camera, _material) => {
                this.overrideClipPlanes(camera);
            };
        }
        else {
            // Setup proper clip planes and update uniforms values.
            onBeforeCallback = (camera, material) => {
                this.overrideClipPlanes(camera);
                // Check material wasn't swapped.
                harp_utils_1.assert(material instanceof harp_materials_1.SkyAtmosphereMaterial);
                const mat = this.m_skyMaterial;
                mat.updateUniforms(mat, this.m_skyMesh, camera, this.m_lightDirection);
            };
        }
        // Sky material should be already created with mesh.
        harp_utils_1.assert(this.m_skyMaterial !== undefined);
        this.m_skyMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
            onBeforeCallback(camera, material);
        };
        this.m_skyMesh.onAfterRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            this.revertClipPlanes(camera);
        };
    }
    setupGroundForRendering() {
        if (this.m_groundMesh === undefined) {
            return;
        }
        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {
            return;
        }
        // Ground material should be already created.
        harp_utils_1.assert(this.m_groundMaterial !== undefined);
        // Ground mesh does not need custom clip planes and uses the same camera setup as
        // real (data source based) geometry.
        this.m_groundMesh.onBeforeRender = (_renderer, _scene, camera, _geometry, material, _group) => {
            harp_utils_1.assert(material instanceof harp_materials_1.GroundAtmosphereMaterial);
            const mat = this.m_groundMaterial;
            mat.updateUniforms(mat, this.m_groundMesh, camera, this.m_lightDirection);
        };
    }
    overrideClipPlanes(rteCamera) {
        // Store current clip planes used by global camera before modifying them.
        const sceneCam = this.m_sceneCamera;
        cache.clipPlanes.near = sceneCam.near;
        cache.clipPlanes.far = sceneCam.far;
        // Calculate view ranges using world camera.
        // NOTE: ElevationProvider is not passed to evaluator, leaves min/max altitudes unchanged.
        const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(this.m_sceneCamera, this.m_projection);
        // Update relative to eye camera used internally in rendering.
        harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);
        const c = rteCamera;
        c.near = viewRanges.near;
        // Small margin ensures that we never cull small triangles just below or at
        // horizon - possible due to frustum culling in-precisions.
        c.far = viewRanges.far + harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * 0.1;
        c.updateProjectionMatrix();
    }
    revertClipPlanes(rteCamera) {
        harp_utils_1.assert(rteCamera instanceof THREE.PerspectiveCamera);
        const c = rteCamera;
        // Restore scene camera clip planes.
        c.near = cache.clipPlanes.near;
        c.far = cache.clipPlanes.far;
        c.updateProjectionMatrix();
    }
}
exports.MapViewAtmosphere = MapViewAtmosphere;
/**
 * User data name attribute assigned to created mesh.
 */
MapViewAtmosphere.SkyAtmosphereUserName = "SkyAtmosphere";
/**
 * User data name attribute assigned to created mesh.
 */
MapViewAtmosphere.GroundAtmosphereUserName = "GroundAtmosphere";
function createMapAnchor(mesh, renderOrder) {
    const anchor = mesh;
    anchor.renderOrder = renderOrder;
    anchor.pickable = false;
    anchor.anchor = new THREE.Vector3(0, 0, 0);
    return anchor;
}


/***/ }),

/***/ "../harp-mapview/lib/MapViewEnvironment.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/MapViewEnvironment.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewEnvironment = exports.DEFAULT_CLEAR_COLOR = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const MapViewFog_1 = __webpack_require__(/*! ./MapViewFog */ "../harp-mapview/lib/MapViewFog.ts");
const SkyBackground_1 = __webpack_require__(/*! ./SkyBackground */ "../harp-mapview/lib/SkyBackground.ts");
const ThemeHelpers_1 = __webpack_require__(/*! ./ThemeHelpers */ "../harp-mapview/lib/ThemeHelpers.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewEnvironment");
//  the default breaks the ibct tests, seems it had not been used in all cases before
exports.DEFAULT_CLEAR_COLOR = 0xffffff; //0xefe9e1;
const cache = {
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    frustumPoints: [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
    ]
};
/**
 * Class handling the Scene Environment, like fog, sky, background datasource, clearColor etc
 *  for MapView
 */
class MapViewEnvironment {
    constructor(m_mapView, options) {
        this.m_mapView = m_mapView;
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_mapView.scene);
        if (options.addBackgroundDatasource !== false) {
            this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();
            this.m_mapView.addDataSource(this.m_backgroundDataSource);
        }
        if (options.backgroundTilingScheme !== undefined &&
            this.m_backgroundDataSource !== undefined) {
            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
        }
        this.updateClearColor();
    }
    get lights() {
        var _a;
        return (_a = this.m_createdLights) !== null && _a !== void 0 ? _a : [];
    }
    get fog() {
        return this.m_fog;
    }
    updateBackgroundDataSource() {
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
    }
    clearBackgroundDataSource() {
        if (this.m_backgroundDataSource !== undefined) {
            this.m_mapView.clearTileCache(this.m_backgroundDataSource.name);
        }
    }
    update() {
        this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);
        if (this.m_skyBackground !== undefined &&
            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_mapView.camera);
        }
        this.updateLights();
    }
    updateClearColor(clearColor, clearAlpha) {
        if (clearColor !== undefined) {
            this.m_mapView.renderer.setClearColor(new THREE.Color(clearColor), clearAlpha);
        }
        else {
            this.m_mapView.renderer.setClearColor(exports.DEFAULT_CLEAR_COLOR, clearAlpha);
        }
    }
    updateSkyBackground(sky, clearColor) {
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(sky, clearColor);
        }
        else if (this.m_skyBackground === undefined && sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(sky, clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    updateLighting(lights) {
        var _a;
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_mapView.scene.remove(light);
            });
        }
        (_a = this.m_overlayCreatedLights) === null || _a === void 0 ? void 0 : _a.forEach(light => {
            this.m_mapView.overlayScene.remove(light);
            if (light instanceof THREE.DirectionalLight) {
                this.m_mapView.overlayScene.remove(light.target);
            }
        });
        if (lights !== undefined) {
            this.m_createdLights = [];
            this.m_overlayCreatedLights = [];
            lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.warn(`MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_mapView.scene.add(light);
                if (light.isDirectionalLight) {
                    const directionalLight = light;
                    // This is needed so that the target is updated automatically, see:
                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target
                    this.m_mapView.scene.add(directionalLight.target);
                }
                this.m_createdLights.push(light);
                const clonedLight = light.clone();
                this.m_mapView.overlayScene.add(clonedLight);
                if (clonedLight instanceof THREE.DirectionalLight) {
                    this.m_mapView.overlayScene.add(clonedLight.target.clone());
                }
            });
        }
    }
    /**
     * Update the directional light camera. Note, this requires the cameras to first be updated.
     */
    updateLights() {
        // TODO: HARP-9479 Globe doesn't support shadows.
        if (!this.m_mapView.shadowsEnabled ||
            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical ||
            this.m_createdLights === undefined ||
            this.m_createdLights.length === 0) {
            return;
        }
        const points = [
            // near plane points
            { x: -1, y: -1, z: -1 },
            { x: 1, y: -1, z: -1 },
            { x: -1, y: 1, z: -1 },
            { x: 1, y: 1, z: -1 },
            // far planes points
            { x: -1, y: -1, z: 1 },
            { x: 1, y: -1, z: 1 },
            { x: -1, y: 1, z: 1 },
            { x: 1, y: 1, z: 1 }
        ];
        const transformedPoints = points.map((p, i) => this.m_mapView.ndcToView(p, cache.frustumPoints[i]));
        this.m_createdLights.forEach(element => {
            const directionalLight = element;
            if (directionalLight.isDirectionalLight === true) {
                const lightDirection = cache.vector3[0];
                lightDirection.copy(directionalLight.target.position);
                lightDirection.sub(directionalLight.position);
                lightDirection.normalize();
                const normal = cache.vector3[1];
                if (this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                    // -Z points to the camera, we can't use Projection.surfaceNormal, because
                    // webmercator and mercator give different results.
                    normal.set(0, 0, -1);
                }
                else {
                    // Enable shadows for globe...
                    //this.projection.surfaceNormal(target, normal);
                }
                // The camera of the shadow has the same height as the map camera, and the target is
                // also the same. The position is then calculated based on the light direction and
                // the height
                // using basic trigonometry.
                const tilt = this.m_mapView.tilt;
                const cameraHeight = this.m_mapView.targetDistance * Math.cos(THREE.MathUtils.degToRad(tilt));
                const lightPosHyp = cameraHeight / normal.dot(lightDirection);
                directionalLight.target.position
                    .copy(this.m_mapView.worldTarget)
                    .sub(this.m_mapView.camera.position);
                directionalLight.position.copy(this.m_mapView.worldTarget);
                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);
                directionalLight.position.sub(this.m_mapView.camera.position);
                directionalLight.updateMatrixWorld();
                directionalLight.shadow.updateMatrices(directionalLight);
                const camera = directionalLight.shadow.camera;
                const pointsInLightSpace = transformedPoints.map(p => this.viewToLightSpace(p.clone(), camera));
                const box = new THREE.Box3();
                pointsInLightSpace.forEach(point => {
                    box.expandByPoint(point);
                });
                camera.left = box.min.x;
                camera.right = box.max.x;
                camera.top = box.max.y;
                camera.bottom = box.min.y;
                // Moving back to the light the near plane in order to catch high buildings, that
                // are not visible by the camera, but existing on the scene.
                camera.near = -box.max.z * 0.95;
                camera.far = -box.min.z;
                camera.updateProjectionMatrix();
            }
        });
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.m_mapView.projection.type, this.m_mapView.camera);
        this.m_mapView.scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_mapView.scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        var _a;
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);
            this.m_mapView.scene.background = (_a = this.m_skyBackground) === null || _a === void 0 ? void 0 : _a.texture;
        }
    }
    /**
     * Transfer from view space to camera space.
     * @param viewPos - position in view space, result is stored here.
     */
    viewToLightSpace(viewPos, camera) {
        return viewPos.applyMatrix4(camera.matrixWorldInverse);
    }
}
exports.MapViewEnvironment = MapViewEnvironment;


/***/ }),

/***/ "../harp-mapview/lib/MapViewFog.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/MapViewFog.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewFog = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const RawShaderMaterial_1 = __webpack_require__(/*! @here/harp-materials/lib/RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Manages the fog display in {@link MapView}.
 */
class MapViewFog {
    /**
     * Constructs a `MapViewFog` instance.
     *
     * @param m_scene - The scene used in {@link MapView} that contains the map objects.
     */
    constructor(m_scene) {
        this.m_scene = m_scene;
        this.m_enabled = true;
        this.m_fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.
        this.m_fogIsDefined = false;
    }
    /**
     * Allows for disabling the fog, even if it is defined in the theme. Use this property for
     * custom views like the demo app's debug camera. However, if the theme does not define a
     * fog, enabling this property here has no effect.
     *
     * @param value - A boolean that specifies whether the fog should be enabled or disabled.
     */
    set enabled(enableFog) {
        this.m_enabled = enableFog;
        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {
            this.add();
        }
        else if (!enableFog && this.m_scene.fog !== null) {
            this.remove();
        }
    }
    /**
     * Returns the current fog status, enabled or disabled.
     */
    get enabled() {
        return this.m_enabled;
    }
    /**
     * Sets the fog depending on the {@link @here/harp-datasource-protocol#Theme}
     * instance provided. This function is called when a
     * theme is loaded. Fog is added only if the theme contains a fog definition with a:
     * - `color` property, used to set the fog color.
     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far
     * clipping plane distance.
     *
     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.
     */
    reset(fog) {
        this.m_cachedFog = fog;
        if (fog !== undefined && fog.color !== undefined && fog.startRatio !== undefined) {
            this.m_fogIsDefined = true;
            this.m_fog.color.set(fog.color);
            if (this.m_enabled && this.m_scene.fog === null) {
                this.add();
            }
        }
        else {
            this.m_fogIsDefined = false;
            if (this.m_scene.fog !== null) {
                this.remove();
            }
        }
    }
    /**
     * Updates the fog at runtime, depending on the camera.
     *
     * @param camera - An instance of a `THREE.Camera` with a `far` property.
     */
    update(mapView, viewDistance) {
        if (this.m_scene.fog !== null &&
            this.m_cachedFog !== undefined &&
            this.m_cachedFog &&
            this.m_cachedFog.startRatio !== undefined &&
            (mapView.camera.far !== undefined || viewDistance !== undefined)) {
            // If maximum visibility range is available use it instead of camera.far distance,
            // this makes fog independent from dynamic camera planes and keeps consistent
            // distance based "melting" (fog) effect during a tilt.
            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;
            // TODO: We may move below constants to theme Fog definition
            // Density of the fog when viewing straight along the horizon line.
            const horizontalDensity = 1.0;
            // Theoretical density of the fog when viewing straight from top to down.
            const verticalDensity = 0.0;
            // The fraction of the maximum viewing distance along the eye vector
            // to start applying the fog.
            const startRatio = this.m_cachedFog.startRatio;
            // The fraction of maximum viewing range at which fog fully covers geometry.
            const endRatio = 1.0;
            harp_utils_1.assert(startRatio <= endRatio);
            const t = Math.abs(Math.cos(mapView.tilt));
            const density = harp_utils_1.MathUtils.smoothStep(horizontalDensity, verticalDensity, t);
            this.m_fog.near = THREE.MathUtils.lerp(viewRange * startRatio, viewRange, 1.0 - density);
            this.m_fog.far = THREE.MathUtils.lerp(viewRange * endRatio, viewRange, density);
            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);
            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);
        }
    }
    /**
     * Handles fog addition.
     */
    add() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = this.m_fog;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(true);
    }
    /**
     * Handles fog removal.
     */
    remove() {
        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...
        this.m_scene.fog = null;
        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.
        this.setFogInRawShaderMaterials(false);
    }
    /**
     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified
     * explicitly.
     *
     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298
     */
    setFogInRawShaderMaterials(enableFog) {
        this.m_scene.traverse(object => {
            if (object instanceof THREE.Mesh) {
                const material = object.material;
                if (material instanceof THREE.Material &&
                    // HighPrecisionLineMaterial does not support fog:
                    !(material instanceof harp_materials_1.HighPrecisionLineMaterial) &&
                    // We may skip redundant updates:
                    material.fog !== enableFog) {
                    material.fog = enableFog;
                    if (material instanceof RawShaderMaterial_1.RawShaderMaterial) {
                        // Fog properties can't be easily changed at runtime (once the material
                        // is rendered at least once) and thus requires building of new shader
                        // program - force material update.
                        material.invalidateFog();
                    }
                }
            }
        });
    }
}
exports.MapViewFog = MapViewFog;


/***/ }),

/***/ "../harp-mapview/lib/MapViewPoints.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/MapViewPoints.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2018-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Squares = exports.Circles = exports.MapViewPoints = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * `MapViewPoints` is a class to extend for the `"circles"` and `"squares"` techniques to
 * implement raycasting of `THREE.Points` as expected in {@link MapView},
 * that are in screen space.
 *
 * @remarks
 * It copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its
 * children classes, {@link Circles} and {@link Squares}, who hold the intersection testing in the
 * `testPoint` method. This class also has the ability to dismiss the testing via the
 * `enableRayTesting` flag.
 *
 * Its main motivation is to handle the point styles of XYZ projects.
 *
 * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js
 *
 * @internal
 */
class MapViewPoints extends THREE.Points {
    constructor() {
        super(...arguments);
        /**
         * This allows to discard the ray testing.
         */
        this.enableRayTesting = true;
    }
    /**
     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it
     * then calls the tailored `testPoint` method in the children classes to test intersections
     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.
     *
     * @param raycaster - The raycaster.
     * @param intersects - The array to fill with the results.
     */
    raycast(raycaster, intersects) {
        if (!this.enableRayTesting) {
            return;
        }
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const ndc = raycaster.ray.origin
            .clone()
            .add(raycaster.ray.direction)
            .project(raycaster.camera);
        const mouseCoords = ndcToScreen(ndc, raycaster);
        const testPoint = (point, index) => {
            const pointInfo = getPointInfo(point, matrixWorld, raycaster);
            if (pointInfo.pointIsOnScreen) {
                this.testPoint(point, pointInfo.absoluteScreenPosition, mouseCoords, index, pointInfo.distance, intersects);
            }
        };
        const point = new THREE.Vector3();
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positions = attributes.position.array;
        if (index !== null) {
            const indices = index.array;
            for (let i = 0, il = indices.length; i < il; i++) {
                testPoint(point.fromArray(positions, indices[i] * 3), i);
            }
        }
        else {
            for (let i = 0, l = positions.length / 3; i < l; i++) {
                testPoint(point.fromArray(positions, i * 3), i);
            }
        }
    }
}
exports.MapViewPoints = MapViewPoints;
function ndcToScreen(ndc, raycaster) {
    return new THREE.Vector2(ndc.x + 1, 1 - ndc.y)
        .divideScalar(2)
        .multiply(raycaster.canvasSize)
        .ceil();
}
function getPointInfo(point, matrixWorld, raycaster) {
    const worldPosition = point.clone().applyMatrix4(matrixWorld);
    const distance = worldPosition.distanceTo(raycaster.ray.origin);
    const ndc = worldPosition.project(raycaster.camera);
    const pointIsOnScreen = ndc.x < 1 && ndc.x > -1 && ndc.y < 1 && ndc.y > -1;
    if (pointIsOnScreen) {
        const absoluteScreenPosition = ndcToScreen(ndc, raycaster);
        return {
            absoluteScreenPosition,
            pointIsOnScreen,
            distance
        };
    }
    return {
        pointIsOnScreen
    };
}
/**
 * Point object that implements the raycasting of circles in screen space.
 * @internal
 */
class Circles extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const radius = this.material.size / 2;
        if (dist <= radius) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Circles = Circles;
/**
 * Point object that implements the raycasting of squares in screen space.
 * @internal
 */
class Squares extends MapViewPoints {
    /** @override */
    testPoint(point, screenPosition, pickCoordinates, index, distance, intersects) {
        const dx = screenPosition.x - pickCoordinates.x;
        const dy = screenPosition.y - pickCoordinates.y;
        const halfSize = this.material.size / 2;
        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {
            intersects.push({
                point,
                distance,
                index,
                object: this
            });
        }
    }
}
exports.Squares = Squares;


/***/ }),

/***/ "../harp-mapview/lib/MapViewTaskScheduler.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/MapViewTaskScheduler.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewTaskScheduler = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const DEFAULT_MAX_FPS = 60;
const DEFAULT_PROCESSING_ESTIMATE_TIME = 2;
const UPDATE_EVENT = { type: "update" };
class MapViewTaskScheduler extends THREE.EventDispatcher {
    constructor(m_maxFps = DEFAULT_MAX_FPS) {
        super();
        this.m_maxFps = m_maxFps;
        this.m_throttlingEnabled = false;
        this.m_taskQueue = new harp_utils_1.TaskQueue({
            groups: [MapView_1.TileTaskGroups.FETCH_AND_DECODE, MapView_1.TileTaskGroups.CREATE],
            prioSortFn: (a, b) => {
                return a.getPriority() - b.getPriority();
            }
        });
        this.maxFps = m_maxFps;
    }
    set maxFps(fps) {
        this.m_maxFps = fps <= 0 ? DEFAULT_MAX_FPS : fps;
    }
    get maxFps() {
        return this.m_maxFps;
    }
    get taskQueue() {
        return this.m_taskQueue;
    }
    get throttlingEnabled() {
        return this.m_throttlingEnabled === true;
    }
    set throttlingEnabled(enabled) {
        this.m_throttlingEnabled = enabled;
    }
    /**
     * Sends a request to the [[MapView]] to redraw the scene.
     */
    requestUpdate() {
        this.dispatchEvent(UPDATE_EVENT);
    }
    /**
     * Processes the pending Tasks of the underlying [[TaskQueue]]
     * !! This should run at the end of the renderLoop, so the calculations of the available
     * frame time are better estimated
     *
     * @param frameStartTime the start time of the current frame, is used to calculate the
     * still available time in the frame to process Tasks
     *
     */
    processPending(frameStartTime) {
        const stats = Statistics_1.PerformanceStatistics.instance;
        const currentFrameEvent = stats.enabled ? stats.currentFrame : undefined;
        let startTime;
        if (stats.enabled) {
            startTime = harp_utils_1.PerformanceTimer.now();
        }
        //update the task queue, to remove expired and sort with priority
        this.m_taskQueue.update();
        let numItemsLeft = this.taskQueue.numItemsLeft();
        currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.numPendingTasks", numItemsLeft);
        if (this.throttlingEnabled) {
            // get the available time in this frame to achieve a max fps rate
            let availableTime = this.spaceInFrame(frameStartTime);
            // get some buffer to balance the inaccurate estimates
            availableTime = availableTime > 2 ? availableTime - 2 : availableTime;
            currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.estimatedAvailableTime", availableTime);
            let counter = 0;
            // check if ther is still time available and tasks left
            while (availableTime > 0 && numItemsLeft > 0) {
                counter++;
                // create a processing condition for the tasks
                function shouldProcess(task) {
                    var _a, _b;
                    // if there is a time estimate use it, otherwise default to 1 ms
                    // TODO: check whats a sane default, 1 seems to do it for now
                    availableTime -= (_b = (_a = task.estimatedProcessTime) === null || _a === void 0 ? void 0 : _a.call(task)) !== null && _b !== void 0 ? _b : DEFAULT_PROCESSING_ESTIMATE_TIME;
                    // always process at least 1 Task, so in the worst case the fps over tiles
                    // paradigma is sacrificed to not have an empty screen
                    if (availableTime > 0 || counter === 1) {
                        return true;
                    }
                    return false;
                }
                // process the CREATE tasks first, as they will have a faster result on the
                // visual outcome and have already spend time in the application during
                // fetching and decoding
                // fetching has lower priority as it wont make to much of a difference if not
                // called at the exact frame, and the tile might expire in the next anyway
                [MapView_1.TileTaskGroups.CREATE, MapView_1.TileTaskGroups.FETCH_AND_DECODE].forEach(tag => {
                    if (this.m_taskQueue.numItemsLeft(tag)) {
                        //TODO:
                        // * if one tag task does not fit another might, how to handle this?
                        // *    ** what if a task of another group could fit instead
                        // * whats the average of time we have here at this point in the programm?
                        this.m_taskQueue.processNext(tag, shouldProcess);
                    }
                });
                numItemsLeft = this.m_taskQueue.numItemsLeft();
            }
            // if there is tasks left in the TaskQueue, request an update to be able to process them
            // in a next frame
            numItemsLeft = this.m_taskQueue.numItemsLeft();
            if (numItemsLeft > 0) {
                currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksNotYetProcessed", numItemsLeft);
                this.requestUpdate();
            }
        }
        else {
            //if throttling is disabled, process all pending tasks
            this.m_taskQueue.processNext(MapView_1.TileTaskGroups.CREATE, undefined, this.m_taskQueue.numItemsLeft(MapView_1.TileTaskGroups.CREATE));
            this.m_taskQueue.processNext(MapView_1.TileTaskGroups.FETCH_AND_DECODE, undefined, this.m_taskQueue.numItemsLeft(MapView_1.TileTaskGroups.FETCH_AND_DECODE));
        }
        if (stats.enabled) {
            currentFrameEvent === null || currentFrameEvent === void 0 ? void 0 : currentFrameEvent.setValue("TaskScheduler.pendingTasksTime", harp_utils_1.PerformanceTimer.now() - startTime);
        }
    }
    /**
     * Removes all tasks that have been queued.
     */
    clearQueuedTasks() {
        this.m_taskQueue.clear();
    }
    spaceInFrame(frameStartTime) {
        const passedTime = (performance || Date).now() - frameStartTime;
        return Math.max(1000 / this.m_maxFps - passedTime, 0);
    }
}
exports.MapViewTaskScheduler = MapViewTaskScheduler;


/***/ }),

/***/ "../harp-mapview/lib/MapViewThemeManager.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/MapViewThemeManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewThemeManager = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const MapViewImageCache_1 = __webpack_require__(/*! ./image/MapViewImageCache */ "../harp-mapview/lib/image/MapViewImageCache.ts");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewThemeManager");
/**
 * Class handling theme updates for MapView
 */
class MapViewThemeManager {
    constructor(m_mapView, m_uriResolver) {
        this.m_mapView = m_mapView;
        this.m_uriResolver = m_uriResolver;
        this.m_abortControllers = [];
        this.m_theme = {};
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache();
    }
    async setTheme(theme) {
        if (this.isUpdating()) {
            logger.warn("Formerly set Theme is still updating, update will be canceled");
            this.cancelThemeUpdate();
        }
        this.m_updatePromise = this.loadTheme(theme).then(async (theme) => {
            await this.updateTheme(theme);
        });
        await this.m_updatePromise;
        this.m_updatePromise = undefined;
        return this.m_theme;
    }
    async getTheme() {
        if (this.isUpdating()) {
            await this.m_updatePromise;
        }
        return this.m_theme;
    }
    isUpdating() {
        return this.m_updatePromise !== undefined;
    }
    /**
     * @deprecated
     * A helper for the deprecated MapView.theme getter, remove when
     * after deprecation
     */
    get theme() {
        return this.isUpdating() ? {} : this.m_theme;
    }
    async loadTheme(theme) {
        let loadedTheme = {};
        if (typeof theme === "string" || !ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {
            try {
                loadedTheme = await ThemeLoader_1.ThemeLoader.load(theme, {
                    uriResolver: this.m_uriResolver,
                    signal: this.createAbortController().signal
                });
            }
            catch (error) {
                if (error.name === "AbortError") {
                    logger.warn(`theme loading was aborted due to: ${error}`);
                }
                else {
                    logger.error(`failed to load theme: ${error}`);
                }
            }
        }
        else {
            loadedTheme = theme;
        }
        return loadedTheme;
    }
    async updateTheme(theme) {
        var _a, _b;
        const environment = this.m_mapView.sceneEnvironment;
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        environment.updateSkyBackground(theme.sky);
        environment.fog.reset(theme.fog);
        this.m_theme.lights = theme.lights;
        environment.updateLighting(theme.lights);
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.m_theme.clearAlpha = theme.clearAlpha;
        environment.updateClearColor(theme.clearColor, theme.clearAlpha);
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        await this.updateImages(theme.images, theme.imageTextures);
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        await this.loadPoiTables(theme.poiTables);
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        await this.m_mapView.resetTextRenderer(theme.fontCatalogs, theme.textStyles, theme.defaultTextStyle);
        if (Array.isArray(theme.priorities)) {
            this.m_theme.priorities = theme.priorities;
        }
        this.m_mapView.mapAnchors.setPriorities((_a = theme.priorities) !== null && _a !== void 0 ? _a : []);
        if (Array.isArray(theme.labelPriorities)) {
            this.m_theme.labelPriorities = theme.labelPriorities;
        }
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = [];
        }
        this.m_theme.styles = (_b = theme.styles) !== null && _b !== void 0 ? _b : [];
        this.m_theme.definitions = theme.definitions;
        environment.clearBackgroundDataSource();
        for (const dataSource of this.m_mapView.dataSources) {
            await dataSource.setTheme(this.m_theme);
        }
    }
    updateCache() {
        this.updateImages(this.m_theme.images, this.m_theme.imageTextures);
        this.m_mapView.sceneEnvironment.updateLighting(this.m_theme.lights);
        this.m_mapView.sceneEnvironment.updateSkyBackground(this.m_theme.sky, this.m_theme.clearColor);
    }
    get imageCache() {
        return this.m_imageCache;
    }
    dispose() {
        this.m_imageCache.clear();
    }
    async loadPoiTables(poiTables) {
        this.m_mapView.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        await this.m_mapView.poiTableManager.loadPoiTables(poiTables);
    }
    cancelThemeUpdate() {
        for (var i = 0; i < this.m_abortControllers.length; i++) {
            this.m_abortControllers[i].abort();
        }
        this.m_abortControllers = [];
        this.m_imageCache.clear();
        this.m_mapView.poiManager.clear();
        this.m_mapView.poiTableManager.clear();
    }
    createAbortController() {
        this.m_abortControllers.push(new AbortController());
        return this.m_abortControllers[this.m_abortControllers.length - 1];
    }
    async updateImages(images, imageTextures) {
        this.m_imageCache.clear();
        this.m_mapView.poiManager.clear();
        if (images !== undefined) {
            for (const name of Object.keys(images)) {
                const image = images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    await this.m_mapView.poiManager.addTextureAtlas(name, image.atlas, this.createAbortController().signal);
                }
            }
        }
        if (imageTextures !== undefined) {
            imageTextures.forEach((imageTexture) => {
                this.m_mapView.poiManager.addImageTexture(imageTexture);
            });
        }
    }
}
exports.MapViewThemeManager = MapViewThemeManager;


/***/ }),

/***/ "../harp-mapview/lib/PathBlockingElement.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/PathBlockingElement.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathBlockingElement = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * This path in world coordinates is projected to screen space and blocks all other labels.
 *
 * It could be used for example:
 * - Border rejects labels.
 * - Route blocks street labels from being rendered underneath.
 *
 * Could potentially be expanded in future to have a priority, however for now, this isn't required.
 */
class PathBlockingElement {
    /**
     * Constructs a path from a list of points.
     * Pre allocates the [[screenSpaceLines]] used to render.
     * @param points - Points in world coordinates.
     */
    constructor(points) {
        this.points = points;
        this.screenSpaceLines = new Array(points.length >= 2 ? points.length - 1 : 0);
        for (let i = 0; i < this.screenSpaceLines.length; i++) {
            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());
        }
    }
}
exports.PathBlockingElement = PathBlockingElement;


/***/ }),

/***/ "../harp-mapview/lib/PickHandler.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/PickHandler.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PickHandler = exports.PickObjectType = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapViewPoints_1 = __webpack_require__(/*! ./MapViewPoints */ "../harp-mapview/lib/MapViewPoints.ts");
const PickingRaycaster_1 = __webpack_require__(/*! ./PickingRaycaster */ "../harp-mapview/lib/PickingRaycaster.ts");
const PickListener_1 = __webpack_require__(/*! ./PickListener */ "../harp-mapview/lib/PickListener.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a {@link TextElement}
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a {@link TextElement}.
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
const tmpV3 = new THREE.Vector3();
const tmpOBB = new harp_geoutils_1.OrientedBox3();
// Intersects the dependent tile objects using the supplied raycaster. Note, because multiple
// tiles can point to the same dependency we need to store which results we have already
// raycasted, see checkedDependencies.
function intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, mapView) {
    for (const tileKey of tile.dependencies) {
        const mortonCode = tileKey.mortonCode();
        if (checkedDependencies.has(mortonCode)) {
            continue;
        }
        checkedDependencies.add(mortonCode);
        const otherTile = mapView.visibleTileSet.getCachedTile(tile.dataSource, tileKey, tile.offset, mapView.frameNumber);
        if (otherTile !== undefined) {
            rayCaster.intersectObjects(otherTile.objects, true, intersects);
        }
    }
}
/**
 * Handles the picking of scene geometry and roads.
 * @internal
 */
class PickHandler {
    constructor(mapView, camera, enablePickTechnique = false) {
        this.mapView = mapView;
        this.camera = camera;
        this.enablePickTechnique = enablePickTechnique;
        this.m_pickingRaycaster = new PickingRaycaster_1.PickingRaycaster(mapView.renderer.getSize(new THREE.Vector2()));
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking.
     *
     * @param x - The X position in CSS/client coordinates, without the applied display ratio.
     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.
     * @param parameters - The intersection test behaviour may be adjusted by providing an instance
     * of {@link IntersectParams}.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y, parameters) {
        const ndc = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.setupRaycaster(x, y);
        const pickListener = new PickListener_1.PickListener(parameters);
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = ndc.x * clientWidth * 0.5;
            const screenY = ndc.y * clientHeight * 0.5;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);
        }
        const intersects = [];
        const intersectedTiles = this.getIntersectedTiles(rayCaster);
        // This ensures that we check a given dependency only once (because multiple tiles could
        // have the same dependency).
        const checkedDependencies = new Set();
        for (const { tile, distance } of intersectedTiles) {
            if (pickListener.done && pickListener.furthestResult.distance < distance) {
                // Stop when the listener has all results it needs and remaining tiles are further
                // away than then furthest pick result found so far.
                break;
            }
            intersects.length = 0;
            rayCaster.intersectObjects(tile.objects, true, intersects);
            intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, this.mapView);
            for (const intersect of intersects) {
                pickListener.addResult(this.createResult(intersect, tile));
            }
        }
        // Intersect any objects added by the user.
        intersects.length = 0;
        for (const child of this.mapView.mapAnchors.children) {
            rayCaster.intersectObject(child, true, intersects);
            for (const intersect of intersects) {
                pickListener.addResult(this.createResult(intersect));
            }
        }
        pickListener.finish();
        return pickListener.results;
    }
    /**
     * Returns a ray caster using the supplied screen positions.
     *
     * @param x - The X position in css/client coordinates (without applied display ratio).
     * @param y - The Y position in css/client coordinates (without applied display ratio).
     *
     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen
     * points.
     */
    raycasterFromScreenPoint(x, y) {
        this.m_pickingRaycaster.setFromCamera(this.mapView.getNormalizedScreenCoordinates(x, y), this.camera);
        this.mapView.renderer.getSize(this.m_pickingRaycaster.canvasSize);
        return this.m_pickingRaycaster;
    }
    createResult(intersection, tile) {
        var _a, _b, _c;
        const pickResult = {
            type: PickObjectType.Unspecified,
            point: intersection.point,
            distance: intersection.distance,
            dataSourceName: (_a = intersection.object.userData) === null || _a === void 0 ? void 0 : _a.dataSource,
            dataSourceOrder: (_b = tile === null || tile === void 0 ? void 0 : tile.dataSource) === null || _b === void 0 ? void 0 : _b.dataSourceOrder,
            intersection,
            tileKey: tile === null || tile === void 0 ? void 0 : tile.tileKey
        };
        if (intersection.object.userData === undefined ||
            intersection.object.userData.feature === undefined) {
            return pickResult;
        }
        if (this.enablePickTechnique) {
            pickResult.technique = intersection.object.userData.technique;
        }
        pickResult.renderOrder = (_c = intersection.object) === null || _c === void 0 ? void 0 : _c.renderOrder;
        const featureData = intersection.object.userData.feature;
        this.addObjInfo(featureData, intersection, pickResult);
        if (pickResult.userData) {
            const featureId = harp_datasource_protocol_1.getFeatureId(pickResult.userData);
            pickResult.featureId = featureId === 0 ? undefined : featureId;
        }
        let pickObjectType;
        switch (featureData.geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                pickObjectType = PickObjectType.Point;
                break;
            case harp_datasource_protocol_1.GeometryType.Line:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                pickObjectType = PickObjectType.Line;
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                pickObjectType = PickObjectType.Area;
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                pickObjectType = PickObjectType.Object3D;
                break;
            default:
                pickObjectType = PickObjectType.Unspecified;
        }
        pickResult.type = pickObjectType;
        return pickResult;
    }
    getIntersectedTiles(rayCaster) {
        const tiles = new Array();
        const tileList = this.mapView.visibleTileSet.dataSourceTileList;
        tileList.forEach(dataSourceTileList => {
            if (!dataSourceTileList.dataSource.enablePicking) {
                return;
            }
            dataSourceTileList.renderedTiles.forEach(tile => {
                tmpOBB.copy(tile.boundingBox);
                tmpOBB.position.sub(this.mapView.worldCenter);
                // This offset shifts the box by the given tile offset, see renderTileObjects in
                // MapView
                const worldOffsetX = tile.computeWorldOffsetX();
                tmpOBB.position.x += worldOffsetX;
                const distance = tmpOBB.intersectsRay(rayCaster.ray);
                if (distance !== undefined) {
                    tiles.push({ tile, distance });
                }
            });
        });
        tiles.sort((lhs, rhs) => {
            return lhs.distance - rhs.distance;
        });
        return tiles;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (featureData.objInfos === undefined) {
            return;
        }
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        if (featureData.starts === undefined ||
            featureData.starts.length === 0 ||
            (typeof intersect.faceIndex !== "number" && intersect.index === undefined)) {
            if (featureData.objInfos.length === 1) {
                pickResult.userData = featureData.objInfos[0];
            }
            return;
        }
        if (featureData.starts.length === 1) {
            pickResult.userData = featureData.objInfos[0];
            return;
        }
        const intersectIndex = typeof intersect.faceIndex === "number" ? intersect.faceIndex * 3 : intersect.index;
        // TODO: Implement binary search.
        let objInfosIndex = 0;
        for (const featureStartIndex of featureData.starts) {
            if (featureStartIndex > intersectIndex) {
                break;
            }
            objInfosIndex++;
        }
        pickResult.userData = featureData.objInfos[objInfosIndex - 1];
    }
    setupRaycaster(x, y) {
        const camera = this.mapView.camera;
        const rayCaster = this.raycasterFromScreenPoint(x, y);
        // A threshold must be set for picking of line and line segments, indicating the maximum
        // distance in world units from the ray to a line to consider it as picked. Use the world
        // units equivalent to one pixel at the furthest intersection (i.e. intersection with ground
        // or far plane).
        const furthestIntersection = this.mapView.getWorldPositionAt(x, y, true);
        const furthestDistance = camera.position.distanceTo(furthestIntersection) /
            this.mapView.camera.getWorldDirection(tmpV3).dot(rayCaster.ray.direction);
        rayCaster.params.Line.threshold = Utils_1.MapViewUtils.calculateWorldSizeByFocalLength(this.mapView.focalLength, furthestDistance, 1);
        return rayCaster;
    }
}
exports.PickHandler = PickHandler;


/***/ }),

/***/ "../harp-mapview/lib/PickListener.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/PickListener.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PickListener = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
// Default sorting by:
// 1. reversed data source order (higher first)
// 2. distance to the camera (closer first)
// 3. reversed render order (higher first)
//
// This criteria order is temporary, until HARP-16245 gets implemented.
// Currently, rendering is configured in a way that makes 2D spatials occlude extruded buildings,
// since spatials belong to a higher layer. Picking order reflects that, but comparison by distance should
// happen first, once extruded buildings become rendered on top of spatials.
function defaultSort(lhs, rhs) {
    var _a, _b;
    // HARP-14531: Compare by "dataSourceOrder" first,
    // to ensure that picking results are sorted according to their layers.
    // The bigger "dataSourceOrder" value is, the higher its stacked in the data model,
    // meaning the higher it should be appear in the resulting picking collection.
    // Defaulting "dataSourceOrder" to 0 (base layer) to not skip comparison when it's undefined - in that case
    // sorting results would not be consistent, as some objects become compared by different criteria.
    const lDataSourceOrder = (_a = lhs.dataSourceOrder) !== null && _a !== void 0 ? _a : 0;
    const rDataSourceOrder = (_b = rhs.dataSourceOrder) !== null && _b !== void 0 ? _b : 0;
    if (lDataSourceOrder !== rDataSourceOrder) {
        return rDataSourceOrder - lDataSourceOrder;
    }
    // HARP-14553: Set a distance tolerance to ignore small distance differences between 2D objects
    // that are supposed to lie on the same plane.
    const eps = 1e-4;
    const distanceDiff = lhs.distance - rhs.distance;
    const haveRenderOrder = lhs.renderOrder !== undefined && rhs.renderOrder !== undefined;
    if (Math.abs(distanceDiff) > eps || !haveRenderOrder) {
        return distanceDiff;
    }
    return rhs.renderOrder - lhs.renderOrder;
}
/**
 * Collects results from a picking (intersection) test.
 *
 * @internal
 */
class PickListener {
    /**
     * Constructs a new `PickListener`.
     *
     * @param m_parameters - Optional parameters to customize picking behaviour.
     */
    constructor(m_parameters) {
        this.m_parameters = m_parameters;
        this.m_results = [];
        this.m_sorted = true;
        this.m_finished = true;
    }
    /**
     * Adds a pick result.
     *
     * @param result - The result to be added.
     */
    addResult(result) {
        // Add the result only if it's a different feature from the ones already collected.
        const foundFeatureIdx = this.m_results.findIndex(otherResult => {
            var _a, _b, _c, _d;
            const sameType = otherResult.type === result.type;
            const dataSource = (_b = (_a = result.intersection) === null || _a === void 0 ? void 0 : _a.object.userData) === null || _b === void 0 ? void 0 : _b.dataSource;
            const sameDataSource = dataSource && ((_d = (_c = otherResult.intersection) === null || _c === void 0 ? void 0 : _c.object.userData) === null || _d === void 0 ? void 0 : _d.dataSource) === dataSource;
            const sameId = result.featureId !== undefined && otherResult.featureId === result.featureId;
            const noId = result.featureId === undefined && otherResult.featureId === undefined;
            const sameUserData = result.userData && otherResult.userData === result.userData;
            return sameType && sameDataSource && (sameId || (noId && sameUserData));
        });
        if (foundFeatureIdx < 0) {
            this.m_sorted = false;
            this.m_finished = false;
            this.m_results.push(result);
            return;
        }
        // Replace the result for the same feature if it's sorted after the new result.
        const oldResult = this.m_results[foundFeatureIdx];
        if (defaultSort(result, oldResult) < 0) {
            this.m_results[foundFeatureIdx] = result;
            this.m_sorted = false;
            this.m_finished = false;
        }
    }
    /**
     * Indicates whether the listener is satisfied with the results already provided.
     * @returns `True` if the listener doesn't expect more results, `False` otherwise.
     */
    get done() {
        return this.maxResults ? this.m_results.length >= this.maxResults : false;
    }
    /**
     * Orders the collected results by distance first, then by reversed render order
     * (topmost/highest render order first), and limits the number of results to the maximum
     * accepted number, see {@link IntersectParams.maxResultCount}.
     */
    finish() {
        // Keep only the closest max results.
        this.sortResults();
        if (this.maxResults && this.m_results.length > this.maxResults) {
            this.m_results.length = this.maxResults;
        }
        this.m_finished = true;
    }
    /**
     * Returns the collected results. {@link PickListener.finish} should be called first to ensure
     * the proper sorting and result count.
     * @returns The pick results.
     */
    get results() {
        harp_utils_1.assert(this.m_finished, "finish() was not called before getting the results");
        return this.m_results;
    }
    /**
     * Returns the closest result collected so far, following the order documented in
     * {@link PickListener.finish}
     * @returns The closest pick result, or `undefined` if no result was collected.
     */
    get closestResult() {
        this.sortResults();
        return this.m_results.length > 0 ? this.m_results[0] : undefined;
    }
    /**
     * Returns the furthest result collected so far, following the order documented in
     * {@link PickListener.results}
     * @returns The furthest pick result, or `undefined` if no result was collected.
     */
    get furthestResult() {
        this.sortResults();
        return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : undefined;
    }
    get maxResults() {
        var _a, _b;
        const maxCount = (_b = (_a = this.m_parameters) === null || _a === void 0 ? void 0 : _a.maxResultCount) !== null && _b !== void 0 ? _b : 0;
        return maxCount > 0 ? maxCount : undefined;
    }
    sortResults() {
        if (this.m_sorted) {
            return;
        }
        // HARP-14531: group zero-distance results first,
        // as screen-space objects (e.g. labels) are currently rendered on top.
        const zeroDistanceGroup = [];
        const nonZeroDistanceGroup = [];
        this.m_results
            .sort(defaultSort)
            .forEach(result => (result.distance === 0 ? zeroDistanceGroup : nonZeroDistanceGroup).push(result));
        // both groups are sorted because "this.m_results" are sorted
        this.m_results = zeroDistanceGroup.concat(nonZeroDistanceGroup);
        this.m_sorted = true;
    }
}
exports.PickListener = PickListener;


/***/ }),

/***/ "../harp-mapview/lib/PickingRaycaster.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/PickingRaycaster.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2018-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PickingRaycaster = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ "../harp-mapview/lib/MapObjectAdapter.ts");
function intersectObject(object, raycaster, intersects, recursive) {
    if (object.layers.test(raycaster.layers) && object.visible) {
        const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
        if (!mapObjectAdapter || mapObjectAdapter.isPickable()) {
            object.raycast(raycaster, intersects);
        }
    }
    if (recursive === true) {
        for (const child of object.children) {
            intersectObject(child, raycaster, intersects, true);
        }
    }
}
/**
 * Raycasting points is not supported as necessary in Three.js. This class extends a
 * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space
 * geometry.
 *
 * @internal
 */
class PickingRaycaster extends THREE.Raycaster {
    /**
     * Constructor.
     *
     * @param canvasSize - the canvas width and height.
     */
    constructor(canvasSize) {
        super();
        this.canvasSize = canvasSize;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of
    // three.js classes.
    intersectObject(object, recursive, optionalTarget) {
        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
        intersectObject(object, this, intersects, recursive);
        return intersects;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of
    // three.js classes.
    intersectObjects(objects, recursive, optionalTarget) {
        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
        for (const object of objects) {
            intersectObject(object, this, intersects, recursive);
        }
        return intersects;
    }
}
exports.PickingRaycaster = PickingRaycaster;


/***/ }),

/***/ "../harp-mapview/lib/PlaneViewBounds.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/PlaneViewBounds.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlaneViewBounds = void 0;
/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
/**
 * Generates Bounds for a camera view and a planar projection.
 *
 * @internal
 */
class PlaneViewBounds {
    constructor(camera, projection, m_options) {
        this.camera = camera;
        this.projection = projection;
        this.m_options = m_options;
        this.m_groundPlaneNormal = new three_1.Vector3(0, 0, 1);
        this.m_groundPlane = new three_1.Plane(this.m_groundPlaneNormal.clone());
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Planar);
    }
    /**
     * @override
     */
    generate() {
        //!!!!!!!ALTITUDE IS NOT TAKEN INTO ACCOUNT!!!!!!!!!
        const coordinates = [];
        // 1.) Raycast into all four corners of the canvas
        //     => if an intersection is found, add it to the polygon
        this.addCanvasCornerIntersection(coordinates);
        // => All 4 corners found an intersection, therefore the screen is covered with the map
        // and the polygon complete
        if (coordinates.length === 4) {
            return this.createPolygon(coordinates);
        }
        //2.) Raycast into the two corners of the horizon cutting the canvas sides
        //    => if an intersection is found, add it to the polygon
        this.addHorizonIntersection(coordinates);
        //Setup the frustum for further checks
        const frustum = new three_1.Frustum().setFromProjectionMatrix(new three_1.Matrix4().multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse));
        // Setup the world corners for further checks.
        // Cast to TileCorners as it cannot be undefined here, due to the forced
        // PlanarProjection above
        const worldCorners = this.getWorldConers(this.projection);
        if (!this.m_options.tileWrappingEnabled) {
            // 3.) If no wrapping, check if any corners of the world plane are inside the view
            //     => if true, add it to the polygon
            [worldCorners.ne, worldCorners.nw, worldCorners.se, worldCorners.sw].forEach(corner => {
                this.addPointInFrustum(corner, frustum, coordinates);
            });
        }
        //4.) Check for any edges of the world plane intersecting with the frustum?
        //    => if true, add to polygon
        if (!this.m_options.tileWrappingEnabled) {
            // if no tile wrapping:
            //       check with limited lines around the world edges
            [
                new three_1.Line3(worldCorners.sw, worldCorners.se),
                new three_1.Line3(worldCorners.ne, worldCorners.nw),
                new three_1.Line3(worldCorners.se, worldCorners.ne),
                new three_1.Line3(worldCorners.nw, worldCorners.sw) //  west edge
            ].forEach(edge => {
                this.addFrustumIntersection(edge, frustum, coordinates);
            });
        }
        else {
            // if tile wrapping:
            //       check for intersections with rays along the south and north edges
            const directionEast = new three_1.Vector3() //west -> east
                .subVectors(worldCorners.sw, worldCorners.se)
                .normalize();
            const directionWest = new three_1.Vector3() //east -> west
                .subVectors(worldCorners.se, worldCorners.sw)
                .normalize();
            [
                new three_1.Ray(worldCorners.se, directionEast),
                new three_1.Ray(worldCorners.se, directionWest),
                new three_1.Ray(worldCorners.ne, directionEast),
                new three_1.Ray(worldCorners.ne, directionWest) //  north west ray
            ].forEach(ray => {
                this.addFrustumIntersection(ray, frustum, coordinates);
            });
        }
        // 5.) Create the Polygon and set needsSort to `true`as we expect it to be convex and
        //     sortable
        return this.createPolygon(coordinates);
    }
    createPolygon(coordinates) {
        if (coordinates.length > 2) {
            return new harp_geoutils_1.GeoPolygon(coordinates, true);
        }
        return undefined;
    }
    getWorldConers(projection) {
        const worldBox = projection.worldExtent(0, 0);
        return {
            sw: worldBox.min,
            se: new three_1.Vector3(worldBox.max.x, worldBox.min.y, 0),
            nw: new three_1.Vector3(worldBox.min.x, worldBox.max.y, 0),
            ne: worldBox.max
        };
    }
    addNDCRayIntersection(ndcPoints, geoPolygon) {
        ndcPoints.forEach(corner => {
            const intersection = Utils_1.MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, corner[0], corner[1]);
            if (intersection) {
                this.validateAndAddToGeoPolygon(intersection, geoPolygon);
            }
        });
    }
    addHorizonIntersection(geoPolygon) {
        const verticalHorizonPosition = this.getVerticalHorizonPositionInNDC();
        if (!verticalHorizonPosition) {
            return;
        }
        this.addNDCRayIntersection([
            [-1, verticalHorizonPosition],
            [1, verticalHorizonPosition] //horizon right
        ], geoPolygon);
    }
    addCanvasCornerIntersection(geoPolygon) {
        this.addNDCRayIntersection([
            [-1, -1],
            [1, -1],
            [1, 1],
            [-1, 1] //upper left
        ], geoPolygon);
    }
    validateAndAddToGeoPolygon(point, geoPolygon) {
        if (this.isInVisibleMap(point)) {
            geoPolygon.push(this.projection.unprojectPoint(point));
        }
    }
    isInVisibleMap(point) {
        if (point.y < 0 || point.y > harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE) {
            return false;
        }
        if (!this.m_options.tileWrappingEnabled &&
            (point.x < 0 || point.x > harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE)) {
            return false;
        }
        return true;
    }
    addPointInFrustum(point, frustum, geoPolygon) {
        if (frustum.containsPoint(point)) {
            const geoPoint = this.projection.unprojectPoint(point);
            geoPoint.altitude = 0;
            geoPolygon.push(geoPoint);
        }
    }
    addFrustumIntersection(edge, frustum, geoPolygon) {
        frustum.planes.forEach(plane => {
            let intersection = null;
            const target = new three_1.Vector3();
            if (edge instanceof three_1.Ray && edge.intersectsPlane(plane)) {
                intersection = edge.intersectPlane(plane, target);
            }
            else if (edge instanceof three_1.Line3 && plane.intersectsLine(edge)) {
                intersection = plane.intersectLine(edge, target);
            }
            if (intersection) {
                //uses this check to fix inaccuracies
                if (Utils_1.MapViewUtils.closeToFrustum(intersection, this.camera)) {
                    const geoIntersection = this.projection.unprojectPoint(intersection);
                    //correct altitude caused by inaccuracies, due to large numbers to 0
                    geoIntersection.altitude = 0;
                    geoPolygon.push(geoIntersection);
                }
            }
        });
    }
    getVerticalHorizonPositionInNDC() {
        const bottomMidFarPoint = new three_1.Vector3(-1, -1, 1)
            .unproject(this.camera)
            .add(new three_1.Vector3(1, -1, 1).unproject(this.camera))
            .multiplyScalar(0.5);
        const topMidFarPoint = new three_1.Vector3(-1, 1, 1)
            .unproject(this.camera)
            .add(new three_1.Vector3(1, 1, 1).unproject(this.camera))
            .multiplyScalar(0.5);
        const farPlaneVerticalCenterLine = new three_1.Line3(bottomMidFarPoint, topMidFarPoint);
        const verticalHorizonPosition = new three_1.Vector3();
        if (!this.m_groundPlane.intersectLine(farPlaneVerticalCenterLine, verticalHorizonPosition)) {
            return undefined;
        }
        return verticalHorizonPosition.project(this.camera).y;
    }
}
exports.PlaneViewBounds = PlaneViewBounds;


/***/ }),

/***/ "../harp-mapview/lib/PolarTileDataSource.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/PolarTileDataSource.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PolarTileDataSource = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const index_decoder_1 = __webpack_require__(/*! @here/harp-datasource-protocol/index-decoder */ "../harp-datasource-protocol/index-decoder.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DataSource_1 = __webpack_require__(/*! ./DataSource */ "../harp-mapview/lib/DataSource.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ./DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ "../harp-mapview/lib/MapObjectAdapter.ts");
const ThemeLoader_1 = __webpack_require__(/*! ./ThemeLoader */ "../harp-mapview/lib/ThemeLoader.ts");
const Tile_1 = __webpack_require__(/*! ./Tile */ "../harp-mapview/lib/Tile.ts");
/**
 * {@link DataSource} providing geometry for poles
 */
class PolarTileDataSource extends DataSource_1.DataSource {
    constructor({ name = "polar", styleSetName = "polar", minDataLevel, maxDataLevel, minDisplayLevel, maxDisplayLevel, storageLevelOffset = -2, geometryLevelOffset = 1, debugTiles = false }) {
        super({
            name,
            styleSetName,
            minDataLevel,
            maxDataLevel,
            minDisplayLevel,
            maxDisplayLevel,
            storageLevelOffset
        });
        this.m_tilingScheme = harp_geoutils_1.polarTilingScheme;
        this.m_maxLatitude = THREE.MathUtils.radToDeg(harp_geoutils_1.MercatorConstants.MAXIMUM_LATITUDE);
        this.m_geometryLevelOffset = geometryLevelOffset;
        this.m_debugTiles = debugTiles;
        this.cacheable = false;
        this.enablePicking = false;
    }
    /** @override */
    dispose() {
        if (this.m_northPoleEntry) {
            this.m_northPoleEntry.material.dispose();
            delete this.m_northPoleEntry;
        }
        if (this.m_southPoleEntry) {
            this.m_southPoleEntry.material.dispose();
            delete this.m_southPoleEntry;
        }
        if (this.m_styleSetEvaluator) {
            delete this.m_styleSetEvaluator;
        }
    }
    createTechiqueEntry(kind) {
        if (!this.m_styleSetEvaluator) {
            return undefined;
        }
        const env = new index_decoder_1.MapEnv({
            $geometryType: "polygon",
            $layer: "earth",
            kind
        });
        const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);
        if (techniques.length === 0) {
            return undefined;
        }
        const technique = techniques[0];
        const material = DecodedTileHelpers_1.createMaterial(this.mapView.renderer.capabilities, {
            technique,
            env: this.mapView.env
        });
        if (!material) {
            return undefined;
        }
        return { material, technique };
    }
    /** @override */
    async setTheme(theme) {
        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.
        theme = await ThemeLoader_1.ThemeLoader.load(theme);
        const styleSet = harp_datasource_protocol_1.getStyles(theme.styles).filter(style => {
            return !style.styleSet || style.styleSet === this.styleSetName;
        });
        if (styleSet.length > 0) {
            this.m_styleSetEvaluator = new index_decoder_1.StyleSetEvaluator({
                styleSet,
                definitions: theme.definitions,
                priorities: theme.priorities,
                labelPriorities: theme.labelPriorities
            });
        }
        this.m_northPoleEntry = this.createTechiqueEntry("north_pole");
        this.m_southPoleEntry = this.createTechiqueEntry("south_pole");
        this.mapView.markTilesDirty(this);
    }
    /** @override */
    canGetTile(zoomLevel, tileKey) {
        if (zoomLevel !== tileKey.level || tileKey.level < 1) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    shouldSubdivide(zoomLevel, tileKey) {
        if (zoomLevel <= tileKey.level) {
            return false;
        }
        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);
        return north > this.m_maxLatitude || south < -this.m_maxLatitude;
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        this.createTileGeometry(tile);
        return tile;
    }
    get geometryLevelOffset() {
        return this.m_geometryLevelOffset;
    }
    set geometryLevelOffset(geometryLevelOffset) {
        this.m_geometryLevelOffset = geometryLevelOffset;
    }
    intersectEdge(latitude, a, b) {
        const latA = a.latitude;
        const latB = b.latitude;
        let lonA = a.longitude;
        let lonB = b.longitude;
        if (Math.abs(latA) === 90) {
            lonA = lonB;
        }
        if (Math.abs(latB) === 90) {
            lonB = lonA;
        }
        const deltaLat = latB - latA;
        const deltaLon = lonB - lonA;
        const scale = (latitude - latA) / deltaLat;
        return new harp_geoutils_1.GeoCoordinates(latitude, lonA + deltaLon * scale, 0);
    }
    createTileGeometry(tile) {
        const { north, south } = tile.geoBox;
        const isNorthPole = north > 0 && south >= 0;
        const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;
        if (techniqueEntry === undefined) {
            tile.forceHasGeometry(true);
            return;
        }
        const srcProjection = this.m_tilingScheme.projection;
        const dstProjection = this.projection;
        const maxLat = this.m_maxLatitude;
        const poleLat = isNorthPole ? maxLat : -maxLat;
        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);
        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));
        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));
        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));
        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));
        let points;
        let needsGeometryCut = false;
        // special case where tile contains half of the hemisphere
        if (tile.tileKey.level === 1) {
            const isLeftHalf = box.min.x === 0;
            const poleX = isLeftHalf ? box.max.x : box.min.x;
            const poleY = (box.max.y + box.min.y) / 2;
            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));
            // coordinates are not used, needed for right position
            const pXX = isLeftHalf ? pBL : pBR;
            points = isNorthPole
                ? isLeftHalf
                    ? [pPole, pTR, pXX, pBR]
                    : [pPole, pBL, pXX, pTL]
                : isLeftHalf
                    ? [pPole, pBR, pXX, pTR]
                    : [pPole, pTL, pXX, pBL];
            needsGeometryCut = true;
        }
        else {
            // ccw for north, cw for south
            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];
            const lats = points.map(p => p.latitude);
            const lmax = Math.max(...lats);
            const lmin = Math.min(...lats);
            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;
            if (isAllPointsOut) {
                return;
            }
            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;
            needsGeometryCut = isSomePointsOut;
            if (needsGeometryCut) {
                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);
                if (nearest !== 0) {
                    for (let i = 0; i < nearest; i++) {
                        points.push(points.shift());
                    }
                }
            }
        }
        if (needsGeometryCut) {
            const centerX = (box.min.x + box.max.x) / 2;
            const centerY = (box.min.y + box.max.y) / 2;
            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));
            harp_geoutils_1.TransverseMercatorUtils.alignLongitude(points, center);
            // points aligned as follows:
            // a - nearest to the pole, always in
            // b - next to nearest
            // c - farthes from the pole, always out
            // d - prev from nearest
            const a = points[0];
            const b = points[1];
            const c = points[2];
            const d = points[3];
            const inPointB = Math.abs(b.latitude) >= maxLat;
            const inPointD = Math.abs(d.latitude) >= maxLat;
            const cutStart = inPointB
                ? this.intersectEdge(poleLat, b, c)
                : this.intersectEdge(poleLat, a, b);
            const cutEnd = inPointD
                ? this.intersectEdge(poleLat, d, c)
                : this.intersectEdge(poleLat, a, d);
            points.splice(inPointB ? 2 : 1, 4, cutStart);
            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;
            const subdivisions = 1 << Math.max(0, level);
            const step = 360 / subdivisions;
            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);
            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);
            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {
                points.push(new harp_geoutils_1.GeoCoordinates(poleLat, i * step - 180, 0));
            }
            points.push(cutEnd);
            if (inPointD) {
                points.push(d);
            }
        }
        const geometry = new THREE.BufferGeometry();
        const vertices = points.map(point => {
            const projected = dstProjection.projectPoint(point, new THREE.Vector3());
            projected.sub(tile.center);
            return projected;
        });
        geometry.setFromPoints(vertices);
        const indices = [];
        for (let i = 1; i < vertices.length - 1; i++) {
            isNorthPole ? indices.push(0, i, i + 1) : indices.push(0, i + 1, i);
        }
        geometry.setIndex(indices);
        const mesh = new THREE.Mesh(geometry, techniqueEntry.material);
        mesh.userData = {
            dataSource: this.name,
            tileKey: tile.tileKey
        };
        if (this.m_debugTiles) {
            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);
            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });
            tile.objects.push(new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true })));
        }
        MapObjectAdapter_1.MapObjectAdapter.create(mesh, {
            dataSource: this,
            technique: techniqueEntry.technique,
            kind: [isNorthPole ? harp_datasource_protocol_1.StandardGeometryKind.Water : harp_datasource_protocol_1.StandardGeometryKind.Background]
        });
        tile.objects.push(mesh);
    }
}
exports.PolarTileDataSource = PolarTileDataSource;


/***/ }),

/***/ "../harp-mapview/lib/ScreenCollisions.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/ScreenCollisions.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenCollisionsDebug = exports.ScreenCollisions = exports.isLineWithBound = exports.DetailedCollisionBox = exports.CollisionBox = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DebugContext_1 = __webpack_require__(/*! ./DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const RBush = __webpack_require__(/*! rbush */ "../harp-mapview/node_modules/rbush/rbush.min.js");
const logger = harp_utils_1.LoggerManager.instance.create("ScreenCollissions");
class CollisionBox extends harp_utils_1.Math2D.Box {
    constructor(box) {
        super();
        if (box !== undefined) {
            this.copy(box);
        }
    }
    copy(box) {
        if (box instanceof harp_utils_1.Math2D.Box) {
            this.set(box.x, box.y, box.w, box.h);
        }
        else if (box instanceof THREE.Box2) {
            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);
        }
        else {
            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);
        }
        return this;
    }
    get minX() {
        return this.x;
    }
    set minX(minX) {
        this.x = minX;
    }
    get maxX() {
        return this.x + this.w;
    }
    set maxX(maxX) {
        this.w = maxX - this.x;
    }
    get minY() {
        return this.y;
    }
    set minY(minY) {
        this.y = minY;
    }
    get maxY() {
        return this.y + this.h;
    }
    set maxY(maxY) {
        this.h = maxY - this.y;
    }
}
exports.CollisionBox = CollisionBox;
/**
 * Collision box with additional boxes defining tighter bounds for the enclosed feature
 * (e.g.glyph bounds for text).
 */
class DetailedCollisionBox extends CollisionBox {
    constructor(box, detailBoxes) {
        super(box);
        this.detailBoxes = detailBoxes;
    }
}
exports.DetailedCollisionBox = DetailedCollisionBox;
function isLineWithBound(box) {
    return box.line !== undefined;
}
exports.isLineWithBound = isLineWithBound;
const tmpCollisionBox = new CollisionBox();
class ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object.
     */
    constructor() {
        /** The screen bounding box. */
        this.screenBounds = new harp_utils_1.Math2D.Box();
        /** Tree of allocated bounds. */
        this.rtree = new RBush();
        //
    }
    /**
     * Resets the list of allocated screen bounds.
     */
    reset() {
        this.rtree.clear();
    }
    /**
     * Updates the screen bounds that are used to check if bounding boxes are visible.
     *
     * @param width - The width of the container.
     * @param height - The height of the container.
     */
    update(width, height) {
        this.screenBounds.set(width / -2, height / -2, width, height);
        this.reset();
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds - The bounding box in NDC scaled coordinates (i.e. top left is -width/2,
     * -height/2)
     */
    allocate(bounds) {
        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;
        this.rtree.insert(bbox);
    }
    /**
     * Inserts the given bounds into the rtree.
     *
     * @param bounds - The bounding boxes (the bounding boxes must be in the space returned from the
     * ScreenProjector.project method).
     */
    allocateIBoxes(bounds) {
        this.rtree.load(bounds);
    }
    /**
     * Search for all bounds in the tree intersecting with the given box.
     * @param box - The box used for the search.
     * @returns An array of all IBoxes intersecting with the given box.
     */
    search(box) {
        return this.rtree.search(box);
    }
    /**
     * Checks if the given bounding box is already allocated.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isAllocated(bounds) {
        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);
        const results = this.search(collisionBox);
        return this.intersectsDetails(collisionBox, results);
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isVisible(bounds) {
        return this.screenBounds.intersects(bounds);
    }
    /**
     * Checks if the given screen bounds is contained within the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     */
    isFullyVisible(bounds) {
        return this.screenBounds.containsBox(bounds);
    }
    /**
     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified
     * [[IBox]]es.
     *
     * @param testBox - The box to test for intersection.
     * @param boxes - The candidate boxes the test box may intersect with. It's assumed that the
     * global bounds of these boxes intersect with the given test box.
     * @returns `true` if any intersection found.
     */
    intersectsDetails(testBox, boxes) {
        for (const box of boxes) {
            if (box instanceof DetailedCollisionBox) {
                for (const detailBox of box.detailBoxes) {
                    if (detailBox.intersects(testBox)) {
                        return true;
                    }
                }
            }
            else if (isLineWithBound(box)) {
                const boundedLine = box;
                if (this.intersectsLine(testBox, boundedLine)) {
                    return true;
                }
            }
            else {
                return true;
            }
        }
        return false;
    }
    /**
     * Computes the intersection between the supplied CollisionBox and the LineWithBound.
     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be
     * in Screen Coordinate space
     */
    intersectsLine(bbox, boundedLine) {
        const line = boundedLine.line;
        // Note, these aren't normalized, but it doesn't matter, we are just interested
        // in the sign.
        const lineXDiffTransformed = line.end.x - line.start.x;
        // Sign of bottom left, bottom right, top left and top right corners.
        let signBL;
        let signBR;
        let signTL;
        let signTR;
        if (lineXDiffTransformed !== 0) {
            const lineYDiffTransformed = line.end.y - line.start.y;
            const normalX = lineYDiffTransformed;
            const normalY = -lineXDiffTransformed;
            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;
            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);
            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);
            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);
            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);
        }
        else {
            signBL = Math.sign(bbox.minX - line.start.x);
            signBR = Math.sign(bbox.maxX - line.start.x);
            signTL = Math.sign(bbox.minX - line.start.x);
            signTR = Math.sign(bbox.maxX - line.start.x);
        }
        return signBL !== signBR || signBL !== signTL || signBL !== signTR;
    }
}
exports.ScreenCollisions = ScreenCollisions;
/**
 * @hidden
 *
 * Shows requests for screen space during labelling in an HTML canvas, which should be sized like
 * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests
 * for screen space were done.
 *
 * Also logs statistics.
 */
class ScreenCollisionsDebug extends ScreenCollisions {
    /**
     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.
     */
    constructor(debugCanvas) {
        super();
        /** 2D rendering context. */
        this.m_renderContext = null;
        this.m_renderingEnabled = false;
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
        if (debugCanvas !== undefined && debugCanvas !== null) {
            this.m_renderContext = debugCanvas.getContext("2d");
        }
    }
    /**
     * Resets the list of allocated bounds and clears the debug canvas.
     * @override
     */
    reset() {
        super.reset();
        this.m_numAllocations = 0;
        this.m_numSuccessfulTests = 0;
        this.m_numFailedTests = 0;
        this.m_numSuccessfulVisibilityTests = 0;
        this.m_numFailedVisibilityTests = 0;
    }
    /**
     * Updates the screen bounds used to check if bounding boxes are visible.
     *
     * @param width - The width of the container.
     * @param height - The height of the container.
     * @override
     */
    update(width, height) {
        if (this.m_renderingEnabled) {
            logger.log(`Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `);
        }
        super.update(width, height);
        if (this.m_renderContext !== null) {
            this.m_renderContext.canvas.width = width;
            this.m_renderContext.canvas.height = height;
        }
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_SCREEN_COLLISIONS", true)
        this.m_renderingEnabled = DebugContext_1.debugContext.getValue("DEBUG_SCREEN_COLLISIONS");
    }
    /**
     * Marks the region of the screen intersecting with the given bounding box as allocated.
     *
     * @param bounds - the bounding box in world coordinates.
     * @override
     */
    allocate(bounds) {
        super.allocate(bounds);
        this.m_numAllocations++;
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            this.m_renderContext.strokeStyle = "#6666ff";
            this.m_renderContext.strokeRect(bounds.x - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.y, bounds.w, -bounds.h);
        }
    }
    /** @override */
    allocateIBoxes(boundsArray) {
        for (const bounds of boundsArray) {
            this.m_numAllocations++;
            if (this.m_renderingEnabled && this.m_renderContext !== null) {
                this.m_renderContext.strokeStyle = "#aa2222";
                this.m_renderContext.strokeRect(bounds.minX - this.screenBounds.x, this.screenBounds.y + this.screenBounds.h - bounds.minY, bounds.maxX - bounds.minX, -(bounds.maxY - bounds.minY));
            }
        }
        super.allocateIBoxes(boundsArray);
    }
    /** @override */
    intersectsDetails(testBox, boxes) {
        const collisionFound = super.intersectsDetails(testBox, boxes);
        if (this.m_renderingEnabled && this.m_renderContext !== null) {
            const padding = collisionFound ? 2 : 1;
            this.m_renderContext.strokeStyle = collisionFound ? "#FF0000" : "#00ff00";
            this.m_renderContext.strokeRect(testBox.x - this.screenBounds.x - padding, this.screenBounds.y + this.screenBounds.h - testBox.y + padding, testBox.w + 2 * padding, -testBox.h - 2 * padding);
        }
        if (collisionFound) {
            this.m_numFailedTests++;
        }
        else {
            this.m_numSuccessfulTests++;
        }
        return collisionFound;
    }
    /**
     * Checks if the given screen bounds intersects with the frustum of the active camera.
     *
     * @param bounds - The bounding box in world coordinates.
     * @override
     */
    isVisible(bounds) {
        const visible = super.isVisible(bounds);
        if (visible) {
            this.m_numSuccessfulVisibilityTests++;
        }
        else {
            this.m_numFailedVisibilityTests++;
        }
        return visible;
    }
}
exports.ScreenCollisionsDebug = ScreenCollisionsDebug;


/***/ }),

/***/ "../harp-mapview/lib/ScreenProjector.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/ScreenProjector.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenProjector = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.
 * @param ndc - The position to check.
 */
function isOnScreen(ndc) {
    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is between the near
 * and far plane.
 * @param ndc - The position to check.
 */
function isInRange(ndc) {
    return ndc.z > -1 && ndc.z < 1;
}
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
class ScreenProjector {
    /**
     * Constructs a new `ScreenProjector`.
     *
     * @param m_camera - Camera to project against.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_width = 0;
        this.m_height = 0;
    }
    /**
     * Height of the screen.
     */
    get width() {
        return this.m_width;
    }
    /**
     * Width of the screen.
     */
    get height() {
        return this.m_height;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target')
     */
    project(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        return this.ndcToScreen(p, target);
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
     * outside of the near/far plane. The point may be outside the screen.
     */
    projectToScreen(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (isInRange(p)) {
            return this.ndcToScreen(p, target);
        }
        return undefined;
    }
    /**
     * Test if the area around the specified point is visible on the screen.
     *
     * @param {(Vector3Like)} source The centered source vector to project.
     * @param {(Number)} halfWidth Half of the width of the area in screen space [0..1].
     * @param {(Number)} halfHeight Half of the height of the area in screen space [0..1].
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
     * the area is completely outside the screen.
     */
    projectAreaToScreen(source, halfWidth, halfHeight, target = new THREE.Vector2()) {
        halfWidth *= 2;
        halfHeight *= 2;
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (isInRange(p) &&
            p.x + halfWidth >= -1 &&
            p.x - halfWidth <= 1 &&
            p.y + halfHeight >= -1 &&
            p.y - halfHeight <= 1) {
            return this.ndcToScreen(p, target);
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates. The z component between -1 and 1 is also returned.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if
     * outside the near / far plane.
     */
    project3(source, target = new THREE.Vector3()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);
            return target;
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector. Stores
     * result in NDC in the target vector.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    projectVector(source, target) {
        target.set(source.x, source.y, source.z).project(this.m_camera);
        return target;
    }
    /**
     * Fast test to check if projected point is on screen.
     *
     * @returns {boolean} `true` if point is on screen, `false` otherwise.
     */
    onScreen(source) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        return isOnScreen(p);
    }
    /**
     * Update the `ScreenProjector` with the latest values of the screen and the camera.
     *
     * @param {THREE.Camera} camera Camera to project against.
     * @param {number} width Width of screen/canvas.
     * @param {number} height Height of screen/canvas.
     */
    update(camera, width, height) {
        this.m_camera = camera;
        this.m_width = width;
        this.m_height = height;
    }
    ndcToScreen(ndc, screenCoords) {
        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);
    }
}
exports.ScreenProjector = ScreenProjector;
ScreenProjector.tempV2 = new THREE.Vector2();
ScreenProjector.tempV3 = new THREE.Vector3();


/***/ }),

/***/ "../harp-mapview/lib/SkyBackground.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/SkyBackground.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkyBackground = void 0;
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
const SkyGradientTexture_1 = __webpack_require__(/*! ./SkyGradientTexture */ "../harp-mapview/lib/SkyGradientTexture.ts");
/**
 * Class that handles {@link MapView}'s sky background.
 */
class SkyBackground {
    /**
     * Constructs a new `SkyBackground`.
     *
     * @param m_sky - Sky configuration parameters.
     * @param m_projectionType - {@link MapView}'s projection type.
     * @param camera - {@link MapView}'s camera.
     */
    constructor(m_sky, m_projectionType, camera) {
        this.m_sky = m_sky;
        this.m_projectionType = m_projectionType;
        switch (this.m_sky.type) {
            case "gradient":
                this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(this.m_sky, this.m_projectionType);
                this.updateCamera(camera);
                break;
            case "cubemap": {
                this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(this.m_sky);
                break;
            }
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skyTexture.dispose();
    }
    /**
     * Sky texture.
     */
    get texture() {
        return this.m_skyTexture.texture;
    }
    /**
     * This method updates the skybox based on the camera position (needed for some types of sky).
     *
     * @param camera - The camera used in the map view.
     */
    updateCamera(camera) {
        if (this.m_sky.type === "gradient") {
            this.m_skyTexture.update(camera);
        }
    }
    /**
     * Updates the sky texture with new parameters.
     *
     * @param params - New sky configuration parameters.
     * @param projectionType - Which projection is used, this may also change (in which case the
     * textures should be recreated).
     */
    updateTexture(params, projectionType) {
        const isSameSkyType = this.m_sky.type === params.type && this.m_projectionType === projectionType;
        switch (params.type) {
            case "gradient":
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyGradientTexture_1.SkyGradientTexture(params, projectionType);
                }
                break;
            case "cubemap": {
                if (isSameSkyType) {
                    this.m_skyTexture.updateTexture(params);
                }
                else {
                    this.m_skyTexture = new SkyCubemapTexture_1.SkyCubemapTexture(params);
                }
                break;
            }
        }
        this.m_projectionType = projectionType;
        this.m_sky = params;
    }
}
exports.SkyBackground = SkyBackground;


/***/ }),

/***/ "../harp-mapview/lib/SkyCubemapTexture.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/SkyCubemapTexture.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkyCubemapTexture = exports.SkyCubemapFaceId = exports.SKY_CUBEMAP_FACE_COUNT = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const logger = harp_utils_1.LoggerManager.instance.create("SkyCubemapTexture");
/**
 * Number of faces that form a [[SkyCubemapTexture]].
 */
exports.SKY_CUBEMAP_FACE_COUNT = 6;
/**
 * Maps the faceId to the expected position in the threejs faces array.
 */
var SkyCubemapFaceId;
(function (SkyCubemapFaceId) {
    SkyCubemapFaceId[SkyCubemapFaceId["positiveX"] = 0] = "positiveX";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeX"] = 1] = "negativeX";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveY"] = 2] = "positiveY";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeY"] = 3] = "negativeY";
    SkyCubemapFaceId[SkyCubemapFaceId["positiveZ"] = 4] = "positiveZ";
    SkyCubemapFaceId[SkyCubemapFaceId["negativeZ"] = 5] = "negativeZ";
})(SkyCubemapFaceId = exports.SkyCubemapFaceId || (exports.SkyCubemapFaceId = {}));
/**
 * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].
 */
class SkyCubemapTexture {
    /**
     * Constructs a new `SkyCubemapTexture`.
     *
     * @param sky - Initial [[CubemapSky]] configuration.
     */
    constructor(sky) {
        const faces = this.createCubemapFaceArray(sky);
        this.m_skybox =
            faces !== undefined ? new three_1.CubeTextureLoader().load(faces) : new three_1.CubeTexture();
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        this.m_skybox.dispose();
    }
    /**
     * `SkyCubemapTexture`'s texture resource.
     */
    get texture() {
        return this.m_skybox;
    }
    /**
     * Updates the `SkyCubemapTexture` with new parameters.
     *
     * @param params - New [[CubemapSky]] configuration.
     */
    updateTexture(sky) {
        const faces = this.createCubemapFaceArray(sky);
        if (faces === undefined) {
            return;
        }
        this.m_skybox = new three_1.CubeTextureLoader().load(faces);
    }
    createCubemapFaceArray(sky) {
        const faces = [
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined
        ];
        for (let i = 0; i < exports.SKY_CUBEMAP_FACE_COUNT; ++i) {
            const face = sky[SkyCubemapFaceId[i]];
            if (face === undefined) {
                logger.error(`Face "${SkyCubemapFaceId[i]}" was not defined.`);
                return;
            }
            faces[i] = face;
        }
        return faces;
    }
}
exports.SkyCubemapTexture = SkyCubemapTexture;


/***/ }),

/***/ "../harp-mapview/lib/SkyGradientTexture.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/SkyGradientTexture.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkyGradientTexture = exports.DEFAULT_MONOMIAL_POWER = exports.DEFAULT_TEXTURE_SIZE = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
exports.DEFAULT_TEXTURE_SIZE = 512;
exports.DEFAULT_MONOMIAL_POWER = 1;
// Vectors used for skybox bitmap computation.
const cameraDir = [
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0),
    new three_1.Vector3(0, -1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1)
];
const cameraRight = [
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(1, 0, 0),
    new three_1.Vector3(-1, 0, 0)
];
const cameraUp = [
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 0, 1),
    new three_1.Vector3(0, 0, -1),
    new three_1.Vector3(0, 1, 0),
    new three_1.Vector3(0, 1, 0)
];
/**
 * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].
 *
 * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,
 * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom
 *  hemisphere..
 */
class SkyGradientTexture {
    /**
     * Constructs a new `SkyGradientTexture`.
     *
     * @param sky - Initial [[GradientSky]] configuration.
     * @param m_projectionType - {@link MapView}'s projection type.
     * @param m_height - Optional height parameter.
     */
    constructor(sky, m_projectionType, m_height = exports.DEFAULT_TEXTURE_SIZE) {
        this.m_projectionType = m_projectionType;
        this.m_height = m_height;
        const topColor = new three_1.Color(sky.topColor);
        const bottomColor = new three_1.Color(sky.bottomColor);
        const groundColor = new three_1.Color(sky.groundColor);
        this.m_width = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : this.m_height;
        this.m_faceCount = this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? 1.0 : 6.0;
        this.m_faces = [];
        for (let i = 0; i < this.m_faceCount; ++i) {
            const data = new Uint8Array(3 * this.m_width * this.m_height);
            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);
            const texture = new three_1.DataTexture(data, this.m_width, this.m_height, three_1.RGBFormat);
            texture.needsUpdate = true;
            texture.unpackAlignment = 1;
            this.m_faces.push(texture);
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox = new three_1.CubeTexture(this.m_faces);
            this.m_skybox.needsUpdate = true;
        }
        else {
            this.m_farClipPlaneDividedVertically = new three_1.Line3();
            this.m_groundPlane = new three_1.Plane(new three_1.Vector3(0, 0, 1));
            this.m_bottomMidFarPoint = new three_1.Vector3();
            this.m_topMidFarPoint = new three_1.Vector3();
            this.m_horizonPosition = new three_1.Vector3();
            this.m_farClipPlaneCorners = [
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3(),
                new three_1.Vector3()
            ];
        }
    }
    /**
     * Disposes allocated resources.
     */
    dispose() {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.m_faces[i].dispose();
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.dispose();
        }
    }
    /**
     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on
     * {@link MapView}'s projection).
     */
    get texture() {
        return this.m_projectionType === harp_geoutils_1.ProjectionType.Planar ? this.m_faces[0] : this.m_skybox;
    }
    /**
     * This method updates the position of the texture depending on the camera frustum.
     *
     * @param camera - The camera used in the map view.
     */
    update(camera) {
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Planar) {
            this.setHorizonPosition(camera);
            this.updateTexturePosition();
        }
    }
    /**
     * Updates the `SkyGradientTexture` with new parameters.
     *
     * @param params - New [[GradientSky]] configuration.
     */
    updateTexture(sky) {
        for (let i = 0; i < this.m_faceCount; ++i) {
            this.fillTextureData(this.m_faces[i].image.data, i, new three_1.Color(sky.topColor), new three_1.Color(sky.bottomColor), new three_1.Color(sky.groundColor), sky.monomialPower);
            this.m_faces[i].needsUpdate = true;
        }
        if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
            this.m_skybox.needsUpdate = true;
        }
    }
    // When creating the texture, a Uint8Array is required, because the resulting texture passed
    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because
    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.
    fillTextureData(data, faceIdx, topColor, bottomColor, groundColor, monomialPower) {
        const color = new three_1.Color();
        const dir = new three_1.Vector3();
        const right = new three_1.Vector3();
        const up = new three_1.Vector3();
        const upDir = new three_1.Vector3(0, 0, 1);
        for (let i = 0; i < this.m_height; ++i) {
            for (let j = 0; j < this.m_width; ++j) {
                if (this.m_projectionType === harp_geoutils_1.ProjectionType.Spherical) {
                    const offsetX = right
                        .copy(cameraRight[faceIdx])
                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);
                    const offsetY = up
                        .copy(cameraUp[faceIdx])
                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);
                    dir.copy(cameraDir[faceIdx]).add(offsetX).add(offsetY).normalize();
                    const t = Math.max(upDir.dot(dir), 0);
                    color
                        .copy(groundColor)
                        .lerp(bottomColor, Math.min(t * 100, 1))
                        .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                        .multiplyScalar(255);
                }
                else {
                    const t = i / this.m_height;
                    if (i === 0) {
                        color.copy(groundColor).multiplyScalar(255);
                    }
                    else {
                        color
                            .copy(bottomColor)
                            .lerp(topColor, t ** harp_utils_1.getOptionValue(monomialPower, exports.DEFAULT_MONOMIAL_POWER))
                            .multiplyScalar(255);
                    }
                }
                data[i * this.m_width * 3 + j * 3] = color.r;
                data[i * this.m_width * 3 + j * 3 + 1] = color.g;
                data[i * this.m_width * 3 + j * 3 + 2] = color.b;
            }
        }
    }
    setHorizonPosition(camera) {
        this.m_farClipPlaneCorners[0].set(-1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[1].set(1, -1, 1).unproject(camera);
        this.m_farClipPlaneCorners[2].set(-1, 1, 1).unproject(camera);
        this.m_farClipPlaneCorners[3].set(1, 1, 1).unproject(camera);
        this.m_bottomMidFarPoint.copy(this.m_farClipPlaneCorners[0])
            .add(this.m_farClipPlaneCorners[1])
            .multiplyScalar(0.5);
        this.m_topMidFarPoint.copy(this.m_farClipPlaneCorners[2])
            .add(this.m_farClipPlaneCorners[3])
            .multiplyScalar(0.5);
        this.m_farClipPlaneDividedVertically.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);
        const hasIntersection = this.m_groundPlane.intersectLine(this.m_farClipPlaneDividedVertically, this.m_horizonPosition);
        // When there is no intersection between the ground plane and the
        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous
        // intersection point stored in the m_horizonPosition will be considered the valid one.
        if (!hasIntersection) {
            this.m_horizonPosition.set(0.0, 0.0, 0.0);
        }
    }
    updateTexturePosition() {
        const coveredBySky = this.m_bottomMidFarPoint.distanceTo(this.m_horizonPosition);
        const frustumHeight = this.m_farClipPlaneDividedVertically.distance();
        const skyRatio = coveredBySky / frustumHeight;
        // If there is no intersection between the ground plane and the line that defines the far
        // clip plane divided vertically, it means that there is no sky visible and therefore the
        // ground color should be displayed. When there is no intersection, the length of the
        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with
        // all the three components to zero.
        // If there is an intersection, calculate the offset.
        const ratio = this.m_horizonPosition.length() === 0 ? 1 : skyRatio - 2 / this.m_height;
        // If the bottom part of the far clipping plane is under the ground plane, scroll the
        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture
        // up.
        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint.z <= 0 ? -ratio : skyRatio);
    }
}
exports.SkyGradientTexture = SkyGradientTexture;


/***/ }),

/***/ "../harp-mapview/lib/SphereHorizon.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/SphereHorizon.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SphereHorizon = exports.previousCanvasSide = exports.nextCanvasSide = exports.CanvasSide = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const CameraUtils_1 = __webpack_require__(/*! ./CameraUtils */ "../harp-mapview/lib/CameraUtils.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
const twoPi = Math.PI * 2;
// Keep counter clockwise order.
var CanvasSide;
(function (CanvasSide) {
    CanvasSide[CanvasSide["Bottom"] = 0] = "Bottom";
    CanvasSide[CanvasSide["Right"] = 1] = "Right";
    CanvasSide[CanvasSide["Top"] = 2] = "Top";
    CanvasSide[CanvasSide["Left"] = 3] = "Left";
})(CanvasSide = exports.CanvasSide || (exports.CanvasSide = {}));
function nextCanvasSide(side) {
    return (side + 1) % 4;
}
exports.nextCanvasSide = nextCanvasSide;
function previousCanvasSide(side) {
    return (side + 3) % 4;
}
exports.previousCanvasSide = previousCanvasSide;
/**
 * Class computing horizon tangent points and intersections with canvas for spherical projection.
 *
 * @remarks
 *
 * The horizon for a sphere is a circle formed by all intersections of tangent lines passing through
 * the camera with said sphere. It lies on a plane perpendicular to the sphere normal at the camera
 * and it's center is at the line segment joining the sphere center and the camera.
 *
 * The further the camera is, the nearer the horizon center gets to the sphere center, only reaching
 * the sphere center when the camera is at infinity. In other words, the horizon observed from a
 * finite distance is always smaller than a great circle (a circle with the sphere radius, dividing
 * the sphere in two hemispheres, and therefore it's radius is smaller than the sphere's.
 *
 * @internal
 */
class SphereHorizon {
    /**
     * Constructs the SphereHorizon for the given camera.
     *
     * @param m_camera - The camera used as a reference to compute the horizon.
     * @param m_cornerIntersects - Array with a boolean for each canvas corner telling whether it
     * intersects with the world. Corners are in ccw-order starting with bottom left.
     */
    constructor(m_camera, m_cornerIntersects) {
        //
        //          TL :,,,,,,,,,,,,,,,,,,,,,,,,,,,,! TR canvas corner (proj. on horizon plane)
        //             >                            +
        //             >                            +
        //             ::                           +
        //              +                           >
        //              >         `::::::'         !"
        //              >     `:::"      ':::,     +
        //              +   :!,              .!!`  +
        //              ,,:;`                   :+`>
        //              >T                        T# <-- Sphere radius to tangent angle (90 deg).
        //             !!>                       `+!(`
        //            =' +                      `.+  {:
        //           /.  +                     `` >   |:`
        //          /`   ::                   .`  >    |:.
        //         /`     >         camZ     '`  `+     /`'`
        //        ;,      +           *,`   '    !,      ( `'
        //       ,^       +              `.~     +       ./  .`
        //       )        +               ' ```  >        !~  `.
        //      *`        '~             '    ``.>         (    .` tangentDistance
        //     `\          +           `'        ?``       '?    `'
        //     /`          +          `.        :.  ```     )      `.
        //    `\           >         `.         >     ```   .=       .`
        //    |`           +        ``          +        ``` (        `.
        //    /            "!      .`           +           `?!         '`
        //   ,+             !,,,,,!:,,,,,,,,,,,,,             {.`        `.
        //   /`            BL    '               BR           )  ```       .`
        //   /                  '                             >`    ``      `'
        //   /                 '                              `*      ```     .`
        //  ,:                ' Sphere radius                  )     camZ```   `.
        //  ?`              `.                                 )           ```   `.
        //  /              `.                                  )              `.`  '`    camY
        //  /             ``              horizon radius       /                 ````.   ^
        //  /            .`          |<----------------------->/                   ``.'` '
        //  /           .`           |                         /`                     `','  camX
        //  /          O`````````````C`````````````````````````(,````````````````````````E-----*
        //             |             |                distanceToHorizonCenter            |
        //             |             |<------------------------------------------------->|
        //             |                                                                 |
        //             |<--------------------------------------------------------------->|
        //                                      cameraHeight
        // O -> Sphere center
        // C -> Horizon center
        // E -> Camera (eye)
        // T -> Tangent points (also intersections with projected canvas)
        this.m_camera = m_camera;
        this.m_cornerIntersects = m_cornerIntersects;
        this.m_intersections = [];
        this.m_isFullyVisible = true;
        const earthRadiusSq = harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS * harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS;
        const xAxis = new THREE.Vector3().setFromMatrixColumn(m_camera.matrixWorld, 0).normalize();
        const zAxis = m_camera.position.clone().normalize();
        const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis);
        const cameraHeight = m_camera.position.length();
        this.m_normalToTangentAngle = Math.asin(harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS / cameraHeight);
        const tangentDistance = Math.sqrt(cameraHeight * cameraHeight - earthRadiusSq);
        this.m_distanceToHorizonCenter = tangentDistance * Math.cos(this.m_normalToTangentAngle);
        const horizonCenterLength = cameraHeight - this.m_distanceToHorizonCenter;
        this.m_radius = Math.sqrt(earthRadiusSq - horizonCenterLength * horizonCenterLength);
        this.m_cameraPitch = Utils_1.MapViewUtils.extractAttitude({ projection: harp_geoutils_1.sphereProjection }, this.m_camera).pitch;
        const horizonCenter = new THREE.Vector3().copy(zAxis).setLength(horizonCenterLength);
        this.m_matrix = new THREE.Matrix4()
            .makeBasis(xAxis, yAxis, zAxis)
            .setPosition(horizonCenter);
        this.computeIntersections();
    }
    /**
     * Gets the world coordinates of a point in the horizon corresponding to the given parameter.
     *
     * @param t - Parameter value in [0,1] corresponding to the point in the horizon circle at
     * angle t*(arcEnd - arcStart)*2*pi counter clockwise.
     * @param arcStart - Start of the arc covered by parameter t, corresponds to angle
     * arcStart*2*pi.
     * @param arcEnd - End of the arc covered by parameter t, corresponds to angle arcEnd*2*pi.
     * @param target - Optional target where resulting world coordinates will be set.
     * @returns the resulting point in world space.
     */
    getPoint(t, arcStart = 0, arcEnd = 1, target = new THREE.Vector3()) {
        const startAngle = arcStart * twoPi;
        const endAngle = arcEnd >= arcStart ? arcEnd * twoPi : (arcEnd + 1) * twoPi;
        const deltaAngle = endAngle - startAngle;
        const angle = startAngle + t * deltaAngle;
        target.set(this.m_radius * Math.cos(angle), this.m_radius * Math.sin(angle), 0);
        target.applyMatrix4(this.m_matrix);
        return target;
    }
    /**
     * Subdivides and arc of the horizon circle, providing the world coordinates of the divisions.
     *
     * @param callback - Function called for every division point, getting the point world
     * coordinates as parameter.
     * @param tStart - Angular parameter of the arc's start point [0,1].
     * @param tEnd - Angular parameter of the arc's end point [0,1].
     * @param maxNumPoints - Number of division points for the whole horizon. Smaller arcs will
     * be assigned a proportionally smaller number of points.
     */
    getDivisionPoints(callback, tStart = 0, tEnd = 1, maxNumPoints = 10) {
        const numPoints = Math.max(Math.ceil(((tEnd < tStart ? 1 + tEnd : tEnd) - tStart) * maxNumPoints), 1);
        // Point corresponding to tEnd is omitted, hence the strict less condition in the loop.
        for (let d = 0; d < numPoints; d++) {
            callback(this.getPoint(d / numPoints, tStart, tEnd));
        }
    }
    /**
     * Indicates whether the horizon circle is fully visible.
     * @returns 'True' if horizon is fully visible, false otherwise.
     */
    get isFullyVisible() {
        return this.m_isFullyVisible;
    }
    /**
     * Gets the horizon intersections with the specified canvas side, specified in angular
     * parameters [0,1].
     * @returns the intersections with the canvas.
     */
    getSideIntersections(side) {
        return this.m_intersections[side];
    }
    isTangentVisible(side) {
        switch (side) {
            case CanvasSide.Top: {
                const eyeToTangentAngle = this.m_normalToTangentAngle - this.m_cameraPitch;
                return CameraUtils_1.CameraUtils.getTopFov(this.m_camera) >= Math.abs(eyeToTangentAngle);
            }
            case CanvasSide.Bottom: {
                const eyeToTangentAngle = this.m_normalToTangentAngle + this.m_cameraPitch;
                return CameraUtils_1.CameraUtils.getBottomFov(this.m_camera) >= Math.abs(eyeToTangentAngle);
            }
            case CanvasSide.Left: {
                const eyeToTangentAngle = this.m_normalToTangentAngle;
                return (CameraUtils_1.CameraUtils.getLeftFov(this.m_camera) >= Math.abs(eyeToTangentAngle) &&
                    this.m_cameraPitch <= CameraUtils_1.CameraUtils.getBottomFov(this.m_camera));
            }
            case CanvasSide.Right: {
                const eyeToTangentAngle = this.m_normalToTangentAngle;
                return (CameraUtils_1.CameraUtils.getRightFov(this.m_camera) >= Math.abs(eyeToTangentAngle) &&
                    this.m_cameraPitch <= CameraUtils_1.CameraUtils.getBottomFov(this.m_camera));
            }
        }
    }
    getTangentOnSide(side) {
        switch (side) {
            case CanvasSide.Bottom:
                return 0.75;
            case CanvasSide.Right:
                return 0;
            case CanvasSide.Top:
                return 0.25;
            case CanvasSide.Left:
                return 0.5;
        }
    }
    computeIntersections() {
        // Look for the intersections of the canvas sides projected in the horizon plane with the
        // horizon circle.
        // Top and bottom canvas sides are horizontal lines at plane coordinates yTop and yBottom
        // respectively. Left and right sides are lines whose slope depends on the camera pitch.
        //
        // Front View (horizon plane):
        //
        //                        Top
        //        TL '{~~~~~~~~~~~~~~~~~~~~~~~~~~}. TR
        //            (                          (
        //            ;"   '!;!!!!!!!!!!!!;!'   ::
        //             I>^^:                :^^|I <--------- Canvas-Horizon intersection
        //          ~>+%.                      ,$+>,
        //        !|~   (                      (   :|!
        //      ~/'   L (----------C----------`) R   ,/"
        //     /;       `/         ^,         )`       ^|
        //    }'         (         |`         (         '}
        //   }`          ,^        |`        *.          .}
        //  ('         BL !::::::::|:::::::::: BR         ,)
        // ,{                      |`  Bottom              }`
        // }                   camZ|`                      `}
        // }                       |`                       }
        // }                       E----> camX              }
        // }                                                } Horizon circle
        // }                                               `}
        // ~{                                              }.
        //  {.                                            '(
        //   }`                                          `}
        //   `}.                                        .}
        //     )!                                      !/
        //      :/.                                  '/:
        //        ^|'                              ,|^
        //          :>+.                        .+>:
        //             !^^;'                ';^^!
        //                 :;!!!!!!!!!!!!;!;:
        //
        // Top-down view (plane defined by camZ and camX):
        //
        //                        Top
        //        TL_______________________________ TR
        //          \              |              /
        //           \   :;!!!!!!!!!!!!!!;!;:    /
        //            I^;'         |        ';^^I
        //         :>+.\           |           /.+>:
        //       ^|'    \          |          /    ,|^ <--- Horizon
        //     :/.       \         |         /       '/:
        //      }         L--------C--------R_________}_________
        //     }           \       ^camZ   /           }       ^
        //      }           \      |      /           }        |
        //     :/.           \     |     /           :/.       |
        //       ^|'          BL----B----BR_______ !|'         |
        //         :>+.        \   |   /        ^              | eyeToHorizon
        //            !^;'      \  |  /      ';!|              |
        //               :;!!!!!!\ | /!!;!;:!   | eyeToBottom  |
        //                        \|/           |              |
        //                         E----> camX__v______________v
        const yBottom = this.m_distanceToHorizonCenter *
            Math.tan(this.m_cameraPitch - CameraUtils_1.CameraUtils.getBottomFov(this.m_camera));
        let tTopRight;
        let tBottomRight;
        // Collect all intersections in counter-clockwise order.
        for (let side = CanvasSide.Bottom; side < 4; side++) {
            if (this.isTangentVisible(side)) {
                this.m_intersections.push([this.getTangentOnSide(side)]);
                continue;
            }
            const sideIntersections = new Array();
            this.m_isFullyVisible = false;
            switch (side) {
                case CanvasSide.Bottom: {
                    sideIntersections.push(...this.computeTBIntersections(yBottom));
                    break;
                }
                case CanvasSide.Right: {
                    const rightFov = CameraUtils_1.CameraUtils.getRightFov(this.m_camera);
                    const intersections = this.computeLRIntersections(yBottom, rightFov);
                    if (intersections) {
                        [tTopRight, tBottomRight] = intersections;
                        sideIntersections.push(tBottomRight !== undefined ? 1 + tBottomRight : undefined, tTopRight);
                    }
                    break;
                }
                case CanvasSide.Top: {
                    const yTop = this.m_distanceToHorizonCenter *
                        Math.tan(this.m_cameraPitch + CameraUtils_1.CameraUtils.getTopFov(this.m_camera));
                    sideIntersections.push(...this.computeTBIntersections(yTop).reverse());
                    break;
                }
                case CanvasSide.Left: {
                    const leftFov = CameraUtils_1.CameraUtils.getLeftFov(this.m_camera);
                    if (leftFov === CameraUtils_1.CameraUtils.getRightFov(this.m_camera)) {
                        // Left side intersections are symmetrical to right ones.
                        sideIntersections.push(tTopRight !== undefined ? 0.5 - tTopRight : undefined, tBottomRight !== undefined ? 0.5 - tBottomRight : undefined);
                    }
                    else {
                        const isections = this.computeLRIntersections(yBottom, leftFov);
                        if (isections) {
                            sideIntersections.push(0.5 - isections[0], // top
                            isections[1] !== undefined ? 0.5 - isections[1] : undefined // bottom
                            );
                        }
                    }
                    break;
                }
            }
            // Filter out undefined values and horizon intersections that are not visible because
            // the canvas corner intersects the world (this may happen with off-center projections).
            const hasCorners = [
                this.m_cornerIntersects[side],
                this.m_cornerIntersects[nextCanvasSide(side)]
            ];
            this.m_intersections.push(sideIntersections.filter((val, i) => val !== undefined && !hasCorners[i]));
        }
    }
    /**
     * Computes horizon intersections with top or bottom canvas side.
     *
     * @returns positions of the intersections in the horizon circle, first left, then right
     * Values are in range [0,1].
     */
    computeTBIntersections(y) {
        const radiusSq = this.m_radius * this.m_radius;
        const x = Math.sqrt(radiusSq - y * y);
        const t = Math.atan2(y, x) / twoPi;
        return [0.5 - t, t > 0 ? t : 1 + t];
    }
    /**
     * Computes horizon intersections with left or right canvas side.
     *
     * @returns positions of the intersections in the horizon circle, first top, then bottom
     * (or undefined if not visible). Values are in range [-0.5,0.5].
     */
    computeLRIntersections(yBottom, sideFov) {
        // Define vertical canvas side line by finding the middle and bottom points of
        // its projection on the horizon plane.
        const eyeToHorizon = this.m_distanceToHorizonCenter / Math.cos(this.m_cameraPitch);
        const yMiddle = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch);
        const xMiddle = eyeToHorizon * Math.tan(sideFov);
        const bottomFov = CameraUtils_1.CameraUtils.getBottomFov(this.m_camera);
        const eyeToBottom = (this.m_distanceToHorizonCenter * Math.cos(bottomFov)) /
            Math.cos(this.m_cameraPitch - bottomFov);
        const xBottom = (xMiddle * eyeToBottom) / eyeToHorizon;
        const intersections = harp_utils_1.Math2D.intersectLineAndCircle(xBottom, yBottom, xMiddle, yMiddle, this.m_radius);
        if (!intersections) {
            return undefined;
        }
        const yTopRight = intersections.y1;
        const tTop = Math.atan2(yTopRight, intersections.x1) / twoPi;
        // If there's a bottom intersection check if it's visible (its above the y
        // coordinate of the bottom canvas side).
        const hasBottomIntersection = -yTopRight >= yBottom && intersections.x2 !== undefined;
        const tBottom = hasBottomIntersection
            ? Math.atan2(intersections.y2, intersections.x2) / twoPi
            : undefined;
        return [tTop, tBottom];
    }
}
exports.SphereHorizon = SphereHorizon;


/***/ }),

/***/ "../harp-mapview/lib/SphereViewBounds.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/SphereViewBounds.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SphereViewBounds = exports.computeEdgeDivisions = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const three_1 = __webpack_require__(/*! three */ "three");
const SphereHorizon_1 = __webpack_require__(/*! ./SphereHorizon */ "../harp-mapview/lib/SphereHorizon.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-mapview/lib/Utils.ts");
// Rough, empirical rule to compute the number of divisions needed for a geopolygon edge to keep
// the deviation from the view bound edge it must follow within acceptable values.
function computeEdgeDivisions(geoStart, geoEnd) {
    const maxLatitudeSpan = 20;
    const maxLongitudeSpan = 5;
    const latitudeSpan = Math.abs(geoEnd.latitude - geoStart.latitude);
    const longitudeSpan = geoStart.minLongitudeSpanTo(geoEnd);
    return Math.ceil(Math.max(latitudeSpan / maxLatitudeSpan, longitudeSpan / maxLongitudeSpan));
}
exports.computeEdgeDivisions = computeEdgeDivisions;
const ccwCanvasCornersNDC = [
    { x: -1, y: -1 },
    { x: 1, y: -1 },
    { x: 1, y: 1 },
    { x: -1, y: 1 } // top left
];
/**
 * Generates Bounds for a camera view and a spherical projection
 *
 * @internal
 */
class SphereViewBounds {
    constructor(camera, projection) {
        this.camera = camera;
        this.projection = projection;
        harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
    }
    /**
     * @override
     */
    generate() {
        const coordinates = this.findBoundsIntersections();
        this.wrapAroundPoles(coordinates);
        return coordinates.length > 2
            ? new harp_geoutils_1.GeoPolygon(coordinates, false, true)
            : undefined;
    }
    addSideSegmentSubdivisions(coordinates, NDCStart, NDCEnd, geoStart, geoEnd) {
        coordinates.push(geoStart);
        const divisionCount = computeEdgeDivisions(geoStart, geoEnd);
        if (divisionCount <= 1) {
            return;
        }
        const NDCStep = new three_1.Vector2(NDCEnd.x - NDCStart.x, NDCEnd.y - NDCStart.y).multiplyScalar(1 / divisionCount);
        const NDCDivision = new three_1.Vector2(NDCStart.x, NDCStart.y);
        for (let i = 0; i < divisionCount - 1; i++) {
            NDCDivision.add(NDCStep);
            const intersection = Utils_1.MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, NDCDivision.x, NDCDivision.y);
            if (intersection) {
                coordinates.push(this.projection.unprojectPoint(intersection));
            }
        }
    }
    addSideIntersections(coordinates, side, geoStartCorner, geoEndCorner, horizon) {
        const startNDCCorner = ccwCanvasCornersNDC[side];
        const endNDCCorner = ccwCanvasCornersNDC[SphereHorizon_1.nextCanvasSide(side)];
        if (geoStartCorner && geoEndCorner) {
            // No horizon visible on this side of the canvas, generate polygon vertices from
            // intersections of the canvas side with the world.
            this.addSideSegmentSubdivisions(coordinates, startNDCCorner, endNDCCorner, geoStartCorner, geoEndCorner);
            return;
        }
        if (!horizon) {
            return;
        }
        // Bounds on this side of the canvas need to be completed with the horizon.
        const horizonIntersections = horizon.getSideIntersections(side);
        if (horizonIntersections.length === 0) {
            return;
        }
        if (geoStartCorner) {
            // Generate polygon vertices from intersections of this canvas side with the world
            // from its starting corner till the last intersection with the horizon.
            const worldHorizonPoint = horizon.getPoint(horizonIntersections[horizonIntersections.length - 1]);
            const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);
            this.addSideSegmentSubdivisions(coordinates, startNDCCorner, worldHorizonPoint.project(this.camera), geoStartCorner, geoHorizonPoint);
        }
        else {
            // Subdivide horizon from last horizon intersection on previous side to this side first.
            const prevSide = SphereHorizon_1.previousCanvasSide(side);
            let prevSideIntersections = horizon.getSideIntersections(prevSide);
            if (prevSideIntersections.length === 0) {
                // When bottom canvas side cuts the horizon above its center, right horizon
                // tangent is not visible. Last horizon tangent is top one.
                prevSideIntersections = horizon.getSideIntersections(SphereHorizon_1.previousCanvasSide(prevSide));
            }
            harp_utils_1.assert(prevSideIntersections.length > 0);
            horizon.getDivisionPoints(point => {
                coordinates.push(this.projection.unprojectPoint(point));
            }, prevSideIntersections[prevSideIntersections.length - 1], horizonIntersections[0]);
        }
        if (horizonIntersections.length > 1) {
            // Subdivide side segment between two horizon intersections.
            const worldHorizonStart = horizon.getPoint(horizonIntersections[0]);
            const worldHorizonEnd = horizon.getPoint(horizonIntersections[1]);
            const geoHorizonStart = this.projection.unprojectPoint(worldHorizonStart);
            const geoHorizonEnd = this.projection.unprojectPoint(worldHorizonEnd);
            this.addSideSegmentSubdivisions(coordinates, worldHorizonStart.project(this.camera), worldHorizonEnd.project(this.camera), geoHorizonStart, geoHorizonEnd);
        }
        if (geoEndCorner) {
            // Subdivice side segment from last horizon intersection to the ending corner of this
            // canvas side.
            const worldHorizonPoint = horizon.getPoint(horizonIntersections[0]);
            const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);
            this.addSideSegmentSubdivisions(coordinates, worldHorizonPoint.project(this.camera), endNDCCorner, geoHorizonPoint, geoEndCorner);
        }
    }
    findBoundsIntersections() {
        const coordinates = [];
        const [cornerCoordinates, numCorners] = this.addCanvasCornerIntersection();
        // Horizon points need to be added to complete the bounds if not all canvas corners
        // intersect with the world.
        const horizon = numCorners < 4
            ? new SphereHorizon_1.SphereHorizon(this.camera, cornerCoordinates.map(value => value !== undefined))
            : undefined;
        if (numCorners === 0 && horizon.isFullyVisible) {
            // Bounds are generated entirely from equidistant points obtained from the horizon
            // circle.
            horizon.getDivisionPoints(point => {
                coordinates.push(this.projection.unprojectPoint(point));
            });
            return coordinates;
        }
        for (let side = SphereHorizon_1.CanvasSide.Bottom; side < 4; side++) {
            const startCorner = cornerCoordinates[side];
            const endCorner = cornerCoordinates[SphereHorizon_1.nextCanvasSide(side)];
            this.addSideIntersections(coordinates, side, startCorner, endCorner, horizon);
        }
        return coordinates;
    }
    wrapAroundPoles(coordinates) {
        // If one of the poles is inside the view bounds, the polygon would have to cover the pole,
        // which is not possible in geo space. Instead, additional vertices (numbered in order from
        // 1 to 6 in the diagram below) are added to the polygon so that it wraps around the pole,
        // covering the same area(except for the pole circle that cannot be mapped to geospace).
        // The globe is cut in two hemispheres by the meridians at the camera longitude (camLon) and
        // its antimeridian (at camLon+180). Then, the polygon side crossing the camera antimeridian
        // is found, and the new pole wrapping vertices are inserted between its start and end
        // vertices.
        //
        //    (end) hem.crossing side (start)
        //        \|<-------------->|/
        // x-------x------6!--------x--------x
        // |         , - ~5!1 ~ -,           |
        // |     , '       !       ' ,       |
        // |   ,           !           ,     |
        // |  ,            !            ,    |
        // | ,             !             ,   |
        // | 4           POLE            2   | <- Bounds polygon
        // | ,             !             ,   |
        // |  ,            !            ,    |
        // |   ,           !           ,     |
        // |     ,         !         ,'      |
        // |       ' -_, _ ! _ ,_ -'         |
        // |               3                 |
        // x---------------!-----------------x
        //                 ! <- hemisphere partition
        const northPoleCenter = new three_1.Vector3(0, 0, harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        const southPoleCenter = new three_1.Vector3(0, 0, -harp_geoutils_1.EarthConstants.EQUATORIAL_RADIUS);
        const northPoleInView = Utils_1.MapViewUtils.closeToFrustum(northPoleCenter, this.camera);
        const southPoleInView = Utils_1.MapViewUtils.closeToFrustum(southPoleCenter, this.camera);
        if (!northPoleInView && !southPoleInView) {
            return;
        }
        // Create first wrapping vertex (number 1 in the diagram above).
        const camLon = this.projection.unprojectPoint(this.camera.position).lng;
        const wrapLat = northPoleInView ? 90 : -90;
        const wrapLon = northPoleInView ? camLon + 180 : camLon - 180;
        const geoWrapTopRight = new harp_geoutils_1.GeoCoordinates(wrapLat, wrapLon);
        const geoWrapTopRightNorm = geoWrapTopRight.normalized();
        // Find the polygon side crossing the camera antimeridian.
        const crossLon = geoWrapTopRightNorm.lng;
        let prevLon = coordinates[coordinates.length - 1].lng;
        // Check whether the camera antimeridian crossing also crosses greenwich antimerdian.
        let isGwAntimerCross = false;
        const hSphereCrossEndIndex = coordinates.findIndex((value) => {
            const crossesAntimer = harp_geoutils_1.isAntimeridianCrossing(prevLon, value.lng);
            const sameSign = Math.sign(crossLon - value.lng) === Math.sign(crossLon - prevLon);
            if (sameSign === crossesAntimer) {
                isGwAntimerCross = crossesAntimer;
                return true;
            }
            prevLon = value.lng;
            return false;
        });
        if (hSphereCrossEndIndex < 0) {
            // No polygon side crosses the camera antimeridian, meaning that the polygon doesn't
            // actually go above the pole to the other side of the world, no wrapping needed.
            return;
        }
        // Create rest of wrapping vertices at pole's latitude (vertices 2-5 in diagram above).
        const wrapSideOffset = northPoleInView ? 90 : -90;
        const wrapCornerOffset = northPoleInView ? 0.00001 : -0.00001;
        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by
        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).
        const geoWrapRight = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon + wrapSideOffset).normalized();
        const geoWrapBottom = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon).normalized();
        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by
        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).
        const geoWrapLeft = new harp_geoutils_1.GeoCoordinates(wrapLat, camLon - wrapSideOffset).normalized();
        const geoWrapTopLeft = new harp_geoutils_1.GeoCoordinates(wrapLat, wrapLon + wrapCornerOffset).normalized();
        const hSphereCrossStartIndex = (hSphereCrossEndIndex + coordinates.length - 1) % coordinates.length;
        const crossStart = coordinates[hSphereCrossStartIndex];
        const crossEnd = coordinates[hSphereCrossEndIndex];
        // Last wrapping vertex (number 6) is linearly interpolated at the polygon side crossing the
        // camera antimeridian.
        let crossLerp = harp_geoutils_1.GeoCoordinates.lerp(crossStart, crossEnd, 0.01, isGwAntimerCross);
        if (isGwAntimerCross && northPoleInView) {
            crossLerp.longitude -= 360;
        }
        else {
            crossLerp = crossLerp.normalized();
        }
        // Add the wrapping vertices to the array in the proper order (see diagram above).
        coordinates.splice(hSphereCrossEndIndex, 0, wrapLon < -180 ? geoWrapTopRight : geoWrapTopRightNorm, // 1
        geoWrapRight, // 2
        geoWrapBottom, // 3
        geoWrapLeft, // 4
        geoWrapTopLeft, // 5
        crossLerp // 6
        );
    }
    // Returns a tuple with the array of canvas corner intersection geocoordinates in ccw order
    // (undefined values for corners not intersecting the world) and the number of intersections.
    addCanvasCornerIntersection() {
        const geoCorners = new Array();
        let numIntersections = 0;
        ccwCanvasCornersNDC.forEach(corner => {
            const intersection = Utils_1.MapViewUtils.rayCastWorldCoordinates({ camera: this.camera, projection: this.projection }, corner.x, corner.y);
            if (intersection) {
                geoCorners.push(this.projection.unprojectPoint(intersection));
                ++numIntersections;
            }
            else {
                geoCorners.push(undefined);
            }
        });
        return [geoCorners, numIntersections];
    }
}
exports.SphereViewBounds = SphereViewBounds;


/***/ }),

/***/ "../harp-mapview/lib/Statistics.ts":
/*!*****************************************!*\
  !*** ../harp-mapview/lib/Statistics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceStatistics = exports.FrameStatsArray = exports.FrameStats = exports.Statistics = exports.MultiStageTimer = exports.computeArrayAverage = exports.computeArrayStats = exports.SampledTimer = exports.SimpleTimer = exports.RingBuffer = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Statistics");
/**
 * A simple ring buffer to store the last `n` values of the timer. The buffer works on
 * a First-In-First-Out (FIFO) basis.
 */
class RingBuffer {
    /**
     * Sets up the ring buffer.
     *
     * @param capacity - The buffer's capacity.
     */
    constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.capacity = capacity;
        this.head = this.tail = this.size = 0;
    }
    /**
     * Clears the contents, removes all elements.
     */
    clear() {
        this.head = this.tail = this.size = 0;
    }
    /**
     * Adds a single element to the ring buffer.
     *
     * @param data - Data element.
     */
    enqOne(data) {
        let next = this.head + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size < this.capacity) {
            this.size++;
        }
        this.buffer[this.head] = data;
        this.head = next;
        if (this.size === this.capacity) {
            this.tail = this.head;
        }
    }
    /**
     * Adds one or more elements.
     *
     * @param data - The elements to add.
     */
    enq(...data) {
        for (const v of data) {
            this.enqOne(v);
        }
    }
    /**
     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.
     * Before calling this method, make sure that `size > 0`.
     */
    deq() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        const data = this.buffer[this.tail];
        let next = this.tail + 1;
        if (next >= this.capacity) {
            next = 0;
        }
        if (this.size > 0) {
            this.size--;
        }
        this.tail = next;
        return data;
    }
    /**
     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get top() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        return this.buffer[this.tail];
    }
    /**
     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is
     * empty. Before calling this method, make sure that `size > 0`.
     */
    get bottom() {
        if (this.size === 0) {
            throw new Error("Ringbuffer underrun");
        }
        let previous = this.head - 1;
        if (previous < 0) {
            previous = this.capacity - 1;
        }
        return this.buffer[previous];
    }
    /**
     * Creates an iterator for the buffer.
     */
    iterator() {
        return new RingBuffer.Iterator(this);
    }
    /**
     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.
     */
    asArray() {
        const array = new Array();
        for (let i = 0; i < this.size; i++) {
            array.push(this.buffer[(this.tail + i) % this.capacity]);
        }
        return array;
    }
}
exports.RingBuffer = RingBuffer;
(function (RingBuffer) {
    /**
     * A local class for RingBuffer<T>
     */
    class Iterator {
        /**
         * Creates an iterator for the ring buffer.
         *
         * @param m_buffer - `Ringbuffer` to iterate over.
         * @param m_index - Start index.
         */
        constructor(m_buffer, m_index = 0) {
            this.m_buffer = m_buffer;
            this.m_index = m_index;
        }
        /**
         * Gets the iterator's current value. This function does not fail even if an overrun occurs.
         * To detect an overrun, watch the result for [[next]].
         */
        get value() {
            return this.m_buffer.buffer[(this.m_buffer.tail + this.m_index) % this.m_buffer.capacity];
        }
        /**
         * Advances the iterator to the next element.
         *
         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.
         */
        next() {
            this.m_index++;
            return this.m_index < this.m_buffer.size;
        }
    }
    RingBuffer.Iterator = Iterator;
})(RingBuffer = exports.RingBuffer || (exports.RingBuffer = {}));
/**
 * A simple timer that stores only the latest measurement.
 *
 * @internal
 */
class SimpleTimer {
    constructor(statistics, name) {
        this.statistics = statistics;
        this.name = name;
        /** `true` if timer has been started. */
        this.running = false;
    }
    /**
     * Gets the latest measurement. This function may return `undefined` if no measurement
     * was done.
     */
    get value() {
        return this.m_currentValue;
    }
    /**
     * Sets the measurement value for the amount of time that has elapsed from start() to stop().
     * Use this function to override the timer's duration.
     *
     * @param val - The timer's duration.
     */
    setValue(val) {
        this.m_currentValue = val;
    }
    /**
     * Resets the value to be able to start again.
     */
    reset() {
        this.m_currentValue = undefined;
    }
    /**
     * Starts the timer. Returns the current time, based on `Performance.now()`.
     */
    start() {
        if (!this.statistics.enabled) {
            return -1;
        }
        if (this.running) {
            throw new Error("Timer '" + this.name + "' is already running");
        }
        this.running = true;
        return (this.m_currentValue = harp_utils_1.PerformanceTimer.now());
    }
    /**
     * Stops the timer. Requires that the timer has started.
     */
    stop() {
        var _a;
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            // this.currentValue is a number now!
            const t = harp_utils_1.PerformanceTimer.now() - ((_a = this.m_currentValue) !== null && _a !== void 0 ? _a : 0);
            this.m_currentValue = t;
            this.setValue(t);
            this.running = false;
            return t;
        }
    }
    /**
     * Samples the timer. Requires that the timer has started.
     *
     * @returns the current timer value; `-1` if statistics are disabled.
     */
    now() {
        var _a;
        if (!this.statistics.enabled) {
            return -1;
        }
        if (!this.running) {
            throw new Error("Timer '" + this.name + "' has not been started");
        }
        else {
            const t = harp_utils_1.PerformanceTimer.now() - ((_a = this.m_currentValue) !== null && _a !== void 0 ? _a : 0);
            return t;
        }
    }
}
exports.SimpleTimer = SimpleTimer;
/**
 * A timer that stores the last `n` samples in a ring buffer.
 *
 * @internal
 */
class SampledTimer extends SimpleTimer {
    /**
     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!
     *
     * @param statistics - Statistics to use for management.
     * @param name - Name of the timer. Use colons to build a hierarchy.
     */
    constructor(statistics, name) {
        super(statistics, name);
        this.statistics = statistics;
        this.name = name;
        /**
         * The number of times the timer has reset.
         */
        this.numResets = 0;
        /**
         * Maximum samples until the statistics are reset and updated, which may destroy a median
         * computation.
         */
        this.maxNumSamples = 1000;
        /**
         * The array of sampled values, its length cannot exceed `maxNumSamples`.
         */
        this.samples = new RingBuffer(this.maxNumSamples);
    }
    /**
     * Resets the timer and clears all of its historical values.
     * @override
     */
    reset() {
        super.reset();
        this.getStats();
        this.samples.clear();
        this.numResets++;
    }
    /**
     * Add a single measurement to the sample.
     *
     * @param val - A measurement to add.
     * @override
     */
    setValue(val) {
        super.setValue(val);
        if (val !== undefined) {
            this.samples.enqOne(val);
        }
    }
    /**
     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,
     * as it requires a copy of the sampled values.
     */
    getStats() {
        return computeArrayStats(this.samples.asArray());
    }
}
exports.SampledTimer = SampledTimer;
/**
 * Only exported for testing
 * @ignore
 *
 * @remarks
 * Compute the [[ArrayStats]] for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the
 *      entries.
 * @returns {(Stats | undefined)}
 *
 * @internal
 */
function computeArrayStats(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    samples.sort((a, b) => {
        return a - b;
    });
    const min = samples[0];
    const max = samples[samples.length - 1];
    let median;
    let median75;
    let median90;
    let median95;
    let median97;
    let median99;
    let median999;
    if (samples.length === 1) {
        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];
    }
    else if (samples.length === 2) {
        median = samples[0] * 0.5 + samples[1] * 0.5;
        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];
    }
    else {
        const mid = Math.floor(samples.length / 2);
        median =
            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];
        const mid75 = Math.round(samples.length * 0.75) - 1;
        median75 = samples[mid75];
        const mid90 = Math.round(samples.length * 0.9) - 1;
        median90 = samples[mid90];
        const mid95 = Math.round(samples.length * 0.95) - 1;
        median95 = samples[mid95];
        const mid97 = Math.round(samples.length * 0.97) - 1;
        median97 = samples[mid97];
        const mid99 = Math.round(samples.length * 0.99) - 1;
        median99 = samples[mid99];
        const mid999 = Math.round(samples.length * 0.999) - 1;
        median999 = samples[mid999];
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return {
        min,
        max,
        avg,
        median,
        median75,
        median90,
        median95,
        median97,
        median99,
        median999,
        numSamples: samples.length
    };
}
exports.computeArrayStats = computeArrayStats;
/**
 * Only exported for testing
 * @ignore
 *
 * @remarks
 * Compute the averages for the passed in array of numbers.
 *
 * @param {number[]} samples Array containing sampled values.
 * @returns {(Stats | undefined)}
 *
 * @internal
 */
function computeArrayAverage(samples) {
    if (samples.length === 0) {
        return undefined;
    }
    let sum = 0;
    for (let i = 0, l = samples.length; i < l; i++) {
        sum += samples[i];
    }
    const avg = sum / samples.length;
    return avg;
}
exports.computeArrayAverage = computeArrayAverage;
/**
 * Measures a sequence of connected events, such as multiple processing stages in a function.
 *
 * @remarks
 * Each stage is identified with a timer name, that must be a valid timer in the statistics
 * object. Additionally, all timers within a `MultiStageTimer` must be unique.
 *
 * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,
 * one timer stops and the next timer starts.
 *
 * @internal
 */
class MultiStageTimer {
    /**
     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.
     *
     * @param statistics - The statistics object that manages the timers.
     * @param name - Name of this `MultiStageTimer`.
     * @param stages - List of timer names.
     */
    constructor(statistics, name, stages) {
        this.statistics = statistics;
        this.name = name;
        this.stages = stages;
        if (stages.length < 1) {
            throw new Error("MultiStageTimer needs stages");
        }
        stages.forEach(stage => {
            if (!statistics.hasTimer(stage)) {
                throw new Error("Unknown timer: " + stage);
            }
        });
    }
    /**
     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its
     * last stage, the value is `undefined`.
     */
    get value() {
        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;
    }
    /**
     * Resets the timers across all stages.
     */
    reset() {
        if (!this.statistics.enabled) {
            return;
        }
        this.stages.forEach(stage => {
            this.statistics.getTimer(stage).reset();
        });
    }
    /**
     * Starts the `MultiStageTimer` at its first stage.
     */
    start() {
        var _a;
        this.stage = this.stages[0];
        return (_a = this.statistics.getTimer(this.stages[0]).value) !== null && _a !== void 0 ? _a : -1;
    }
    /**
     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be
     * `undefined` if not all stages started.
     */
    stop() {
        this.stage = undefined;
        return this.value !== undefined ? this.value : -1;
    }
    /**
     * Gets the current stage.
     */
    get stage() {
        return this.currentStage;
    }
    /**
     * Sets the current stage. If a new stage is provided, the current timer (if available) is
     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,
     * this is equivalent to calling `stop` on the `MultiStageTimer`.
     *
     * @param stage - The next stage to start.
     */
    set stage(stage) {
        if (this.currentStage === stage) {
            return;
        }
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).stop();
        }
        this.currentStage = stage;
        if (this.statistics.enabled && this.currentStage !== undefined) {
            this.statistics.getTimer(this.currentStage).start();
        }
    }
}
exports.MultiStageTimer = MultiStageTimer;
/**
 * Manages a set of timers.
 *
 * @remarks
 * The main objective of `Statistics` is to log these timers. You can
 * disable statistics to minimize their impact on performance.
 *
 * @internal
 */
class Statistics {
    /**
     * Sets up a group of timers.
     *
     * @param name - The statistics name, for logging purposes.
     * @param enabled - If `false`, the timers do not measure the performance.
     */
    constructor(name, enabled = false) {
        this.name = name;
        this.enabled = enabled;
        this.timers = new Map();
        this.nullTimer = new SimpleTimer(this, "<null>");
    }
    /**
     * Adds a timer, based on the name specified.
     *
     * @param name - The timer's name; must be unique.
     */
    createTimer(name, keepSamples = true) {
        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);
        return this.addTimer(timer);
    }
    /**
     * Adds the timer specified.
     *
     * @param timer - The timer's name, which must be unique within this statistics object.
     */
    addTimer(timer) {
        if (this.timers.get(timer.name) !== undefined) {
            throw new Error("Duplicate timer name: '" + timer.name + "'");
        }
        this.timers.set(timer.name, timer);
        return timer;
    }
    /**
     * Gets a timer by name.
     *
     * @param name - The timer's name.
     */
    getTimer(name) {
        if (!this.enabled) {
            return this.nullTimer;
        }
        const t = this.timers.get(name);
        return t === undefined ? this.nullTimer : t;
    }
    /**
     * Checks if a timer with the specified name already exists.
     *
     * @param name - The timer's name.
     * @returns `true` if a timer with `name` already exists; `false` otherwise.
     */
    hasTimer(name) {
        const t = this.timers.get(name);
        return t !== undefined;
    }
    /**
     * Resets all timers.
     */
    reset() {
        this.timers.forEach((timer) => {
            timer.reset();
        });
    }
    /**
     * Prints all values to the console.
     *
     * @param header - Optional header line.
     * @param footer - Optional footer line.
     */
    log(header, footer) {
        if (header !== undefined || this.name !== undefined) {
            logger.log(header !== undefined ? header : this.name);
        }
        let maxNameLength = 0;
        this.timers.forEach((timer) => {
            maxNameLength = Math.max(maxNameLength, timer.name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.timers.forEach((timer) => {
            let s = timer.name + ": " + " ".repeat(maxNameLength - timer.name.length);
            s += print(timer.value);
            // sampled timers also update their stats and log them
            if (timer instanceof SampledTimer) {
                const simpleStats = timer.getStats();
                if (simpleStats !== undefined) {
                    s +=
                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                            `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                            `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                            `N=${print(simpleStats.numSamples)} ]`;
                }
            }
            logger.log(s);
        });
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
}
exports.Statistics = Statistics;
/**
 * Class containing all counters, timers and events of the current frame.
 *
 * @internal
 */
class FrameStats {
    constructor() {
        this.entries = new Map();
        this.messages = undefined;
    }
    /**
     * Retrieve the value of the performance number.
     *
     * @param name - Name of the performance number.
     * @returns The value of the performance number or `undefined` if it has not been declared by
     *      `setValue` before.
     */
    getValue(name) {
        return this.entries.get(name);
    }
    /**
     * Set the value of the performance number.
     *
     * @param name - Name of the performance number.
     * @param name - New value of the performance number.
     */
    setValue(name, value) {
        this.entries.set(name, value);
    }
    /**
     * Add a value to the current value of the performance number. If the performance is not known,
     * it will be initialized with `value`.
     *
     * @param name - Name of the performance number.
     * @param name - Value to be added to the performance number.
     */
    addValue(name, value) {
        const oldValue = this.entries.get(name);
        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));
    }
    /**
     * Add a text message to the frame, like "Font XYZ has been loaded"
     *
     * @param message - The message to add.
     */
    addMessage(message) {
        if (this.messages === undefined) {
            this.messages = [];
        }
        this.messages.push(message);
    }
    /**
     * Reset all known performance values to `0` and the messages to `undefined`.
     */
    reset() {
        this.entries.forEach((value, name) => {
            this.entries.set(name, 0);
        });
        this.messages = undefined;
    }
}
exports.FrameStats = FrameStats;
/**
 * @ignore
 * Only exported for testing.
 *
 * @remarks
 * Instead of passing around an array of objects, we store the frame statistics as an object of
 * arrays. This allows convenient computations from {@link RingBuffer},
 */
class FrameStatsArray {
    constructor(capacity = 0) {
        this.capacity = capacity;
        this.frameEntries = new Map();
        this.messages = new RingBuffer(capacity);
    }
    get length() {
        return this.messages.size;
    }
    reset() {
        this.frameEntries.forEach((buffer, name) => {
            buffer.clear();
        });
        this.messages.clear();
    }
    addFrame(frameStats) {
        const currentSize = this.length;
        const frameEntries = this.frameEntries;
        frameStats.entries.forEach((value, name) => {
            let buffer = frameEntries.get(name);
            if (buffer === undefined) {
                // If there is a buffer that has not been known before, add it to the known buffers,
                // fill it up with with 0 to the size of all the other buffers to make them of equal
                // size to make PerfViz happy.
                buffer = new RingBuffer(this.capacity);
                for (let i = 0; i < currentSize; i++) {
                    buffer.enqOne(0);
                }
                this.frameEntries.set(name, buffer);
            }
            buffer.enqOne(value);
        });
        this.messages.enq(frameStats.messages);
    }
    /**
     * Prints all values to the console.
     */
    log() {
        let maxNameLength = 0;
        this.frameEntries.forEach((buffer, name) => {
            maxNameLength = Math.max(maxNameLength, name.length);
        });
        // simple printing function for number limits the number of decimal points.
        const print = (v) => {
            return v !== undefined ? v.toFixed(5) : "?";
        };
        this.frameEntries.forEach((buffer, name) => {
            let s = name + ": " + " ".repeat(maxNameLength - name.length);
            const simpleStats = computeArrayStats(buffer.asArray());
            if (simpleStats !== undefined) {
                s +=
                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +
                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +
                        `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +
                        `N=${print(simpleStats.numSamples)} ]`;
            }
            logger.log(s);
        });
    }
}
exports.FrameStatsArray = FrameStatsArray;
/**
 * Performance measurement central.
 *
 * @remarks
 * Maintains the current. Implemented as an instance for easy access.
 *
 * {@link FrameStats}, which holds all individual performance numbers.
 *
 * @internal
 */
class PerformanceStatistics {
    /**
     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.
     *
     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.
     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.
     * @memberof PerformanceStatistics
     */
    constructor(enabled = true, maxNumFrames = 1000) {
        this.enabled = enabled;
        this.maxNumFrames = maxNumFrames;
        /**
         * Current frame statistics. Contains all values for the current frame. Will be cleared when
         * [[PerformanceStatistics#storeFrameInfo]] is called.
         *
         * @type {FrameStats}
         * @memberof PerformanceStatistics
         */
        this.currentFrame = new FrameStats();
        /**
         * Additional results stored for the current application run, not per frame. Only the last value
         * is stored.
         *
         * @type {(Map<string, number>)}
         */
        this.appResults = new Map();
        /**
         * Additional configuration values stored for the current application run, not per frame. Only
         * the last value is stored.
         *
         * @type {(Map<string, string>)}
         * @memberof PerformanceStatistics
         */
        this.configs = new Map();
        PerformanceStatistics.m_instance = this;
        this.m_frameEvents = new FrameStatsArray(maxNumFrames);
    }
    /**
     * Returns `true` when the maximum number of storable frames is reached.
     *
     * @readonly
     * @type {boolean}
     * @memberof PerformanceStatistics
     */
    get isFull() {
        return this.m_frameEvents.length >= this.maxNumFrames;
    }
    /**
     * Global instance to the instance. The current instance can be overridden by creating a new
     * `PerformanceStatistics`.
     */
    static get instance() {
        if (PerformanceStatistics.m_instance === undefined) {
            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);
        }
        return PerformanceStatistics.m_instance;
    }
    /**
     * @ignore
     * Only exported for testing.
     *
     * Return the array of frame events.
     */
    get frameEvents() {
        return this.m_frameEvents;
    }
    /**
     * Clears all settings, all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clear() {
        this.clearFrames();
        this.configs.clear();
        this.appResults.clear();
    }
    /**
     * Clears only all stored frame events as well as the current frame values.
     *
     * @memberof PerformanceStatistics
     */
    clearFrames() {
        this.m_frameEvents.reset();
        this.currentFrame.reset();
    }
    /**
     * Add the render state information from [[THREE.WebGLInfo]] to the current frame.
     * @param {THREE.WebGLInfo} webGlInfo
     */
    addWebGLInfo(webGlInfo) {
        if (webGlInfo.render !== undefined) {
            this.currentFrame.setValue("gl.numCalls", webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls);
            this.currentFrame.setValue("gl.numPoints", webGlInfo.render.points === null ? 0 : webGlInfo.render.points);
            this.currentFrame.setValue("gl.numLines", webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines);
            this.currentFrame.setValue("gl.numTriangles", webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles);
        }
        if (webGlInfo.memory !== undefined) {
            this.currentFrame.setValue("gl.numGeometries", webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries);
            this.currentFrame.setValue("gl.numTextures", webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures);
        }
        if (webGlInfo.programs !== undefined) {
            this.currentFrame.setValue("gl.numPrograms", webGlInfo.programs === null ? 0 : webGlInfo.programs.length);
        }
    }
    /**
     * Add memory statistics to the current frame if available.
     * @note Currently only supported on Chrome
     */
    addMemoryInfo() {
        if (window !== undefined && window.performance !== undefined) {
            const memory = window.performance.memory;
            if (memory !== undefined) {
                this.currentFrame.setValue("memory.totalJSHeapSize", memory.totalJSHeapSize);
                this.currentFrame.setValue("memory.usedJSHeapSize", memory.usedJSHeapSize);
                this.currentFrame.setValue("memory.jsHeapSizeLimit", memory.jsHeapSizeLimit);
            }
        }
    }
    /**
     * Stores the current frame events into the array of events and clears all values.
     *
     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.
     * @memberof PerformanceStatistics
     */
    storeAndClearFrameInfo() {
        if (this.m_frameEvents.length >= this.maxNumFrames) {
            return false;
        }
        this.m_frameEvents.addFrame(this.currentFrame);
        this.currentFrame.reset();
        return true;
    }
    /**
     * Logs all values to the logger.
     *
     * @param header - Optional header line.
     * @param footer - Optional footer line.
     */
    log(header, footer) {
        logger.log(header !== undefined ? header : "PerformanceStatistics");
        const appResults = this.appResults;
        appResults.forEach((value, name) => {
            logger.log(name, value);
        });
        const configs = this.configs;
        configs.forEach((value, name) => {
            logger.log(name, value);
        });
        this.m_frameEvents.log();
        if (footer !== undefined) {
            logger.log(footer);
        }
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsPlainObject(onlyLastFrame = false) {
        const appResults = {};
        const configs = {};
        const frames = {};
        const plainObject = {
            configs,
            appResults,
            frames
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults[name] = value;
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs[name] = value;
        });
        if (onlyLastFrame) {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames[name] = buffer.bottom;
            }
        }
        else {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames[name] = buffer.asArray();
            }
        }
        plainObject.messages = this.m_frameEvents.messages.asArray();
        return plainObject;
    }
    /**
     * Convert the last frame values to a plain object that can be serialized. Required to copy the
     * test results over to nightwatch.
     */
    getLastFrameStatistics() {
        return this.getAsPlainObject(true);
    }
    /**
     * Convert to a plain object that can be serialized. Required to copy the test results over to
     * nightwatch.
     */
    getAsSimpleFrameStatistics(onlyLastFrame = false) {
        const configs = new Map();
        const appResults = new Map();
        const frames = new Map();
        const simpleStatistics = {
            configs,
            appResults,
            frames,
            messages: this.m_frameEvents.messages.asArray()
        };
        const appResultValues = this.appResults;
        appResultValues.forEach((value, name) => {
            appResults.set(name, value);
        });
        const configValues = this.configs;
        configValues.forEach((value, name) => {
            configs.set(name, value);
        });
        if (onlyLastFrame) {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames.set(name, buffer.bottom);
            }
        }
        else {
            for (const [name, buffer] of this.m_frameEvents.frameEntries) {
                frames.set(name, buffer.asArray());
            }
        }
        return simpleStatistics;
    }
}
exports.PerformanceStatistics = PerformanceStatistics;
PerformanceStatistics.m_instance = undefined;


/***/ }),

/***/ "../harp-mapview/lib/TextureLoader.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/TextureLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextureLoader = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * A texture loader that supports request headers(e.g. for Authorization)
 */
class TextureLoader {
    constructor() {
        this.m_textureLoader = new THREE.TextureLoader();
    }
    /**
     * Load an image from url and create a texture
     * @param url - URL to the image
     * @param requestHeaders - Optional request headers to load image(e.g. Authorization)
     * @param abortSignal - Optional AbortSignal to cancel the load.
     * @param crossOrigin - Enable/disable CORS
     */
    async load(url, requestHeaders, abortSignal, crossOrigin = true) {
        // Use THREE.js texture loader directly if no request header is set
        if (requestHeaders === undefined) {
            return await this.loadWithThreeLoader(url);
        }
        // Load image with fetch API if request header is set
        const response = await fetch(url, {
            headers: requestHeaders,
            signal: abortSignal,
            mode: crossOrigin ? "cors" : "no-cors"
        });
        const blob = await response.blob();
        // Load image from blob using THREE.js loader
        const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));
        // Set correct image format from original URL or blob mime type
        // (object URL does not contain file format)
        const isJPEG = blob.type === "image/jpeg/" ||
            url.search(/\.jpe?g($|\?)/i) > 0 ||
            url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;
        return texture;
    }
    loadWithThreeLoader(url) {
        return new Promise((resolve, reject) => {
            this.m_textureLoader.setCrossOrigin("");
            this.m_textureLoader.load(url, texture => resolve(texture), undefined, () => reject(new Error("failed to load texture")));
        });
    }
}
exports.TextureLoader = TextureLoader;


/***/ }),

/***/ "../harp-mapview/lib/ThemeHelpers.ts":
/*!*******************************************!*\
  !*** ../harp-mapview/lib/ThemeHelpers.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLight = exports.toTextureFilter = exports.toWrappingMode = exports.toTextureDataType = exports.toPixelFormat = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.
 */
function toPixelFormat(format) {
    switch (format) {
        case "Alpha":
            return THREE.AlphaFormat;
        case "RGB":
            return THREE.RGBFormat;
        case "RGBA":
            return THREE.RGBAFormat;
        case "Luminance":
            return THREE.LuminanceFormat;
        case "LuminanceAlpha":
            return THREE.LuminanceAlphaFormat;
        case "RGBE":
            return THREE.RGBEFormat;
        case "Depth":
            return THREE.DepthFormat;
        case "DepthStencil":
            return THREE.DepthStencilFormat;
        case "Red":
            return THREE.RedFormat;
        default:
            throw new Error(`invalid pixel format: ${format}`);
    }
}
exports.toPixelFormat = toPixelFormat;
/**
 * Returns `three.js` texture data types based on a [[TextureDataType]] specified.
 */
function toTextureDataType(dataType) {
    switch (dataType) {
        case "UnsignedByte":
            return THREE.UnsignedByteType;
        case "Byte":
            return THREE.ByteType;
        case "Short":
            return THREE.ShortType;
        case "UnsignedShort":
            return THREE.UnsignedShortType;
        case "Int":
            return THREE.IntType;
        case "UnsignedInt":
            return THREE.UnsignedIntType;
        case "Float":
            return THREE.FloatType;
        case "HalfFloat":
            return THREE.HalfFloatType;
        default:
            throw new Error(`invalid texture data type: ${dataType}`);
    }
}
exports.toTextureDataType = toTextureDataType;
/**
 * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.
 */
function toWrappingMode(mode) {
    switch (mode) {
        case "clamp":
            return THREE.ClampToEdgeWrapping;
        case "repeat":
            return THREE.RepeatWrapping;
        case "mirror":
            return THREE.MirroredRepeatWrapping;
        default:
            throw new Error(`invalid wrapping mode: ${mode}`);
    }
}
exports.toWrappingMode = toWrappingMode;
/**
 * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.
 */
function toTextureFilter(filter) {
    switch (filter) {
        case "nearest":
            return THREE.NearestFilter;
        case "nearestMipMapNearest":
            return THREE.NearestMipMapNearestFilter;
        case "nearestMipMapLinear":
            return THREE.NearestMipMapLinearFilter;
        case "linear":
            return THREE.LinearFilter;
        case "linearMipMapNearest":
            return THREE.LinearMipMapNearestFilter;
        case "linearMipMapLinear":
            return THREE.LinearMipMapLinearFilter;
        default:
            throw new Error(`invalid texture filter: ${filter}`);
    }
}
exports.toTextureFilter = toTextureFilter;
/**
 * Create a specific light for lighting the map.
 */
function createLight(lightDescription) {
    switch (lightDescription.type) {
        case "ambient": {
            const light = new THREE.AmbientLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            return light;
        }
        case "directional": {
            const light = new THREE.DirectionalLight(lightDescription.color, lightDescription.intensity);
            light.name = lightDescription.name;
            if (lightDescription.castShadow !== undefined) {
                light.castShadow = lightDescription.castShadow;
            }
            if (light.castShadow) {
                light.shadow.bias = 0.00001;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
            }
            light.position.set(lightDescription.direction.x, lightDescription.direction.y, lightDescription.direction.z);
            light.position.normalize();
            return light;
        }
    }
}
exports.createLight = createLight;


/***/ }),

/***/ "../harp-mapview/lib/ThemeLoader.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/ThemeLoader.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemeLoader = exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const Theme_1 = __webpack_require__(/*! @here/harp-datasource-protocol/lib/Theme */ "../harp-datasource-protocol/lib/Theme.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const SkyCubemapTexture_1 = __webpack_require__(/*! ./SkyCubemapTexture */ "../harp-mapview/lib/SkyCubemapTexture.ts");
/**
 * @internal
 */
exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;
/**
 * Loads and validates a theme from URL objects.
 */
class ThemeLoader {
    /**
     * Loads a {@link @here/harp-datasource-protocol#Theme} from a
     * remote resource, provided as a URL that points to a
     * JSON-encoded theme.
     *
     * By default, resolves following features of theme:
     *
     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])
     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section
     *     of theme (see [[resolveThemeReferences]])
     *
     * Relative URIs of reference resources are resolved to full URL using the document's base URL
     * (see [[resolveUrls]]).
     *
     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by
     * providing {@link @here/harp-utils#UriResolver} using {@link ThemeLoadOptions.uriResolver}
     * option.
     *
     * @param theme - {@link @here/harp-datasource-protocol#Theme} instance or theme URL
     *                to the theme.
     * @param options - Optional, a {@link ThemeLoadOptions} objects
     *                  containing any custom settings for
     *                  this load request.
     */
    static async load(theme, options) {
        var _a;
        options = options !== null && options !== void 0 ? options : {};
        if (typeof theme === "string") {
            const uriResolver = options.uriResolver;
            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;
            const response = await fetch(themeUrl, { signal: options.signal });
            if (!response.ok) {
                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);
            }
            theme = (await response.json());
            theme.url = themeUrl;
            theme = this.resolveUrls(theme, options);
        }
        else if (theme.url === undefined) {
            // assume that theme url is same as baseUrl
            theme.url = harp_utils_1.getAppBaseUrl();
            theme = this.resolveUrls(theme, options);
        }
        theme.styles = Theme_1.getStyles(theme.styles);
        if (theme === null || theme === undefined) {
            throw new Error("ThemeLoader#load: loaded resource is not valid JSON");
        }
        const resolveDefinitions = harp_utils_1.getOptionValue(options.resolveDefinitions, false);
        theme = await ThemeLoader.resolveBaseThemes(theme, options);
        if (resolveDefinitions) {
            const contextLoader = new harp_utils_1.ContextLogger((_a = options.logger) !== null && _a !== void 0 ? _a : console, `when processing Theme ${theme.url}:`);
            ThemeLoader.resolveThemeReferences(theme, contextLoader);
        }
        return theme;
    }
    /**
     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.
     *
     * @param theme -
     */
    static isThemeLoaded(theme) {
        //TODO: Removed isStylesDictionary check when {@link StylesDictionary} is
        // fully deprecated
        return theme.extends === undefined && !Theme_1.isStylesDictionary(theme.styles);
    }
    /**
     * @deprecated Please use `ThemeLoader.load`
     *
     * Loads a {@link @here/harp-datasource-protocol#Theme} from a remote resource,
     * provided as a URL that points to a JSON-encoded
     * theme.
     *
     * @param themeUrl - The URL to the theme.
     *
     */
    static async loadAsync(themeUrl) {
        return await ThemeLoader.load(themeUrl);
    }
    /**
     * Resolves all {@link @here/harp-datasource-protocol#Theme}'s relatives URLs
     * to full URL using the {@link @here/harp-datasource-protocol#Theme}'s URL
     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
     *
     * This method mutates original `theme` instance.
     *
     * @param theme - The {@link @here/harp-datasource-protocol#Theme} to resolve.
     */
    static resolveUrls(theme, options) {
        // Ensure that all resources referenced in theme by relative URIs are in fact relative to
        // theme.
        if (theme.url === undefined) {
            return theme;
        }
        const childUrlResolver = harp_utils_1.composeUriResolvers(options === null || options === void 0 ? void 0 : options.uriResolver, new harp_utils_1.RelativeUriResolver(theme.url));
        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);
        if (theme.extends && resolveIncludes) {
            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(baseTheme => {
                if (typeof baseTheme === "string") {
                    return childUrlResolver.resolveUri(baseTheme);
                }
                else {
                    if (baseTheme.url !== undefined) {
                        return baseTheme;
                    }
                    else {
                        baseTheme.url = theme.url;
                        return this.resolveUrls(baseTheme, options);
                    }
                }
            });
        }
        const resolveResources = options === undefined || !(options.resolveResourceUris === false);
        if (resolveResources) {
            ThemeLoader.resolveResources(theme, childUrlResolver);
        }
        return theme;
    }
    /**
     * Expand all `ref` expressions in {@link @here/harp-datasource-protocol#Theme}
     * basing on `definitions`.
     *
     * @remarks
     * This method mutates original `theme` instance.
     */
    static resolveThemeReferences(theme, contextLogger) {
        if (theme.styles !== undefined) {
            contextLogger.pushAttr("styles");
            theme.styles = ThemeLoader.resolveStyles(Theme_1.getStyles(theme.styles), theme.definitions, contextLogger);
            contextLogger.pop();
            contextLogger.pop();
        }
        return theme;
    }
    /**
     * Expand all `ref` in [[StyleSet]] basing on `definitions`.
     */
    static resolveStyles(styles, definitions, contextLogger) {
        const result = [];
        for (let index = 0; index < styles.length; ++index) {
            const currentStyle = styles[index];
            contextLogger.pushIndex(index);
            const resolvedStyle = ThemeLoader.resolveStyle(currentStyle, definitions, contextLogger);
            if (resolvedStyle !== undefined) {
                result.push(resolvedStyle);
            }
            else {
                contextLogger.warn("invalid style, ignored");
            }
            contextLogger.pop();
        }
        return result;
    }
    /**
     * Expand all `ref` in [[Style]] instance basing on `definitions`.
     */
    static resolveStyle(style, definitions, contextLogger) {
        if (Array.isArray(style.when)) {
            contextLogger.pushAttr("when");
            const resolvedWhen = this.resolveExpressionReferences(style.when, definitions, contextLogger);
            contextLogger.pop();
            if (resolvedWhen === undefined) {
                return undefined;
            }
            style.when = resolvedWhen;
        }
        if (style.attr !== undefined) {
            const attr = style.attr;
            contextLogger.pushAttr("attr");
            for (const prop in attr) {
                if (!attr.hasOwnProperty(prop)) {
                    continue;
                }
                const value = attr[prop];
                if (!Array.isArray(value)) {
                    continue; // nothing to do
                }
                contextLogger.pushAttr(prop);
                const resolvedValue = this.resolveExpressionReferences(value, definitions, contextLogger);
                contextLogger.pop();
                if (resolvedValue !== undefined) {
                    attr[prop] = resolvedValue;
                }
                else {
                    delete attr[prop];
                }
            }
            contextLogger.pop();
        }
        return style;
    }
    /**
     * Resolve `[ref, ...]` in expressions.
     *
     * Returns `undefined` some reference was invalid (missing or wrong type).
     */
    static resolveExpressionReferences(value, definitions, contextLogger) {
        let failed = false;
        function resolveInternal(node) {
            if (Theme_1.isJsonExprReference(node)) {
                const defName = node[1];
                const def = definitions && definitions[defName];
                if (def === undefined) {
                    contextLogger.warn(`invalid reference '${defName}' - not found`);
                    failed = true;
                    return undefined;
                }
                if (harp_datasource_protocol_1.isJsonExpr(def)) {
                    return def;
                }
                return Theme_1.getDefinitionValue(def);
            }
            else if (Array.isArray(node)) {
                const result = [...node];
                for (let i = 1; i < result.length; ++i) {
                    result[i] = resolveInternal(result[i]);
                }
                return result;
            }
            else {
                return node;
            }
        }
        const r = resolveInternal(value);
        if (failed) {
            return undefined;
        }
        return r;
    }
    /**
     * Realize `extends` clause by merging `theme` with
     * its base {@link @here/harp-datasource-protocol#Theme}.
     *
     * @param theme - {@link @here/harp-datasource-protocol#Theme} object
     * @param options - Optional, a {@link ThemeLoadOptions} objects
     *                  containing any custom settings for
     *                  this load request.
     */
    static async resolveBaseThemes(theme, options) {
        options = options !== null && options !== void 0 ? options : {};
        if (theme.extends === undefined) {
            return theme;
        }
        const maxInheritanceDepth = harp_utils_1.getOptionValue(options.maxInheritanceDepth, exports.DEFAULT_MAX_THEME_INTHERITANCE_DEPTH);
        if (maxInheritanceDepth <= 0) {
            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);
        }
        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;
        delete theme.extends;
        let baseThemesMerged = {};
        for (const baseTheme of baseThemes) {
            const actualBaseTheme = await ThemeLoader.load(baseTheme, Object.assign(Object.assign({}, options), { resolveDefinitions: false, maxInheritanceDepth: maxInheritanceDepth - 1 }));
            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);
        }
        return ThemeLoader.mergeThemes(theme, baseThemesMerged);
    }
    static mergeThemes(theme, baseTheme) {
        const definitions = Object.assign(Object.assign({}, baseTheme.definitions), theme.definitions);
        let styles;
        const baseStyles = Theme_1.getStyles(baseTheme.styles);
        const themeStyles = Theme_1.getStyles(theme.styles);
        if (baseTheme.styles && theme.styles) {
            const newStyles = [];
            const styleIdMap = new Map();
            baseStyles.forEach(style => {
                if (typeof style.id === "string") {
                    //multiple identical style.ids are not supported and will fall back to the
                    //first occurence
                    if (!styleIdMap.has(style.id)) {
                        styleIdMap.set(style.id, newStyles.length);
                    }
                }
                newStyles.push(style);
            });
            themeStyles.forEach(style => {
                if (typeof style.extends === "string" && styleIdMap.has(style.extends)) {
                    // extends the existing style referenced by `style.extends`.
                    const baseStyleIndex = styleIdMap.get(style.extends);
                    const baseStyle = newStyles[baseStyleIndex];
                    newStyles[baseStyleIndex] = Object.assign(Object.assign({}, baseStyle), style);
                    newStyles[baseStyleIndex].extends = undefined;
                    return;
                }
                if (typeof style.id === "string" && styleIdMap.has(style.id)) {
                    // overrides the existing style with `id` equals to `style.id`.
                    const styleIndex = styleIdMap.get(style.id);
                    // only match if the two rules are from the same styleset
                    if (newStyles[styleIndex].styleSet === style.styleSet) {
                        newStyles[styleIndex] = style;
                    }
                    return;
                }
                newStyles.push(style);
            });
            styles = newStyles;
        }
        else if (baseTheme.styles) {
            styles = [...baseStyles];
        }
        else if (theme.styles) {
            styles = [...themeStyles];
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({}, baseTheme), theme), ThemeLoader.mergeImageTextures(theme, baseTheme)), { definitions,
            styles });
    }
    static mergeImageTextures(theme, baseTheme) {
        const images = Object.assign(Object.assign({}, baseTheme.images), theme.images);
        let imageTextures = [];
        if (!baseTheme.imageTextures && theme.imageTextures) {
            imageTextures = theme.imageTextures;
        }
        else if (baseTheme.imageTextures && !theme.imageTextures) {
            imageTextures = baseTheme.imageTextures;
        }
        else if (baseTheme.imageTextures && theme.imageTextures) {
            imageTextures = theme.imageTextures.slice();
            baseTheme.imageTextures.forEach(val => {
                if (!imageTextures.find(({ name }) => name === val.name)) {
                    imageTextures.push(val);
                }
            });
        }
        return {
            images,
            imageTextures
        };
    }
    static resolveResources(theme, childUrlResolver) {
        if (theme.sky && theme.sky.type === "cubemap") {
            for (let i = 0; i < SkyCubemapTexture_1.SKY_CUBEMAP_FACE_COUNT; ++i) {
                const faceUrl = theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]];
                if (faceUrl !== undefined) {
                    theme.sky[SkyCubemapTexture_1.SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);
                }
            }
        }
        if (theme.images) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                image.url = childUrlResolver.resolveUri(image.url);
                if (image.atlas !== undefined) {
                    image.atlas = childUrlResolver.resolveUri(image.atlas);
                }
            }
        }
        if (theme.fontCatalogs) {
            for (const font of theme.fontCatalogs) {
                font.url = childUrlResolver.resolveUri(font.url);
            }
        }
        if (theme.poiTables) {
            for (const poiTable of theme.poiTables) {
                poiTable.url = childUrlResolver.resolveUri(poiTable.url);
            }
        }
        if (theme.styles !== undefined) {
            for (const style of Theme_1.getStyles(theme.styles)) {
                if (!style.attr) {
                    continue;
                }
                ["map", "normalMap", "displacementMap", "roughnessMap"].forEach(texturePropertyName => {
                    const textureProperty = style.attr[texturePropertyName];
                    if (textureProperty && typeof textureProperty === "string") {
                        style.attr[texturePropertyName] = childUrlResolver.resolveUri(textureProperty);
                    }
                });
            }
        }
    }
}
exports.ThemeLoader = ThemeLoader;


/***/ }),

/***/ "../harp-mapview/lib/Tile.ts":
/*!***********************************!*\
  !*** ../harp-mapview/lib/Tile.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = exports.getFeatureDataSize = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const LodMesh_1 = __webpack_require__(/*! ./geometry/LodMesh */ "../harp-mapview/lib/geometry/LodMesh.ts");
const Object3DUtils_1 = __webpack_require__(/*! ./geometry/Object3DUtils */ "../harp-mapview/lib/geometry/Object3DUtils.ts");
const TileGeometryLoader_1 = __webpack_require__(/*! ./geometry/TileGeometryLoader */ "../harp-mapview/lib/geometry/TileGeometryLoader.ts");
const ITileLoader_1 = __webpack_require__(/*! ./ITileLoader */ "../harp-mapview/lib/ITileLoader.ts");
const Statistics_1 = __webpack_require__(/*! ./Statistics */ "../harp-mapview/lib/Statistics.ts");
const TextElement_1 = __webpack_require__(/*! ./text/TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementGroup_1 = __webpack_require__(/*! ./text/TextElementGroup */ "../harp-mapview/lib/text/TextElementGroup.ts");
const TextElementGroupPriorityList_1 = __webpack_require__(/*! ./text/TextElementGroupPriorityList */ "../harp-mapview/lib/text/TextElementGroupPriorityList.ts");
const TileTextStyleCache_1 = __webpack_require__(/*! ./text/TileTextStyleCache */ "../harp-mapview/lib/text/TileTextStyleCache.ts");
const logger = harp_utils_1.LoggerManager.instance.create("Tile");
/**
 * Minimum estimated size of a JS object.
 */
const MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;
const MINIMUM_OBJECT_SIZE_ESTIMATION = 100;
/**
 * Compute the memory footprint of `TileFeatureData`.
 *
 * @internal
 */
function getFeatureDataSize(featureData) {
    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;
    if (featureData.starts !== undefined) {
        numBytes += featureData.starts.length * 8;
    }
    if (featureData.objInfos !== undefined) {
        // 16 (estimated) bytes per objInfos
        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;
    }
    return numBytes;
}
exports.getFeatureDataSize = getFeatureDataSize;
/**
 * The class that holds the tiled data for a {@link DataSource}.
 */
class Tile {
    /**
     * Creates a new {@link Tile}.
     *
     * @param dataSource - The {@link DataSource} that created this {@link Tile}.
     * @param tileKey - The unique identifier for this {@link Tile}.
     *                  Currently only up to level 24 is
     *                  supported, because of the use of the upper bits for the offset.
     * @param offset - The optional offset, this is an integer which represents what multiple of 360
     *                 degrees to shift, only useful for flat projections, hence optional.
     * @param localTangentSpace - Whether the tile geometry is in local tangent space or not.
     */
    constructor(dataSource, tileKey, offset = 0, localTangentSpace) {
        this.dataSource = dataSource;
        this.tileKey = tileKey;
        /**
         * A list of the THREE.js objects stored in this `Tile`.
         */
        this.objects = [];
        /**
         * The optional list of HERE TileKeys of tiles with geometries that cross the boundaries of this
         * `Tile`.
         */
        this.dependencies = [];
        /**
         * Keeping some stats for the individual {@link Tile}s to analyze caching behavior.
         *
         * The frame the {@link Tile} was last requested. This is
         * required to know when the given {@link Tile}
         * can be removed from the cache.
         */
        this.frameNumLastRequested = -1;
        /**
         * The frame the `Tile` was first visible.
         */
        this.frameNumVisible = -1;
        /**
         * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine
         * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is
         * visible.
         */
        this.frameNumLastVisible = -1;
        /**
         * After removing from cache, this is the number of frames the `Tile` was visible.
         */
        this.numFramesVisible = 0;
        /**
         * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the
         * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of
         * computing visibility.
         */
        this.visibilityCounter = -1;
        /**
         * @hidden
         *
         * Used to tell if the Tile is used temporarily as a fallback tile.
         *
         * levelOffset is in in the range [-quadTreeSearchDistanceUp,
         * quadTreeSearchDistanceDown], where these values come from the
         * {@link VisibleTileSetOptions}
         */
        this.levelOffset = 0;
        /**
         * If the tile should not be rendered, this is used typically when the tile in question
         * is completely covered by another tile and therefore can be skipped without any visual
         * impact. Setting this value directly affects the [[willRender]] method, unless
         * overriden by deriving classes.
         */
        this.skipRendering = false;
        /**
         * If the tile should not yet be rendered, this is used typically when the tile in question
         * does not fit into the gpu upload limit of the current frame.
         * Setting this value directly affects the [[willRender]] method, unless
         * overriden by deriving classes.
         */
        this.delayRendering = false;
        /**
         * The bounding box of this `Tile` in world coordinates.
         */
        this.m_boundingBox = new harp_geoutils_1.OrientedBox3();
        this.m_disposed = false;
        this.m_forceHasGeometry = undefined;
        // Used for {@link TextElement}s that are stored in the data, and that are placed explicitly,
        // fading in and out.
        this.m_textElementGroups = new TextElementGroupPriorityList_1.TextElementGroupPriorityList();
        // Blocks other labels from showing.
        this.m_pathBlockingElements = [];
        // Center of the tile's un-elevated bounding box world coordinates.
        this.m_worldCenter = new THREE.Vector3();
        this.m_visibleArea = 0;
        // Tile elevation range in meters
        this.m_elevationRange = { minElevation: 0, maxElevation: 0 };
        // List of owned textures for disposal
        this.m_ownedTextures = new WeakSet();
        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);
        this.updateBoundingBox();
        this.m_worldCenter.copy(this.boundingBox.position);
        this.m_localTangentSpace = localTangentSpace !== null && localTangentSpace !== void 0 ? localTangentSpace : false;
        this.m_textStyleCache = new TileTextStyleCache_1.TileTextStyleCache(this);
        this.m_offset = offset;
        this.m_uniqueKey = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);
        if (dataSource.useGeometryLoader) {
            this.m_tileGeometryLoader = new TileGeometryLoader_1.TileGeometryLoader(this, this.mapView.taskQueue);
            this.attachGeometryLoadedCallback();
        }
    }
    /**
     * The visibility status of the {@link Tile}. It is actually
     * visible or planned to become visible.
     */
    get isVisible() {
        // Tiles are not evaluated as invisible until the second frame they aren't requested.
        // This happens in order to prevent that, during VisibleTileSet visibility evaluation,
        // visible tiles that haven't yet been evaluated for the current frame are preemptively
        // removed from [[DataSourceCache]].
        // There is cases when a tile was already removed from the MapView, i.e. the PolaCaps
        // Datasource might get remove on a change of projection, in this case
        // this.dataSource.mapView will throw an error
        try {
            return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;
        }
        catch (error) {
            logger.debug(error);
            return false;
        }
    }
    /**
     * Sets the tile visibility status.
     * @param visible - `True` to mark the tile as visible, `False` otherwise.
     */
    set isVisible(visible) {
        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;
        if (!visible && this.m_tileGeometryLoader && !this.m_tileGeometryLoader.isSettled) {
            this.m_tileGeometryLoader.cancel();
        }
    }
    /**
     * The {@link @here/harp-geoutils#Projection} currently used by the {@link MapView}.
     */
    get projection() {
        return this.dataSource.projection;
    }
    /**
     * The {@link MapView} this `Tile` belongs to.
     */
    get mapView() {
        return this.dataSource.mapView;
    }
    /**
     * Whether the data of this tile is in local tangent space or not.
     *
     * @remarks
     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then
     * {@link MapView} will rotate the objects before rendering using the rotation matrix of the
     * oriented [[boundingBox]].
     */
    get localTangentSpace() {
        return this.m_localTangentSpace;
    }
    /*
     * The size of this Tile in system memory.
     */
    get memoryUsage() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo.heapSize;
    }
    /**
     * The center of this `Tile` in world coordinates.
     */
    get center() {
        return this.m_worldCenter;
    }
    /**
     * Gets the key to uniquely represent this tile (based on
     * the {@link tileKey} and {@link offset}).
     *
     * @remarks
     * This key is only unique within the given {@link DataSource},
     * to get a key which is unique across
     * {@link DataSource}s see [[DataSourceCache.getKeyForTile]].
     */
    get uniqueKey() {
        return this.m_uniqueKey;
    }
    /**
     * The optional offset, this is an integer which represents what multiple of 360 degrees to
     * shift, only useful for flat projections, hence optional.
     */
    get offset() {
        return this.m_offset;
    }
    /**
     * The optional offset, this is an integer which represents what multiple of 360 degrees to
     * shift, only useful for flat projections, hence optional.
     * @param offset - Which multiple of 360 degrees to apply to the {@link Tile}.
     */
    set offset(offset) {
        if (this.m_offset !== offset) {
            this.m_uniqueKey = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);
        }
        this.m_offset = offset;
    }
    /**
     * Compute {@link TileResourceInfo} of this `Tile`.
     *
     * @remarks
     * May be using a cached value. The method
     * `invalidateResourceInfo` can be called beforehand to force a recalculation.
     *
     * @returns `TileResourceInfo` for this `Tile`.
     */
    getResourceInfo() {
        if (this.m_resourceInfo === undefined) {
            this.computeResourceInfo();
        }
        return this.m_resourceInfo;
    }
    /**
     * Force invalidation of the cached {@link TileResourceInfo}.
     *
     * @remarks
     * Useful after the `Tile` has been
     * modified.
     */
    invalidateResourceInfo() {
        this.m_resourceInfo = undefined;
    }
    /**
     * Add ownership of a texture to this tile.
     *
     * @remarks
     * The texture will be disposed if the `Tile` is disposed.
     * @param texture - Texture to be owned by the `Tile`
     */
    addOwnedTexture(texture) {
        this.m_ownedTextures.add(texture);
    }
    /**
     * @internal
     * @deprecated User text elements are deprecated.
     *
     * Gets the list of developer-defined {@link TextElement} in this `Tile`.
     *
     * @remarks
     * This list is always rendered first.
     */
    get userTextElements() {
        let group = this.m_textElementGroups.groups.get(TextElement_1.TextElement.HIGHEST_PRIORITY);
        if (group === undefined) {
            group = new TextElementGroup_1.TextElementGroup(TextElement_1.TextElement.HIGHEST_PRIORITY);
            this.m_textElementGroups.groups.set(group.priority, group);
        }
        return group;
    }
    /**
     * Adds a developer-defined {@link TextElement} to this `Tile`.
     *
     * @remarks
     * The {@link TextElement} is always
     * visible, if it's in the map's currently visible area.
     *
     * @deprecated use [[addTextElement]].
     *
     * @param textElement - The Text element to add.
     */
    addUserTextElement(textElement) {
        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;
        this.addTextElement(textElement);
    }
    /**
     * Removes a developer-defined {@link TextElement} from this `Tile`.
     *
     * @deprecated use `removeTextElement`.
     *
     * @param textElement - A developer-defined TextElement to remove.
     * @returns `true` if the element has been removed successfully; `false` otherwise.
     */
    removeUserTextElement(textElement) {
        textElement.priority = TextElement_1.TextElement.HIGHEST_PRIORITY;
        return this.removeTextElement(textElement);
    }
    /**
     * Adds a {@link TextElement} to this `Tile`, which is added to the visible set of
     * {@link TextElement}s based on the capacity and visibility.
     *
     * @remarks
     * The {@link TextElement}'s priority controls if or when it becomes visible.
     *
     * To ensure that a TextElement is visible, use a high value for its priority, such as
     * `TextElement.HIGHEST_PRIORITY`. Since the number of visible TextElements is limited by the
     * screen space, not all TextElements are visible at all times.
     *
     * @param textElement - The TextElement to add.
     */
    addTextElement(textElement) {
        this.textElementGroups.add(textElement);
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Clone all groups so that they are handled as new element groups
            // by TextElementsRenderer and it doesn't try to reuse the same state stored
            // for the old groups.
            this.m_textElementGroups = this.textElementGroups.clone();
        }
        this.textElementsChanged = true;
    }
    /**
     * Adds a `PathBlockingElement` to this `Tile`.
     *
     * @remarks
     * This path has the highest priority and blocks
     * all other labels. There maybe in future a use case to give it a priority, but as that isn't
     * yet required, it is left to be implemented later if required.
     * @param blockingElement - Element which should block all other labels.
     */
    addBlockingElement(blockingElement) {
        this.m_pathBlockingElements.push(blockingElement);
    }
    /**
     * Removes a {@link TextElement} from this `Tile`.
     *
     * @remarks
     * For the element to be removed successfully, the
     * priority of the {@link TextElement} has to be equal to its priority when it was added.
     *
     * @param textElement - The TextElement to remove.
     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.
     */
    removeTextElement(textElement) {
        const groups = this.textElementGroups;
        if (!groups.remove(textElement)) {
            return false;
        }
        if (this.m_textElementsChanged === false) {
            // HARP-8733: Clone all groups so that they are handled as new element groups
            // by TextElementsRenderer and it doesn't try to reuse the same state stored
            // for the old groups.
            this.m_textElementGroups = groups.clone();
        }
        this.textElementsChanged = true;
        return true;
    }
    /**
     * @internal
     *
     * Gets the current `GroupedPriorityList` which
     * contains a list of all {@link TextElement}s to be
     * selected and placed for rendering.
     */
    get textElementGroups() {
        return this.m_textElementGroups;
    }
    /**
     * Gets the current modification state for the list
     * of {@link TextElement}s in the `Tile`.
     *
     * @remarks
     * If the value is `true` the `TextElement` is placed for
     * rendering during the next frame.
     */
    get textElementsChanged() {
        var _a;
        return (_a = this.m_textElementsChanged) !== null && _a !== void 0 ? _a : false;
    }
    set textElementsChanged(changed) {
        this.m_textElementsChanged = changed;
    }
    /**
     * Returns true if the `Tile` has any text elements to render.
     */
    hasTextElements() {
        return this.m_textElementGroups.count() > 0;
    }
    /**
     * Get the current blocking elements.
     */
    get blockingElements() {
        return this.m_pathBlockingElements;
    }
    /**
     * Called before {@link MapView} starts rendering this `Tile`.
     *
     * @remarks
     * @param zoomLevel - The current zoom level.
     * @returns Returns `true` if this `Tile` should be rendered. Influenced directly by the
     *      `skipRendering` property unless specifically overriden in deriving classes.
     */
    willRender(_zoomLevel) {
        return !this.skipRendering && !this.delayRendering;
    }
    /**
     * Called after {@link MapView} has rendered this `Tile`.
     */
    didRender() {
        // to be overridden by subclasses
    }
    /**
     * Estimated visible area of tile used for sorting the priorities during loading.
     */
    get visibleArea() {
        return this.m_visibleArea;
    }
    set visibleArea(area) {
        this.m_visibleArea = area;
        if (this.tileLoader !== undefined) {
            this.tileLoader.priority = area;
        }
    }
    /**
     * @internal
     * Gets the tile's ground elevation range in meters.
     */
    get elevationRange() {
        return this.m_elevationRange;
    }
    /**
     * @internal
     * Sets the tile's ground elevation range in meters.
     *
     * @param elevationRange - The elevation range.
     */
    set elevationRange(elevationRange) {
        var _a;
        if (elevationRange.minElevation === this.m_elevationRange.minElevation &&
            elevationRange.maxElevation === this.m_elevationRange.maxElevation &&
            elevationRange.calculationStatus === this.m_elevationRange.calculationStatus) {
            return;
        }
        this.m_elevationRange.minElevation = elevationRange.minElevation;
        this.m_elevationRange.maxElevation = elevationRange.maxElevation;
        this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;
        this.elevateGeoBox();
        // Only update bounding box if tile has already been decoded and a maximum/minimum geometry
        // height is provided by the data source.
        if (this.m_maxGeometryHeight !== undefined || this.m_minGeometryHeight !== undefined) {
            harp_utils_1.assert(((_a = this.decodedTile) === null || _a === void 0 ? void 0 : _a.boundingBox) === undefined);
            this.updateBoundingBox();
        }
    }
    /**
     * Gets the decoded tile; it is removed after geometry handling.
     */
    get decodedTile() {
        return this.m_decodedTile;
    }
    /**
     * Applies the decoded tile to the tile.
     *
     * @remarks
     * If the geometry is empty, then the tile's forceHasGeometry flag is set.
     * Map is updated.
     * @param decodedTile - The decoded tile to set.
     */
    set decodedTile(decodedTile) {
        var _a, _b;
        this.m_decodedTile = decodedTile;
        this.invalidateResourceInfo();
        if (decodedTile === undefined) {
            return;
        }
        if (decodedTile.geometries.length === 0) {
            this.forceHasGeometry(true);
        }
        // If the decoder provides a more accurate bounding box than the one we computed from
        // the flat geo box we take it instead. Otherwise, if an elevation range was set, elevate
        // bounding box to match the elevated geometry.
        this.m_maxGeometryHeight = decodedTile.boundingBox
            ? undefined
            : (_a = decodedTile.maxGeometryHeight) !== null && _a !== void 0 ? _a : 0;
        this.m_minGeometryHeight = decodedTile.boundingBox
            ? undefined
            : (_b = decodedTile.minGeometryHeight) !== null && _b !== void 0 ? _b : 0;
        this.elevateGeoBox();
        this.updateBoundingBox(decodedTile.boundingBox);
        const stats = Statistics_1.PerformanceStatistics.instance;
        if (stats.enabled && decodedTile.decodeTime !== undefined) {
            stats.currentFrame.addValue("decode.decodingTime", decodedTile.decodeTime);
            stats.currentFrame.addValue("decode.decodedTiles", 1);
        }
        if (decodedTile.copyrightHolderIds !== undefined) {
            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));
        }
        this.dataSource.requestUpdate();
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free the geometry of a `Tile` object.
     *
     * @param object - The object that references the geometry.
     * @returns `true` if the geometry can be disposed.
     */
    shouldDisposeObjectGeometry(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a `Tile` object's material.
     *
     * @param object - The object referencing the geometry.
     * @returns `true` if the material can be disposed.
     */
    shouldDisposeObjectMaterial(object) {
        return true;
    }
    /**
     * Called when the default implementation of `dispose()` needs
     * to free a Texture that is part of a `Tile` object's material.
     *
     * @param texture - The texture about to be disposed.
     * @returns `true` if the texture can be disposed.
     */
    shouldDisposeTexture(texture) {
        return this.m_ownedTextures.has(texture);
    }
    /**
     * Returns `true` if this `Tile` has been disposed.
     */
    get disposed() {
        return this.m_disposed;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded.
     */
    get allGeometryLoaded() {
        var _a, _b;
        return (_b = (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.isFinished) !== null && _b !== void 0 ? _b : this.hasGeometry;
    }
    /**
     * MapView checks if this `Tile` is ready to be rendered while culling.
     *
     * By default, MapView checks if the [[objects]] list is not empty. However, you can override
     * this check by manually setting this property.
     */
    get hasGeometry() {
        if (this.m_forceHasGeometry === undefined) {
            return this.objects.length !== 0;
        }
        else {
            return this.m_forceHasGeometry;
        }
    }
    /**
     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.
     *
     * @param value - A new value for the [[hasGeometry]] flag.
     */
    forceHasGeometry(value) {
        this.m_forceHasGeometry = value;
    }
    /**
     * Reset the visibility counter. This will force the visibility check to be rerun on all objects
     * in this `Tile`.
     */
    resetVisibilityCounter() {
        this.visibilityCounter = -1;
    }
    /**
     * Gets the {@link ITileLoader} that manages this tile.
     */
    get tileLoader() {
        return this.m_tileLoader;
    }
    /**
     * Sets the {@link ITileLoader} to manage this tile.
     *
     * @param tileLoader - A {@link ITileLoader} instance to manage
     *                     the loading process for this tile.
     */
    set tileLoader(tileLoader) {
        this.m_tileLoader = tileLoader;
    }
    /**
     * Loads this `Tile` geometry.
     *
     * @returns Promise which can be used to wait for the loading to be finished.
     */
    async load() {
        const tileLoader = this.tileLoader;
        if (tileLoader === undefined) {
            return await Promise.resolve();
        }
        if (this.m_tileGeometryLoader) {
            const wasSettled = this.m_tileGeometryLoader.isSettled;
            this.m_tileGeometryLoader.reset();
            if (wasSettled) {
                this.attachGeometryLoadedCallback();
            }
        }
        return await tileLoader
            .loadAndDecode()
            .then(tileLoaderState => {
            var _a;
            harp_utils_1.assert(tileLoaderState === ITileLoader_1.TileLoaderState.Ready);
            const decodedTile = tileLoader.decodedTile;
            this.decodedTile = decodedTile;
            (_a = decodedTile === null || decodedTile === void 0 ? void 0 : decodedTile.dependencies) === null || _a === void 0 ? void 0 : _a.forEach(mortonCode => {
                this.dependencies.push(harp_geoutils_1.TileKey.fromMortonCode(mortonCode));
            });
        })
            .catch(tileLoaderState => {
            if (tileLoaderState === ITileLoader_1.TileLoaderState.Failed) {
                this.dispose();
            }
            else if (tileLoaderState !== ITileLoader_1.TileLoaderState.Canceled) {
                logger.error("Unknown error" + tileLoaderState);
            }
        });
    }
    /**
     * Text style cache for this tile.
     * @hidden
     */
    get textStyleCache() {
        return this.m_textStyleCache;
    }
    /**
     * Frees the rendering resources allocated by this `Tile`.
     *
     * @remarks
     * The default implementation of this method frees the geometries and the materials for all the
     * reachable objects.
     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this
     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).
     */
    clear() {
        const disposeMaterial = (material) => {
            Object.getOwnPropertyNames(material).forEach((property) => {
                const materialProperty = material[property];
                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {
                    const texture = materialProperty;
                    if (this.shouldDisposeTexture(texture)) {
                        texture.dispose();
                    }
                }
            });
            material.dispose();
        };
        const disposeObject = (object) => {
            if (this.shouldDisposeObjectGeometry(object)) {
                if (object.geometry !== undefined) {
                    object.geometry.dispose();
                }
                if (object.geometries !== undefined) {
                    for (const geometry of object.geometries) {
                        geometry.dispose();
                    }
                }
            }
            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {
                if (object.material instanceof Array) {
                    object.material.forEach((material) => {
                        if (material !== undefined) {
                            disposeMaterial(material);
                        }
                    });
                }
                else {
                    disposeMaterial(object.material);
                }
            }
        };
        this.objects.forEach((rootObject) => {
            rootObject.traverse((object) => {
                disposeObject(object);
            });
            disposeObject(rootObject);
        });
        this.objects.length = 0;
        if (this.preparedTextPaths) {
            this.preparedTextPaths = [];
        }
        this.m_textStyleCache.clear();
        this.clearTextElements();
        this.invalidateResourceInfo();
    }
    /**
     * Removes all {@link TextElement} from the tile.
     */
    clearTextElements() {
        if (!this.hasTextElements()) {
            return;
        }
        this.textElementsChanged = true;
        this.m_pathBlockingElements.splice(0);
        this.textElementGroups.forEach((element) => {
            element.dispose();
        });
        this.textElementGroups.clear();
    }
    /**
     * Adds a callback that will be called whenever the tile is disposed.
     *
     * @remarks
     * Multiple callbacks may be added.
     * @internal
     * @param callback - The callback to be called when the tile is disposed.
     */
    addDisposeCallback(callback) {
        this.m_disposeCallback = harp_utils_1.chainCallbacks(this.m_disposeCallback, callback);
    }
    /**
     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.
     */
    dispose() {
        var _a;
        if (this.m_disposed) {
            return;
        }
        if (this.m_tileLoader) {
            this.m_tileLoader.cancel();
            this.m_tileLoader = undefined;
        }
        this.clear();
        // Ensure that tile is removable from tile cache.
        this.frameNumLastRequested = 0;
        this.m_disposed = true;
        (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.dispose();
        if (this.m_disposeCallback) {
            this.m_disposeCallback(this);
        }
    }
    /**
     * Computes the offset in the x world coordinates corresponding to this tile, based on
     * its {@link offset}.
     *
     * @returns The x offset.
     */
    computeWorldOffsetX() {
        return this.projection.worldExtent(0, 0).max.x * this.offset;
    }
    /**
     * Update tile for current map view zoom level
     * @param zoomLevel - Zoom level of the map view
     * @internal
     */
    update(zoomLevel) {
        for (const object of this.objects) {
            if (object instanceof LodMesh_1.LodMesh) {
                object.setLevelOfDetail(zoomLevel - this.tileKey.level);
            }
        }
    }
    /**
     * Gets the tile's bounding box.
     */
    get boundingBox() {
        return this.m_boundingBox;
    }
    /**
     * Start with or continue with loading geometry for tiles requiring this step. Called
     * repeatedly until loading is finished.
     * @param priority - Priority assigned to asynchronous tasks doing the geometry update.
     * @param enabledKinds - {@link GeometryKind}s that will be created.
     * @param disabledKinds - {@link GeometryKind}s that will not be created.
     * @return `true` if tile uses a geometry loader, `false` otherwise.
     * @internal
     */
    updateGeometry(priority, enabledKinds, disabledKinds) {
        if (!this.m_tileGeometryLoader) {
            return false;
        }
        if (this.m_tileGeometryLoader.isSettled) {
            return true;
        }
        if (this.dataSource.isDetached()) {
            this.m_tileGeometryLoader.cancel();
            return true;
        }
        if (this.tileLoader) {
            if (!this.tileLoader.isFinished) {
                return true;
            }
            else if (!this.decodedTile) {
                // Finish loading if tile has no data.
                this.m_tileGeometryLoader.finish();
                return true;
            }
        }
        if (priority !== undefined) {
            this.m_tileGeometryLoader.priority = priority;
        }
        this.m_tileGeometryLoader.update(enabledKinds, disabledKinds);
        return true;
    }
    /**
     * Gets a set of the {@link GeometryKind}s that were loaded (if any).
     * @internal
     */
    get loadedGeometryKinds() {
        var _a;
        return (_a = this.m_tileGeometryLoader) === null || _a === void 0 ? void 0 : _a.availableGeometryKinds;
    }
    /**
     * Called when {@link TileGeometryLoader} is finished.
     *
     * @remarks
     * It may be used to add content to the `Tile`.
     * The {@link @here/harp-datasource-protocol#DecodedTile} is still available.
     */
    loadingFinished() {
        // To be used in subclasses.
    }
    attachGeometryLoadedCallback() {
        harp_utils_1.assert(this.m_tileGeometryLoader !== undefined);
        this.m_tileGeometryLoader.waitFinished()
            .then(() => {
            this.loadingFinished();
            this.removeDecodedTile();
        })
            .catch(() => {
            if (this.disposed) {
                return;
            }
            // Loader was canceled, dispose tile.
            if (!this.dataSource.isDetached()) {
                this.mapView.visibleTileSet.disposeTile(this);
            }
        });
    }
    /**
     * Remove the decodedTile when no longer needed.
     */
    removeDecodedTile() {
        this.m_decodedTile = undefined;
        this.invalidateResourceInfo();
    }
    /**
     * Updates the tile's world bounding box.
     * @param newBoundingBox - The new bounding box to set. If undefined, the bounding box will be
     *                         computed by projecting the tile's geoBox.
     */
    updateBoundingBox(newBoundingBox) {
        if (newBoundingBox) {
            this.m_boundingBox.copy(newBoundingBox);
            this.m_worldCenter.copy(this.boundingBox.position);
        }
        else {
            this.projection.projectBox(this.geoBox, this.boundingBox);
        }
    }
    /**
     * Elevates the tile's geo box using the elevation range and maximum geometry height.
     */
    elevateGeoBox() {
        var _a, _b;
        this.geoBox.southWest.altitude =
            this.m_elevationRange.minElevation + ((_a = this.m_minGeometryHeight) !== null && _a !== void 0 ? _a : 0);
        this.geoBox.northEast.altitude =
            this.m_elevationRange.maxElevation + ((_b = this.m_maxGeometryHeight) !== null && _b !== void 0 ? _b : 0);
    }
    computeResourceInfo() {
        let heapSize = 0;
        let num3dObjects = 0;
        let numTextElements = 0;
        const aggregatedObjSize = {
            heapSize: 0,
            gpuSize: 0
        };
        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.
        // They should be counted only once even if they are shared.
        const visitedObjects = new Map();
        for (const object of this.objects) {
            if (object.visible) {
                num3dObjects++;
            }
            Object3DUtils_1.Object3DUtils.estimateSize(object, aggregatedObjSize, visitedObjects);
        }
        for (const group of this.textElementGroups.groups) {
            numTextElements += group[1].elements.length;
        }
        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes
        // was the minimum retained size of a TextElement that was not being rendered. If a
        // TextElement is actually rendered, the size may be _much_ bigger.
        heapSize += numTextElements * 312;
        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {
            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;
        }
        this.m_resourceInfo = {
            heapSize: aggregatedObjSize.heapSize + heapSize,
            gpuSize: aggregatedObjSize.gpuSize,
            num3dObjects,
            numTextElements,
            numUserTextElements: 0
        };
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "../harp-mapview/lib/TileObjectsRenderer.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/TileObjectsRenderer.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileObjectRenderer = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const SolidLineMesh_1 = __webpack_require__(/*! ./geometry/SolidLineMesh */ "../harp-mapview/lib/geometry/SolidLineMesh.ts");
const MapObjectAdapter_1 = __webpack_require__(/*! ./MapObjectAdapter */ "../harp-mapview/lib/MapObjectAdapter.ts");
const DEFAULT_STENCIL_VALUE = 1;
class TileObjectRenderer {
    constructor(m_env, m_renderer) {
        this.m_env = m_env;
        this.m_renderer = m_renderer;
        this.m_renderOrderStencilValues = new Map();
        // Valid values start at 1, because the screen is cleared to zero
        this.m_stencilValue = DEFAULT_STENCIL_VALUE;
    }
    render(tile, storageLevel, zoomLevel, cameraPosition, rootNode) {
        const worldOffsetX = tile.computeWorldOffsetX();
        if (tile.willRender(storageLevel)) {
            for (const object of tile.objects) {
                const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
                if (!this.processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter)) {
                    continue;
                }
                this.updateStencilRef(object);
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(cameraPosition);
                if (tile.localTangentSpace) {
                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                }
                object.frustumCulled = false;
                rootNode.add(object);
            }
            tile.didRender();
        }
    }
    prepareRender() {
        this.m_stencilValue = DEFAULT_STENCIL_VALUE;
        this.m_renderOrderStencilValues.clear();
    }
    /**
     * Prepares the sorting of tile objects.
     */
    setupRenderer() {
        /**
         * Custom sorting function to avoid non-deterministic IBCT testcases. It's basically a copy
         * of the three.js internal sorting, see:
         * https://github.com/mrdoob/three.js/blob/r118/src/renderers/webgl/WebGLRenderLists.js#L5
         * but additionally checking tile-id before checking object.id, material.id and program.id
         * b/c these ids are generated by incrementing a counter. This means if for two test
         * executions the tiles are processed in a different order the ids hence draw call order
         * will also be different.
         */
        const stableSort = (a, b) => {
            if (a.groupOrder !== b.groupOrder) {
                return a.groupOrder - b.groupOrder;
            }
            else if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            }
            else if (a.object.userData.tileKey &&
                b.object.userData.tileKey &&
                a.object.userData.tileKey.mortonCode() !== b.object.userData.tileKey.mortonCode()) {
                return (a.object.userData.tileKey.mortonCode() - b.object.userData.tileKey.mortonCode());
            }
            else if (a.program !== b.program) {
                return a.program.id - b.program.id;
            }
            else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
            }
            else if (a.z !== b.z) {
                return a.z - b.z;
            }
            else {
                return a.id - b.id;
            }
        };
        // Custom sorting function which first sorts by the data source order, then by the level,
        // then by the function `stableSort` above.
        const painterSortStable = (a, b) => {
            var _a, _b, _c, _d;
            const mapObjectAdapterA = MapObjectAdapter_1.MapObjectAdapter.get(a.object);
            const mapObjectAdapterB = MapObjectAdapter_1.MapObjectAdapter.get(b.object);
            const dataSourceOrder = (_a = mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : mapObjectAdapterA.dataSource) === null || _a === void 0 ? void 0 : _a.dataSourceOrder;
            const otherDataSourceOrder = (_b = mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : mapObjectAdapterB.dataSource) === null || _b === void 0 ? void 0 : _b.dataSourceOrder;
            if (
            // We need to check against undefined because if either is 0, it will evaluate false
            dataSourceOrder !== undefined &&
                otherDataSourceOrder !== undefined &&
                dataSourceOrder !== otherDataSourceOrder) {
                return dataSourceOrder - otherDataSourceOrder;
            }
            // Background data source must be sorted by rendorOrder and not level, otherwise
            // fallback tiles are useless, because they will be covered by this datasource
            if (a.renderOrder === BackgroundDataSource_1.BackgroundDataSource.GROUND_RENDER_ORDER ||
                b.renderOrder === BackgroundDataSource_1.BackgroundDataSource.GROUND_RENDER_ORDER) {
                return stableSort(a, b);
            }
            if ((mapObjectAdapterA === null || mapObjectAdapterA === void 0 ? void 0 : mapObjectAdapterA.level) !== undefined && (mapObjectAdapterB === null || mapObjectAdapterB === void 0 ? void 0 : mapObjectAdapterB.level) !== undefined) {
                // Extruded buildings may interfere with landmarks, so we need to sort by
                // renderOrder, see LandmarkDataSource.computeRenderOrder
                const eitherIsBuilding = ((_c = mapObjectAdapterA.kind) === null || _c === void 0 ? void 0 : _c.find(s => s === "building")) !== undefined ||
                    ((_d = mapObjectAdapterB.kind) === null || _d === void 0 ? void 0 : _d.find(s => s === "building")) !== undefined;
                const sameLevel = mapObjectAdapterA.level === mapObjectAdapterB.level;
                if (sameLevel || eitherIsBuilding) {
                    return stableSort(a, b);
                }
                return mapObjectAdapterA.level - mapObjectAdapterB.level;
            }
            return stableSort(a, b);
        };
        // Temporary workaround due to incorrect comparator type definition:
        // https://github.com/three-types/three-ts-types/issues/41
        this.m_renderer.setOpaqueSort(painterSortStable);
    }
    updateStencilRef(object) {
        // TODO: acquire a new style value of if transparent
        if (object.renderOrder !== undefined && object instanceof SolidLineMesh_1.SolidLineMesh) {
            const material = object.material;
            if (Array.isArray(material)) {
                material.forEach(mat => (mat.stencilRef = this.getStencilValue(object.renderOrder)));
            }
            else {
                material.stencilRef = this.getStencilValue(object.renderOrder);
            }
        }
    }
    allocateStencilValue(renderOrder) {
        const stencilValue = this.m_stencilValue++;
        this.m_renderOrderStencilValues.set(renderOrder, stencilValue);
        return stencilValue;
    }
    getStencilValue(renderOrder) {
        var _a;
        return ((_a = this.m_renderOrderStencilValues.get(renderOrder)) !== null && _a !== void 0 ? _a : this.allocateStencilValue(renderOrder));
    }
    /**
     * Process dynamic updates of [[TileObject]]'s style.
     *
     * @returns `true` if object shall be used in scene, `false` otherwise
     */
    processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter) {
        if (!object.visible) {
            return false;
        }
        if (!this.processTileObjectFeatures(tile, storageLevel, zoomLevel, object)) {
            return false;
        }
        if (mapObjectAdapter) {
            mapObjectAdapter.ensureUpdated(tile.mapView);
            if (!mapObjectAdapter.isVisible() &&
                !(mapObjectAdapter.pickability === harp_datasource_protocol_1.Pickability.all)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Process the features owned by the given `TileObject`.
     *
     * @param tile - The {@link Tile} owning the `TileObject`'s features.
     * @param storageLevel - The storage level of the `Tile` containing the object,
     * @param zoomLevel - The current zoom level of `MapView`.
     * @param object - The `TileObject` to process.
     * @returns `false` if the given `TileObject` should not be added to the scene.
     */
    processTileObjectFeatures(tile, storageLevel, zoomLevel, object) {
        var _a, _b;
        const technique = object.userData.technique;
        const minZoomLevel = harp_datasource_protocol_1.getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.minZoomLevel, this.m_env);
        const maxZoomLevel = harp_datasource_protocol_1.getPropertyValue(technique === null || technique === void 0 ? void 0 : technique.maxZoomLevel, this.m_env);
        if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
            return false;
        }
        if (typeof maxZoomLevel === "number" && zoomLevel >= maxZoomLevel) {
            return false;
        }
        if ((technique === null || technique === void 0 ? void 0 : technique.enabled) === undefined) {
            // Nothing to do, there's no technique.
            return true;
        }
        const feature = object.userData.feature;
        if (!feature || !harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
            return Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, this.m_env));
        }
        const { starts, objInfos } = feature;
        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {
            // Nothing to do, the object is missing feature ids and their position
            // in the index buffer.
            return true;
        }
        const geometry = object.geometry;
        if (!geometry || !geometry.isBufferGeometry) {
            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]
            // and we can't generate groups.
            return true;
        }
        // ExtrudeBufferGeometry for example doesn't have an index, hence we get the final index
        // from the number of vertices.
        const finalIndex = (_b = (_a = geometry.getIndex()) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : geometry.attributes.position.count;
        // clear the groups.
        geometry.clearGroups();
        // The offset in the index buffer of the end of the last
        // pushed group.
        let endOfLastGroup;
        objInfos.forEach((properties, featureIndex) => {
            var _a, _b;
            // the id of the current feature.
            const featureId = harp_datasource_protocol_1.getFeatureId(properties);
            let enabled = true;
            if (harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
                // the state of current feature.
                const featureState = tile.dataSource.getFeatureState(featureId);
                // create a new {@link @here/harp-datasource-protocol#Env} that can be used
                // to evaluate expressions that access the feature state.
                const $state = featureState ? new harp_datasource_protocol_1.MapEnv(featureState) : null;
                const parentEnv = typeof properties === "object"
                    ? new harp_datasource_protocol_1.MapEnv(properties, this.m_env)
                    : this.m_env;
                const env = new harp_datasource_protocol_1.MapEnv({ $state }, parentEnv);
                enabled = Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, env));
            }
            if (!enabled) {
                // skip this feature, it was disabled.
                return;
            }
            // HARP-12247, geometry with no featureStarts would set start to `undefined`, in this
            // case, `endOfLastGroup` is also undefined (first execution in this loop), so it would
            // try to change the count of a group which hasn't yet been added, `addGroup` wasn't yet
            // called, hence we use the `??` operator and fall back to 0. Because featureStarts are
            // optional, we need to have a fallback.
            const start = (_a = starts[featureIndex]) !== null && _a !== void 0 ? _a : 0;
            const end = (_b = starts[featureIndex + 1]) !== null && _b !== void 0 ? _b : finalIndex;
            const count = end - start;
            if (start === endOfLastGroup) {
                // extend the last group
                geometry.groups[geometry.groups.length - 1].count += count;
            }
            else {
                geometry.addGroup(start, count);
            }
            endOfLastGroup = start + count;
        });
        return geometry.groups.length > 0;
    }
}
exports.TileObjectRenderer = TileObjectRenderer;


/***/ }),

/***/ "../harp-mapview/lib/Utils.ts":
/*!************************************!*\
  !*** ../harp-mapview/lib/Utils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileOffsetUtils = exports.MapViewUtils = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const EarthConstants_1 = __webpack_require__(/*! @here/harp-geoutils/lib/projection/EarthConstants */ "../harp-geoutils/lib/projection/EarthConstants.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const CameraUtils_1 = __webpack_require__(/*! ./CameraUtils */ "../harp-mapview/lib/CameraUtils.ts");
const Object3DUtils_1 = __webpack_require__(/*! ./geometry/Object3DUtils */ "../harp-mapview/lib/geometry/Object3DUtils.ts");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewUtils");
/**
 * Zoom level to request terrain tiles for getting the height of the camera above terrain.
 */
const TERRAIN_ZOOM_LEVEL = 4;
// Caching those for performance reasons.
const groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);
const groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());
const groundSphere = new THREE.Sphere(undefined, EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS);
const rayCaster = new THREE.Raycaster();
const epsilon = 1e-5;
/**
 * Cached ThreeJS instances for realtime maths.
 */
const space = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const tangentSpace = {
    x: new THREE.Vector3(),
    y: new THREE.Vector3(),
    z: new THREE.Vector3()
};
const cache = {
    box3: [new THREE.Box3()],
    obox3: [new harp_geoutils_1.OrientedBox3()],
    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],
    vector2: [new THREE.Vector2(), new THREE.Vector2()],
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],
    transforms: [
        {
            xAxis: new THREE.Vector3(),
            yAxis: new THREE.Vector3(),
            zAxis: new THREE.Vector3(),
            position: new THREE.Vector3()
        }
    ]
};
const tmpCamera = new THREE.PerspectiveCamera();
/**
 * Rounds a given zoom level up to the nearest integer value if it's close enough.
 *
 * The zoom level set in {@link MapView} after a zoom level
 * target is given to {@link (MapView.lookAt:WITH_PARAMS)} or
 * {@link @here/harp-map-controls#MapControls} never matches
 * exactly the target due to the precision loss caused by the
 * conversion from zoom level to camera distance (done in
 * {@link (MapView.lookAt:WITH_PARAMS)} and {@link @here/harp-map-controls#MapControls})
 * and from distance back to zoom level (done at every frame on camera update).
 * As a result, given a fixed integer zoom level input, the final zoom level computed at every frame
 * may fall sometimes below the integer value and others above. This causes flickering since each
 * frame will use different tile levels and different style evaluations for object visibility.
 * See HARP-9673 and HARP-8523.
 * @param zoomLevel - Input zoom level
 * @return The ceiling zoom level if input zoom level is close enough, otherwise the unmodified
 * input zoom level.
 */
function snapToCeilingZoomLevel(zoomLevel) {
    const eps = 1e-6;
    const ceiling = Math.ceil(zoomLevel);
    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;
}
/**
 * MapView utilities: View transformations, camera setup, view bounds computation...
 */
var MapViewUtils;
(function (MapViewUtils) {
    MapViewUtils.MAX_TILT_DEG = 89;
    MapViewUtils.MAX_TILT_RAD = MapViewUtils.MAX_TILT_DEG * THREE.MathUtils.DEG2RAD;
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView - Instance of MapView.
     * @param targetNDCx - Target x position in NDC space.
     * @param targetNDCy - Target y position in NDC space.
     * @param zoomLevel - The desired zoom level.
     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.
     * @returns `false` if requested zoom cannot be achieved due to the map view's maximum bounds
     * {@link MapView.geoMaxBounds},`true` otherwise.
     */
    function zoomOnTargetPosition(mapView, targetNDCx, targetNDCy, zoomLevel, maxTiltAngle = MapViewUtils.MAX_TILT_RAD) {
        const { elevationProvider, camera, projection } = mapView;
        // Use for now elevation at camera position. See getTargetAndDistance.
        const elevation = elevationProvider
            ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)
            : undefined;
        // Get current target position in world space before we zoom.
        const zoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        // Compute current camera target, it may not be the one set in MapView, e.g. when this
        // function is called multiple times between frames.
        const cameraTarget = MapViewUtils.getTargetAndDistance(projection, camera, elevationProvider).target;
        const newCameraDistance = calculateDistanceFromZoomLevel(mapView, zoomLevel);
        if (mapView.geoMaxBounds) {
            // If map view has maximum bounds set, constrain camera target and distance to ensure
            // they remain within bounds.
            const constrained = constrainTargetAndDistanceToViewBounds(cameraTarget, newCameraDistance, mapView);
            if (constrained.distance !== newCameraDistance) {
                // Only indicate failure when zooming out. This avoids zoom in cancellations when
                // camera is already at the maximum distance allowed by the view bounds.
                return zoomLevel >= mapView.zoomLevel;
            }
        }
        // Set the camera distance according to the given zoom level.
        camera
            .getWorldDirection(camera.position)
            .multiplyScalar(-newCameraDistance)
            .add(cameraTarget);
        // In sphere, we may have to also orbit the camera around the target, in order to limit the
        // the tilt to `maxTiltAngle`, as we change this tilt by changing the camera's height above.
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // FIXME: We cannot use mapView.tilt here b/c it does not reflect the latest camera
            // changes.
            const tilt = extractCameraTilt(camera, projection);
            const deltaTilt = tilt - maxTiltAngle;
            if (deltaTilt > 0) {
                orbitAroundScreenPoint(mapView, { deltaTilt, maxTiltAngle });
            }
        }
        // Get new target position after the zoom
        const newZoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);
        if (!zoomTarget || !newZoomTarget) {
            return true;
        }
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // Calculate the difference and pan the map to maintain the map relative to the target
            // position.
            zoomTarget.sub(newZoomTarget);
            panCameraAboveFlatMap(mapView, zoomTarget.x, zoomTarget.y);
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            panCameraAroundGlobe(mapView, zoomTarget, newZoomTarget);
        }
        return true;
    }
    MapViewUtils.zoomOnTargetPosition = zoomOnTargetPosition;
    function orbitAroundScreenPoint(mapView, offsetXOrOrbitParams, offsetY, deltaAzimuth, deltaTilt, maxTiltAngle) {
        var _a, _b, _c;
        const ppalPoint = CameraUtils_1.CameraUtils.getPrincipalPoint(mapView.camera, cache.vector2[0]);
        const mapTargetWorld = MapViewUtils.rayCastWorldCoordinates(mapView, ppalPoint.x, ppalPoint.y);
        if (mapTargetWorld === null) {
            return;
        }
        let orbitCenter;
        if (typeof offsetXOrOrbitParams === "number") {
            orbitCenter = cache.vector2[1].set(offsetXOrOrbitParams, offsetY);
        }
        else {
            const params = offsetXOrOrbitParams;
            orbitCenter = (_a = params.center) !== null && _a !== void 0 ? _a : ppalPoint;
            deltaAzimuth = (_b = params.deltaAzimuth) !== null && _b !== void 0 ? _b : 0;
            deltaTilt = (_c = params.deltaTilt) !== null && _c !== void 0 ? _c : 0;
            maxTiltAngle = params.maxTiltAngle;
        }
        const orbitAroundPpalPoint = orbitCenter.x === ppalPoint.x && orbitCenter.y === ppalPoint.y;
        const rotationTargetWorld = orbitAroundPpalPoint
            ? mapTargetWorld
            : MapViewUtils.rayCastWorldCoordinates(mapView, orbitCenter.x, orbitCenter.y);
        if (rotationTargetWorld === null) {
            return;
        }
        applyAzimuthAroundTarget(mapView, rotationTargetWorld, -deltaAzimuth);
        const tiltAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(mapView.camera.quaternion);
        const clampedDeltaTilt = computeClampedDeltaTilt(mapView, orbitCenter.y - ppalPoint.y, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis);
        applyTiltAroundTarget(mapView, rotationTargetWorld, clampedDeltaTilt, tiltAxis);
    }
    MapViewUtils.orbitAroundScreenPoint = orbitAroundScreenPoint;
    /**
     * @hidden
     * @internal
     *
     * Applies the given Azimith to the camera around the supplied target.
     */
    function applyAzimuthAroundTarget(mapView, rotationTargetWorld, deltaAzimuth) {
        const camera = mapView.camera;
        const projection = mapView.projection;
        const headingAxis = projection.surfaceNormal(rotationTargetWorld, cache.vector3[0]);
        const headingQuat = cache.quaternions[0].setFromAxisAngle(headingAxis, deltaAzimuth);
        camera.quaternion.premultiply(headingQuat);
        camera.position.sub(rotationTargetWorld);
        camera.position.applyQuaternion(headingQuat);
        camera.position.add(rotationTargetWorld);
    }
    /**
     * @hidden
     * @internal
     *
     * Clamps the supplied `deltaTilt` to the `maxTiltAngle` supplied. Note, when a non-zero offset
     * is applied, we apply another max angle of 89 degrees to the rotation center to prevent some
     * corner cases where the angle at the rotation center is 90 degrees and therefore intersects
     * the geometry with the near plane.
     */
    function computeClampedDeltaTilt(mapView, offsetY, deltaTilt, maxTiltAngle, mapTargetWorld, rotationTargetWorld, tiltAxis) {
        const camera = mapView.camera;
        const projection = mapView.projection;
        const tilt = extractTiltAngleFromLocation(projection, camera, mapTargetWorld, tiltAxis);
        if (tilt + deltaTilt < 0) {
            // Clamp the final tilt to 0
            return -tilt;
        }
        else if (deltaTilt <= 0) {
            // Reducing the tilt isn't clamped (apart from above).
            return deltaTilt;
        }
        else if (mapTargetWorld.equals(rotationTargetWorld) || offsetY < 0) {
            // When the rotation target is the center, or the offsetY is < 0, i.e. the angle at the
            // `mapTargetWorld` is always bigger, then we have a simple formula
            return harp_geoutils_1.MathUtils.clamp(deltaTilt + tilt, 0, maxTiltAngle) - tilt;
        }
        const rotationCenterTilt = extractTiltAngleFromLocation(projection, camera, rotationTargetWorld, tiltAxis);
        const maxRotationTiltAngle = THREE.MathUtils.degToRad(89);
        // The rotationCenterTilt may exceed 89 degrees when for example the user has tilted to 89
        // at the mapTargetWorld, then choose a rotation center target above the mapTargetWorld,
        // i.e. offsetY > 0. In such case, we just return 0, i.e. we don't let the user increase
        // the tilt (but it can decrease, see check above for "deltaTilt <= 0").
        if (rotationCenterTilt > maxRotationTiltAngle) {
            return 0;
        }
        // This is used to find the max tilt angle, because the difference in normals is needed
        // to correct the triangle used to find the max tilt angle at the rotation center.
        let angleBetweenNormals = 0;
        if (projection === harp_geoutils_1.sphereProjection) {
            const projectedRotationTargetNormal = projection
                .surfaceNormal(rotationTargetWorld, cache.vector3[0])
                .projectOnPlane(tiltAxis)
                .normalize();
            const mapTargetNormal = projection.surfaceNormal(mapTargetWorld, cache.vector3[1]);
            angleBetweenNormals = projectedRotationTargetNormal.angleTo(mapTargetNormal);
        }
        const ninetyRad = THREE.MathUtils.degToRad(90);
        // The following terminology will be used:
        // Ta = Tilt axis, tilting is achieved by rotating the camera around this direction.
        // R = rotation target, i.e. the point about which we are rotating: `rotationTargetWorld`
        // Rp = rotation target projected on to Ta
        // C = camera position
        // M = map target, i.e. the point which the camera is looking at at the NDC coordinates 0,0
        // Note, the points Rp, C, and M create a plane that is perpendicular to the earths surface,
        // because the tilt axis is perpendicular to the up vector. The following variable `RpCM` is
        // the angle between the two rays C->Rp and C->M. This angle remains constant when tilting
        // with a fixed `offsetX` and `offsetY`. It is calculated by using the intersection of the
        // two rays with the earth.
        // Note the use of `angleBetweenNormals` to ensure this works for spherical projections.
        // Note, this calculation only works when the tilt at M is less than the tilt
        // at Rp, otherwise the above formula won't work. We however don't need to worry about this
        // case because this happens only when offsetY is less than zero, and this is handled above.
        const MRpC = ninetyRad + angleBetweenNormals - rotationCenterTilt;
        const CMRp = ninetyRad + tilt;
        const RpCM = ninetyRad * 2 - (MRpC + CMRp);
        // We want to find the greatest angle at the rotation target that gives us the max
        // angle at the map center target.
        const CMRpMaxTilt = ninetyRad * 2 - RpCM - ninetyRad - maxTiltAngle;
        // Converting the `MRpC` back to a tilt is as easy as subtracting it from 90 and the
        // `angleBetweenNormals`, i.e. this gives us the maximum allowed tilt at R that satisfies
        // the `maxTiltAngle` constraint. Note, for globe projection, this is just an approximation,
        // because once we move the camera by delta, the map target changes, and therefore the
        // normal also changes, this would need to be applied iteratively until the difference in
        // normals is reduced to some epsilon. I don't apply this because it is computationally
        // expensive and the user would never notice this in practice.
        const maxTilt = ninetyRad + angleBetweenNormals - CMRpMaxTilt;
        // Here we clamp to the min of `maxTilt` and 89 degrees. The check for 89 is to prevent it
        // intersecting with the world at 90. This is possible for example when the R position is
        // near the horizon. If the angle RCM is say 5 degrees, then an angle of say 89 degrees at
        // R, plus 5 degrees means the tilt at M would be 84 degrees, so the camera can reach 90
        // from the point R whilst the tilt to M never reaches the `maxTiltAngle`
        const clampedDeltaTilt = harp_geoutils_1.MathUtils.clamp(deltaTilt + rotationCenterTilt, 0, Math.min(maxTilt, maxRotationTiltAngle)) - rotationCenterTilt;
        return clampedDeltaTilt;
    }
    /**
     * @hidden
     * @internal
     *
     * Applies the given tilt to the camera around the supplied target.
     */
    function applyTiltAroundTarget(mapView, rotationTargetWorld, deltaTilt, tiltAxis) {
        const camera = mapView.camera;
        // Consider to use the cache if necessary, but beware, because the `rayCastWorldCoordinates`
        // also uses this cache.
        const posBackup = camera.position.clone();
        const quatBackup = camera.quaternion.clone();
        const tiltQuat = cache.quaternions[0].setFromAxisAngle(tiltAxis, deltaTilt);
        camera.quaternion.premultiply(tiltQuat);
        camera.position.sub(rotationTargetWorld);
        camera.position.applyQuaternion(tiltQuat);
        camera.position.add(rotationTargetWorld);
        if (MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0) === null) {
            logger.warn("Target got invalidated during rotation.");
            camera.position.copy(posBackup);
            camera.quaternion.copy(quatBackup);
        }
    }
    /**
     * Calculate target (focus) point geo-coordinates for given camera.
     * @see getTargetPositionFromCamera
     *
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level measured in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future. Use
     * MapView.worldTarget instead.
     */
    function getGeoTargetFromCamera(camera, projection, elevation) {
        // This function does almost the same as:
        // rayCastGeoCoordinates(mapView, 0, 0)
        // but in more gentle and performance wise manner
        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);
        if (targetWorldPos !== null) {
            return projection.unprojectPoint(targetWorldPos);
        }
        return null;
    }
    MapViewUtils.getGeoTargetFromCamera = getGeoTargetFromCamera;
    /**
     * Calculate target (focus) point world coordinates for given camera position and orientation.
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future.
     */
    function getWorldTargetFromCamera(camera, projection, elevation) {
        const cameraPos = cache.vector3[0].copy(camera.position);
        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);
        rayCaster.set(cameraPos, cameraLookAt);
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const targetWorldPos = new THREE.Vector3();
        const result = projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)
            : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.getWorldTargetFromCamera = getWorldTargetFromCamera;
    /**
     * Constrains given camera target and distance to {@link MapView.maxBounds}.
     *
     * @remarks
     * The resulting
     * target and distance will keep the view within the maximum bounds for a camera with tilt and
     * yaw set to 0.
     * @param target - The camera target.
     * @param distance - The camera distance.
     * @param mapView - The map view whose maximum bounds will be used as constraints.
     * @returns constrained target and distance, or the unchanged input arguments if the view
     * does not have maximum bounds set.
     */
    function constrainTargetAndDistanceToViewBounds(target, distance, mapView) {
        const unconstrained = { target, distance };
        const worldMaxBounds = mapView.worldMaxBounds;
        const camera = mapView.camera;
        const projection = mapView.projection;
        if (!worldMaxBounds) {
            return unconstrained;
        }
        /**
         * Constraints are checked similarly for planar and sphere. The extents of a top down view
         * (even if camera isn't top down) using the given camera distance are compared with those
         * of the maximum bounds to compute a scale. There are two options:
         * a) scale > 1. The view covers a larger area than the maximum bounds. The distance is
         * is reduced to match the bounds extents and the target is set at the bounds center.
         * b) scale <= 1. The view may fit within the bounds without changing the distance, only the
         * target is moved to fit the whole view within the bounds.
         **/
        const boundsSize = worldMaxBounds.getSize(cache.vector3[1]);
        const screenSize = mapView.renderer.getSize(cache.vector2[0]);
        const viewHeight = CameraUtils_1.CameraUtils.convertScreenToWorldSize(mapView.focalLength, unconstrained.distance, screenSize.height);
        const viewWidth = viewHeight * camera.aspect;
        const scale = Math.max(viewWidth / boundsSize.x, viewHeight / boundsSize.y);
        const viewHalfSize = new THREE.Vector3(viewWidth / 2, viewHeight / 2, 0);
        const constrained = {
            target: unconstrained.target.clone(),
            distance: unconstrained.distance
        };
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            if (scale > 1) {
                constrained.distance /= scale;
                camera
                    .getWorldDirection(camera.position)
                    .multiplyScalar(-constrained.distance)
                    .add(worldMaxBounds.getCenter(constrained.target));
            }
            else {
                const targetBounds = cache.box3[0]
                    .copy(worldMaxBounds)
                    .expandByVector(viewHalfSize.multiplyScalar(-1));
                targetBounds
                    .clampPoint(unconstrained.target, constrained.target)
                    .setZ(unconstrained.target.z);
                if (constrained.target.equals(unconstrained.target)) {
                    return unconstrained;
                }
                camera.position.x += constrained.target.x - unconstrained.target.x;
                camera.position.y += constrained.target.y - unconstrained.target.y;
            }
            return constrained;
        }
        // Spherical projection
        if (scale > 1) {
            // Set target to center of max bounds but keeping same height as unconstrained target.
            worldMaxBounds.getCenter(constrained.target);
            constrained.target.setLength(unconstrained.target.length());
            constrained.distance /= scale;
        }
        else {
            // Compute the bounds where the target must be to ensure a top down view remains within
            // the maximum bounds.
            const targetMaxBounds = cache.obox3[0];
            targetMaxBounds.copy(worldMaxBounds);
            targetMaxBounds.position.setLength(unconstrained.target.length());
            targetMaxBounds.extents.sub(viewHalfSize);
            // Project unconstrained target to local tangent plane at the max bounds center.
            const rotMatrix = targetMaxBounds.getRotationMatrix(cache.matrix4[0]);
            const localTarget = cache.vector3[1]
                .copy(constrained.target)
                .sub(targetMaxBounds.position)
                .applyMatrix4(cache.matrix4[1].copy(rotMatrix).transpose())
                .setZ(0);
            // Clamp the projected target with the target bounds and check if it changes.
            const constrainedLocalTarget = cache.vector3[2]
                .copy(localTarget)
                .clamp(cache.vector3[3].copy(targetMaxBounds.extents).multiplyScalar(-1), targetMaxBounds.extents);
            if (constrainedLocalTarget.equals(localTarget)) {
                return unconstrained;
            }
            // Project the local constrained target back into the sphere.
            constrained.target
                .copy(constrainedLocalTarget)
                .applyMatrix4(rotMatrix)
                .add(targetMaxBounds.position);
            const targetHeightSq = targetMaxBounds.position.lengthSq();
            const constTargetDistSq = constrained.target.distanceToSquared(targetMaxBounds.position);
            const constTargetDistToGround = Math.sqrt(targetHeightSq) - Math.sqrt(targetHeightSq - constTargetDistSq);
            constrained.target.addScaledVector(targetMaxBounds.zAxis, -constTargetDistToGround);
            // Set the constrained target to the same height as the unconstrained one.
            constrained.target.setLength(unconstrained.target.length());
        }
        // Pan camera to constrained target and set constrained distance.
        MapViewUtils.panCameraAroundGlobe(mapView, cache.vector3[1].copy(constrained.target), cache.vector3[2].copy(unconstrained.target));
        camera
            .getWorldDirection(camera.position)
            .multiplyScalar(-constrained.distance)
            .add(constrained.target);
        return constrained;
    }
    MapViewUtils.constrainTargetAndDistanceToViewBounds = constrainTargetAndDistanceToViewBounds;
    /**
     * @internal
     * Computes the target for a given camera and the distance between them.
     * @param projection - The world space projection.
     * @param camera - The camera whose target will be computed.
     * @param elevationProvider - If provided, elevation at the camera position will be used.
     * @returns The target, the distance to it and a boolean flag set to false in case an elevation
     * provider was passed but the elevation was not available yet.
     */
    function getTargetAndDistance(projection, camera, elevationProvider) {
        const cameraPitch = extractAttitude({ projection }, camera).pitch;
        //FIXME: For now we keep the old behaviour when terrain is enabled (i.e. use the camera
        //       height above terrain to deduce the target distance).
        //       This leads to zoomlevel changes while panning. We have to find a proper solution
        //       for terrain (e.g. raycast with the ground surfcae that is elevated by the average
        //       elevation in the scene)
        const elevation = elevationProvider
            ? elevationProvider.getHeight(projection.unprojectPoint(camera.position), TERRAIN_ZOOM_LEVEL)
            : undefined;
        const final = !elevationProvider || elevation !== undefined;
        // Even for a tilt of 90 raycastTargetFromCamera is returning some point almost at
        // infinity.
        const target = cameraPitch < MapViewUtils.MAX_TILT_RAD
            ? getWorldTargetFromCamera(camera, projection, elevation)
            : null;
        if (target !== null) {
            const distance = camera.position.distanceTo(target);
            return { target, distance, final };
        }
        else {
            // We either reached the [[PITCH_LIMIT]] or we did not hit the ground surface.
            // In this case we do the reverse, i.e. compute some fallback distance and
            // use it to compute the tagret point by using the camera direction.
            const groundDistance = projection.groundDistance(camera.position);
            const heightAboveTerrain = Math.max(groundDistance - (elevation !== null && elevation !== void 0 ? elevation : 0), 0);
            //For flat projection we fallback to the target distance at 89 degree pitch.
            //For spherical projection we fallback to the tangent line distance
            const distance = projection.type === harp_geoutils_1.ProjectionType.Planar
                ? heightAboveTerrain / Math.cos(Math.min(cameraPitch, MapViewUtils.MAX_TILT_RAD))
                : Math.sqrt(Math.pow(heightAboveTerrain + EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2) -
                    Math.pow(EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS, 2));
            const cameraDir = camera.getWorldDirection(cache.vector3[0]);
            cameraDir.multiplyScalar(distance);
            const fallbackTarget = cache.vector3[1];
            fallbackTarget.copy(camera.position).add(cameraDir);
            return { target: fallbackTarget, distance, final };
        }
    }
    MapViewUtils.getTargetAndDistance = getTargetAndDistance;
    /**
     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,
     * given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates - Coordinates of the center of the view.
     * @param distance - Distance to the target in meters.
     * @param yawDeg - Camera yaw in degrees.
     * @param pitchDeg - Camera pitch in degrees.
     * @param projection - Active MapView, needed to get the camera fov and map projection.
     * @param result - Optional output vector.
     * @returns Camera position in world space.
     */
    function getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, projection, result = new THREE.Vector3()) {
        const pitchRad = THREE.MathUtils.degToRad(pitchDeg);
        const altitude = Math.cos(pitchRad) * distance;
        const yawRad = THREE.MathUtils.degToRad(yawDeg);
        projection.projectPoint(targetCoordinates, result);
        const groundDistance = distance * Math.sin(pitchRad);
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            result.x = result.x + Math.sin(yawRad) * groundDistance;
            result.y = result.y - Math.cos(yawRad) * groundDistance;
            result.z = result.z + altitude;
        }
        else if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // In globe yaw and pitch are understood to be in tangent space. The approach below is
            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and
            // set its new length (groundDistance). Finally the up vector's length is set to the
            // camera height and added to the transformed Y above.
            // Get the Z axis in tangent space: it is the normalized position vector of the target.
            tangentSpace.z.copy(result).normalize();
            // Get the Y axis (north axis in tangent space):
            tangentSpace.y.set(0, 0, 1).projectOnPlane(tangentSpace.z).normalize();
            // Rotate this north axis by the given yaw, giving the camera direction relative to
            // the target.
            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);
            tangentSpace.y.applyQuaternion(cache.quaternions[0]);
            // Push the camera to the specified distance.
            tangentSpace.y.setLength(groundDistance);
            // Now get the actual camera position vector: from the target position, add the
            // previous computation to get the projection of the camera on the ground, then add
            // the height of the camera in the tangent space.
            const height = distance * Math.cos(pitchRad);
            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));
            const a = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS + altitude;
            const b = Math.sin(pitchRad) * distance;
            const cameraHeight = Math.sqrt(a * a + b * b);
            result.setLength(cameraHeight);
        }
        return result;
    }
    MapViewUtils.getCameraPositionFromTargetCoordinates = getCameraPositionFromTargetCoordinates;
    /**
     * @hidden
     * @internal
     *
     * Add offset to geo points for minimal view box in flat projection with tile wrapping.
     *
     * @remarks
     * In flat projection, with wrap around enabled, we should detect clusters of points around that
     * wrap antimeridian.
     *
     * Here, we fit points into minimal geo box taking world wrapping into account.
     */
    function wrapGeoPointsToScreen(points, startPosition) {
        let startIndex = 0;
        if (startPosition === undefined) {
            startPosition = harp_geoutils_1.GeoCoordinates.fromObject(points[0]);
            startIndex = 1;
        }
        let north = startPosition.latitude;
        let south = startPosition.latitude;
        let lonCenter = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(startPosition.longitude);
        let lonSpan = 0;
        let east = startPosition.longitude;
        let west = startPosition.longitude;
        const result = [];
        result.push(new harp_geoutils_1.GeoCoordinates(north, lonCenter));
        for (let i = startIndex; i < points.length; i++) {
            const p = harp_geoutils_1.GeoCoordinates.fromObject(points[i]);
            if (p.latitude > north) {
                north = p.latitude;
            }
            else if (p.latitude < south) {
                south = p.latitude;
            }
            let longitude = harp_geoutils_1.MathUtils.normalizeLongitudeDeg(p.longitude);
            const relToCenter = harp_geoutils_1.MathUtils.angleDistanceDeg(lonCenter, longitude);
            longitude = lonCenter - relToCenter;
            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {
                east = Math.max(east, lonCenter - relToCenter);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            }
            else if (relToCenter > 0 && relToCenter > lonSpan / 2) {
                west = Math.min(west, longitude);
                lonSpan = east - west;
                lonCenter = (east + west) / 2;
            }
            result.push(new harp_geoutils_1.GeoCoordinates(p.latitude, longitude));
        }
        return result;
    }
    MapViewUtils.wrapGeoPointsToScreen = wrapGeoPointsToScreen;
    /**
     * @hidden
     * @internal
     *
     * Given `cameraPos`, force all points that lie on non-visible sphere half to be "near" max
     * possible viewable circle from given camera position.
     *
     * @remarks
     * Assumes that shpere projection with world center is in `(0, 0, 0)`.
     */
    function wrapWorldPointsToView(points, cameraPos) {
        const cameraPosNormalized = cameraPos.clone().normalize();
        for (const point of points) {
            if (point.angleTo(cameraPos) > Math.PI / 2) {
                // Point is on other side of sphere, we "clamp it to" max possible viewable circle
                // from given camera position
                const pointLen = point.length();
                point.projectOnPlane(cameraPosNormalized).setLength(pointLen);
            }
        }
    }
    MapViewUtils.wrapWorldPointsToView = wrapWorldPointsToView;
    /**
     * @hidden
     * @internal
     *
     * Return `GeoPoints` bounding {@link @here/harp-geoutils#GeoBox}
     * applicable for {@link getFitBoundsDistance}.
     *
     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`
     */
    function geoBoxToGeoPoints(box) {
        const center = box.center;
        return [
            new harp_geoutils_1.GeoCoordinates(box.north, box.west),
            new harp_geoutils_1.GeoCoordinates(box.north, box.east),
            new harp_geoutils_1.GeoCoordinates(center.latitude, box.west),
            new harp_geoutils_1.GeoCoordinates(center.latitude, box.east),
            new harp_geoutils_1.GeoCoordinates(box.south, box.west),
            new harp_geoutils_1.GeoCoordinates(box.south, box.east),
            new harp_geoutils_1.GeoCoordinates(box.north, center.longitude),
            new harp_geoutils_1.GeoCoordinates(box.south, center.longitude)
        ];
    }
    MapViewUtils.geoBoxToGeoPoints = geoBoxToGeoPoints;
    /**
     * @hidden
     * @internal
     *
     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.
     *
     * All dimensions belong to world space.
     *
     * @param points - points which must be in view.
     * @param worldTarget - readonly, world target of {@link MapView}
     * @param camera - readonly, camera with proper `position` and rotation set
     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}
     */
    function getFitBoundsDistance(points, worldTarget, camera) {
        // Diagram of the camera space YZ plane with the initial situation. Camera is at C0 and may
        // need to be moved to make point P visible.
        //
        //                camY
        //       targetDist^
        //      |<-------->|     Ps
        //     constD pEyeZ|    /|  ^
        //      |<-->|<--->|   / |  |
        //      |    |     |  /  |  | |ndcY-O.y|*h/2
        //      |    |     | /   |  |
        //  <---T----P'----C0----O  v
        // camZ      |_|  /|     |                              C0  - Initial camera position
        //           |   / |<--->|                              T   - Camera target
        //      PcamY|  /     f                                 P   - Bounds point (world space)
        //           | / (focal length)                         O   - Principal point.
        //           |/                                         h   - viewport height.
        //           P
        //
        // Diagram of camera space YZ plane with the final camera position C1 that leaves P at the
        // edge of the viewport. The new camera distance is the sum of a constant term (constD) and
        // the new distance to P (newPEyeZ), which is the initial distance (pEyeZ) multiplied by a
        // factor that needs to be found.
        //
        //                            camY
        //     constD      newPEyeZ    ^          Ps
        //      |<-->|<--------------->|       _-`|  ^
        //      |    |                 |    _-`   |  | |sign(ndcY)-O.y|h/2
        //      |    |                 | _-`      |  |
        //  <---T----P'----C0----------C1---------O  v
        // camZ      |_|            _-`|          |              C0  - Initial camera position
        //           |           _-`   |<-------->|              C1  - New camera position
        //      PcamY|        _-`           f                    T   - Camera target
        //           |     _-`        (focal length)             P   - Bounds point (world space)
        //           |  _-`                                      Ps  - P projected on screen.
        //           P-`                                         O   - Principal point.
        //                                                       h   - viewport height.
        //
        // P is between target and initial camera position, but calculations are equivalent for
        // points beyond the target (pEyeZ negative) or behind the camera (constD negative).
        // Right triangles PP'C0 and PsOC0 are equivalent, as well as PP'C1 and Ps0C1, that means:
        // |ndcY-O.y|*h/(2*f) = PcamY / |pEyeZ| (1) (ndcY-O.y,pEyeZ may be negative, take abs vals).
        // |sign(ndcY)-O.y|h/(2*f) = PcamY / newPEyeZ (2)
        // Dividing (1) by (2) and solving for newPEyeZ we get:
        // newPEyeZ = | pEyeZ || ndcY - O.y | / |sign(ndcY)-O.y|
        // The target distance to project P at the top/bottom border of the viewport is then:
        // constD + newPEyeZ = targetDist - pEyeZ + |pEyeZ||ndcY-O.y| / |sign(ndcY)-O.y|
        // The target distance to project P at the left/right border of the viewport is similarly:
        // targetDist - pEyeZ + |pEyeZ||ndcX-O.x| / |sign(ndcX)-O.x|
        // Take the largest of both distances to ensure the point is inside the viewport:
        // newDistance = targetDist - pEyeZ +
        // max(| ndcX - O.x | /|sign(ndcX)-O.x|, |ndcY-O.y|/sign(ndcY) - O.y |) *| pEyeZ |
        const targetDist = cache.vector3[0].copy(worldTarget).sub(camera.position).length();
        const ppalPoint = CameraUtils_1.CameraUtils.getPrincipalPoint(camera);
        let newDistance = targetDist;
        const getDistanceFactor = (pointNDC, ppNDC) => {
            // Use as maximum NDC a value slightly smaller than 1 to ensure the point is visible
            // with the final camera distance. Otherwise any precision loss might leave it just
            // outside of the viewport.
            const maxNDC = 0.99;
            return Math.abs(pointNDC) > 1
                ? Math.abs((pointNDC - ppNDC) / (maxNDC * Math.sign(pointNDC) - ppNDC))
                : 1;
        };
        for (const point of points) {
            const pEyeZ = -cache.vector3[0].copy(point).applyMatrix4(camera.matrixWorldInverse).z;
            const pointNDC = cache.vector3[0].applyMatrix4(camera.projectionMatrix);
            const maxFactor = Math.max(getDistanceFactor(pointNDC.x, ppalPoint.x), getDistanceFactor(pointNDC.y, ppalPoint.y));
            if (maxFactor > 1) {
                const constDist = targetDist - pEyeZ;
                const newPEyeZ = Math.abs(pEyeZ) * maxFactor + constDist;
                newDistance = Math.max(newDistance, newPEyeZ);
            }
        }
        return newDistance;
    }
    MapViewUtils.getFitBoundsDistance = getFitBoundsDistance;
    /**
     * @hidden
     * @internal
     *
     * Get {@link LookAtParams} that fit all `worldPoints`
     * giving that {@link MapView} will target at
     * `geoTarget`.
     *
     * @param geoTarget - desired target (see {@link MapView.target}) as geo point
     * @param worldTarget - same as `geoTarget` but in world space
     * @param worldPoints - points we want to see
     * @param params - other params derived from {@link MapView}.
     */
    function getFitBoundsLookAtParams(geoTarget, worldTarget, worldPoints, params) {
        const { tilt, heading, projection } = params;
        const startDistance = params.minDistance;
        const tmpCamera = params.camera.clone();
        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera.quaternion);
        getCameraPositionFromTargetCoordinates(geoTarget, startDistance, -heading, tilt, projection, tmpCamera.position);
        tmpCamera.updateMatrixWorld(true);
        if (projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            wrapWorldPointsToView(worldPoints, tmpCamera.position);
        }
        const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera);
        return {
            target: geoTarget,
            distance,
            heading,
            tilt
        };
    }
    MapViewUtils.getFitBoundsLookAtParams = getFitBoundsLookAtParams;
    /**
     * @deprecated use getCameraPositionFromTargetCoordinates instead
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView) {
        return mapView.projection.unprojectPoint(getCameraPositionFromTargetCoordinates(targetCoordinates, distance, yawDeg, pitchDeg, mapView.projection, cache.vector3[1]));
    }
    MapViewUtils.getCameraCoordinatesFromTargetCoordinates = getCameraCoordinatesFromTargetCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXinNDC - X coordinate in NDC space.
     * @param pointOnScreenYinNDC - Y coordinate in NDC space.
     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC, elevation) {
        const pointInNDCPosition = cache.vector3[0].set(pointOnScreenXinNDC, pointOnScreenYinNDC, 0);
        mapView.camera.updateMatrixWorld();
        const cameraPos = cache.vector3[1].copy(mapView.camera.position);
        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);
        // Prepare the unprojection matrix which projects from NDC space to camera space
        // and takes the current rotation of the camera into account.
        cache.matrix4[1].multiplyMatrices(cache.matrix4[0], cache.matrix4[1].copy(mapView.camera.projectionMatrix).invert());
        // Unproject the point via the unprojection matrix.
        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);
        // Use the point in camera space as the vector towards this point.
        rayCaster.set(cameraPos, pointInCameraSpace.normalize());
        if (elevation !== undefined) {
            groundPlane.constant -= elevation;
            groundSphere.radius += elevation;
        }
        const worldPosition = new THREE.Vector3();
        const result = mapView.projection.type === harp_geoutils_1.ProjectionType.Planar
            ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)
            : rayCaster.ray.intersectSphere(groundSphere, worldPosition);
        if (elevation !== undefined) {
            groundPlane.constant = 0;
            groundSphere.radius = EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS;
        }
        return result;
    }
    MapViewUtils.rayCastWorldCoordinates = rayCastWorldCoordinates;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView - Instance of MapView.
     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan
     *                  the map to the left in default camera orientation.
     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the
     *                  map downwards in default camera orientation.
     */
    function panCameraAboveFlatMap(mapView, offsetX, offsetY) {
        mapView.camera.position.x += offsetX;
        mapView.camera.position.y += offsetY;
    }
    MapViewUtils.panCameraAboveFlatMap = panCameraAboveFlatMap;
    /**
     * The function doing a pan in the spherical space
     * when {@link MapView}'s active [[ProjectionType]]
     * is spherical. In other words, the function that rotates the camera around the globe.
     *
     * @param mapView - MapView instance.
     * @param fromWorld - Start vector representing the scene position of a geolocation.
     * @param toWorld - End vector representing the scene position of a geolocation.
     */
    function panCameraAroundGlobe(mapView, fromWorld, toWorld) {
        cache.quaternions[0]
            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())
            .invert();
        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);
        mapView.camera.applyMatrix4(cache.matrix4[0]);
        mapView.camera.updateMatrixWorld();
    }
    MapViewUtils.panCameraAroundGlobe = panCameraAroundGlobe;
    /**
     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the
     * maximum possible tilt to the new target, and under the horizon in sphere projection.
     *
     * @param mapView - The {@link MapView} instance in use.
     * @param deltaYawDeg - Delta yaw in degrees.
     * @param deltaPitchDeg - Delta pitch in degrees.
     * @param maxTiltAngleRad - Max tilt angle in radians.
     */
    function rotate(mapView, deltaYawDeg, deltaPitchDeg = 0, maxTiltAngleRad = Math.PI / 4) {
        // 1. Apply yaw: rotate around the vertical axis.
        mapView.camera.rotateOnWorldAxis(mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical
            ? cache.vector3[0].copy(mapView.camera.position).normalize()
            : cache.vector3[0].set(0, 0, 1), THREE.MathUtils.degToRad(-deltaYawDeg));
        mapView.camera.updateMatrixWorld();
        // 2. Apply pitch: rotate around the camera's local X axis.
        if (deltaPitchDeg === 0) {
            return;
        }
        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;
        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.
        let newPitch = THREE.MathUtils.clamp(pitch + THREE.MathUtils.degToRad(deltaPitchDeg), 0, maxTiltAngleRad);
        // In sphere projection, the value of a maximum pitch is smaller than the value of the
        // maximum tilt, as the curvature of the surface adds up to it.
        if (mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.
            const maxPitch = Math.asin((EarthConstants_1.EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /
                mapView.camera.position.length());
            newPitch = Math.min(newPitch, maxPitch);
        }
        mapView.camera.rotateX(newPitch - pitch);
    }
    MapViewUtils.rotate = rotate;
    /**
     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations
     * hinge on the current `projection` and `target`, because yaw and pitch are defined in
     * tangent space of the target point.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param projection - Current projection.
     * @param target - The camera target.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function getCameraRotationAtTarget(projection, target, yawDeg, pitchDeg, result = new THREE.Quaternion()) {
        const transform = cache.transforms[0];
        projection.localTangentSpace(target, transform);
        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);
        result.setFromRotationMatrix(cache.matrix4[0]);
        cache.quaternions[0].setFromAxisAngle(cache.vector3[1].set(0, 0, 1), THREE.MathUtils.degToRad(yawDeg));
        cache.quaternions[1].setFromAxisAngle(cache.vector3[1].set(1, 0, 0), THREE.MathUtils.degToRad(pitchDeg));
        result.multiply(cache.quaternions[0]);
        result.multiply(cache.quaternions[1]);
        return result;
    }
    MapViewUtils.getCameraRotationAtTarget = getCameraRotationAtTarget;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge
     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent
     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView - Instance of MapView.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function setRotation(mapView, yawDeg, pitchDeg) {
        getCameraRotationAtTarget(mapView.projection, mapView.geoCenter, yawDeg, pitchDeg, mapView.camera.quaternion);
    }
    MapViewUtils.setRotation = setRotation;
    /**
     * Extracts current camera tilt angle in radians.
     *
     * @param camera - The [[Camera]] in use.
     * @param projection - The {@link @here/harp-geoutils#Projection} used to
     *                     convert between geo and world coordinates.
     *
     * @deprecated Use MapView.tilt
     */
    function extractCameraTilt(camera, projection) {
        // For planar projections the camera target point local tangent is the same
        // at every point on the ground (ignoring terrain fluctuations), so we may
        // simply use inverted ground normal for tilt calculation. This simplifies
        // the more generic calculus used for spherical projections.
        if (projection.type === harp_geoutils_1.ProjectionType.Planar) {
            const lookAt = camera.getWorldDirection(cache.vector3[0]).normalize();
            const normal = projection
                .surfaceNormal(camera.position, cache.vector3[1])
                .negate();
            const cosTheta = lookAt.dot(normal);
            return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));
        }
        else {
            // Sanity check if new projection type is introduced.
            harp_utils_1.assert(projection.type === harp_geoutils_1.ProjectionType.Spherical);
            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);
            // If focus point is lost we then expose maximum allowable tilt value.
            if (targetGeoCoords !== null) {
                return MapViewUtils.extractTiltAngleFromLocation(projection, camera, targetGeoCoords);
            }
            else {
                logger.warn("MapView camera is pointing in the void, using maxTilt: ", MapViewUtils.MAX_TILT_RAD);
                return MapViewUtils.MAX_TILT_RAD;
            }
        }
    }
    MapViewUtils.extractCameraTilt = extractCameraTilt;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),
     * starting north.
     * - Pitch :Rotation around the horizontal axis.
     * - Roll : Rotation around the view axis.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.
     */
    function extractAttitude(mapView, object) {
        // 1. Build the matrix of the tangent space of the object.
        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.
        mapView.projection.localTangentSpace(cache.vector3[1], {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);
        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.
        cache.matrix4[0].copy(cache.matrix4[1]).invert().multiply(object.matrixWorld);
        space.x.setFromMatrixColumn(cache.matrix4[0], 0);
        space.y.setFromMatrixColumn(cache.matrix4[0], 1);
        space.z.setFromMatrixColumn(cache.matrix4[0], 2);
        // 3. Deduce orientation from the base axes.
        let yaw = 0;
        let pitch = 0;
        let roll = 0;
        // Decompose rotation matrix into Z0 X Z1 Euler angles.
        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));
        if (d < 1.0 - Number.EPSILON) {
            if (d > -1.0 + Number.EPSILON) {
                yaw = Math.atan2(space.z.x, -space.z.y);
                pitch = Math.acos(space.z.z);
                roll = Math.atan2(space.x.z, space.y.z);
            }
            else {
                // Looking bottom-up with space.z.z == -1.0
                yaw = -Math.atan2(-space.y.x, space.x.x);
                pitch = 180;
                roll = 0;
            }
        }
        else {
            // Looking top-down with space.z.z == 1.0
            yaw = Math.atan2(-space.y.x, space.x.x);
            pitch = 0.0;
            roll = 0.0;
        }
        return {
            yaw,
            pitch,
            roll
        };
    }
    MapViewUtils.extractAttitude = extractAttitude;
    /**
     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical
     * coordinates of `object` in the tangent space of `location`.
     *
     * @param mapView - The {@link MapView} instance to consider.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     */
    function extractSphericalCoordinatesFromLocation(mapView, object, location) {
        // if (projection instanceof MapView) {
        //     logger.warn("Passing MapView to extractSphericalCoordinatesFromLocation is deprecated");
        //     projection = projection.projection;
        // }
        mapView.projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        let tilt = 0;
        let azimuth = 0;
        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with
        // tangent Z.
        cache.vector3[1].copy(object.position).sub(cache.vector3[0]).normalize();
        if (cache.vector3[1].dot(tangentSpace.z) > 1 - Number.EPSILON) {
            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.
            azimuth = Math.PI - extractAttitude(mapView, object).yaw;
            // Wrap between -PI and PI.
            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));
            tilt = 0;
            return { tilt, azimuth };
        }
        tilt = cache.vector3[1].angleTo(tangentSpace.z);
        // Tilted view: the azimuth is the direction of the object from the origin.
        cache.vector3[1]
            .copy(object.position)
            .sub(cache.vector3[0])
            .projectOnPlane(tangentSpace.z)
            .normalize();
        azimuth = cache.vector3[1].angleTo(tangentSpace.y);
        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {
            azimuth = -azimuth;
        }
        return { tilt, azimuth };
    }
    MapViewUtils.extractSphericalCoordinatesFromLocation = extractSphericalCoordinatesFromLocation;
    /**
     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle
     * (in radians) of `object` in the tangent space of `location`.
     *
     * @param projection - The {@link @here/harp-geoutils#Projection} used when
     *                     converting from geo to world coordinates.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     * @param tiltAxis - Optional axis used to define the rotation about which the object's tilt
     * occurs, the direction vector to the location from the camera is projected on the plane with
     * the given angle.
     */
    function extractTiltAngleFromLocation(projection, object, location, tiltAxis) {
        projection.localTangentSpace(location, {
            xAxis: tangentSpace.x,
            yAxis: tangentSpace.y,
            zAxis: tangentSpace.z,
            position: cache.vector3[0]
        });
        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.
        const dirVec = cache.vector3[2].copy(object.position).sub(cache.vector3[0]);
        if (tiltAxis) {
            dirVec.projectOnPlane(tiltAxis);
            tangentSpace.z.projectOnPlane(tiltAxis).normalize();
        }
        const dirLen = dirVec.length();
        if (dirLen < epsilon) {
            logger.error("Can not calculate tilt for the zero length vector!");
            return 0;
        }
        dirVec.divideScalar(dirLen);
        const cosTheta = dirVec.dot(tangentSpace.z);
        if (cosTheta >= 1 - Number.EPSILON) {
            // Top down view.
            return 0;
        }
        return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));
    }
    MapViewUtils.extractTiltAngleFromLocation = extractTiltAngleFromLocation;
    /**
     * Get perspective camera frustum planes distances.
     * @deprecated
     * @return all plane distances in helper object.
     */
    function getCameraFrustumPlanes(camera) {
        const near = camera.near;
        const far = camera.far;
        let top = (near * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov))) / camera.zoom;
        let height = 2 * top;
        let width = camera.aspect * height;
        let left = -0.5 * width;
        const view = camera.view;
        if (view !== null && view.enabled) {
            const fullWidth = view.fullWidth;
            const fullHeight = view.fullHeight;
            left += (view.offsetX * width) / fullWidth;
            top -= (view.offsetY * height) / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        // Correct by skew factor
        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;
        return {
            left,
            right: left + width,
            top,
            bottom: top - height,
            near,
            far
        };
    }
    MapViewUtils.getCameraFrustumPlanes = getCameraFrustumPlanes;
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXNDC -  Abscissa in NDC space.
     * @param pointOnScreenYNDC -  Ordinate in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC) {
        const worldCoordinates = rayCastWorldCoordinates(mapView, pointOnScreenXinNDC, pointOnScreenYinNDC);
        if (!worldCoordinates) {
            return null;
        }
        return mapView.projection.unprojectPoint(worldCoordinates);
    }
    MapViewUtils.rayCastGeoCoordinates = rayCastGeoCoordinates;
    /**
     * Calculates and returns the distance from the ground, which is needed to put the camera to
     * this height, to see the size of the area that would be covered by one tile for the given zoom
     * level.
     *
     * @param mapView - Instance of MapView.
     * @param options - Subset of necessary {@link MapView} properties.
     */
    function calculateDistanceToGroundFromZoomLevel(mapView, zoomLevel) {
        const cameraPitch = extractAttitude(mapView, mapView.camera).pitch;
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);
    }
    MapViewUtils.calculateDistanceToGroundFromZoomLevel = calculateDistanceToGroundFromZoomLevel;
    /**
     * Calculates and returns the distance to the target point.
     *
     * @param options - Necessary subset of MapView properties to compute the distance.
     * @param zoomLevel - The zoom level to get the equivalent height to.
     */
    function calculateDistanceFromZoomLevel(options, zoomLevel) {
        const tileSize = EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);
        return (options.focalLength * tileSize) / 256;
    }
    MapViewUtils.calculateDistanceFromZoomLevel = calculateDistanceFromZoomLevel;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param distance - The distance in meters, which are scene units in {@link MapView}.
     */
    function calculateZoomLevelFromDistance(options, distance) {
        const tileSize = (256 * distance) / options.focalLength;
        const zoomLevel = THREE.MathUtils.clamp(Math.log2(EarthConstants_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize), options.minZoomLevel, options.maxZoomLevel);
        return snapToCeilingZoomLevel(zoomLevel);
    }
    MapViewUtils.calculateZoomLevelFromDistance = calculateZoomLevelFromDistance;
    /**
     * @deprecated
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance, camera) {
        const perspCam = camera;
        const cameraRange = perspCam.far - perspCam.near;
        const viewSpaceDistance = clipDistance * perspCam.far;
        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);
    }
    MapViewUtils.calculateDepthFromClipDistance = calculateDepthFromClipDistance;
    /**
     * @deprecated
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance - Distance from the camera (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance, camera) {
        const perspCam = camera;
        return distance * perspCam.far;
    }
    MapViewUtils.cameraToWorldDistance = cameraToWorldDistance;
    /**
     * @deprecated
     */
    function calculateVerticalFovByHorizontalFov(hFov, aspect) {
        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);
    }
    MapViewUtils.calculateVerticalFovByHorizontalFov = calculateVerticalFovByHorizontalFov;
    /**
     * @deprecated Use {@link CameraUtils.getHorizontalFov}.
     */
    function calculateHorizontalFovByVerticalFov(vFov, aspect) {
        tmpCamera.fov = THREE.MathUtils.radToDeg(vFov);
        tmpCamera.aspect = aspect;
        return CameraUtils_1.CameraUtils.getHorizontalFov(tmpCamera);
    }
    MapViewUtils.calculateHorizontalFovByVerticalFov = calculateHorizontalFovByVerticalFov;
    /**
     * @deprecated Use {@link CameraUtils.setVerticalFov}.
     */
    function calculateFocalLengthByVerticalFov(vFov, height) {
        // setVerticalFov takes into account the principal point position to support
        // off-center projections. Keep previous behaviour by passing a camera with centered
        // principal point.
        CameraUtils_1.CameraUtils.setPrincipalPoint(tmpCamera, new THREE.Vector2());
        CameraUtils_1.CameraUtils.setVerticalFov(tmpCamera, vFov, height);
        return CameraUtils_1.CameraUtils.getFocalLength(tmpCamera);
    }
    MapViewUtils.calculateFocalLengthByVerticalFov = calculateFocalLengthByVerticalFov;
    /**
     * @deprecated Use {@link CameraUtils.setFocalLength}.
     */
    function calculateFovByFocalLength(focalLength, height) {
        // setFocalLength takes into account the principal point position to support
        // off-center projections. Keep previous behaviour by passing a camera with centered
        // principal point.
        CameraUtils_1.CameraUtils.setPrincipalPoint(tmpCamera, new THREE.Vector2());
        CameraUtils_1.CameraUtils.setFocalLength(tmpCamera, focalLength, height);
        return tmpCamera.fov;
    }
    MapViewUtils.calculateFovByFocalLength = calculateFovByFocalLength;
    /**
     * @deprecated Use {@link CameraUtils.convertWorldToScreenSize}.
     */
    MapViewUtils.calculateScreenSizeByFocalLength = CameraUtils_1.CameraUtils.convertWorldToScreenSize;
    /**
     * @deprecated Use {@link CameraUtils.convertScreenToWorldSize}.
     */
    MapViewUtils.calculateWorldSizeByFocalLength = CameraUtils_1.CameraUtils.convertScreenToWorldSize;
    /**
     * @deprecated
     */
    MapViewUtils.estimateObject3dSize = Object3DUtils_1.Object3DUtils.estimateSize;
    /**
     * Check if tiles or other content is currently being loaded.
     *
     * This method can be removed once HARP-7932 is implemented.
     *
     * @returns `true` if MapView has visible tiles or other content that is being loaded.
     */
    function mapViewIsLoading(mapView) {
        let numTilesLoading = 0;
        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {
            numTilesLoading += tileList.numTilesLoading;
            for (const tile of tileList.visibleTiles) {
                if (!tile.allGeometryLoaded) {
                    numTilesLoading++;
                }
            }
        }
        let isLoading = numTilesLoading > 0;
        if (mapView.textElementsRenderer !== undefined) {
            isLoading = isLoading || mapView.textElementsRenderer.loading;
        }
        isLoading =
            isLoading ||
                !mapView.poiTableManager.finishedLoading ||
                !mapView.visibleTileSet.allVisibleTilesLoaded;
        return isLoading;
    }
    MapViewUtils.mapViewIsLoading = mapViewIsLoading;
    function closeToFrustum(point, camera, eps = 1e-13) {
        const ndcPoint = new THREE.Vector3().copy(point).project(camera);
        if (Math.abs(ndcPoint.x) - eps < 1 &&
            Math.abs(ndcPoint.y) - eps < 1 &&
            Math.abs(ndcPoint.z) - eps < 1) {
            return true;
        }
        return false;
    }
    MapViewUtils.closeToFrustum = closeToFrustum;
    /**
     * @deprecated Use {@link @here/harp-utils#DOMUtils.getBrowserLanguages}
     */
    MapViewUtils.getBrowserLanguages = harp_utils_1.DOMUtils.getBrowserLanguages;
})(MapViewUtils = exports.MapViewUtils || (exports.MapViewUtils = {}));
var TileOffsetUtils;
(function (TileOffsetUtils) {
    /**
     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getKeyForTileKeyAndOffset}.
     */
    TileOffsetUtils.getKeyForTileKeyAndOffset = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset;
    /**
     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getKeyForTileKeyAndOffset}.
     */
    TileOffsetUtils.extractOffsetAndMortonKeyFromKey = harp_geoutils_1.TileKeyUtils.extractOffsetAndMortonKeyFromKey;
    /**
     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getParentKeyFromKey}.
     */
    TileOffsetUtils.getParentKeyFromKey = harp_geoutils_1.TileKeyUtils.getParentKeyFromKey;
})(TileOffsetUtils = exports.TileOffsetUtils || (exports.TileOffsetUtils = {}));


/***/ }),

/***/ "../harp-mapview/lib/VisibleTileSet.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/VisibleTileSet.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VisibleTileSet = exports.ResourceComputationType = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const BackgroundDataSource_1 = __webpack_require__(/*! ./BackgroundDataSource */ "../harp-mapview/lib/BackgroundDataSource.ts");
const FrustumIntersection_1 = __webpack_require__(/*! ./FrustumIntersection */ "../harp-mapview/lib/FrustumIntersection.ts");
const MapView_1 = __webpack_require__(/*! ./MapView */ "../harp-mapview/lib/MapView.ts");
/**
 * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If
 * it is in MB, an estimation is used.
 */
var ResourceComputationType;
(function (ResourceComputationType) {
    ResourceComputationType[ResourceComputationType["EstimationInMb"] = 0] = "EstimationInMb";
    ResourceComputationType[ResourceComputationType["NumberOfTiles"] = 1] = "NumberOfTiles";
})(ResourceComputationType = exports.ResourceComputationType || (exports.ResourceComputationType = {}));
// Direction in quad tree to search: up -> shallower levels, down -> deeper levels.
var SearchDirection;
(function (SearchDirection) {
    SearchDirection[SearchDirection["NONE"] = 0] = "NONE";
    SearchDirection[SearchDirection["UP"] = 1] = "UP";
    SearchDirection[SearchDirection["DOWN"] = 2] = "DOWN";
    SearchDirection[SearchDirection["BOTH"] = 3] = "BOTH";
})(SearchDirection || (SearchDirection = {}));
const MB_FACTOR = 1.0 / (1024.0 * 1024.0);
/**
 * Wrapper for LRU cache that encapsulates tiles caching for any {@link DataSource} used.
 *
 * Provides LRU based caching mechanism where each tile is identified by its tile key
 * (morton code) and data source name.
 * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted
 * only when cache reaches full saturation and tile is no longer visible.
 * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and
 * data source name, thus it is required that each {@link DataSource} used should have unique
 * name, but implementation could be improved to omit this limitation.
 */
class DataSourceCache {
    constructor(cacheSize, rct = ResourceComputationType.EstimationInMb) {
        this.m_disposedTiles = [];
        this.m_resourceComputationType = rct;
        this.m_tileCache = new harp_lrucache_1.LRUCache(cacheSize, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
        this.m_tileCache.evictionCallback = (_, tile) => {
            if (tile.tileLoader !== undefined) {
                // Cancel downloads as early as possible.
                tile.tileLoader.cancel();
            }
            this.m_disposedTiles.push(tile);
        };
        this.m_tileCache.canEvict = (_, tile) => {
            // Tiles can be evicted that weren't requested in the last frame.
            return !tile.isVisible;
        };
    }
    /**
     * Creates unique tile key for caching based on morton code, tile offset and its data source.
     *
     * @param mortonCode - The tile morton code.
     * @param offset - The tile offset.
     * @param dataSource - The {@link DataSource} from which tile was loaded.
     */
    static getKey(mortonCode, offset, dataSource) {
        return `${dataSource.name}_${mortonCode}_${offset}`;
    }
    /**
     * Create unique tile identifier for caching, based on tile object passed in.
     *
     * @param tile - The tile for which key is generated.
     */
    static getKeyForTile(tile) {
        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);
    }
    /**
     * Get information how cached tiles affects cache space available.
     *
     * The way how cache evaluates the __resources size__ have a big influence on entire
     * caching mechanism, if [[resourceComputationType]] is set to:
     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size
     * differently depending on the memory consumed, on other side
     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,
     * so its real memory consumed does not matter affect caching behavior. Of course in
     * the second scenario cache may grow significantly in terms of memory usage and thus it
     * is out of control.
     *
     * @return [[ResourceComputationType]] enum that describes if resources are counted by
     * space occupied in memory or just by number of them.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Get the cache capacity measured as number if megabytes or number of entries.
     *
     * The total cached tiles size determines cache saturation, if it reaches the capacity value
     * then the resources becomes evicted (released) starting from the oldest (the latest used).
     *
     * @see size.
     * @see resourceComputationType.
     */
    get capacity() {
        return this.m_tileCache.capacity;
    }
    /**
     * Get total cache size described as number of megabytes consumed or number of tiles stored.
     *
     * @see capacity.
     * @see resourceComputationType.
     */
    get size() {
        return this.m_tileCache.size;
    }
    /**
     * Set cache capacity and the algorithm used for cache size calculation.
     *
     * @see capacity.
     * @see resourceComputationType.
     * @param size - The new capacity declared in megabytes or number of entires.
     * @param rct - The enum value that determines how size and capacity are evaluated.
     */
    setCapacity(size, rct) {
        this.m_resourceComputationType = rct;
        this.m_tileCache.setCapacityAndMeasure(size, (tile) => {
            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {
                // Default is size in MB.
                return tile.memoryUsage * MB_FACTOR;
            }
            else {
                return 1;
            }
        });
    }
    /**
     * Get tile cached or __undefined__ if tile is not yet in cache.
     *
     * @param mortonCode - An unique tile morton code.
     * @param offset - Tile offset.
     * @param dataSource - A {@link DataSource} the tile comes from.
     */
    get(mortonCode, offset, dataSource) {
        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));
    }
    /**
     * Add new tile to the cache.
     *
     * @param mortonCode - En unique tile code (morton code).
     * @param offset - The tile offset.
     * @param dataSource - A {@link DataSource} the tile comes from.
     * @param tile - The tile reference.
     */
    set(mortonCode, offset, dataSource, tile) {
        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);
    }
    /**
     * Delete tile from cache.
     *
     * @note This method will not call eviction callback.
     * @param tile - The tile reference to be removed from cache.
     */
    delete(tile) {
        const tileKey = DataSourceCache.getKeyForTile(tile);
        this.deleteByKey(tileKey);
    }
    /**
     * Delete tile using its unique identifier.
     *
     * @note Tile identifier its constructed using information about tile code (morton code) and its
     * {@link DataSource}.
     * @note This is explicit removal thus eviction callback will not be processed.
     * @see DataSourceCache.getKey.
     * @param tileKey - The unique tile identifier.
     */
    deleteByKey(tileKey) {
        this.m_tileCache.delete(tileKey);
    }
    /**
     * Dispose all tiles releasing their internal data.
     */
    disposeTiles() {
        this.m_disposedTiles.forEach(tile => {
            tile.dispose();
        });
        this.m_disposedTiles.length = 0;
    }
    /**
     * Shrink cache to its allowed capacity.
     *
     * This method should be called each time after operations are performed on the cache entries,
     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory
     * consumed by its entries and check if cache is overgrown, is such case some tiles will be
     * evicted.
     */
    shrinkToCapacity() {
        this.m_tileCache.shrinkToCapacity();
    }
    /**
     * Evict all cached tiles implicitly even without checking if still in use.
     */
    evictAll() {
        this.m_tileCache.evictAll();
    }
    /**
     * Evict selected tiles implicitly.
     *
     * @param selector - The callback used to determine if tile should be evicted.
     */
    evictSelected(selector) {
        this.m_tileCache.evictSelected(selector);
    }
    /**
     * Call functor (callback) on each tile store in cache.
     *
     * Optionally you may specify from which {@link DataSource} tiles should be processed.
     * This limits the tiles visited to a sub-set originating from single {@link DataSource}.
     * @param callback - The function to be called for each visited tile.
     * @param inDataSource - The optional {@link DataSource} to which tiles should belong.
     */
    forEach(callback, inDataSource) {
        this.m_tileCache.forEach((entry, key) => {
            if (inDataSource === undefined || entry.dataSource === inDataSource) {
                callback(entry, key);
            }
        });
    }
}
// Sort by distance to camera, now the tiles that are further away are at the end
// of the list.
//
// Sort is unstable if distance is equal, which happens a lot when looking top-down.
// Unstable sorting makes label placement unstable at tile borders, leading to
// flickering.
const compareDistances = (a, b) => {
    const distanceDiff = a.distance - b.distance;
    // Take care or numerical precision issues
    const minDiff = (a.distance + b.distance) * 0.000001;
    return Math.abs(distanceDiff) < minDiff
        ? a.tileKey.mortonCode() - b.tileKey.mortonCode()
        : distanceDiff;
};
/**
 * Manages visible {@link Tile}s for {@link MapView}.
 *
 * Responsible for election of rendered tiles:
 *  - quad-tree traversal
 *  - frustum culling
 *  - sorting tiles by relevance (visible area) to prioritize load
 *  - limiting number of visible tiles
 *  - caching tiles
 *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby
 *    zoom levels
 */
class VisibleTileSet {
    constructor(m_frustumIntersection, m_tileGeometryManager, options, m_taskQueue) {
        var _a;
        this.m_frustumIntersection = m_frustumIntersection;
        this.m_tileGeometryManager = m_tileGeometryManager;
        this.options = options;
        this.m_taskQueue = m_taskQueue;
        this.dataSourceTileList = [];
        this.allVisibleTilesLoaded = false;
        this.m_cameraOverride = new THREE.PerspectiveCamera();
        this.m_viewRange = {
            near: 0.1,
            far: Infinity,
            minimum: 0.1,
            maximum: Infinity
        };
        // Maps morton codes to a given Tile, used to find overlapping Tiles. We only need to have this
        // for a single TilingScheme, i.e. that of the BackgroundDataSource.
        this.m_coveringMap = new Map();
        this.m_resourceComputationType = ResourceComputationType.EstimationInMb;
        this.options = options;
        this.options.maxTilesPerFrame = Math.floor((_a = this.options.maxTilesPerFrame) !== null && _a !== void 0 ? _a : 0);
        this.m_resourceComputationType =
            options.resourceComputationType === undefined
                ? ResourceComputationType.EstimationInMb
                : options.resourceComputationType;
        this.m_dataSourceCache = new DataSourceCache(this.options.tileCacheSize, this.m_resourceComputationType);
    }
    /**
     * Returns cache size.
     */
    getDataSourceCacheSize() {
        return this.options.tileCacheSize;
    }
    /**
     * Sets cache size.
     *
     * @param size - cache size
     * @param computationType - Optional value specifying the way a {@link Tile}s cache usage is
     *      computed, either based on size in MB (mega bytes) or in number of tiles. Defaults to
     *      `ResourceComputationType.EstimationInMb`.
     */
    setDataSourceCacheSize(size, computationType = ResourceComputationType.EstimationInMb) {
        this.options.tileCacheSize = size;
        // This effectively invalidates DataSourceCache
        this.resourceComputationType = computationType;
    }
    /**
     * Retrieves maximum number of visible tiles.
     */
    getNumberOfVisibleTiles() {
        return this.options.maxVisibleDataSourceTiles;
    }
    /**
     * Sets maximum number of visible tiles.
     *
     * @param size - size of visible tiles array
     */
    setNumberOfVisibleTiles(size) {
        this.options.maxVisibleDataSourceTiles = size;
    }
    /**
     * Gets the maximum number of tiles that can be added to the scene per frame
     * @beta
     * @internal
     */
    get maxTilesPerFrame() {
        return this.options.maxTilesPerFrame;
    }
    /**
     * Gets the maximum number of tiles that can be added to the scene per frame
     * @beta
     * @internal
     * @param value
     */
    set maxTilesPerFrame(value) {
        if (value < 0) {
            throw new Error("Invalid value, this will result in no tiles ever showing");
        }
        this.options.maxTilesPerFrame = Math.floor(value);
    }
    /**
     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of
     * tiles.
     */
    get resourceComputationType() {
        return this.m_resourceComputationType;
    }
    /**
     * Sets the way tile cache is managing its elements.
     *
     * Cache may be either keeping number of elements stored or the memory consumed by them.
     *
     * @param computationType - Type of algorith used in cache for checking full saturation,
     * may be counting number of elements or memory consumed by them.
     */
    set resourceComputationType(computationType) {
        this.m_resourceComputationType = computationType;
        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);
    }
    /**
     * Evaluate frustum near/far clip planes and visibility ranges.
     */
    updateClipPlanes(maxElevation, minElevation) {
        if (maxElevation !== undefined) {
            this.options.clipPlanesEvaluator.maxElevation = maxElevation;
        }
        if (minElevation !== undefined) {
            this.options.clipPlanesEvaluator.minElevation = minElevation;
        }
        const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;
        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(camera, projection, elevationProvider);
        return this.m_viewRange;
    }
    /**
     * Calculates a new set of visible tiles.
     * @param storageLevel - The camera storage level, see {@link MapView.storageLevel}.
     * @param zoomLevel - The camera zoom level.
     * @param dataSources - The data sources for which the visible tiles will be calculated.
     * @param elevationRangeSource - Source of elevation range data if any.
     * @returns view ranges and their status since last update (changed or not).
     */
    updateRenderList(storageLevel, zoomLevel, dataSources, frameNumber, elevationRangeSource) {
        let allVisibleTilesLoaded = true;
        // This isn't really const, because we pass by ref to the methods below.
        const newTilesPerFrame = 0;
        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource);
        this.dataSourceTileList = [];
        this.m_coveringMap.clear();
        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {
            visibleTileKeys.sort(compareDistances);
            // Create actual tiles only for the allowed number of visible tiles
            const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
            const visibleResult = this.processVisibleTiles(visibleTileKeys, dataSource, frameNumber, {
                newTilesPerFrame
            }, true);
            const dependentResult = this.processVisibleTiles(visibleResult.dependentTiles, dataSource, frameNumber, {
                newTilesPerFrame
            }, false);
            // creates geometry if not yet available
            this.m_tileGeometryManager.updateTiles(visibleResult.visibleTiles);
            this.m_tileGeometryManager.updateTiles(dependentResult.visibleTiles);
            // used to actually render the tiles or find alternatives for incomplete tiles
            this.dataSourceTileList.push({
                dataSource,
                storageLevel,
                zoomLevel: dataZoomLevel,
                allVisibleTileLoaded: visibleResult.allDataSourceTilesLoaded &&
                    dependentResult.allDataSourceTilesLoaded,
                numTilesLoading: visibleResult.numTilesLoading + dependentResult.numTilesLoading,
                visibleTiles: [...visibleResult.visibleTiles, ...dependentResult.visibleTiles],
                renderedTiles: new Map()
            });
            allVisibleTilesLoaded = allVisibleTilesLoaded && visibleResult.allDataSourceTilesLoaded;
        }
        this.allVisibleTilesLoaded =
            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;
        this.populateRenderedTiles();
        this.forEachCachedTile(tile => {
            // Remove all tiles that are still being loaded, but are no longer visible. They have to
            // be reloaded when they become visible again. Hopefully, they are still in the browser
            // cache by then.
            if (!tile.isVisible && !tile.allGeometryLoaded) {
                // The internal TileLoader is cancelled automatically when the Tile is disposed.
                this.disposeTile(tile);
            }
        });
        this.m_dataSourceCache.shrinkToCapacity();
        let minElevation;
        let maxElevation;
        this.dataSourceTileList.forEach(renderListEntry => {
            // Calculate min/max elevation from every data source tiles,
            // data sources without elevationRangeSource will contribute to
            // values with zero levels for both elevations.
            const tiles = renderListEntry.renderedTiles;
            tiles.forEach(tile => {
                tile.update(renderListEntry.zoomLevel);
                minElevation = harp_utils_1.MathUtils.min2(minElevation, tile.geoBox.minAltitude);
                maxElevation = harp_utils_1.MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);
            });
        });
        if (minElevation === undefined) {
            minElevation = 0;
        }
        if (maxElevation === undefined) {
            maxElevation = 0;
        }
        // If clip planes evaluator depends on the tiles elevation re-calculate
        // frustum planes and update the camera near/far plane distances.
        let viewRangesChanged = false;
        const oldViewRanges = this.m_viewRange;
        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);
        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;
        return {
            viewRanges: newViewRanges,
            viewRangesChanged
        };
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset, creating it if
     * necessary.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @param frameNumber - Frame in which the tile was requested
     * @return The tile if it was found or created, undefined otherwise.
     */
    getTile(dataSource, tileKey, offset, frameNumber) {
        const cacheOnly = false;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the cache.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @param frameNumber - Frame in which the tile was requested
     * @return The tile if found in cache, undefined otherwise.
     */
    getCachedTile(dataSource, tileKey, offset, frameNumber) {
        harp_utils_1.assert(dataSource.cacheable);
        const cacheOnly = true;
        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);
    }
    /**
     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param tileKey - The key identifying the tile.
     * @param offset - Tile offset.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTile(dataSource, tileKey, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        return dataSourceVisibleTileList.renderedTiles.get(harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset));
    }
    /**
     * Gets the tile corresponding to the given data source and location from the rendered tiles.
     *
     * @param dataSource - The data source the tile belongs to.
     * @param geoPoint - The geolocation included within the tile.
     * @return The tile if found among the rendered tiles, undefined otherwise.
     */
    getRenderedTileAtLocation(dataSource, geoPoint, offset = 0) {
        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {
            return list.dataSource === dataSource;
        });
        if (dataSourceVisibleTileList === undefined) {
            return undefined;
        }
        const tilingScheme = dataSource.getTilingScheme();
        const visibleLevel = dataSourceVisibleTileList.zoomLevel;
        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);
        if (!visibleTileKey) {
            return undefined;
        }
        let tile = dataSourceVisibleTileList.renderedTiles.get(harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset));
        if (tile !== undefined) {
            return tile;
        }
        const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(dataSource, visibleLevel);
        let parentTileKey = visibleTileKey;
        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {
            parentTileKey = parentTileKey.parent();
            tile = dataSourceVisibleTileList.renderedTiles.get(harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(parentTileKey, offset));
            if (tile !== undefined) {
                return tile;
            }
        }
        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);
        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {
            const childLevel = visibleLevel + levelOffset;
            const childTileKey = harp_geoutils_1.TileKeyUtils.worldCoordinatesToTileKey(tilingScheme, worldPoint, childLevel);
            if (childTileKey) {
                tile = dataSourceVisibleTileList.renderedTiles.get(harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset));
                if (tile !== undefined) {
                    return tile;
                }
            }
        }
        return undefined;
    }
    /**
     * Removes all internal bookkeeping entries and cache related to specified datasource.
     *
     * Called by {@link MapView} when {@link DataSource} has been removed from {@link MapView}.
     */
    removeDataSource(dataSource) {
        this.clearTileCache(dataSource);
        this.dataSourceTileList = this.dataSourceTileList.filter(tileList => tileList.dataSource !== dataSource);
    }
    /**
     * Clear the tile cache.
     *
     * Remove the {@link Tile} objects created by cacheable {@link DataSource}.
     * If a {@link DataSource} name is
     * provided, this method restricts the eviction
     * the {@link DataSource} with the given name.
     *
     * @param dataSourceName - The name of the {@link DataSource}.
     * @param filter Optional tile filter
     */
    clearTileCache(dataSource, filter) {
        if (dataSource !== undefined) {
            this.m_dataSourceCache.evictSelected((tile, _) => {
                return (tile.dataSource === dataSource && (filter !== undefined ? filter(tile) : true));
            });
        }
        else if (filter !== undefined) {
            this.m_dataSourceCache.evictSelected(filter);
        }
        else {
            this.m_dataSourceCache.evictAll();
        }
    }
    /**
     * Visit each tile in visible, rendered, and cached sets.
     *
     *  * Visible and temporarily rendered tiles will be marked for update and retained.
     *  * Cached but not rendered/visible will be evicted.
     *
     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance
     *      are processed. If `undefined`, tiles from all {@link DataSource}s are processed.
     * @param filter Optional tile filter
     */
    markTilesDirty(dataSource, filter) {
        if (dataSource === undefined) {
            this.dataSourceTileList.forEach(renderListEntry => {
                this.markDataSourceTilesDirty(renderListEntry, filter);
            });
        }
        else {
            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);
            if (renderListEntry === undefined) {
                return;
            }
            this.markDataSourceTilesDirty(renderListEntry, filter);
        }
    }
    /**
     * Dispose tiles that are marked for removal by {@link @here/harp-lrucache#LRUCache} algorithm.
     */
    disposePendingTiles() {
        this.m_dataSourceCache.disposeTiles();
    }
    /**
     * Process callback function [[fun]] with each visible tile in set.
     *
     * @param fun - The callback function to be called.
     */
    forEachVisibleTile(fun) {
        for (const listEntry of this.dataSourceTileList) {
            listEntry.renderedTiles.forEach(fun);
        }
    }
    /**
     * Process callback function [[fun]] with each tile in the cache.
     *
     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to
     * DataSource passed in.
     *
     * @param fun - The callback function to be called.
     * @param dataSource - The optional DataSource reference for tiles selection.
     */
    forEachCachedTile(fun, dataSource) {
        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);
    }
    /**
     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.
     */
    disposeTile(tile) {
        // TODO: Consider using evict here!
        this.m_dataSourceCache.delete(tile);
        tile.dispose();
    }
    // Requests the tiles using the tilekeys from the DataSource and returns them, including whether
    // all tiles were loaded and how many are loading.
    processVisibleTiles(visibleTileKeys, dataSource, frameNumber, 
    // Must be passed by reference
    refs, processDependentTiles) {
        var _a;
        let allDataSourceTilesLoaded = true;
        let numTilesLoading = 0;
        const visibleTiles = [];
        const dependentTiles = [];
        for (let i = 0; i < visibleTileKeys.length &&
            visibleTiles.length < this.options.maxVisibleDataSourceTiles; i++) {
            const tileEntry = visibleTileKeys[i];
            const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset, frameNumber);
            if (tile === undefined) {
                continue;
            }
            visibleTiles.push(tile);
            allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;
            if (!tile.allGeometryLoaded) {
                numTilesLoading++;
            }
            else {
                // If this tile's data source is "covering" then other tiles beneath it have
                // their rendering skipped, see [[Tile.willRender]].
                this.skipOverlappedTiles(dataSource, tile);
                if (this.processDelayTileRendering(tile, refs.newTilesPerFrame, frameNumber)) {
                    refs.newTilesPerFrame++;
                }
            }
            // Update the visible area of the tile. This is used for those tiles that are
            // currently loaded and are waiting to be decoded to sort the jobs by area.
            tile.visibleArea = tileEntry.area;
            tile.elevationRange = (_a = tileEntry.elevationRange) !== null && _a !== void 0 ? _a : { minElevation: 0, maxElevation: 0 };
            if (processDependentTiles) {
                // Add any dependent tileKeys if not already visible. Consider to optimize with a
                // Set if this proves to be a bottleneck (because of O(n^2) search). Given the fact
                // that dependencies are rare and used for non tiled data, this shouldn't be a
                // problem.
                for (const tileKey of tile.dependencies) {
                    if (visibleTileKeys.find(tileKeyEntry => tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()) === undefined &&
                        // Check that we haven't already added this TileKey
                        dependentTiles.find(tileKeyEntry => tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()) === undefined) {
                        dependentTiles.push(new FrustumIntersection_1.TileKeyEntry(tileKey, 0));
                    }
                }
            }
        }
        return {
            allDataSourceTilesLoaded,
            numTilesLoading,
            visibleTiles,
            dependentTiles
        };
    }
    // Processes if the tile should delay its rendering, returns if the tile is new, which is needed
    // to count how many tiles are generated per frame.
    processDelayTileRendering(tile, newTilesPerFrame, frameNumber) {
        let isNewTile = false;
        if (
        // if set to 0, it will ignore the limit and upload all available
        this.options.maxTilesPerFrame !== 0 &&
            newTilesPerFrame > this.options.maxTilesPerFrame &&
            //if the tile was already visible last frame dont delay it
            !(tile.frameNumLastVisible === frameNumber - 1)) {
            tile.delayRendering = true;
            tile.mapView.update();
        }
        else {
            if (tile.frameNumVisible < 0) {
                // Store the fist frame the tile became visible.
                tile.frameNumVisible = frameNumber;
                isNewTile = true;
            }
            tile.numFramesVisible++;
            tile.delayRendering = false;
        }
        return isNewTile;
    }
    /**
     * Skips rendering of tiles that are overlapped. The overlapping {@link Tile} comes from a
     * {@link DataSource} which is fully covering, i.e. there it is fully opaque.
     **/
    skipOverlappedTiles(dataSource, tile) {
        if (this.options.projection.type === harp_geoutils_1.ProjectionType.Spherical) {
            // HARP-7899, currently the globe has no background planes in the tiles (it relies on
            // the BackgroundDataSource), because the LOD mismatches, hence disabling for globe.
            return;
        }
        if (dataSource.isFullyCovering()) {
            const key = tile.uniqueKey;
            const entry = this.m_coveringMap.get(key);
            if (entry === undefined) {
                // We need to reset the flag so that if the covering datasource is disabled, that
                // the tiles beneath then start to render.
                tile.skipRendering = false;
                this.m_coveringMap.set(key, tile);
            }
            else {
                // Skip the Tile if either the stored entry or the tile to consider is from the
                // [[BackgroundDataSource]]
                if (entry.dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {
                    entry.skipRendering = true;
                }
                else if (dataSource instanceof BackgroundDataSource_1.BackgroundDataSource) {
                    tile.skipRendering = true;
                }
            }
        }
    }
    // Returns the search direction and the number of levels up / down that can be searched.
    getSearchDirection(dataSource, visibleLevel) {
        const searchLevelsUp = Math.min(this.options.quadTreeSearchDistanceUp, Math.max(0, visibleLevel - dataSource.minDataLevel));
        const searchLevelsDown = Math.min(this.options.quadTreeSearchDistanceDown, Math.max(0, dataSource.maxDataLevel - visibleLevel));
        const searchDirection = searchLevelsDown > 0 && searchLevelsUp > 0
            ? SearchDirection.BOTH
            : searchLevelsDown > 0
                ? SearchDirection.DOWN
                : searchLevelsUp > 0
                    ? SearchDirection.UP
                    : SearchDirection.NONE;
        return { searchDirection, searchLevelsUp, searchLevelsDown };
    }
    /**
     * Populates the list of tiles to render, see "renderedTiles". Tiles that are loaded and which
     * are an exact match are added straight to the list, tiles that are still loading are replaced
     * with tiles in the cache that are either a parent or child of the requested tile. This helps
     * to prevent flickering when zooming in / out. The distance to search is based on the options
     * [[quadTreeSearchDistanceDown]] and [[quadTreeSearchDistanceUp]].
     *
     * Each {@link DataSource} can also switch this behaviour on / off using the
     * [[allowOverlappingTiles]] flag.
     *
     */
    populateRenderedTiles() {
        this.dataSourceTileList.forEach(renderListEntry => {
            const renderedTiles = renderListEntry.renderedTiles;
            // Tiles for which we need to fall(back/forward) to.
            const incompleteTiles = [];
            // Populate the list of tiles which can be shown ("renderedTiles"), and the list of
            // tiles that are incomplete, and for which we search for an alternative
            // ("incompleteTiles").
            renderListEntry.visibleTiles.forEach(tile => {
                tile.levelOffset = 0;
                if (tile.hasGeometry && !tile.delayRendering) {
                    renderedTiles.set(tile.uniqueKey, tile);
                }
                else {
                    // if dataSource supports cache and it was existing before this render
                    // then enable searching for loaded tiles in cache
                    incompleteTiles.push(tile.uniqueKey);
                }
            });
            const dataSource = renderListEntry.dataSource;
            if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {
                // Either all tiles are loaded or the datasource doesn't support using cached tiles
                // from other levels.
                return;
            }
            const dataZoomLevel = renderListEntry.zoomLevel;
            const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);
            // Minor optimization for the fallback search, only check parent tiles once, otherwise
            // the recursive algorithm checks all parent tiles multiple times, the key is the code
            // of the tile that is checked and the value is whether a parent was found or not.
            const checkedTiles = new Map();
            // Iterate over incomplete (not loaded tiles) and find their parents or children that
            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour
            // falling back to parent tiles rather than children.
            for (const tileKeyCode of incompleteTiles) {
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.UP) {
                    if (this.findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource)) {
                        // Continue to next entry so we don't search down.
                        continue;
                    }
                }
                if (searchDirection === SearchDirection.BOTH ||
                    searchDirection === SearchDirection.DOWN) {
                    this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);
                }
            }
        });
    }
    findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource) {
        const { offset, mortonCode } = harp_geoutils_1.TileKeyUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const tilingScheme = dataSource.getTilingScheme();
        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {
            const childTileCode = harp_geoutils_1.TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset);
            const childTile = this.m_dataSourceCache.get(childTileKey.mortonCode(), offset, dataSource);
            const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);
            if (childTile !== undefined && childTile.hasGeometry && !childTile.delayRendering) {
                //childTile has geometry and was/can be uploaded to the GPU,
                //so we can use it as fallback
                renderedTiles.set(childTileCode, childTile);
                childTile.levelOffset = nextLevelDiff;
                continue;
            }
            // Recurse down until the max distance is reached.
            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {
                this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);
            }
        }
    }
    /**
     * Returns true if a tile was found in the cache which is a parent
     * @param tileKeyCode - Morton code of the current tile that should be searched for.
     * @param dataZoomLevel - The current data zoom level of tiles that are to be displayed.
     * @param renderedTiles - The list of tiles that are shown to the user.
     * @param checkedTiles - Used to map a given code to a boolean which tells us if an ancestor is
     * displayed or not.
     * @param dataSource - The provider of tiles.
     * @returns Whether a parent tile exists.
     */
    findUp(tileKeyCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource) {
        const parentCode = harp_geoutils_1.TileKeyUtils.getParentKeyFromKey(tileKeyCode);
        // Check if another sibling has already added the parent.
        if (renderedTiles.get(parentCode) !== undefined) {
            return true;
        }
        const exists = checkedTiles.get(parentCode);
        if (exists !== undefined) {
            return exists;
        }
        const { offset, mortonCode } = harp_geoutils_1.TileKeyUtils.extractOffsetAndMortonKeyFromKey(parentCode);
        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);
        const parentTileKey = parentTile ? parentTile.tileKey : harp_geoutils_1.TileKey.fromMortonCode(mortonCode);
        const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);
        if (parentTile !== undefined && parentTile.hasGeometry && !parentTile.delayRendering) {
            checkedTiles.set(parentCode, true);
            // parentTile has geometry, so can be reused as fallback
            renderedTiles.set(parentCode, parentTile);
            // We want to have parent tiles as -ve, hence the minus.
            parentTile.levelOffset = -nextLevelDiff;
            return true;
        }
        else {
            checkedTiles.set(parentCode, false);
        }
        // Recurse up until the max distance is reached or we go to the parent of all parents.
        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {
            const foundUp = this.findUp(parentCode, dataZoomLevel, renderedTiles, checkedTiles, dataSource);
            // If there was a tile upstream found, then add it to the list, so we can
            // early skip checkedTiles.
            checkedTiles.set(parentCode, foundUp);
            if (foundUp) {
                return true;
            }
        }
        return false;
    }
    getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber) {
        function touchTile(tileToUpdate) {
            // Keep the tile from being removed from the cache.
            tileToUpdate.frameNumLastRequested = frameNumber;
        }
        if (!dataSource.cacheable && !cacheOnly) {
            const resultTile = dataSource.getTile(tileKey, true);
            if (resultTile !== undefined) {
                this.addToTaskQueue(resultTile);
                touchTile(resultTile);
            }
            return resultTile;
        }
        const tileCache = this.m_dataSourceCache;
        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);
        if (tile !== undefined && tile.offset === offset) {
            touchTile(tile);
            return tile;
        }
        if (cacheOnly) {
            return undefined;
        }
        tile = dataSource.getTile(tileKey, true);
        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry
        if (tile !== undefined) {
            this.addToTaskQueue(tile);
            tile.offset = offset;
            touchTile(tile);
            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);
        }
        return tile;
    }
    addToTaskQueue(tile) {
        this.m_taskQueue.add({
            execute: tile.load.bind(tile),
            group: MapView_1.TileTaskGroups.FETCH_AND_DECODE,
            getPriority: () => {
                var _a, _b;
                return (_b = (_a = tile === null || tile === void 0 ? void 0 : tile.tileLoader) === null || _a === void 0 ? void 0 : _a.priority) !== null && _b !== void 0 ? _b : 0;
            },
            isExpired: () => {
                return !(tile === null || tile === void 0 ? void 0 : tile.isVisible);
            },
            estimatedProcessTime: () => {
                return 1;
            }
        });
    }
    markDataSourceTilesDirty(renderListEntry, filter) {
        const dataSourceCache = this.m_dataSourceCache;
        const retainedTiles = new Set();
        const markTileDirty = (tile) => {
            var _a;
            const tileKey = DataSourceCache.getKeyForTile(tile);
            if (!retainedTiles.has(tileKey)) {
                retainedTiles.add(tileKey);
                // We need to cancel the loader first because if we don't then the call to
                // tileLoader.loadAndDecode() inside Tile::load will return the existing promise (if
                // the tile is still loading) and not re-request the tile data from the provider as
                // required.
                (_a = tile.tileLoader) === null || _a === void 0 ? void 0 : _a.cancel();
                this.addToTaskQueue(tile);
            }
        };
        renderListEntry.visibleTiles.forEach(tile => {
            if (filter === undefined || filter(tile)) {
                markTileDirty(tile);
            }
        });
        renderListEntry.renderedTiles.forEach(tile => {
            if (filter === undefined || filter(tile)) {
                markTileDirty(tile);
            }
        });
        dataSourceCache.forEach((tile, key) => {
            if ((filter === undefined || filter(tile)) && !retainedTiles.has(key)) {
                dataSourceCache.deleteByKey(key);
                tile.dispose();
            }
        }, renderListEntry.dataSource);
    }
    // Computes the visible tile keys for each supplied data source.
    getVisibleTileKeysForDataSources(zoomLevel, dataSources, elevationRangeSource) {
        const tileKeys = Array();
        let allBoundingBoxesFinal = true;
        if (dataSources.length === 0) {
            return { tileKeys, allBoundingBoxesFinal };
        }
        const dataSourceBuckets = new Map();
        dataSources.forEach(dataSource => {
            const tilingScheme = dataSource.getTilingScheme();
            const bucket = dataSourceBuckets.get(tilingScheme);
            if (bucket === undefined) {
                dataSourceBuckets.set(tilingScheme, [dataSource]);
            }
            else {
                bucket.push(dataSource);
            }
        });
        // If elevation is to be taken into account extend view frustum:
        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that
        // are far below ground plane and high enough to intersect the frustum.
        if (elevationRangeSource !== undefined) {
            this.m_cameraOverride.copy(this.m_frustumIntersection.camera);
            this.m_cameraOverride.near = Math.min(this.m_cameraOverride.near, this.m_viewRange.minimum);
            this.m_cameraOverride.far = Math.max(this.m_cameraOverride.far, this.m_viewRange.maximum);
            this.m_cameraOverride.updateProjectionMatrix();
            this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);
        }
        else {
            this.m_frustumIntersection.updateFrustum();
        }
        // For each bucket of data sources with same tiling scheme, calculate frustum intersection
        // once using the maximum display level.
        for (const [tilingScheme, bucket] of dataSourceBuckets) {
            const zoomLevels = bucket.map(dataSource => dataSource.getDataZoomLevel(zoomLevel));
            const result = this.m_frustumIntersection.compute(tilingScheme, elevationRangeSource, zoomLevels, bucket);
            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;
            for (const dataSource of bucket) {
                // For each data source check what tiles from the intersection should be rendered
                // at this zoom level.
                const visibleTileKeys = [];
                const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);
                for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel).values()) {
                    if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {
                        visibleTileKeys.push(tileKeyEntry);
                    }
                }
                tileKeys.push({ dataSource, visibleTileKeys });
            }
        }
        return { tileKeys, allBoundingBoxesFinal };
    }
}
exports.VisibleTileSet = VisibleTileSet;
function viewRangesEqual(a, b) {
    return (a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near);
}


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedDecoder.ts":
/*!*************************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedDecoder.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerBasedDecoder = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Decoder based on [[ConcurrentWorkerSet]].
 *
 * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends decode requests,
 * - configuration.
 */
class WorkerBasedDecoder {
    /**
     * Creates a new `WorkerBasedDecoder`.
     *
     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.
     * @param decoderServiceType - Service type identifier.
     */
    constructor(workerSet, decoderServiceType) {
        this.workerSet = workerSet;
        this.decoderServiceType = decoderServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tile decoder services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.decoderServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Get {@link Tile} from tile decoder service in worker.
     *
     * @remarks
     * Invokes {@link @here/harp-datasource-protocol#DecodeTileRequest} on
     * [[TileDecoderService]] running in worker pool.
     */
    decodeTile(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.DecodeTileRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Get {@link @here/harp-datasource-protocol#TileInfo} from tile decoder service in worker.
     *
     * @remarks
     * Invokes {@link @here/harp-datasource-protocol#TileInfoRequest}
     * on [[TileDecoderService]] running in worker pool.
     */
    getTileInfo(data, tileKey, projection, requestController) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerDecoderProtocol.Requests.TileInfoRequest,
            tileKey: tileKeyCode,
            data,
            projection: harp_datasource_protocol_1.getProjectionName(projection)
        };
        const transferList = data instanceof ArrayBuffer ? [data] : undefined;
        return this.workerSet.invokeRequest(this.serviceId, message, transferList, requestController);
    }
    /**
     * Configure tile decoder service in workers.
     *
     * @remarks
     * Broadcasts {@link @here/harp-datasource-protocol#ConfigurationMessage}
     * to all [[TileDecoderService]]s running in worker pool.
     *
     * @param options - Options that will be applied to the styles
     * @param customOptions -   new options, undefined options are not changed
     */
    configure(options, customOptions) {
        const message = Object.assign(Object.assign({ service: this.serviceId, type: harp_datasource_protocol_1.WorkerDecoderProtocol.DecoderMessageName.Configuration }, options), { options: customOptions });
        this.workerSet.broadcastMessage(message);
    }
    /**
     * The number of workers started for this decoder. The value is `undefined` until the workers
     * have been created.
     */
    get workerCount() {
        return this.workerSet.workerCount;
    }
}
exports.WorkerBasedDecoder = WorkerBasedDecoder;


/***/ }),

/***/ "../harp-mapview/lib/WorkerBasedTiler.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/WorkerBasedTiler.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerBasedTiler = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
/**
 * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers
 * dedicated to different datasources.
 */
let nextUniqueServiceId = 0;
/**
 * Tiler based on [[ConcurrentWorkerSet]].
 *
 * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):
 * - connection establishment,
 * - sends tile requests,
 * - configuration.
 */
class WorkerBasedTiler {
    /**
     * Creates a new `WorkerBasedTiler`.
     *
     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.
     * @param tilerServiceType - Service type identifier.
     */
    constructor(workerSet, tilerServiceType) {
        this.workerSet = workerSet;
        this.tilerServiceType = tilerServiceType;
        this.m_serviceCreated = false;
        this.workerSet.addReference();
        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;
    }
    /**
     * Dispose of dedicated tiler services in workers and remove reference to underlying
     * [[ConcurrentWorkerSet]].
     */
    dispose() {
        if (this.m_serviceCreated) {
            this.workerSet
                .broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService,
                targetServiceId: this.serviceId
            })
                .catch(() => {
                /* Ignoring these errors as underlying workers possibly do not exist anymore. */
            });
        }
        this.workerSet.removeReference();
    }
    /**
     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates
     * dedicated [[TilerService]]s in all workers to serve tiling requests.
     */
    async connect() {
        await this.workerSet.connect(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        if (!this.m_serviceCreated) {
            await this.workerSet.broadcastRequest(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {
                type: harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService,
                targetServiceType: this.tilerServiceType,
                targetServiceId: this.serviceId
            });
            this.m_serviceCreated = true;
        }
    }
    /**
     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId - Index identifier.
     * @param input - Url to the index payload, or direct GeoJSON.
     */
    registerIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.RegisterIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved
     * tiled payloads using `getTile`.
     *
     * @param indexId - Index identifier.
     * @param input - Url to the index payload, or direct GeoJSON.
     */
    updateIndex(indexId, input) {
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.UpdateIndex,
            id: indexId,
            input: input instanceof URL ? input.href : input
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
    /**
     * Retrieves a tile for a previously registered index.
     *
     * @param indexId - Index identifier.
     * @param tileKey - The {@link @here/harp-geoutils#TileKey} that identifies the tile.
     */
    getTile(indexId, tileKey) {
        const tileKeyCode = tileKey.mortonCode();
        const message = {
            type: harp_datasource_protocol_1.WorkerTilerProtocol.Requests.TileRequest,
            index: indexId,
            tileKey: tileKeyCode
        };
        return this.workerSet.invokeRequest(this.serviceId, message);
    }
}
exports.WorkerBasedTiler = WorkerBasedTiler;


/***/ }),

/***/ "../harp-mapview/lib/composing/LowResRenderPass.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/composing/LowResRenderPass.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LowResRenderPass = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * The `LowResRenderPass` renders the scene at a lower resolution into an internal
 * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal
 * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.
 *
 * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be
 * visible.
 */
class LowResRenderPass extends Pass_1.Pass {
    /**
     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at
     * a quad.
     *
     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     */
    constructor(lowResPixelRatio) {
        super();
        this.lowResPixelRatio = lowResPixelRatio;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.CopyMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_savedWidth = 0;
        this.m_savedHeight = 0;
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
        this.m_pixelRatio = lowResPixelRatio;
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        this.m_quadMaterial.dispose();
        this.m_quad.geometry.dispose();
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * If a value is specified, a low resolution render pass is used to render the scene into a
     * low resolution render target, before it is copied to the screen.
     *
     * A value of `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     *
     * @default `undefined`
     */
    set pixelRatio(ratio) {
        this.m_pixelRatio = ratio;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio));
        }
    }
    get pixelRatio() {
        return this.m_pixelRatio;
    }
    /**
     * The render function of `LowResRenderPass`. It renders the whole scene into an internal
     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.
     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it
     * is the screen.
     *
     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene - The ThreeJS Scene instance to render the scene with.
     * @param camera - The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.
     * @override
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled || this.pixelRatio === undefined) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_savedWidth = readBuffer.width;
            this.m_savedHeight = readBuffer.height;
            this.m_renderTarget = new THREE.WebGLRenderTarget(Math.floor(this.m_savedWidth * this.pixelRatio), Math.floor(this.m_savedHeight * this.pixelRatio), {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                depthBuffer: true,
                stencilBuffer: true
            });
            this.m_renderTarget.texture.name = "LowResRenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        this.m_quadUniforms.opacity.value = 1.0;
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.m_renderTarget);
        renderer.clear();
        // Render into the low resolution internal render target.
        renderer.render(scene, camera);
        // Render the low resolution target into the screen.
        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.clear();
        renderer.render(this.m_quadScene, this.m_localCamera);
        renderer.setRenderTarget(oldRenderTarget);
    }
    /**
     * Resize the internal render target to match the new size specified. The size of internal
     * buffer depends on the `pixelRatio`.
     *
     * @param width - New width to apply to the render target.
     * @param height - New height to apply to the render target.
     * @override
     */
    setSize(width, height) {
        this.m_savedWidth = width;
        this.m_savedHeight = height;
        if (this.m_renderTarget && this.pixelRatio !== undefined) {
            this.m_renderTarget.setSize(Math.floor(width * this.pixelRatio), Math.floor(height * this.pixelRatio));
        }
    }
}
exports.LowResRenderPass = LowResRenderPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/MSAARenderPass.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/composing/MSAARenderPass.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MSAARenderPass = exports.MSAASampling = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
/**
 * This enum represents the sampling level to apply to
 * a {@link MSAARenderPass} instance. At level 0,
 * only one sample is performed, which is like
 * disabling the MSAA pass.
 */
var MSAASampling;
(function (MSAASampling) {
    MSAASampling[MSAASampling["Level_0"] = 0] = "Level_0";
    MSAASampling[MSAASampling["Level_1"] = 1] = "Level_1";
    MSAASampling[MSAASampling["Level_2"] = 2] = "Level_2";
    MSAASampling[MSAASampling["Level_3"] = 3] = "Level_3";
    MSAASampling[MSAASampling["Level_4"] = 4] = "Level_4";
    MSAASampling[MSAASampling["Level_5"] = 5] = "Level_5";
})(MSAASampling = exports.MSAASampling || (exports.MSAASampling = {}));
/**
 * {@link MapView}'s MSAA implementation.
 *
 * @remarks
 * MSAA stands for Multi Sampling Anti-Aliasing, and its concept
 * is to provide a rendering engine with additional color values for each pixel, so they can include
 * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation
 * with four samples. Because of its native nature, it is more efficient and one may not want to use
 * MapView's MSAA implementation when these four samples are satisfying. However in some situations
 * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the
 * number of samples at runtime. On the other hand, when the interaction stops, the engine also
 * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then
 * turn very noticeable. In such static renders, the number of samples could be dramatically
 * increased on a last frame to render.
 */
class MSAARenderPass extends Pass_1.Pass {
    /**
     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a
     * quad.
     *
     * @param m_scene - The scene to render.
     * @param m_camera - The camera to render the scene through.
     */
    constructor() {
        super();
        /**
         * The sampling level determines the number of samples that will be performed per frame.
         * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.
         * Therefore there can be between 1 and 32 samples.
         *
         * @default `SamplingLevel.Level_1`
         */
        this.samplingLevel = MSAASampling.Level_1;
        this.m_renderTarget = null;
        this.m_localCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_quadScene = new THREE.Scene();
        this.m_quadUniforms = harp_materials_1.CopyShader.uniforms;
        this.m_quadMaterial = new harp_materials_1.MSAAMaterial(this.m_quadUniforms);
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.m_quadMaterial);
        this.m_tmpColor = new THREE.Color();
        this.m_quad.frustumCulled = false;
        this.m_quadScene.add(this.m_quad);
    }
    /**
     * Releases all used resources.
     */
    dispose() {
        if (this.m_renderTarget !== null) {
            this.m_renderTarget.dispose();
            this.m_renderTarget = null;
        }
    }
    /**
     * The render function of `MSAARenderPass`.
     *
     * @remarks
     * At each call of this method, and for each sample the {@link MapView}
     * camera provided in the `render method is offset within the dimension of a
     * pixel on screen. It then renders the whole scene with this offset to a local
     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera
     * created in the constructor shoots the quad and renders to the write buffer or to the frame
     * buffer. The quad material's opacity is modified so the renders can accumulate in the
     * targetted buffer.
     *
     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].
     *
     * If there is no further pass, the {@link Pass.renderToScreen} flag can be set to `true` to
     * output directly to the framebuffer.
     *
     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.
     * @param scene - The ThreeJS Scene instance to render the scene with.
     * @param camera - The ThreeJS Camera instance to render the scene with.
     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.
     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.
     * @override
     */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        if (!this.enabled) {
            return;
        }
        // Initiates the local render target with the read buffer's dimensions, if not available.
        if (this.m_renderTarget === null) {
            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            });
            this.m_renderTarget.texture.name = "MSAARenderPass.sample";
        }
        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;
        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];
        const rendererClearColor = renderer.getClearColor(this.m_tmpColor);
        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;
        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain
        // its usability externally (like for the triple view in mosaic demo) we must cache the
        // previous values stored in `camera.view` and re-assign them at the end of the pass.
        // 1. Create a default cache object, with default dimensions the size of our read buffer.
        const oldView = {
            enabled: camera.view !== null && camera.view.enabled,
            fullWidth: readBuffer.width,
            fullHeight: readBuffer.height,
            x: 0,
            y: 0,
            width: readBuffer.width,
            height: readBuffer.height
        };
        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called
        // externally: copy the existing `camera.view` values in the cache. Override the cache
        // object with the values provided externally.
        if (oldView.enabled && camera.view !== null) {
            oldView.fullWidth = camera.view.fullWidth;
            oldView.fullHeight = camera.view.fullHeight;
            oldView.x = camera.view.offsetX;
            oldView.y = camera.view.offsetY;
            oldView.width = camera.view.width;
            oldView.height = camera.view.height;
        }
        const oldRenderTarget = renderer.getRenderTarget();
        for (let i = 0; i < offsets.length; i++) {
            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the
            // `camera.view` object in Three.js.
            const offset = offsets[i];
            camera.setViewOffset(oldView.fullWidth, oldView.fullHeight, oldView.x + offset[0] / 16, oldView.y + offset[1] / 16, oldView.width, oldView.height);
            // 5. Divide the opacity of the quad by the number of samples to accumulate on the
            // target buffer, and reduce the impact of the offset on color to reduce banding. Then
            // render.
            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;
            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;
            this.m_quadUniforms.opacity.value = sampleWeight;
            renderer.setRenderTarget(this.m_renderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            // 6. Render the quad on top of the previous renders.
            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`
            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
            if (i === 0) {
                renderer.setClearColor(0x000000);
                renderer.clear();
            }
            renderer.render(this.m_quadScene, this.m_localCamera);
            if (i === 0 && rendererClearColor !== undefined) {
                renderer.setClearColor(oldClearColor);
            }
        }
        renderer.setRenderTarget(oldRenderTarget);
        // 7. Restore `camera.view` as set externally (or not).
        if (camera.view !== null) {
            camera.view.enabled = oldView.enabled;
            camera.view.offsetX = oldView.x;
            camera.view.offsetY = oldView.y;
        }
    }
    /**
     * Resize the internal render target to match the new size specified.
     *
     * @param width - New width to apply to the render target.
     * @param height - New height to apply to the render target.
     * @override
     */
    setSize(width, height) {
        if (this.m_renderTarget) {
            this.m_renderTarget.setSize(width, height);
        }
    }
}
exports.MSAARenderPass = MSAARenderPass;
/**
 * The list of offsets to apply to the camera, per sampling level, adapted from :
 *
 * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
 */
MSAARenderPass.OffsetVectors = [
    [[0, 0]],
    [
        [4, 4],
        [-4, -4]
    ],
    [
        [-2, -6],
        [6, -2],
        [-6, 2],
        [2, 6]
    ],
    [
        [1, -3],
        [-1, 3],
        [5, 1],
        [-3, -5],
        [-5, 5],
        [-7, -1],
        [3, 7],
        [7, -7]
    ],
    [
        [1, 1],
        [-1, -3],
        [-3, 2],
        [4, -1],
        [-5, -2],
        [2, 5],
        [5, 3],
        [3, -5],
        [-2, 6],
        [0, -7],
        [-4, -6],
        [-6, 4],
        [-8, 0],
        [7, -4],
        [6, 7],
        [-7, -8]
    ],
    [
        [-4, -7],
        [-7, -5],
        [-3, -5],
        [-5, -4],
        [-1, -4],
        [-2, -2],
        [-6, -1],
        [-4, 0],
        [-7, 1],
        [-1, 2],
        [-6, 3],
        [-3, 3],
        [-7, 6],
        [-3, 6],
        [-5, 7],
        [-1, 7],
        [5, -7],
        [1, -6],
        [6, -5],
        [4, -4],
        [2, -3],
        [7, -2],
        [1, -1],
        [4, -1],
        [2, 1],
        [6, 2],
        [0, 4],
        [4, 4],
        [2, 5],
        [7, 5],
        [5, 6],
        [3, 7]
    ]
];


/***/ }),

/***/ "../harp-mapview/lib/composing/MapRenderingManager.ts":
/*!************************************************************!*\
  !*** ../harp-mapview/lib/composing/MapRenderingManager.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapRenderingManager = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const LowResRenderPass_1 = __webpack_require__(/*! ./LowResRenderPass */ "../harp-mapview/lib/composing/LowResRenderPass.ts");
const MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
const Outline_1 = __webpack_require__(/*! ./Outline */ "../harp-mapview/lib/composing/Outline.ts");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const UnrealBloomPass_1 = __webpack_require__(/*! ./UnrealBloomPass */ "../harp-mapview/lib/composing/UnrealBloomPass.ts");
const DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_1;
const DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAARenderPass_1.MSAASampling.Level_4;
/**
 * The implementation of {@link IMapRenderingManager} to
 * instantiate in {@link MapView} and manage the map
 * rendering.
 */
class MapRenderingManager {
    /**
     * The constructor of `MapRenderingManager`.
     *
     * @param width - Width of the frame buffer.
     * @param height - Height of the frame buffer.
     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal
     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give
     * good results. A value of `undefined` disables the low res render pass. The value should not
     * be larger than`window.devicePixelRatio`.
     * @param antialiasSetting - The object defining the demeanor of MSAA.
     */
    constructor(width, height, lowResPixelRatio, antialiasSettings = { msaaEnabled: false }) {
        this.bloom = {
            enabled: false,
            strength: 1.5,
            radius: 0.4,
            threshold: 0.85
        };
        this.outline = {
            enabled: false,
            thickness: 0.005,
            color: "#000000",
            ghostExtrudedPolygons: false,
            needsUpdate: false
        };
        this.vignette = {
            enabled: false,
            offset: 1.0,
            darkness: 1.0
        };
        this.sepia = {
            enabled: false,
            amount: 0.5
        };
        this.m_width = 1;
        this.m_height = 1;
        this.m_renderPass = new Pass_1.RenderPass();
        this.m_target1 = new THREE.WebGLRenderTarget(1, 1);
        this.m_target2 = new THREE.WebGLRenderTarget(1, 1);
        this.m_sepiaPass = new Pass_1.ShaderPass(harp_materials_1.SepiaShader);
        this.m_vignettePass = new Pass_1.ShaderPass(harp_materials_1.VignetteShader);
        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);
        this.m_msaaPass = new MSAARenderPass_1.MSAARenderPass();
        this.m_msaaPass.enabled =
            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;
        this.m_dynamicMsaaSamplingLevel =
            antialiasSettings.dynamicMsaaSamplingLevel === undefined
                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.dynamicMsaaSamplingLevel;
        this.m_staticMsaaSamplingLevel =
            antialiasSettings.staticMsaaSamplingLevel === undefined
                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL
                : antialiasSettings.staticMsaaSamplingLevel;
        this.m_lowResPass = new LowResRenderPass_1.LowResRenderPass(lowResPixelRatio);
        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;
    }
    updateOutline(options) {
        this.outline.color = options.color;
        this.outline.thickness = options.thickness;
        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;
        this.outline.needsUpdate = true;
    }
    /**
     * The method to call to render the map with the `MapRenderingManager` instance. It contains the
     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering
     * conditions as disabling AA when a high DPI device is in use.
     *
     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.
     * @param scene - The ThreeJS Scene instance containing the map objects to render.
     * @param camera - The ThreeJS Camera instance to render the scene through.
     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of
     * antialiasing.
     */
    render(renderer, scene, camera, isStaticFrame) {
        const target = null;
        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {
            // Not designed to be combined with our own MSAA
            this.m_lowResPass.renderToScreen = true;
            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);
            return;
        }
        const usePostEffects = this.bloom.enabled ||
            this.outline.enabled ||
            this.vignette.enabled ||
            this.sepia.enabled;
        let activeTarget = null;
        // 1. If the bloom is enabled, clear the depth.
        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
            renderer.setRenderTarget(this.m_target1);
            renderer.clearDepth();
        }
        // 2. Render the map.
        if (this.m_msaaPass.enabled) {
            // Use a higher MSAA sampling level for static rendering.
            this.m_msaaPass.samplingLevel = isStaticFrame
                ? this.m_staticMsaaSamplingLevel
                : this.m_dynamicMsaaSamplingLevel;
            // MSAA is the only effect for the moment.
            this.m_msaaPass.renderToScreen = !usePostEffects;
            // Render to the specified target with the MSAA pass.
            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);
        }
        else {
            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {
                activeTarget = this.m_target1;
                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null);
            }
            else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {
                renderer.render(scene, camera);
            }
        }
        // 3. Apply effects
        if (this.outline.enabled) {
            if (this.m_outlineEffect === undefined) {
                this.m_outlineEffect = new Outline_1.OutlineEffect(renderer);
            }
            if (this.outline.needsUpdate) {
                this.m_outlineEffect.color = this.outline.color;
                this.m_outlineEffect.thickness = this.outline.thickness;
                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;
                this.outline.needsUpdate = false;
            }
            const nextEffectEnabled = this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;
            if (nextEffectEnabled) {
                activeTarget = this.m_target1;
            }
            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null);
            this.m_outlineEffect.render(scene, camera);
        }
        if (this.bloom.enabled) {
            if (this.m_bloomPass === undefined) {
                this.m_bloomPass = new UnrealBloomPass_1.BloomPass(new THREE.Vector2(this.m_width, this.m_height), this.bloom.strength, this.bloom.radius, this.bloom.threshold);
            }
            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;
            this.m_bloomPass.renderToScreen = !nextEffectEnabled;
            this.m_bloomPass.radius = this.bloom.radius;
            this.m_bloomPass.strength = this.bloom.strength;
            this.m_bloomPass.threshold = this.bloom.threshold;
            this.m_bloomPass.render(renderer, scene, camera, null, activeTarget);
        }
        else if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.dispose();
            this.m_bloomPass = undefined;
        }
        if (this.vignette.enabled) {
            const oldTarget = activeTarget;
            const nextEffectEnabled = this.sepia.enabled;
            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;
            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;
            this.m_vignettePass.renderToScreen = !nextEffectEnabled;
            if (nextEffectEnabled) {
                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;
            }
            this.m_vignettePass.render(renderer, scene, camera, activeTarget, oldTarget);
        }
        if (this.sepia.enabled) {
            this.m_sepiaPass.renderToScreen = true;
            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;
            this.m_sepiaPass.render(renderer, scene, camera, null, activeTarget);
        }
    }
    /**
     * The resize function to call on resize events to resize the render targets. It shall include
     * the resize methods of all the sub-passes used in `MapRenderingManager`.
     *
     * @param width - New width to use.
     * @param height - New height to use.
     */
    setSize(width, height) {
        this.m_readBuffer.setSize(width, height);
        this.m_msaaPass.setSize(width, height);
        if (this.m_bloomPass !== undefined) {
            this.m_bloomPass.setSize(width, height);
        }
        this.m_lowResPass.setSize(width, height);
        this.m_target1.setSize(width, height);
        this.m_target2.setSize(width, height);
        this.m_width = width;
        this.m_height = height;
    }
    /**
     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values
     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of
     * `undefined` disables the low res render pass. The value should not be larger than
     * `window.devicePixelRatio`.
     */
    get lowResPixelRatio() {
        return this.m_lowResPass.pixelRatio;
    }
    set lowResPixelRatio(pixelRatio) {
        this.m_lowResPass.pixelRatio = pixelRatio;
        this.m_lowResPass.enabled = pixelRatio !== undefined;
    }
    /**
     * Set the level of sampling while the user interacts.
     *
     * @param samplingLevel - The sampling level.
     */
    set dynamicMsaaSamplingLevel(samplingLevel) {
        this.m_dynamicMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined during continuous rendering.
     */
    get dynamicMsaaSamplingLevel() {
        return this.m_dynamicMsaaSamplingLevel;
    }
    /**
     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided
     * in the {@link MapRenderingManager.render} method to render the scene.
     *
     * @param value - If `true`, MSAA is enabled, disabled otherwise.
     */
    set msaaEnabled(value) {
        this.m_msaaPass.enabled = value;
    }
    /**
     * Return whether the MSAA is enabled.
     */
    get msaaEnabled() {
        return this.m_msaaPass.enabled;
    }
    /**
     * Set the sampling level for rendering static frames.
     *
     * @param samplingLevel - The sampling level.
     */
    set staticMsaaSamplingLevel(samplingLevel) {
        this.m_staticMsaaSamplingLevel = samplingLevel;
    }
    /**
     * Return the sampling level defined for rendering static frames.
     */
    get staticMsaaSamplingLevel() {
        return this.m_staticMsaaSamplingLevel;
    }
}
exports.MapRenderingManager = MapRenderingManager;


/***/ }),

/***/ "../harp-mapview/lib/composing/Outline.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/composing/Outline.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutlineEffect = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const vertexShaderChunk = `
#ifdef USE_EXTRUSION
  #ifndef HAS_EXTRUSION_PARS_VERTEX
    #include <extrusion_pars_vertex>
  #endif
#endif

#ifdef USE_FADING
  #include <fading_pars_vertex>
#endif

uniform float outlineThickness;

vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {
    float thickness = outlineThickness;
    const float ratio = 1.0;
    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );
    vec4 norm = normalize( pos - pos2 );
    return pos + norm * thickness * pos.w * ratio;
}`;
const vertexShaderChunk2 = `
#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )
    #ifndef USE_ENVMAP
        vec3 objectNormal = normalize( normal );
    #endif
#endif

#ifdef FLIP_SIDED
    objectNormal = -objectNormal;
#endif

#ifdef DECLARE_TRANSFORMED
    vec3 transformed = vec3( position );
#endif

#ifdef USE_EXTRUSION
 #ifndef HAS_EXTRUSION_VERTEX
  #include <extrusion_vertex>
 #endif
#endif

#ifdef USE_FADING
  #include <fading_vertex>
#endif

#ifdef USE_EXTRUSION
  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),
      objectNormal, vec4( transformed, 1.0 ) );
#else
  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );
#endif

#include <fog_vertex>`;
const fragmentShader = `
#include <common>
#include <fog_pars_fragment>

#ifdef USE_EXTRUSION
  #include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
  #include <fading_pars_fragment>
#endif

uniform vec3 outlineColor;
uniform float outlineAlpha;

void main() {

    gl_FragColor = vec4( outlineColor, outlineAlpha );

    #include <fog_fragment>

    #ifdef USE_EXTRUSION
      #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
      #include <fading_fragment>
    #endif
}`;
/**
 * Effect to render bold lines around extruded polygons.
 *
 * Implemented by rendering the mesh geometries with an outline material before rendering them
 * again with their original.
 */
class OutlineEffect {
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.enabled = true;
        this.m_defaultThickness = 0.02;
        this.m_defaultColor = new THREE.Color(0, 0, 0);
        this.m_defaultAlpha = 1;
        this.m_defaultKeepAlive = false;
        this.m_ghostExtrudedPolygons = false;
        this.m_cache = {};
        this.m_removeThresholdCount = 60;
        this.m_originalMaterials = {};
        this.m_originalOnBeforeRenders = {};
        this.m_shaderIDs = {
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical"
        };
        this.m_uniformsChunk = {
            outlineThickness: { value: this.m_defaultThickness },
            outlineColor: { value: this.m_defaultColor },
            outlineAlpha: { value: this.m_defaultAlpha }
        };
        this.autoClear = m_renderer.autoClear;
        this.domElement = m_renderer.domElement;
        this.shadowMap = m_renderer.shadowMap;
    }
    set thickness(thickness) {
        this.m_defaultThickness = thickness;
        this.m_uniformsChunk.outlineThickness.value = thickness;
        this.m_cache = {};
    }
    set color(color) {
        this.m_defaultColor.set(color);
        this.m_cache = {};
    }
    set ghostExtrudedPolygons(ghost) {
        this.m_ghostExtrudedPolygons = ghost;
    }
    clear(color, depth, stencil) {
        this.m_renderer.clear(color, depth, stencil);
    }
    getPixelRatio() {
        return this.m_renderer.getPixelRatio();
    }
    setPixelRatio(value) {
        this.m_renderer.setPixelRatio(value);
    }
    getSize(target) {
        return this.m_renderer.getSize(target);
    }
    setSize(width, height, updateStyle) {
        this.m_renderer.setSize(width, height, updateStyle);
    }
    setViewport(x, y, width, height) {
        this.m_renderer.setViewport(x, y, width, height);
    }
    setScissor(x, y, width, height) {
        this.m_renderer.setScissor(x, y, width, height);
    }
    setScissorTest(boolean) {
        this.m_renderer.setScissorTest(boolean);
    }
    setRenderTarget(renderTarget) {
        this.m_renderer.setRenderTarget(renderTarget);
    }
    render(scene, camera) {
        // Re-rendering the scene with the outline effect enables to hide the
        // extruded polygons and show only the outlines (it is a hack and should be
        // implemented another way!).
        if (this.m_ghostExtrudedPolygons) {
            if (!this.enabled) {
                this.m_renderer.render(scene, camera);
                return;
            }
            const currentAutoClear = this.m_renderer.autoClear;
            this.m_renderer.autoClear = this.autoClear;
            this.m_renderer.render(scene, camera);
            this.m_renderer.autoClear = currentAutoClear;
        }
        this.renderOutline(scene, camera);
    }
    renderOutline(scene, camera) {
        const currentAutoClear = this.m_renderer.autoClear;
        const currentSceneAutoUpdate = scene.autoUpdate;
        const currentSceneBackground = scene.background;
        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        this.m_renderer.autoClear = false;
        this.m_renderer.shadowMap.enabled = false;
        scene.traverse(this.setOutlineMaterial.bind(this));
        this.m_renderer.render(scene, camera);
        scene.traverse(this.restoreOriginalMaterial.bind(this));
        this.cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        this.m_renderer.autoClear = currentAutoClear;
        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
    createInvisibleMaterial() {
        return new THREE.ShaderMaterial({ name: "invisible", visible: false });
    }
    createMaterial(originalMaterial) {
        // EdgeMaterial or depth prepass material should not be used for outlines.
        if (originalMaterial instanceof harp_materials_1.EdgeMaterial ||
            originalMaterial.isDepthPrepassMaterial === true) {
            return this.createInvisibleMaterial();
        }
        const shaderID = this.m_shaderIDs[originalMaterial.type];
        let originalVertexShader;
        let originalUniforms = originalMaterial.shaderUniforms !== undefined
            ? originalMaterial.shaderUniforms
            : originalMaterial.uniforms;
        if (shaderID !== undefined) {
            const shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        }
        else if (originalMaterial.isRawShaderMaterial === true) {
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) ||
                !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                return this.createInvisibleMaterial();
            }
        }
        else if (originalMaterial.isShaderMaterial === true) {
            originalVertexShader = originalMaterial.vertexShader;
        }
        else {
            return this.createInvisibleMaterial();
        }
        const isExtrusionMaterial = originalMaterial.shaderUniforms !== undefined &&
            originalMaterial.shaderUniforms.extrusionRatio !== undefined;
        const isFadingMaterial = harp_materials_1.FadingFeature.isDefined(originalMaterial);
        const uniforms = Object.assign(Object.assign({}, originalUniforms), this.m_uniformsChunk);
        const vertexShader = originalVertexShader
            // put vertexShaderChunk right before "void main() {...}"
            .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")
            // put vertexShaderChunk2 the end of "void main() {...}"
            // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
            .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")
            // remove any light related lines
            // Note: here is very sensitive to originalVertexShader
            // TODO: consider safer way
            .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        const defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) &&
            !/#include\s+<begin_vertex>/.test(originalVertexShader)) {
            defines.DECLARE_TRANSFORMED = true;
        }
        if (isExtrusionMaterial) {
            // If the original material is setup for animated extrusion (like buildings), add the
            // uniform describing the extrusion to the outline material.
            uniforms.extrusionRatio = { value: harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN };
            defines.USE_EXTRUSION = 1;
        }
        if (isFadingMaterial) {
            uniforms.fadeNear = {
                value: originalUniforms.fadeNear !== undefined
                    ? originalUniforms.fadeNear.value
                    : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR
            };
            uniforms.fadeFar = {
                value: originalUniforms.fadeFar !== undefined
                    ? originalUniforms.fadeFar.value
                    : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR
            };
            defines.USE_FADING = 1;
        }
        const outlineMaterial = new THREE.ShaderMaterial({
            defines,
            uniforms,
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
            morphTargets: false,
            morphNormals: false,
            fog: false,
            blending: THREE.CustomBlending,
            blendSrc: THREE.SrcAlphaFactor,
            blendDst: THREE.OneMinusSrcAlphaFactor,
            blendSrcAlpha: THREE.OneFactor,
            blendDstAlpha: THREE.OneMinusSrcAlphaFactor,
            transparent: true,
            polygonOffset: true,
            // Extreme values used here to reduce artifacts, especially at tile borders.
            polygonOffsetFactor: 10.0,
            polygonOffsetUnits: 30.0
        });
        return outlineMaterial;
    }
    getOutlineMaterialFromCache(originalMaterial) {
        let data = this.m_cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: this.createMaterial(originalMaterial),
                used: true,
                keepAlive: this.m_defaultKeepAlive,
                count: 0
            };
            this.m_cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    getOutlineMaterial(originalMaterial) {
        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);
        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;
        this.updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    setOutlineMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.getOutlineMaterial(object.material[i]);
            }
        }
        else {
            object.material = this.getOutlineMaterial(object.material);
        }
        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, this.onBeforeRender.bind(this));
    }
    restoreOriginalMaterial(object) {
        if (object.material === undefined) {
            return;
        }
        if (Array.isArray(object.material)) {
            for (let i = 0, il = object.material.length; i < il; i++) {
                object.material[i] = this.m_originalMaterials[object.material[i].uuid];
            }
        }
        else {
            object.material = this.m_originalMaterials[object.material.uuid];
        }
        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
        const originalMaterial = this.m_originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) {
            return;
        }
        this.updateUniforms(material, originalMaterial);
    }
    updateUniforms(material, originalMaterial) {
        var _a;
        const outlineParameters = originalMaterial.userData.outlineParameters;
        const outlineUniforms = material.uniforms;
        outlineUniforms.outlineAlpha.value = originalMaterial.opacity;
        const originalUniforms = originalMaterial.shaderUniforms !== undefined
            ? originalMaterial.shaderUniforms
            : originalMaterial.uniforms;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) {
                outlineUniforms.outlineThickness.value = outlineParameters.thickness;
            }
            if (outlineParameters.color !== undefined) {
                outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);
            }
            if (outlineParameters.alpha !== undefined) {
                outlineUniforms.outlineAlpha.value = outlineParameters.alpha;
            }
        }
        // If the original material is setup for animated extrusion (like buildings), update the
        // uniforms in the outline material.
        if (originalUniforms !== undefined && originalUniforms.extrusionRatio !== undefined) {
            const value = originalMaterial.shaderUniforms.extrusionRatio.value;
            material.extrusionRatio = value;
            material.uniforms.extrusionRatio.value =
                value !== undefined ? value : harp_materials_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
        }
        // Copy available fading params to the outline material.
        if (((_a = material.defines) === null || _a === void 0 ? void 0 : _a.USE_FADING) !== undefined &&
            originalUniforms.fadeNear !== undefined &&
            originalUniforms.fadeFar !== undefined &&
            originalUniforms.fadeFar.value >= 0.0) {
            outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;
            outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;
        }
    }
    updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") {
            return;
        }
        const outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            material.visible =
                originalMaterial.visible === false
                    ? false
                    : outlineParameters.visible !== undefined
                        ? outlineParameters.visible
                        : true;
            if (outlineParameters.keepAlive !== undefined) {
                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
            }
        }
        else {
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) {
            material.visible = false;
        }
    }
    cleanupCache() {
        let keys;
        // clear originialMaterials
        keys = Object.keys(this.m_originalMaterials);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalMaterials[keys[i]] = undefined;
        }
        // clear originalOnBeforeRenders
        keys = Object.keys(this.m_originalOnBeforeRenders);
        for (let i = 0, il = keys.length; i < il; i++) {
            this.m_originalOnBeforeRenders[keys[i]] = undefined;
        }
        // remove unused outlineMaterial from cache
        keys = Object.keys(this.m_cache);
        for (const key of keys) {
            if (this.m_cache[key].used === false) {
                this.m_cache[key].count++;
                if (this.m_cache[key].keepAlive === false &&
                    this.m_cache[key].count > this.m_removeThresholdCount) {
                    delete this.m_cache[key];
                }
            }
            else {
                this.m_cache[key].used = false;
                this.m_cache[key].count = 0;
            }
        }
    }
}
exports.OutlineEffect = OutlineEffect;


/***/ }),

/***/ "../harp-mapview/lib/composing/Pass.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/composing/Pass.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShaderPass = exports.RenderPass = exports.Pass = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base class to extend for further passes in {@link MapView},
 * like the {@link MSAARenderPass},
 *
 * @remarks
 * `Pass` provides the core logic for both :
 * - render passes (proper scene renders),
 * - and shader passes (quad renders, i.e. effects added on top of the render output as a
 * postprocess).
 *
 * Even some shader passes still actually fall within the render pass category as they need to
 * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the
 * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.
 * These only are proper shader passes.
 */
class Pass {
    constructor() {
        this.enabled = false;
        this.renderToScreen = false;
    }
    setSize(width, height) {
        // Implemented in sub-classes.
    }
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        // Implemented in sub-classes.
    }
}
exports.Pass = Pass;
/**
 * The pass that does a default normal scene rendering for further post-effects.
 */
class RenderPass extends Pass {
    constructor() {
        super();
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        renderer.render(scene, camera);
    }
}
exports.RenderPass = RenderPass;
/**
 * The base class to extend for post-effects on the final render (like Vignette, Sepia, color
 * correction...)
 */
class ShaderPass extends Pass {
    constructor(shader, textureID = "tDiffuse") {
        super();
        this.textureID = textureID;
        if (shader instanceof THREE.ShaderMaterial) {
            this.uniforms = shader.uniforms;
            this.material = shader;
        }
        else {
            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
            this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, shader.defines),
                uniforms: this.uniforms,
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            });
        }
        this.fsQuad = new FullScreenQuad(this.material);
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.fsQuad.material = this.material;
        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
        this.fsQuad.render(renderer);
    }
}
exports.ShaderPass = ShaderPass;
class FullScreenQuad {
    constructor(material) {
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const geometry = new THREE.PlaneBufferGeometry(2, 2);
        this.m_mesh = new THREE.Mesh(geometry, material);
    }
    get material() {
        return this.m_mesh.material;
    }
    set material(value) {
        this.m_mesh.material = value;
    }
    render(renderer) {
        renderer.render(this.m_mesh, this.m_camera);
    }
}


/***/ }),

/***/ "../harp-mapview/lib/composing/UnrealBloomPass.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/composing/UnrealBloomPass.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BloomPass = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
const BlurDirectionX = new THREE.Vector2(1.0, 0.0);
const BlurDirectionY = new THREE.Vector2(0.0, 1.0);
/**
 * The TS version of ThreeJS's UnrealBloomPass.
 */
class BloomPass extends Pass_1.Pass {
    constructor(resolution, strength, radius, threshold) {
        super();
        this.resolution = new THREE.Vector2(256, 256);
        this.m_renderTargetsHorizontal = [];
        this.m_renderTargetsVertical = [];
        this.m_nMips = 5;
        this.m_separableBlurMaterials = [];
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.m_scene = new THREE.Scene();
        this.m_basic = new THREE.MeshBasicMaterial();
        this.m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));
        this.m_bloomTintColors = [
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1),
            new THREE.Vector3(1, 1, 1)
        ];
        this.strength = strength;
        this.radius = radius;
        this.threshold = threshold;
        this.resolution = resolution;
        this.m_quad.frustumCulled = false;
        this.m_scene.add(this.m_quad);
        const pars = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat
        };
        let resx = Math.round(this.resolution.x / 2);
        let resy = Math.round(this.resolution.y / 2);
        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
        this.m_renderTargetBright.texture.name = "UnrealBloomPass.bright";
        this.m_renderTargetBright.texture.generateMipmaps = false;
        for (let i = 0; i < this.m_nMips; i++) {
            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
            renderTargetHorizonal.texture.generateMipmaps = false;
            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);
            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
            renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this.m_renderTargetsVertical.push(renderTargetVertical);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        this.m_highPassUniforms = THREE.UniformsUtils.clone(harp_materials_1.LuminosityHighPassShader.uniforms);
        this.m_highPassUniforms["luminosityThreshold"].value = threshold;
        this.m_highPassUniforms["smoothWidth"].value = 0.01;
        this.m_materialHighPassFilter = new THREE.ShaderMaterial({
            uniforms: this.m_highPassUniforms,
            vertexShader: harp_materials_1.LuminosityHighPassShader.vertexShader,
            fragmentShader: harp_materials_1.LuminosityHighPassShader.fragmentShader,
            defines: {}
        });
        // Gaussian Blur Materials
        const kernelSizeArray = [3, 5, 7, 9, 11];
        resx = Math.round(this.resolution.x / 2);
        resy = Math.round(this.resolution.y / 2);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
        // Composite material
        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);
        this.m_compositeMaterial.uniforms["blurTexture1"].value = this.m_renderTargetsVertical[0].texture;
        this.m_compositeMaterial.uniforms["blurTexture2"].value = this.m_renderTargetsVertical[1].texture;
        this.m_compositeMaterial.uniforms["blurTexture3"].value = this.m_renderTargetsVertical[2].texture;
        this.m_compositeMaterial.uniforms["blurTexture4"].value = this.m_renderTargetsVertical[3].texture;
        this.m_compositeMaterial.uniforms["blurTexture5"].value = this.m_renderTargetsVertical[4].texture;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = 0.1;
        this.m_compositeMaterial.needsUpdate = true;
        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
        this.m_compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        this.m_copyUniforms = THREE.UniformsUtils.clone(harp_materials_1.CopyShader.uniforms);
        this.m_copyUniforms["opacity"].value = 1.0;
        this.m_materialCopy = new THREE.ShaderMaterial({
            uniforms: this.m_copyUniforms,
            vertexShader: harp_materials_1.CopyShader.vertexShader,
            fragmentShader: harp_materials_1.CopyShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
    }
    dispose() {
        for (const rt of this.m_renderTargetsHorizontal) {
            rt.dispose();
        }
        for (const rt of this.m_renderTargetsVertical) {
            rt.dispose();
        }
        this.m_renderTargetBright.dispose();
    }
    /** @override */
    setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this.m_renderTargetBright.setSize(resx, resy);
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_renderTargetsHorizontal[i].setSize(resx, resy);
            this.m_renderTargetsVertical[i].setSize(resx, resy);
            this.m_separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    /** @override */
    render(renderer, scene, camera, writeBuffer, readBuffer) {
        // Render input to screen
        if (this.renderToScreen) {
            this.m_quad.material = this.m_basic;
            this.m_basic.map = readBuffer.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
        }
        // 1. Extract bright areas
        this.m_highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.m_highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.m_quad.material = this.m_materialHighPassFilter;
        renderer.setRenderTarget(this.m_renderTargetBright);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this.m_renderTargetBright;
        for (let i = 0; i < this.m_nMips; i++) {
            this.m_quad.material = this.m_separableBlurMaterials[i];
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value =
                inputRenderTarget.texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionX;
            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            this.m_separableBlurMaterials[i].uniforms["colorTexture"].value = this.m_renderTargetsHorizontal[i].texture;
            this.m_separableBlurMaterials[i].uniforms["direction"].value = BlurDirectionY;
            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);
            renderer.clear();
            renderer.render(this.m_scene, this.m_camera);
            inputRenderTarget = this.m_renderTargetsVertical[i];
        }
        // Composite all the mips
        this.m_quad.material = this.m_compositeMaterial;
        this.m_compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.m_compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.m_compositeMaterial.uniforms["bloomTintColors"].value = this.m_bloomTintColors;
        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);
        renderer.clear();
        renderer.render(this.m_scene, this.m_camera);
        // Blend it additively over the input texture
        this.m_quad.material = this.m_materialCopy;
        this.m_copyUniforms["tDiffuse"].value = this.m_renderTargetsHorizontal[0].texture;
        if (this.renderToScreen) {
            renderer.setRenderTarget(null);
            renderer.render(this.m_scene, this.m_camera);
        }
        else {
            renderer.setRenderTarget(readBuffer);
            renderer.render(this.m_scene, this.m_camera);
        }
    }
    getSeperableBlurMaterial(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new THREE.Vector2(0.5, 0.5) },
                direction: { value: new THREE.Vector2(0.5, 0.5) }
            },
            vertexShader: `varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }`,
            fragmentShader: `#include <common>
            varying vec2 vUv;
            uniform sampler2D colorTexture;
            uniform vec2 texSize;
            uniform vec2 direction;

            float gaussianPdf(in float x, in float sigma) {
                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
            }
            void main() {\n\
                vec2 invSize = 1.0 / texSize;
                float fSigma = float(SIGMA);
                float weightSum = gaussianPdf(0.0, fSigma);
                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
                    float x = float(i);
                    float w = gaussianPdf(x, fSigma);
                    vec2 uvOffset = direction * invSize * x;
                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
                    diffuseSum += (sample1 + sample2) * w;
                    weightSum += 2.0 * w;
                }
                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
            }`
        });
    }
    getCompositeMaterial(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: { value: null },
                blurTexture2: { value: null },
                blurTexture3: { value: null },
                blurTexture4: { value: null },
                blurTexture5: { value: null },
                dirtTexture: { value: null },
                bloomStrength: { value: 1.0 },
                bloomFactors: { value: null },
                bloomTintColors: { value: null },
                bloomRadius: { value: 0.0 }
            },
            vertexShader: `varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
            fragmentShader: `varying vec2 vUv;
                uniform sampler2D blurTexture1;
                uniform sampler2D blurTexture2;
                uniform sampler2D blurTexture3;
                uniform sampler2D blurTexture4;
                uniform sampler2D blurTexture5;
                uniform sampler2D dirtTexture;
                uniform float bloomStrength;
                uniform float bloomRadius;
                uniform float bloomFactors[NUM_MIPS];
                uniform vec3 bloomTintColors[NUM_MIPS];

                float lerpBloomFactor(const in float factor) {
                    float mirrorFactor = 1.2 - factor;
                    return mix(factor, mirrorFactor, bloomRadius);
                }

                void main() {
                    gl_FragColor = bloomStrength * (
lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
                }`
        });
    }
}
exports.BloomPass = BloomPass;


/***/ }),

/***/ "../harp-mapview/lib/composing/index.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/composing/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MSAASampling = exports.MSAARenderPass = exports.Pass = exports.MapRenderingManager = void 0;
var MapRenderingManager_1 = __webpack_require__(/*! ./MapRenderingManager */ "../harp-mapview/lib/composing/MapRenderingManager.ts");
Object.defineProperty(exports, "MapRenderingManager", ({ enumerable: true, get: function () { return MapRenderingManager_1.MapRenderingManager; } }));
var Pass_1 = __webpack_require__(/*! ./Pass */ "../harp-mapview/lib/composing/Pass.ts");
Object.defineProperty(exports, "Pass", ({ enumerable: true, get: function () { return Pass_1.Pass; } }));
var MSAARenderPass_1 = __webpack_require__(/*! ./MSAARenderPass */ "../harp-mapview/lib/composing/MSAARenderPass.ts");
Object.defineProperty(exports, "MSAARenderPass", ({ enumerable: true, get: function () { return MSAARenderPass_1.MSAARenderPass; } }));
Object.defineProperty(exports, "MSAASampling", ({ enumerable: true, get: function () { return MSAARenderPass_1.MSAASampling; } }));


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts":
/*!*******************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyrightCoverageProvider = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const RBush = __webpack_require__(/*! rbush */ "../harp-mapview/node_modules/rbush/rbush.min.js");
/**
 * Base class to provide copyrights based on copyright coverage information, defined by geographical
 * bounding boxes and relevant zoom level ranges.
 */
class CopyrightCoverageProvider {
    constructor() {
        /** Logger instance. */
        this.logger = harp_utils_1.LoggerManager.instance.create("CopyrightCoverageProvider");
    }
    /** @inheritdoc */
    getTree() {
        if (this.m_cachedTreePromise !== undefined) {
            return this.m_cachedTreePromise;
        }
        this.m_cachedTreePromise = this.getCopyrightCoverageData()
            .then(coverageInfo => this.initRBush(coverageInfo))
            .catch(error => {
            this.logger.error(error);
            return new RBush();
        });
        return this.m_cachedTreePromise;
    }
    /** @inheritdoc */
    async getCopyrights(geoBox, level) {
        const tree = await this.getTree();
        const result = [];
        const matchingEntries = tree.search({
            minX: geoBox.west,
            minY: geoBox.south,
            maxX: geoBox.east,
            maxY: geoBox.north
        });
        for (const entry of matchingEntries) {
            const minLevel = harp_utils_1.getOptionValue(entry.minLevel, 0);
            const maxLevel = harp_utils_1.getOptionValue(entry.maxLevel, Infinity);
            if (level >= minLevel && level <= maxLevel) {
                if (result.find(item => item.id === entry.label) === undefined) {
                    result.push({ id: entry.label });
                }
            }
        }
        return result;
    }
    /**
     * Initializes RBush.
     *
     * @param entries - Entries for tree.
     * @returns RBush instance.
     */
    initRBush(entries) {
        const tree = new RBush();
        if (!entries) {
            this.logger.warn("No copyright coverage data provided");
            return tree;
        }
        for (const entry of entries) {
            const { minLevel, maxLevel, label, alt } = entry;
            if (!entry.boxes) {
                tree.insert({
                    minX: -180,
                    minY: -90,
                    maxX: 180,
                    maxY: 180,
                    minLevel,
                    maxLevel,
                    label,
                    alt
                });
            }
            else {
                for (const box of entry.boxes) {
                    const [minY, minX, maxY, maxX] = box;
                    tree.insert({
                        minX,
                        minY,
                        maxX,
                        maxY,
                        minLevel,
                        maxLevel,
                        label,
                        alt
                    });
                }
            }
        }
        return tree;
    }
}
exports.CopyrightCoverageProvider = CopyrightCoverageProvider;


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightElementHandler.ts":
/*!*****************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightElementHandler.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyrightElementHandler = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const MapView_1 = __webpack_require__(/*! ../MapView */ "../harp-mapview/lib/MapView.ts");
const CopyrightInfo_1 = __webpack_require__(/*! ./CopyrightInfo */ "../harp-mapview/lib/copyrights/CopyrightInfo.ts");
/**
 * Helper class that maintains up-to-date {@link MapView} copyright information in DOM element.
 *
 * @example
 *
 *     // HTML snippet
 *     <div id="copyrightNotice" style="position:absolute; right:0; bottom:0; z-index:100"></div>
 *
 *     // JavaScript
 *     const mapView = new MapView({ ... });
 *     CopyrightElementHandler.install("copyrightNotice", mapView);
 */
class CopyrightElementHandler {
    /**
     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info
     * of the given `mapView`.
     *
     * Note: Generally, the static [[install]] method can be used to create and attach a new
     * `CopyrightElementHandler` to a {@link MapView}
     *
     * @param element - HTML DOM element or a HTML DOM element id
     * @param mapView - optional, [[attach]] to this {@link MapView} instance
     */
    constructor(element, mapView) {
        this.m_defaults = new Map();
        this.m_mapViews = [];
        /**
         * Update copyright info text in controlled HTML element.
         */
        this.update = () => {
            var _a;
            const mergedCopyrightInfo = this.m_mapViews
                .map(mapView => mapView.copyrightInfo)
                .reduce(CopyrightInfo_1.CopyrightInfo.mergeArrays, (_a = this.staticInfo) !== null && _a !== void 0 ? _a : []);
            // Conditionally hiding of element with copyright information.
            // If nothing to show we schould to avoid empty white rectangle in right bottom corner.
            if (mergedCopyrightInfo.length === 0) {
                this.m_element.style.display = "none";
                return;
            }
            else {
                this.m_element.style.display = "block";
            }
            if (this.m_defaults.size !== 0) {
                for (const sourceInfo of mergedCopyrightInfo) {
                    const defaults = this.m_defaults.get(sourceInfo.id);
                    if (defaults !== undefined) {
                        sourceInfo.year = harp_utils_1.getOptionValue(sourceInfo.year, defaults.year);
                        sourceInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, defaults.label);
                        sourceInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, defaults.link);
                    }
                }
            }
            const deduped = CopyrightInfo_1.CopyrightInfo.mergeArrays(mergedCopyrightInfo);
            this.m_element.innerHTML = CopyrightInfo_1.CopyrightInfo.formatAsHtml(deduped);
        };
        if (typeof element === "string") {
            const htmlElement = document.getElementById(element);
            if (!htmlElement) {
                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);
            }
            this.m_element = htmlElement;
        }
        else {
            this.m_element = element;
        }
        if (mapView !== undefined) {
            this.attach(mapView);
        }
    }
    /**
     * Install {@link CopyrightElementHandler} on DOM element and - optionally -
     * attach to a {@link MapView} instance.
     *
     * @param element - HTML DOM element or a HTML DOM element id
     * @param mapView -, optional, [[attach]] to this {@link MapView}
     */
    static install(element, mapView) {
        return new CopyrightElementHandler(element, mapView);
    }
    /**
     * Destroys this object by removing all event listeners from the attached {@link MapView}s.
     */
    destroy() {
        for (const mapView of this.m_mapViews) {
            mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        }
    }
    /**
     * Attaches this {@link CopyrightInfo} updates from {@link MapView} instance.
     */
    attach(mapView) {
        this.m_mapViews.push(mapView);
        mapView.addEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.update();
        return this;
    }
    /**
     * Stop following {@link CopyrightInfo} updates from {@link MapView} instance.
     */
    detach(mapView) {
        mapView.removeEventListener(MapView_1.MapViewEventNames.CopyrightChanged, this.update);
        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);
        this.update();
        return this;
    }
    /**
     * Set {@link CopyrightInfo} defaults to be used in case
     * {@link DataSource} does not provide deatailed
     * copyright information.
     *
     * @remarks
     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright
     * information retrieved from {@link MapView}.
     */
    setDefaults(defaults) {
        this.m_defaults.clear();
        if (defaults !== undefined) {
            for (const item of defaults) {
                this.m_defaults.set(item.id, item);
            }
        }
        return this;
    }
    /**
     * Sets the [[staticInfo]] property.
     *
     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and
     * copyright information obtained from attached {@link MapView}s.
     *
     * This information is used when {@link DataSource}
     * instances of given {@link MapView} do not provide
     * copyright information.
     */
    setStaticCopyightInfo(staticInfo) {
        this.staticInfo = staticInfo;
        return this;
    }
}
exports.CopyrightElementHandler = CopyrightElementHandler;


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightInfo.ts":
/*!*******************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightInfo.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyrightInfo = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
var CopyrightInfo;
(function (CopyrightInfo) {
    /**
     * Merge {@link CopyrightInfo} arrays, removing duplicates.
     *
     * `id` and `label` are considered keys in deduplication algorithm.
     *
     * @param sources - non-duplicate elements from this array are added to `target`
     * @returns merge of all copyright infos in `sources`
     */
    function mergeArrays(a, b) {
        const result = [];
        for (const source of [a, b]) {
            if (source === undefined) {
                continue;
            }
            for (const sourceInfo of source) {
                const existingInfo = result.find(findItem => findItem.id === sourceInfo.id ||
                    (findItem.label !== undefined && findItem.label === sourceInfo.label));
                if (existingInfo === undefined) {
                    result.push(Object.assign({}, sourceInfo));
                }
                else {
                    existingInfo.year = harp_utils_1.MathUtils.max2(sourceInfo.year, existingInfo.year);
                    existingInfo.label = harp_utils_1.getOptionValue(sourceInfo.label, existingInfo.label);
                    existingInfo.link = harp_utils_1.getOptionValue(sourceInfo.link, existingInfo.link);
                }
            }
        }
        return result;
    }
    CopyrightInfo.mergeArrays = mergeArrays;
    /**
     * Format copyright information to a HTML string that can be displayed in the UI.
     *
     * * Empty list returns empty string.
     * * Entries with empty (but defined) labels are skipped.
     *
     * @param copyrightInfo - Array of copyrights to format.
     */
    function formatAsHtml(copyrightInfo) {
        if (copyrightInfo.length === 0) {
            return "";
        }
        const filtered = copyrightInfo.filter(entry => entry.label !== "");
        if (filtered.length === 0) {
            return "";
        }
        return (" " +
            filtered
                .map(entry => {
                var _a;
                const label = (_a = entry.label) !== null && _a !== void 0 ? _a : entry.id;
                const text = entry.year !== undefined ? `${entry.year} ${label}` : label;
                const link = entry.link;
                return link
                    ? `<a href="${link}" target="_blank" rel="noreferrer noopener">${text}</a>`
                    : `${text}`;
            })
                .join(", "));
    }
    CopyrightInfo.formatAsHtml = formatAsHtml;
})(CopyrightInfo = exports.CopyrightInfo || (exports.CopyrightInfo = {}));


/***/ }),

/***/ "../harp-mapview/lib/copyrights/CopyrightProvider.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/copyrights/CopyrightProvider.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts":
/*!**************************************************************!*\
  !*** ../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlCopyrightProvider = void 0;
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "../harp-transfer-manager/index.ts");
const CopyrightCoverageProvider_1 = __webpack_require__(/*! ./CopyrightCoverageProvider */ "../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts");
/**
 * Copyright provider which retrieves copyright coverage information from provided URL.
 */
class UrlCopyrightProvider extends CopyrightCoverageProvider_1.CopyrightCoverageProvider {
    /**
     * Default constructor.
     *
     * @param m_fetchURL - URL to fetch copyrights data from.
     * @param m_baseScheme - Scheme to get copyrights from.
     * @param m_requestHeaders - Optional request headers for requests(e.g. Authorization)
     */
    constructor(m_fetchURL, m_baseScheme, m_requestHeaders, m_transferManager = harp_transfer_manager_1.TransferManager.instance()) {
        super();
        this.m_fetchURL = m_fetchURL;
        this.m_baseScheme = m_baseScheme;
        this.m_requestHeaders = m_requestHeaders;
        this.m_transferManager = m_transferManager;
    }
    /**
     * Sets request headers.
     * @param headers -
     */
    setRequestHeaders(headers) {
        this.m_requestHeaders = headers;
    }
    /**
     * @inheritdoc
     * @override
     */
    getCopyrightCoverageData(abortSignal) {
        if (this.m_cachedCopyrightResponse !== undefined) {
            return this.m_cachedCopyrightResponse;
        }
        this.m_cachedCopyrightResponse = this.m_transferManager
            .downloadJson(this.m_fetchURL, {
            headers: this.m_requestHeaders,
            signal: abortSignal
        })
            .then(json => json[this.m_baseScheme])
            .catch(error => {
            this.logger.error(error);
            return [];
        });
        return this.m_cachedCopyrightResponse;
    }
}
exports.UrlCopyrightProvider = UrlCopyrightProvider;


/***/ }),

/***/ "../harp-mapview/lib/geometry/AddGroundPlane.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/geometry/AddGroundPlane.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addGroundPlane = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const EdgeLengthGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier */ "../harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.ts");
const SphericalGeometrySubdivisionModifier_1 = __webpack_require__(/*! @here/harp-geometry/lib/SphericalGeometrySubdivisionModifier */ "../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const LodMesh_1 = __webpack_require__(/*! ./LodMesh */ "../harp-mapview/lib/geometry/LodMesh.ts");
const ProjectTilePlaneCorners_1 = __webpack_require__(/*! ./ProjectTilePlaneCorners */ "../harp-mapview/lib/geometry/ProjectTilePlaneCorners.ts");
const RegisterTileObject_1 = __webpack_require__(/*! ./RegisterTileObject */ "../harp-mapview/lib/geometry/RegisterTileObject.ts");
const tmpV = new THREE.Vector3();
/**
 * Creates and adds a background plane mesh for the tile.
 * @param tile - The tile to which the ground plane belongs.
 * @param renderOrder - The plane render order.
 * @param materialOrColor - The plane material or a color for a default material.
 * @param opacity - The plane opacity.
 * @param createTexCoords - Whether to create texture coordinates.
 * @param receiveShadow - Whether the plane should receive shadows.
 * @param createMultiLod - Whether to generate multiple LODs for sphere projection.
 * @internal
 */
function addGroundPlane(tile, renderOrder, materialOrColor = tile.mapView.clearColor, opacity = 1, createTexCoords = false, receiveShadow = tile.mapView.shadowsEnabled, createMultiLod = tile.mapView.enableMixedLod !== false) {
    const mesh = createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity);
    mesh.receiveShadow = receiveShadow;
    mesh.renderOrder = renderOrder;
    RegisterTileObject_1.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background, { pickability: harp_datasource_protocol_1.Pickability.transient });
    tile.objects.push(mesh);
    return mesh;
}
exports.addGroundPlane = addGroundPlane;
function createGroundPlane(tile, createTexCoords, receiveShadow, materialOrColor, createMultiLod, opacity) {
    const { dataSource, projection } = tile;
    const sourceProjection = dataSource.getTilingScheme().projection;
    const shouldSubdivide = projection.type === harp_geoutils_1.ProjectionType.Spherical;
    const useLocalTargetCoords = !shouldSubdivide;
    const material = typeof materialOrColor === "number"
        ? createGroundPlaneMaterial(new THREE.Color(materialOrColor), receiveShadow, projection.type === harp_geoutils_1.ProjectionType.Spherical, opacity)
        : materialOrColor;
    const geometry = createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow);
    if (!shouldSubdivide) {
        return new THREE.Mesh(geometry, material);
    }
    const geometries = [];
    const sphericalModifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.MathUtils.degToRad(10), sourceProjection);
    if (!createMultiLod) {
        sphericalModifier.modify(geometry);
        toLocalTargetCoords(geometry, sourceProjection, tile);
        return new THREE.Mesh(geometry, material);
    }
    // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level
    for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {
        const subdivision = Math.pow(2, zoomLevelOffset);
        const zoomLevelGeometry = geometry.clone();
        if (subdivision > 1) {
            const edgeModifier = new EdgeLengthGeometrySubdivisionModifier_1.EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, EdgeLengthGeometrySubdivisionModifier_1.SubdivisionMode.All, sourceProjection);
            edgeModifier.modify(zoomLevelGeometry);
        }
        sphericalModifier.modify(zoomLevelGeometry);
        toLocalTargetCoords(zoomLevelGeometry, sourceProjection, tile);
        geometries.push(zoomLevelGeometry);
    }
    return new LodMesh_1.LodMesh(geometries, material);
}
function toLocalTargetCoords(geom, srcProjection, tile) {
    const attr = geom.getAttribute("position");
    const oldArray = attr.array;
    // Convert to single precision before rendering (WebGL does not support double
    // precision).
    const newArray = new Float32Array(oldArray.length);
    for (let i = 0; i < attr.array.length; i += 1) {
        tmpV.fromBufferAttribute(attr, i);
        tile.projection.reprojectPoint(srcProjection, tmpV, tmpV).sub(tile.center);
        tmpV.toArray(newArray, i * 3);
    }
    attr.array = newArray;
    attr.needsUpdate = true;
}
function createGroundPlaneGeometry(tile, useLocalTargetCoords, createTexCoords, receiveShadow) {
    const { dataSource, projection } = tile;
    const sourceProjection = dataSource.getTilingScheme().projection;
    const tmpV = new THREE.Vector3();
    const geometry = new THREE.BufferGeometry();
    const tileCorners = ProjectTilePlaneCorners_1.projectTilePlaneCorners(tile, sourceProjection);
    const cornersArray = [tileCorners.sw, tileCorners.se, tileCorners.nw, tileCorners.ne];
    if (useLocalTargetCoords) {
        for (const corner of cornersArray) {
            projection.reprojectPoint(sourceProjection, corner, corner).sub(tile.center);
        }
    }
    // Use 64bits floats for world coordinates to avoid precision issues on coordinate
    // tranformations. The array must be converted to single precision before rendering.
    const bufferArray = useLocalTargetCoords ? new Float32Array(12) : new Float64Array(12);
    const posAttr = new THREE.BufferAttribute(bufferArray, 3).copyVector3sArray(cornersArray);
    geometry.setAttribute("position", posAttr);
    if (receiveShadow) {
        // Webmercator needs to have it negated to work correctly.
        sourceProjection.surfaceNormal(tileCorners.sw, tmpV).negate();
        const normAttr = new THREE.BufferAttribute(new Float32Array(12), 3).copyVector3sArray(Array(4).fill(tmpV));
        geometry.setAttribute("normal", normAttr);
    }
    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
    if (createTexCoords) {
        const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
        geometry.setAttribute("uv", uvAttr);
    }
    return geometry;
}
function createGroundPlaneMaterial(color, receiveShadow, depthWrite, opacity) {
    if (receiveShadow) {
        return new harp_materials_1.MapMeshStandardMaterial({
            color,
            visible: true,
            depthWrite,
            removeDiffuseLight: true,
            opacity
        });
    }
    else {
        return new harp_materials_1.MapMeshBasicMaterial({
            color,
            visible: true,
            depthWrite,
            opacity
        });
    }
}


/***/ }),

/***/ "../harp-mapview/lib/geometry/DisplacedBufferAttribute.ts":
/*!****************************************************************!*\
  !*** ../harp-mapview/lib/geometry/DisplacedBufferAttribute.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplacedBufferAttribute = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const VertexCache_1 = __webpack_require__(/*! ./VertexCache */ "../harp-mapview/lib/geometry/VertexCache.ts");
/**
 * @internal
 * BufferAttribute decorator that displaces on the fly the coordinates in a given attribute using a
 * specified displacement map.
 */
class DisplacedBufferAttribute extends THREE.BufferAttribute {
    /**
     * Creates an instance of displaced buffer attribute.
     * @param originalAttribute - The buffer attribute to be displaced
     *                            (e.g. the position attribute).
     * @param m_normals - The normals along which the coordinates will be displaced.
     * @param m_uvs - The uv coordinates to be used to sample the displacement map.
     * @param displacementMap - A texture with the displacement values in 32bit floats.
     */
    constructor(originalAttribute, m_normals, m_uvs, displacementMap) {
        super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);
        this.originalAttribute = originalAttribute;
        this.m_normals = m_normals;
        this.m_uvs = m_uvs;
        this.m_textureWidth = 0;
        this.m_textureHeight = 0;
        this.m_cache = new VertexCache_1.VertexCache(DisplacedBufferAttribute.MAX_CACHE_SIZE);
        this.m_lastPos = new THREE.Vector3();
        this.m_tmpNormal = new THREE.Vector3();
        this.resetTexture(displacementMap);
    }
    /**
     * Resets the displaced buffer attribute to use new buffer attributes or displacement map.
     * @param originalAttribute - The buffer attribute to be displaced
     *                            (e.g. the position attribute).
     * @param normals - The normals along which the coordinates will be displaced.
     * @param uvs -  The uv coordinates to be used to sample the displacement map.
     * @param displacementMap - A texture with the displacement values in 32bit floats.
     */
    reset(originalAttribute, normals, uvs, displacementMap) {
        this.array = originalAttribute.array;
        this.itemSize = originalAttribute.itemSize;
        this.count = this.array.length / this.itemSize;
        this.normalized = originalAttribute.normalized;
        this.originalAttribute = originalAttribute;
        this.m_normals = normals;
        this.m_uvs = uvs;
        this.m_cache.clear();
        this.m_lastBufferIndex = undefined;
        this.resetTexture(displacementMap);
    }
    // HARP-9585: These getters are overrides of the base class ones, however tslint doesn't
    // recognize them as such.
    getX(index) {
        return this.getDisplacedCoordinate(index).x;
    }
    getY(index) {
        return this.getDisplacedCoordinate(index).y;
    }
    getZ(index) {
        return this.getDisplacedCoordinate(index).z;
    }
    resetTexture(displacementMap) {
        this.m_texture = new Float32Array(displacementMap.image.data.buffer);
        this.m_textureWidth = displacementMap.image.width;
        this.m_textureHeight = displacementMap.image.height;
    }
    getDisplacedCoordinate(bufferIndex) {
        if (bufferIndex === this.m_lastBufferIndex) {
            return this.m_lastPos;
        }
        this.m_lastBufferIndex = bufferIndex;
        if (this.m_cache.get(bufferIndex, this.m_lastPos)) {
            return this.m_lastPos;
        }
        this.displacePosition(bufferIndex);
        this.m_cache.set(bufferIndex, this.m_lastPos);
        return this.m_lastPos;
    }
    displacePosition(bufferIndex) {
        this.m_lastPos.fromBufferAttribute(this.originalAttribute, bufferIndex);
        const normals = this.m_normals;
        this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);
        const uvs = this.m_uvs;
        const u = THREE.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);
        const v = THREE.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);
        const displacement = harp_utils_1.sampleBilinear(this.m_texture, this.m_textureWidth, this.m_textureHeight, u, v);
        this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));
    }
}
exports.DisplacedBufferAttribute = DisplacedBufferAttribute;
DisplacedBufferAttribute.MAX_CACHE_SIZE = 6;


/***/ }),

/***/ "../harp-mapview/lib/geometry/DisplacedBufferGeometry.ts":
/*!***************************************************************!*\
  !*** ../harp-mapview/lib/geometry/DisplacedBufferGeometry.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplacedBufferGeometry = exports.displaceBox = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ "../harp-mapview/lib/geometry/DisplacedBufferAttribute.ts");
const tmpV1 = new THREE.Vector3();
const tmpV2 = new THREE.Vector3();
const tmpBox = new THREE.Box3();
/**
 * @internal
 * Displace a box in a given direction by a specified range. The original box min and max vertices
 * are translated as a result by displacementRange.min and displacementRange.max respectively.
 * @param box - The original box to displace.
 * @param displacementRange - The minimum and maximum displacement values.
 * @param displacementDir - Direction in which the displacement will be applied.
 * @return The displaced box.
 */
function displaceBox(box, displacementRange, displacementDir) {
    tmpBox.copy(box);
    const tmpNormalMin = tmpV1.copy(displacementDir);
    const tmpNormalMax = tmpV2.copy(tmpNormalMin);
    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max)));
    return box;
}
exports.displaceBox = displaceBox;
/**
 * @internal
 * BufferGeometry decorator that displaces on the fly the position attribute using a specified
 * displacement map.
 */
class DisplacedBufferGeometry extends THREE.BufferGeometry {
    /**
     * Creates an instance of displaced buffer geometry.
     * @param originalGeometry - The goeometry to be displaced.
     * @param displacementMap - A texture with the displacement values.
     * @param displacementRange - The displacement value range found in the displacement map.
     * @param displacedPositions - Buffer attribute that will be used for displaced positions if
     * provided, otherwise a new buffer attribute will be created.
     */
    constructor(originalGeometry, displacementMap, displacementRange, displacedPositions) {
        super();
        this.originalGeometry = originalGeometry;
        this.displacementRange = displacementRange;
        this.m_originalBoundingBox = new THREE.Box3();
        if (!displacedPositions) {
            this.m_displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(originalGeometry.attributes.position, originalGeometry.attributes.normal, originalGeometry.attributes.uv, displacementMap);
        }
        else {
            this.m_displacedPositions = displacedPositions;
        }
        this.resetAttributes();
    }
    /**
     * Resets the displaced buffer geometry to use new geometry or displacement map.
     * @param geometry - The goeometry to be displaced.
     * @param displacementMap - A texture with the displacement values.
     * @param displacementRange - The displacement value range found in the displacement map.
     */
    reset(geometry, displacementMap, displacementRange) {
        this.originalGeometry = geometry;
        const positions = geometry.attributes.position;
        const normals = geometry.attributes.normal;
        const uvs = geometry.attributes.uv;
        this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);
        const displacementRangeChanged = this.displacementRange.min !== displacementRange.min ||
            this.displacementRange.max !== displacementRange.max;
        this.displacementRange = displacementRange;
        this.resetAttributes();
        this.resetBoundingVolumes(displacementRangeChanged);
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    computeBoundingBox() {
        // Calculate a coarse approximation of the displaced geometry bbox by displacing the
        // original bbox and enlarging it to cover the whole displacement range.
        // This approximation is used to avoid having to displace the whole geometry, which will
        // be done only if the bbox test passes.
        if (this.originalGeometry.boundingBox === null) {
            this.originalGeometry.computeBoundingBox();
        }
        const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox);
        if (this.boundingBox === null) {
            this.boundingBox = origBBox.clone();
        }
        else {
            this.boundingBox.copy(origBBox);
        }
        displaceBox(this.boundingBox, this.displacementRange, tmpV1.fromBufferAttribute(this.attributes.normal, 0));
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    computeBoundingSphere() {
        // Use as coarse approximation the sphere bounding the bbox.
        if (this.boundingBox === null) {
            this.computeBoundingBox();
        }
        if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
        }
        this.boundingBox.getBoundingSphere(this.boundingSphere);
    }
    needsBoundingBoxUpdate(displacementRangeChanged) {
        return (displacementRangeChanged ||
            (this.boundingBox !== null &&
                (!this.originalGeometry.boundingBox ||
                    !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox))));
    }
    resetBoundingVolumes(displacementRangeChanged) {
        if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {
            this.computeBoundingBox();
            if (this.boundingSphere) {
                this.computeBoundingSphere();
            }
        }
    }
    resetAttributes() {
        this.index = this.originalGeometry.index;
        this.groups = this.originalGeometry.groups;
        this.drawRange = this.originalGeometry.drawRange;
        this.attributes = Object.assign({}, this.originalGeometry.attributes);
        this.attributes.position = this.m_displacedPositions;
    }
}
exports.DisplacedBufferGeometry = DisplacedBufferGeometry;


/***/ }),

/***/ "../harp-mapview/lib/geometry/DisplacedMesh.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/geometry/DisplacedMesh.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplacedMesh = void 0;
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DisplacedBufferAttribute_1 = __webpack_require__(/*! ./DisplacedBufferAttribute */ "../harp-mapview/lib/geometry/DisplacedBufferAttribute.ts");
const DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ "../harp-mapview/lib/geometry/DisplacedBufferGeometry.ts");
function isDisplacementMaterial(material) {
    const isDisplacementFeature = harp_materials_1.hasDisplacementFeature(material);
    harp_utils_1.assert(isDisplacementFeature, "Material does not support displacement maps.");
    return isDisplacementFeature;
}
function isDataTextureMap(map) {
    if (!map) {
        return false;
    }
    const isDataTexture = map instanceof THREE.DataTexture;
    harp_utils_1.assert(isDataTexture, "Material does not support displacement maps.");
    return isDataTexture;
}
/**
 * Mesh with geometry modified by a displacement map. Overrides raycasting behaviour to apply
 * displacement map before intersection test.
 * @internal
 */
class DisplacedMesh extends THREE.Mesh {
    /**
     * Creates an instance of displaced mesh.
     * @param geometry - Original geometry to displace.
     * @param material - Material(s) to be used by the mesh. All must have the same
     *                   displacement map.
     * @param m_getDisplacementRange - Displacement values range getter.
     * @param [m_raycastStrategy] Function that will be used to find ray intersections. If not
     * provided, THREE.Mesh's raycast will be used.
     */
    constructor(geometry, material, m_getDisplacementRange, m_raycastStrategy) {
        super(geometry, material);
        this.m_getDisplacementRange = m_getDisplacementRange;
        this.m_raycastStrategy = m_raycastStrategy;
    }
    static getDisplacedPositionAttribute(geometry, displacementMap) {
        // Reuse same buffer attribute for all meshes since it's only needed during the
        // intersection test.
        if (!DisplacedMesh.displacedPositions) {
            DisplacedMesh.displacedPositions = new DisplacedBufferAttribute_1.DisplacedBufferAttribute(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
        }
        else {
            DisplacedMesh.displacedPositions.reset(geometry.attributes.position, geometry.attributes.normal, geometry.attributes.uv, displacementMap);
        }
        return DisplacedMesh.displacedPositions;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    raycast(raycaster, intersects) {
        // All materials in the object are expected to have the same displacement map.
        const firstMaterial = this.firstMaterial;
        // Use default raycasting implementation if there's no displacement material or if there's
        // no displacement map or its type is not supported.
        if (!isDisplacementMaterial(firstMaterial) ||
            !isDataTextureMap(firstMaterial.displacementMap)) {
            super.raycast(raycaster, intersects);
            return;
        }
        const displacementMap = firstMaterial.displacementMap;
        const displacementRange = Object.assign({}, this.m_getDisplacementRange());
        harp_utils_1.assert(this.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type.");
        const geometry = this.geometry;
        if (this.displacedGeometry) {
            this.displacedGeometry.reset(geometry, displacementMap, displacementRange);
        }
        else {
            this.displacedGeometry = new DisplacedBufferGeometry_1.DisplacedBufferGeometry(geometry, displacementMap, displacementRange, DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap));
        }
        // Replace the original geometry by the displaced one only during the intersection test.
        this.geometry = this.displacedGeometry;
        if (this.m_raycastStrategy) {
            this.m_raycastStrategy(this, raycaster, intersects);
        }
        else {
            super.raycast(raycaster, intersects);
        }
        super.geometry = this.displacedGeometry.originalGeometry;
    }
    get firstMaterial() {
        return Array.isArray(this.material) ? this.material[0] : this.material;
    }
}
exports.DisplacedMesh = DisplacedMesh;


/***/ }),

/***/ "../harp-mapview/lib/geometry/LodMesh.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/geometry/LodMesh.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LodMesh = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * A mesh that can store multiple versions of a geometry with differents level of detail.
 * The rendered level of detail can be adapted during runtime.
 * @internal
 * @hidden
 */
class LodMesh extends THREE.Mesh {
    /**
     * Creates a [[LodMesh]] with given geometries and materials
     * @param geometries - A list of geometries with different levels of detail
     * @param material - Material for the mesh
     */
    constructor(geometries, material) {
        super(undefined, material);
        this.geometries = geometries;
    }
    /**
     * Update geometries of mesh
     */
    set geometries(geometries) {
        // dispose previous geometries
        if (this.m_geometries !== geometries) {
            this.disposeGeometries();
        }
        this.m_geometries = geometries;
        if (this.geometries && this.m_geometries.length > 0) {
            this.geometry = this.m_geometries[0];
        }
    }
    /**
     * Get geometries of mesh
     */
    get geometries() {
        return this.m_geometries;
    }
    /**
     * Change the rendered level of detail of the mesh
     * @param level - The level of detail (index of the geometry in the list).
     */
    setLevelOfDetail(level) {
        if (!this.m_geometries || this.m_geometries.length === 0) {
            return;
        }
        level = THREE.MathUtils.clamp(level, 0, this.m_geometries.length - 1);
        this.geometry = this.m_geometries[level];
    }
    /**
     * Dispose all geometries of mesh
     */
    disposeGeometries() {
        if (this.m_geometries) {
            for (const geometry of this.m_geometries) {
                geometry.dispose();
            }
        }
        this.geometry.dispose();
    }
}
exports.LodMesh = LodMesh;


/***/ }),

/***/ "../harp-mapview/lib/geometry/Object3DUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/geometry/Object3DUtils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Object3DUtils = void 0;
/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Tile_1 = __webpack_require__(/*! ../Tile */ "../harp-mapview/lib/Tile.ts");
// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.
// There may be cases where it is possible to construct Object3Ds with considerable less memory
// consumption, but this value is used to simplify the estimation.
const MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;
const MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;
const logger = harp_utils_1.LoggerManager.instance.create("Object3DUtils");
/**
 * @internal
 */
var Object3DUtils;
(function (Object3DUtils) {
    function estimateTextureSize(texture, objectSize, visitedObjects) {
        if (texture === null ||
            texture === undefined ||
            texture.image === undefined ||
            texture.image === null) {
            return;
        }
        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {
            return;
        }
        visitedObjects.set(texture.uuid, true);
        // May be HTMLImage or ImageData
        const image = texture.image;
        // Assuming RGBA
        const imageBytes = 4 * image.width * image.height;
        objectSize.heapSize += imageBytes;
        objectSize.gpuSize += imageBytes;
    }
    function estimateMaterialSize(material, objectSize, visitedObjects) {
        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {
            return;
        }
        visitedObjects.set(material.uuid, true);
        if (material instanceof THREE.RawShaderMaterial ||
            material instanceof THREE.ShaderMaterial) {
            const rawMaterial = material;
            for (const name in rawMaterial.uniforms) {
                if (rawMaterial.uniforms[name] !== undefined) {
                    const uniform = rawMaterial.uniforms[name];
                    if (uniform instanceof THREE.Texture) {
                        estimateTextureSize(uniform, objectSize, visitedObjects);
                    }
                }
            }
        }
        else if (material instanceof THREE.MeshBasicMaterial ||
            material instanceof harp_materials_1.MapMeshBasicMaterial) {
            const meshMaterial = material;
            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof harp_materials_1.MapMeshStandardMaterial) {
            const standardMaterial = material;
            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);
            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);
        }
        else if (material instanceof THREE.LineBasicMaterial ||
            material instanceof THREE.LineDashedMaterial ||
            material instanceof THREE.PointsMaterial) {
            // Nothing to be done here
        }
        else {
            logger.warn("estimateMeshSize: unidentified material: ", material);
        }
    }
    function estimateAttributeSize(attribute, attrName, objectSize, visitedObjects) {
        // Attributes (apparently) do not have their uuid set up.
        if (attribute.uuid === undefined) {
            attribute.uuid = THREE.MathUtils.generateUUID();
        }
        if (visitedObjects.get(attribute.uuid) === true) {
            return;
        }
        visitedObjects.set(attribute.uuid, true);
        let attrBytes = 0;
        let bytesPerElement = 4;
        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {
            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;
        }
        if (attribute instanceof THREE.InterleavedBufferAttribute ||
            attribute instanceof THREE.BufferAttribute) {
            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified attribute: ", attrName);
        }
        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;
        objectSize.gpuSize += attrBytes;
    }
    function estimateGeometrySize(geometry, objectSize, visitedObjects) {
        const isNewObject = geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;
        if (!isNewObject) {
            return;
        }
        visitedObjects.set(geometry.uuid, true);
        if (geometry === undefined) {
            // Nothing more to calculate.
            return;
        }
        const attributes = geometry.attributes;
        if (attributes === undefined) {
            logger.warn("estimateGeometrySize: unidentified geometry: ", geometry);
            return;
        }
        for (const property in attributes) {
            if (attributes[property] !== undefined) {
                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);
            }
        }
        if (geometry.index !== null) {
            estimateAttributeSize(geometry.index, "index", objectSize, visitedObjects);
        }
    }
    function estimateMeshSize(object, objectSize, visitedObjects) {
        if (!object.isObject3D || object instanceof THREE.Scene) {
            return;
        }
        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {
            return;
        }
        visitedObjects.set(object.uuid, true);
        if (object.isMesh || object.isLine || object.isPoints) {
            // Estimated minimum impact on heap.
            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;
            const gpuSize = 0;
            // Cast to LodMesh class which contains the minimal required properties sub-set.
            const mesh = object;
            // Calculate material(s) impact.
            if (mesh.material !== undefined) {
                if (Array.isArray(mesh.material)) {
                    const materials = mesh.material;
                    for (const material of materials) {
                        estimateMaterialSize(material, objectSize, visitedObjects);
                    }
                }
                else {
                    const material = mesh.material;
                    estimateMaterialSize(material, objectSize, visitedObjects);
                }
            }
            // Calculate cost of geometry.
            if (mesh.geometries !== undefined) {
                for (const geometry of mesh.geometries) {
                    estimateGeometrySize(geometry, objectSize, visitedObjects);
                }
            }
            else if (mesh.geometry !== undefined) {
                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);
            }
            // Add info that is required for picking (parts of) objects and match them to
            // the featureID in the map data.
            const featureData = object.userData !== undefined
                ? object.userData.feature
                : undefined;
            if (featureData !== undefined) {
                heapSize += Tile_1.getFeatureDataSize(featureData);
            }
            objectSize.heapSize += heapSize;
            objectSize.gpuSize += gpuSize;
        }
        else {
            logger.warn("estimateMeshSize: unidentified object", object);
        }
    }
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object - The mesh object to evaluate
     * @param size - The {@link MemoryUsage} to update.
     * @param visitedObjects - Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateSize(object, parentSize, visitedObjects) {
        const size = parentSize !== undefined
            ? parentSize
            : {
                heapSize: 0,
                gpuSize: 0
            };
        if (visitedObjects === undefined) {
            visitedObjects = new Map();
        }
        estimateMeshSize(object, size, visitedObjects);
        if (object.children.length > 0) {
            for (const child of object.children) {
                estimateSize(child, size, visitedObjects);
            }
        }
        return size;
    }
    Object3DUtils.estimateSize = estimateSize;
})(Object3DUtils = exports.Object3DUtils || (exports.Object3DUtils = {}));


/***/ }),

/***/ "../harp-mapview/lib/geometry/ProjectTilePlaneCorners.ts":
/*!***************************************************************!*\
  !*** ../harp-mapview/lib/geometry/ProjectTilePlaneCorners.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.projectTilePlaneCorners = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Returns the corners of the tile's geo bounding box projected using a given projection.
 * @param tile - The tile whose corners will be projected.
 * @param projection - The projection to be used.
 * @returns The projected tile corners.
 * @internal
 * @hidden
 */
function projectTilePlaneCorners(tile, projection) {
    const { east, west, north, south } = tile.geoBox;
    const sw = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), new THREE.Vector3());
    const se = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), new THREE.Vector3());
    const nw = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), new THREE.Vector3());
    const ne = projection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), new THREE.Vector3());
    return { sw, se, nw, ne };
}
exports.projectTilePlaneCorners = projectTilePlaneCorners;


/***/ }),

/***/ "../harp-mapview/lib/geometry/RegisterTileObject.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/RegisterTileObject.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerTileObject = void 0;
const MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ "../harp-mapview/lib/MapObjectAdapter.ts");
/**
 * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].
 *
 * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the
 * object, such that the tile it belongs to can be identified during picking.
 *
 * @param tile - The {@link Tile} to add the object to.
 * @param object - The object to add to the root of the tile.
 * @param geometryKind - The kind of object. Can be used for filtering.
 * @param mapAdapterParams - additional parameters for [[MapObjectAdapter]]
 */
function registerTileObject(tile, object, geometryKind, mapAdapterParams) {
    const kind = geometryKind instanceof Set
        ? Array.from(geometryKind.values())
        : Array.isArray(geometryKind)
            ? geometryKind
            : [geometryKind];
    MapObjectAdapter_1.MapObjectAdapter.create(object, Object.assign({ dataSource: tile.dataSource, kind, level: tile.tileKey.level }, mapAdapterParams));
    // TODO legacy fields, encoded directly in `userData to be removed
    if (object.userData === undefined) {
        object.userData = {};
    }
    const userData = object.userData;
    userData.tileKey = tile.tileKey;
    userData.dataSource = tile.dataSource.name;
    userData.kind = kind;
    // Force a visibility check of all objects.
    tile.resetVisibilityCounter();
}
exports.registerTileObject = registerTileObject;


/***/ }),

/***/ "../harp-mapview/lib/geometry/SolidLineMesh.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/geometry/SolidLineMesh.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SolidLineMesh = void 0;
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DisplacedBufferGeometry_1 = __webpack_require__(/*! ./DisplacedBufferGeometry */ "../harp-mapview/lib/geometry/DisplacedBufferGeometry.ts");
const tmpSphere = new THREE.Sphere();
const tmpInverseMatrix = new THREE.Matrix4();
const tmpRay = new THREE.Ray();
const tmpLine1 = new THREE.Line3();
const tmpBox = new THREE.Box3();
const tmpOBB = new harp_geoutils_1.OrientedBox3();
const tmpPlane = new THREE.Plane();
const tmpV1 = new THREE.Vector3();
const tmpV2 = new THREE.Vector3();
const tmpV3 = new THREE.Vector3();
const tmpV4 = new THREE.Vector3();
// Strides to access the index buffer. See [[createLineGeometry]].
// Stride between the start vertex indices of consecutive segments, each one made of 2 triangles.
const SEGMENT_STRIDE = 6;
// Stride between the start and end vertex indices of a segment. Vertices are duplicated so that
// each copy is extruded in opposite directions in the vertex shader.
const VERTEX_STRIDE = 2;
function isSolidLineMaterial(material) {
    return Array.isArray(material)
        ? material.every(mat => mat instanceof harp_materials_1.SolidLineMaterial)
        : material instanceof harp_materials_1.SolidLineMaterial;
}
/**
 * Create an [[AttributeInfo]] for the specified attribute.
 * @param attribute The attribute to retrieve version info from.
 * @returns The [[AttributeInfo]] containing a reference and version of the attribute's data.
 */
function getAttributeInfo(attribute) {
    const isBufferAttribute = attribute.isBufferAttribute === true;
    const data = isBufferAttribute
        ? attribute
        : attribute.data;
    return {
        data,
        version: data.version
    };
}
/**
 * Check if an attribute has changed compared to the version info.
 * @param attribute Attribute to check.
 * @param attrInfo Attribute version info.
 * @returns `true` if the attribute is the same, `false` otherwise.
 */
function attributeChanged(attribute, attrInfo) {
    const isBufferAttribute = attribute.isBufferAttribute === true;
    const data = isBufferAttribute
        ? attribute
        : attribute.data;
    return (attrInfo === undefined ||
        attrInfo.data !== data ||
        (attribute.isBufferAttribute &&
            attrInfo.version !== data.version));
}
/**
 * Computes the bounding sphere of the part of a given geometry corresponding to a feature.
 * @param geometry - The geometry containing the feature.
 * @param featureBeginIndex - The index where the feature starts in the geometry's
 *                            indices attribute.
 * @param featureEndIndex - The index where the feature end in the geometry's indices attribute.
 * @returns The feature bounding sphere.
 */
function computeFeatureBoundingSphere(geometry, featureBeginIndex, featureEndIndex) {
    let displacementRange;
    if (geometry instanceof DisplacedBufferGeometry_1.DisplacedBufferGeometry) {
        displacementRange = geometry.displacementRange;
        geometry = geometry.originalGeometry;
    }
    const attributes = geometry.attributes;
    const pos = attributes.position;
    const indices = geometry.index.array;
    const sphere = new THREE.Sphere();
    const bbox = tmpBox.makeEmpty();
    const vertex = tmpV1;
    // First compute the bounding box for all line segments.
    for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));
        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));
    }
    if (displacementRange) {
        // If geometry is displaced, expand the bounding box to cover the whole displacement range,
        // and return the sphere bounding the box. This is a coarse estimation, but avoids having
        // to displace all vertices.
        // All normals in the geometry are assumed to be the same or close enough so that any of
        // them can be used as displacement direction. For sphere projection, the surface normals
        // within a tile are approximately the same from level 4 onwards. Here are some examples of
        // the minimum dot product between normals in a tile (normals at tile's opposite corners):
        // TILE: (6,9,4): 0.9806892129880023
        // TILE: (12,17,5): 0.9946739445457075
        // TILE: (25,34,6): 0.9986326302953471
        // TILE: (50,68,7): 0.9996583822992287
        // TILE: (1620,2199,12): 0.9999996706085572
        const normal = tmpV2;
        normal.fromBufferAttribute(geometry.attributes.normal, 0);
        return DisplacedBufferGeometry_1.displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);
    }
    return bbox.getBoundingSphere(sphere);
}
/**
 * Finds the intersection of a ray with a extruded line.
 * @param ray - Intersection ray in object's local space.
 * @param line - The centerline.
 * @param vExtrusion - Line extrusion vector.
 * @param normal - Extrusion plane normal.
 * @param hWidth - Extrusion half width.
 * @returns Distance of the extruded line intersection to the ray origin.
 */
function intersectExtrudedLine(ray, line, vExtrusion, normal, hWidth) {
    var _a;
    const obb = tmpOBB;
    line.getCenter(obb.position);
    line.delta(obb.xAxis).normalize();
    obb.yAxis.copy(vExtrusion);
    obb.zAxis.copy(normal);
    obb.extents.set(line.distance() / 2, hWidth, hWidth);
    if (obb.contains(ray.origin)) {
        return 0;
    }
    return (_a = obb.intersectsRay(ray)) !== null && _a !== void 0 ? _a : Infinity;
}
/**
 * Finds the intersection of a ray with the closest end cap of a extruded line.
 * @param ray - Intersection ray in object's local space.
 * @param line - The centerline.
 * @param hWidth - Extrusion half width.
 * @returns Distance of the end cap intersection to the ray origin.
 */
function intersectClosestEndCap(ray, line, hWidth) {
    const sphere = new THREE.Sphere(line.start, hWidth);
    const startCapT = sphere.containsPoint(ray.origin)
        ? 0
        : ray.intersectSphere(sphere, tmpV4)
            ? tmpV4.sub(ray.origin).length()
            : Infinity;
    sphere.center.copy(line.end);
    const endCapT = sphere.containsPoint(ray.origin)
        ? 0
        : ray.intersectSphere(sphere, tmpV4)
            ? tmpV4.sub(ray.origin).length()
            : Infinity;
    return Math.min(startCapT, endCapT);
}
/**
 * Intersects line
 * @param ray - Intersection ray in object's local space.
 * @param line - The line to intersect.
 * @param vExtrusion - Line extrusion vector.
 * @param hWidth - The line's extrusion half width.
 * @param hWidthSq - The line's extrusion half width squared.
 * @param plane - The extrusion plane.
 * @param interPlane - The intersection of the ray with the extrusion plane.
 * @param outInterLine - The ray intersection with the extruded line.
 * @returns true if ray intersects the extruded line, false otherwise.
 */
function intersectLine(ray, line, vExtrusion, hWidth, hWidthSq, plane, interPlane, outInterLine) {
    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {
        // Corner case: ray is coplanar to extruded line, find distance to extruded line sides
        // and end caps.
        const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);
        const endCapT = intersectClosestEndCap(ray, line, hWidth);
        const minT = Math.min(extrLineT, endCapT);
        if (minT === Infinity) {
            return false;
        }
        ray.at(minT, outInterLine);
        return true;
    }
    // The plain intersection is also a line intersection only if it's closer to the line
    // than the extrusion half width.
    const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));
    if (distSq > hWidthSq) {
        return false;
    }
    outInterLine.copy(interPlane);
    return true;
}
/**
 * Finds the intersections of a ray with a partition of a solid line mesh representing a feature.
 * @param mesh - The mesh whose intersections will be found.
 * @param raycaster - Contains the intersection ray.
 * @param localRay - Same ray as raycaster.ray but in object's local space.
 * @param halfWidth - The line's extrusion half width.
 * @param lHalfWidth - The line's extrusion half width in mesh local space.
 * @param lHalfWidthSq - The line's extrusion half width squared in mesh local space.
 * @param beginIdx - The index where the feature starts in the mesh geometry's indices attribute.
 * @param endIdx - The index where the feature end in the mesh geometry's indices attribute.
 * @param bSphere - The feature bounding sphere.
 * @param intersections - Array where all intersections found between ray and feature will
 *                        be pushed.
 */
function intersectFeature(mesh, raycaster, localRay, halfWidth, lHalfWidth, lHalfWidthSq, beginIdx, endIdx, bSphere, intersections) {
    const vExt = tmpV1;
    const plane = tmpPlane;
    const interPlane = tmpV2;
    const line = tmpLine1;
    const geometry = mesh.geometry;
    const attributes = geometry.attributes;
    const position = attributes.position;
    const bitangent = attributes.biTangent;
    const indices = geometry.index.array;
    tmpSphere.copy(bSphere);
    tmpSphere.applyMatrix4(mesh.matrixWorld);
    tmpSphere.radius += halfWidth;
    if (!raycaster.ray.intersectsSphere(tmpSphere)) {
        return;
    }
    for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {
        const a = indices[i];
        const b = indices[i + VERTEX_STRIDE];
        // Find the plane containing the line segment, using the segment start, end and extrusion
        // vector.
        line.start.fromBufferAttribute(position, a);
        line.end.fromBufferAttribute(position, b);
        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();
        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);
        if (plane.normal.manhattanLength() === 0) {
            // Invalid plane, coplanar points are actually collinear because:
            // a) The line segment has length 0.
            // b) The extrusion vector has length 0.
            // c) The extrusion and segment directions are the same.
            // In any case it's a degenerate segment, skip it.
            continue;
        }
        // The ray intersection if any, will be on the extrusion plane.
        if (!localRay.intersectPlane(plane, interPlane)) {
            continue;
        }
        const interLine = tmpV3;
        if (!intersectLine(localRay, line, vExt, lHalfWidth, lHalfWidthSq, plane, interPlane, interLine)) {
            continue;
        }
        // Move back to world space for distance calculation
        const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interLineWorld);
        if (distance < raycaster.near || distance > raycaster.far) {
            continue;
        }
        intersections.push({
            distance,
            point: interLineWorld.clone(),
            index: i,
            object: mesh
        });
    }
}
const singleFeatureStart = [0];
const MAX_SCALE_RATIO_DIFF = 1e-2;
/**
 * Finds the intersections of a ray with a group within a solid line mesh.
 * @param mesh - The mesh whose intersections will be found.
 * @param material - The material used by the group inside the mesh.
 * @param raycaster -  Contains the intersection ray.
 * @param localRay - Same ray as raycaster.ray but in object's local space.
 * @param firstFeatureIdx - Index of the first feature in the group.
 * @param groupEndIdx - Index of the last vertex in the group.
 * @param intersections -  Array where all intersections found between ray and group will be pushed.
 * @returns The next feature index after the group.
 */
function intersectGroup(mesh, material, raycaster, localRay, firstFeatureIdx, groupEndIdx, intersections) {
    var _a;
    const bVolumes = mesh.userData.feature.boundingVolumes;
    harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type.");
    const geometry = mesh.geometry;
    harp_utils_1.assert(isSolidLineMaterial(material), "Unsupported material type");
    const solidLineMaterial = material;
    const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;
    // Assumption: scaling is uniform or close enough to use a local width independent of direction.
    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);
    harp_utils_1.assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    harp_utils_1.assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);
    const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);
    const localHalfWidthSq = localHalfWidth * localHalfWidth;
    const featureStarts = (_a = mesh.userData.feature.starts) !== null && _a !== void 0 ? _a : singleFeatureStart;
    let featureIdx = firstFeatureIdx;
    let beginIdx = featureStarts[featureIdx];
    const lastFeatureIdx = featureStarts.length - 1;
    while (beginIdx < groupEndIdx) {
        const bVolumeIdx = featureIdx;
        const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;
        if (bVolumeIdx >= bVolumes.length) {
            // Geometry might be extruded on any direction. To avoid extruding all vertices, the
            // centerline geometry is used to compute a bounding sphere whose radius is later
            // expanded by the extrusion half width to ensure it contains the extruded geometry.
            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));
        }
        intersectFeature(mesh, raycaster, localRay, halfWidth, localHalfWidth, localHalfWidthSq, beginIdx, endIdx, bVolumes[bVolumeIdx], intersections);
        beginIdx = endIdx;
    }
    return featureIdx;
}
/**
 * Mesh formed by extruding a polyline in the shaders. Overrides raycasting behaviour to account for
 * extrusion, see [[SolidLineMaterial]].
 * @internal
 */
class SolidLineMesh extends THREE.Mesh {
    /**
     * Finds the intersections of a ray with a mesh, assuming the mesh is a polyline extruded in
     * the shaders (see [[SolidLineMaterial]]).
     * @param mesh - The mesh whose intersections will be found.
     * @param raycaster - Contains the intersection ray.
     * @param intersections - Array where all intersections found between ray and mesh will
     *                        be pushed.
     */
    static raycast(mesh, raycaster, intersections) {
        harp_utils_1.assert(mesh.geometry instanceof THREE.BufferGeometry, "Unsupported geometry type");
        const geometry = mesh.geometry;
        harp_utils_1.assert(geometry.index !== null, "Geometry does not have indices");
        const matrixWorld = mesh.matrixWorld;
        tmpInverseMatrix.copy(matrixWorld).invert();
        const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
        // Test intersection of ray with each of the features within the mesh.
        if (mesh.userData.feature === undefined) {
            mesh.userData.feature = {};
        }
        const positionAttribute = geometry.attributes["position"];
        const attributeInfo = mesh.userData.feature
            .attributeInfo;
        // Rebuild bounding volumes if geometry has been modified.
        if (attributeInfo === undefined ||
            mesh.userData.feature.boundingVolumes === undefined ||
            attributeChanged(positionAttribute, attributeInfo)) {
            mesh.userData.feature.boundingVolumes = [];
            mesh.userData.feature.attributeInfo = getAttributeInfo(positionAttribute);
        }
        const indices = geometry.index.array;
        if (Array.isArray(mesh.material)) {
            let nextFeatureIdx = 0;
            for (const group of geometry.groups) {
                const material = mesh.material[group.materialIndex];
                const groupEndIdx = group.start + group.count;
                nextFeatureIdx = intersectGroup(mesh, material, raycaster, localRay, nextFeatureIdx, groupEndIdx, intersections);
            }
        }
        else {
            intersectGroup(mesh, mesh.material, raycaster, localRay, 0, indices.length, intersections);
        }
    }
    /**
     * Creates an instance of SolidLineMesh.
     * @param geometry - Mesh geometry.
     * @param material - Material(s) to be used by the mesh. They must be instances of
     * [[SolidLineMaterial]].
     */
    constructor(geometry, material) {
        super(geometry, material);
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.
    raycast(raycaster, intersects) {
        SolidLineMesh.raycast(this, raycaster, intersects);
    }
}
exports.SolidLineMesh = SolidLineMesh;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileDataAccessor.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileDataAccessor.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileDataAccessor = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TileGeometry_1 = __webpack_require__(/*! ./TileGeometry */ "../harp-mapview/lib/geometry/TileGeometry.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileDataAccessor");
/**
 * An accessor for all geometries in a tile.
 *
 * @remarks
 * This class uses a client-provided {@link ITileDataVisitor}
 * to visit all objects, based on filtering options specified
 * by both, the `TileDataAccessor` and
 * the visitor itself.
 */
class TileDataAccessor {
    /**
     * Constructs a `TileDataAccessor` instance.
     *
     * @param tile - The tile to access.
     * @param visitor - The visitor.
     * @param options - Options for the tile.
     */
    constructor(tile, visitor, options) {
        this.tile = tile;
        this.visitor = visitor;
        const wantsAll = options.wantsAll === true;
        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);
        this.m_wantsLines = wantsAll || !(options.wantsLines === false);
        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);
        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);
    }
    /**
     * Calls the visitor on all objects in the tile.
     */
    visitAll() {
        const objects = this.tile.objects;
        for (const object of objects) {
            this.visitObject(object);
        }
    }
    /**
     * Visits a single object. This function should normally be called during visiting.
     *
     * @param object - The object to visit.
     */
    visitObject(object) {
        const featureData = object.userData !== undefined
            ? object.userData.feature
            : undefined;
        // early opt out if there is no feature data, or if the feature data has only a single id
        // and the visitor wants to ignore that featureId
        if (featureData === undefined ||
            (featureData.objInfos !== undefined &&
                featureData.objInfos.length === 1 &&
                !this.visitor.wantsFeature(harp_datasource_protocol_1.getFeatureId(featureData.objInfos[0])))) {
            return;
        }
        const geometryType = featureData.geometryType;
        if (geometryType === undefined) {
            logger.warn("#visitObject: visiting object failed, no geometryType", object);
            return;
        }
        harp_utils_1.assert(featureData.objInfos !== undefined, "featureData.ids missing");
        harp_utils_1.assert(featureData.starts !== undefined, "featureData.starts missing");
        harp_utils_1.assert(Array.isArray(featureData.starts), "featureData.starts is not an array");
        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {
            harp_utils_1.assert(featureData.objInfos.length === featureData.starts.length, "featureData.ids and featureData.starts have unequal length");
        }
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                if (!this.m_wantsPoints) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                if (!this.m_wantsLines) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                if (!this.m_wantsAreas) {
                    return;
                }
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                if (!this.m_wantsObject3D) {
                    return;
                }
                break;
            default:
                logger.warn("#visitObject: invalid geometryType");
        }
        if (object.type !== "Mesh") {
            logger.warn("#visitObject: visiting object failed, not of type 'Mesh'", object);
            return;
        }
        const mesh = object;
        this.visitMesh(mesh, featureData);
    }
    /**
     * Gets the `BufferGeometry` from the specified object. This function requires the
     * attribute `position` in `BufferGeometry` to be set.
     *
     * @param object - The object from which to get the geometry.
     * @returns the geometry of the object, or `undefined`.
     */
    getBufferGeometry(object) {
        const geometry = object.geometry;
        if (geometry.type !== "BufferGeometry") {
            logger.warn("#visitObject: object does not have BufferGeometry");
            return undefined;
        }
        const bufferGeometry = geometry;
        // we know its a BufferAttribute because it is a BufferGeometry
        const position = bufferGeometry.getAttribute("position");
        if (!position) {
            logger.warn("#visitLines: BufferGeometry has no position attribute");
            return undefined;
        }
        return bufferGeometry;
    }
    /**
     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType - The type of geometry.
     * @param object - The object for which to access the attributes and geometry.
     * @param bufferGeometry - The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                return new TileGeometry_1.BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);
            default:
                logger.warn("#getGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Obtains an accessor for the indexed geometry. This function may return `undefined`
     * if the accessor is not implemented.
     *
     * @param geometryType - The type of geometry.
     * @param object - The object for which to access the attributes and geometry.
     * @param bufferGeometry - The object's `BufferGeometry`.
     * @returns an accessor for a specified object, if available.
     */
    getIndexedGeometryAccessor(geometryType, object, bufferGeometry) {
        switch (geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                return new TileGeometry_1.IndexedBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);
                return undefined;
            default:
                logger.warn("#getIndexedGeometryAccessor: invalid geometryType");
        }
        return undefined;
    }
    /**
     * Visit the object.
     *
     * @param meshObject - Object of type `Mesh`.
     * @param featureData - Dataset stored along with the object.
     */
    visitMesh(meshObject, featureData) {
        const { objInfos, starts } = featureData;
        const geometryType = featureData.geometryType;
        // make linter happy: we already know that these both are valid
        if (objInfos === undefined || starts === undefined || geometryType === undefined) {
            return;
        }
        let geometryAccessor;
        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {
            const featureId = harp_datasource_protocol_1.getFeatureId(objInfos[featureIndex]);
            if (!this.visitor.wantsFeature(featureId)) {
                continue;
            }
            const featureStart = starts[featureIndex];
            let featureEnd = -1;
            // lazy creation of accessor, in case featureId was not wanted...
            if (geometryAccessor === undefined) {
                const bufferGeometry = this.getBufferGeometry(meshObject);
                if (bufferGeometry === undefined) {
                    continue;
                }
                if (bufferGeometry.index !== null) {
                    geometryAccessor = this.getIndexedGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                else {
                    geometryAccessor = this.getGeometryAccessor(geometryType, meshObject, bufferGeometry);
                }
                if (geometryAccessor === undefined) {
                    logger.warn("#visitObject: no accessor geometryType", geometryType);
                    continue;
                }
            }
            featureEnd =
                featureIndex < starts.length - 1
                    ? starts[featureIndex + 1]
                    : geometryAccessor.getCount();
            // setup/update the accessor for the new range of the object
            geometryAccessor.setRange(featureStart, featureEnd);
            switch (geometryType) {
                case harp_datasource_protocol_1.GeometryType.Point:
                case harp_datasource_protocol_1.GeometryType.Text:
                    this.visitor.visitPoint(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.SolidLine:
                case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
                case harp_datasource_protocol_1.GeometryType.TextPath:
                    harp_utils_1.assert(TileGeometry_1.isLineAccessor(geometryAccessor));
                    this.visitor.visitLine(featureId, geometryAccessor);
                    break;
                case harp_datasource_protocol_1.GeometryType.Polygon:
                case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                    this.visitor.visitArea(featureId);
                    break;
                case harp_datasource_protocol_1.GeometryType.Object3D:
                    harp_utils_1.assert(TileGeometry_1.isObject3dAccessor(geometryAccessor));
                    this.visitor.visitObject3D(featureId, geometryAccessor);
                    break;
                default:
                    logger.warn("#visitObject: invalid geometryType");
            }
        }
    }
}
exports.TileDataAccessor = TileDataAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometry.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometry.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IndexedBufferedGeometryLineAccessor = exports.IndexedBufferedGeometryAccessor = exports.BufferedGeometryObject3dAccessor = exports.BufferedGeometryLineAccessor = exports.BufferedGeometryAccessor = exports.BufferedGeometryAccessorBase = exports.isObject3dAccessor = exports.isLineAccessor = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_lines_1 = __webpack_require__(/*! @here/harp-lines */ "../harp-lines/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometry");
/**
 * Helper function to check if an accessor is of type `ILineAccessor`.
 *
 * @param arg - `true` if `arg` is `ILineAccessor`.
 * @internal
 */
function isLineAccessor(arg) {
    /**
     * Get vertices from the object.
     *
     * @param mode - Specifies which part of the vertices should be returned.
     */
    return typeof arg.isLineAccessor === "function" && arg.isLineAccessor() === true;
}
exports.isLineAccessor = isLineAccessor;
/**
 * Helper function to check if an accessor is of type `IObject3dAccessor`.
 *
 * @param arg - `true` if `arg` is `IObject3dAccessor`.
 * @internal
 */
function isObject3dAccessor(arg) {
    return typeof arg.isObject3dAccessor === "function" && arg.isObject3dAccessor() === true;
}
exports.isObject3dAccessor = isObject3dAccessor;
/**
 * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.
 */
class BufferedGeometryAccessorBase {
    constructor(object, geometryType, bufferGeometry) {
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.start = -1;
        this.end = -1;
        this.startCapSize = 0;
        this.endCapSize = 0;
        harp_utils_1.assert(!!object);
        if (bufferGeometry.type !== "BufferGeometry") {
            logger.error("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong " + "type");
        }
        harp_utils_1.assert(bufferGeometry.type === "BufferGeometry", "IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type");
        // we know its a BufferAttribute because it is a BufferGeometry
        this.position = this.bufferGeometry.getAttribute("position");
        this.itemSize = this.position.itemSize;
        if (!this.position) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry has no position " +
                "attribute");
        }
        if (this.position.array.constructor !== Float32Array) {
            logger.warn("BufferedGeometryAccessor#constructor: BufferGeometry.position: " +
                "unsupported ArrayBuffer");
        }
    }
    /**
     * Get the number of accessible geometries in this buffer.
     *
     * @returns Number of primitives in this geometry.
     */
    getCount() {
        return this.position.count;
    }
    /**
     * Get `renderOrder` of object.
     *
     * @returns `renderOrder` of the object.
     */
    get renderOrder() {
        return this.object.renderOrder;
    }
    setRange(start, end, startCapSize = 0, endCapSize = 0) {
        harp_utils_1.assert(start >= 0);
        harp_utils_1.assert(end >= 0);
        harp_utils_1.assert(start <= end);
        this.start = start;
        this.end = end;
        this.startCapSize = startCapSize;
        this.endCapSize = endCapSize;
    }
    /**
     * Get one or more colors from materials.
     */
    get color() {
        /**
         * TODO: Get color(s) from vertex colors
         */
        const getColor = (material) => {
            const meshMaterial = material;
            if (meshMaterial.type === "MeshBasicMaterial" ||
                meshMaterial.type === "MeshStandardMaterial") {
                return meshMaterial.color;
            }
            else if (meshMaterial.type === "RawShaderMaterial") {
                const rawShaderMaterial = material;
                if (rawShaderMaterial.name === "SolidLineMaterial") {
                    return rawShaderMaterial.uniforms.diffuseColor.value;
                }
                logger.warn("BufferedGeometryAccessor#color: unknown shader material name", rawShaderMaterial.name);
            }
            else {
                logger.warn("BufferedGeometryAccessor#color: unknown material type", meshMaterial.type);
            }
            return undefined;
        };
        if (Array.isArray(this.object.material)) {
            const results = new Array();
            const materials = this.object.material;
            for (const material of materials) {
                results.push(getColor(material));
            }
            return results;
        }
        else {
            return getColor(this.object.material);
        }
    }
}
exports.BufferedGeometryAccessorBase = BufferedGeometryAccessorBase;
/**
 * Abstract base class of an accessor for nonindexed geometry.
 */
class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Create an object of type `BufferedGeometryAccessor`
     *
     * @param object - mesh object
     * @param geometryType - type of geometry to be used
     * @param bufferGeometry - which buffer geometry to use
     * @param stride - geometry stride length
     */
    constructor(object, geometryType, bufferGeometry, stride) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.stride = stride;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const positionsArray = this.position.array;
        const start = this.start * this.itemSize;
        const end = this.end * this.itemSize;
        for (let i = start; i < end; i++) {
            positionsArray[i] = 0;
        }
        this.position.needsUpdate = true;
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "BufferedGeometryAccessor not setup");
        const start = this.start;
        const end = this.end;
        return this.position.array.subarray(start * this.itemSize, end * this.itemSize);
    }
    checkSetUp() {
        return (this.position !== undefined &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.position.count &&
            this.start <= this.end);
    }
}
exports.BufferedGeometryAccessor = BufferedGeometryAccessor;
/**
 * Accessor for nonindexed line geometry.
 */
class BufferedGeometryLineAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    get width() {
        //TODO: There is no implementation of such a line, yet...
        harp_utils_1.assert(this.checkSetUp(), "RoBufferedGeometryLineAccessor not setup");
        return undefined;
    }
}
exports.BufferedGeometryLineAccessor = BufferedGeometryLineAccessor;
/**
 * Accessor for nonindexed unspecified (`Object3D`) geometry.
 */
class BufferedGeometryObject3dAccessor extends BufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 1);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isObject3dAccessor() {
        return true;
    }
    /** @override */
    getVertices() {
        return super.getVertices();
    }
}
exports.BufferedGeometryObject3dAccessor = BufferedGeometryObject3dAccessor;
/**
 * Abstract base class of indexed geometry.
 */
class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {
    /**
     * Creates an abstract class `IndexedBufferedGeometryAccessor`.
     *
     * @param object - mesh to be used
     * @param geometryType - type of geometry
     * @param bufferGeometry - geometry used
     * @param start -
     * @param end -
     */
    constructor(object, geometryType, bufferGeometry, start, end) {
        super(object, geometryType, bufferGeometry);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
        this.indices =
            this.bufferGeometry.index !== null
                ? this.bufferGeometry.index.array
                : undefined;
        if (!this.indices) {
            logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no " + "index");
            harp_utils_1.assert(!!this.indices);
        }
        else {
            if (!(this.indices instanceof Uint32Array)) {
                logger.warn("IndexedBufferedGeometryAccessor#constructor: BufferGeometry index " +
                    "has wrong type");
                harp_utils_1.assert(this.indices instanceof Uint32Array);
            }
        }
    }
    /**
     * Returns number of primitives, which is not known in this base class, so we return the number
     * of indices.
     *
     * @returns The number of indices in the geometry.
     * @override
     */
    getCount() {
        return this.indices.length;
    }
    checkSetUp() {
        return (!!this.indices &&
            this.start !== undefined &&
            this.end !== undefined &&
            this.start >= 0 &&
            this.end <= this.indices.length &&
            this.start <= this.end);
    }
}
exports.IndexedBufferedGeometryAccessor = IndexedBufferedGeometryAccessor;
/**
 * Accessor for lines in an indexed geometry.
 */
class IndexedBufferedGeometryLineAccessor extends IndexedBufferedGeometryAccessor {
    constructor(object, geometryType, bufferGeometry) {
        super(object, geometryType, bufferGeometry, 3);
        this.object = object;
        this.geometryType = geometryType;
        this.bufferGeometry = bufferGeometry;
    }
    isLineAccessor() {
        return true;
    }
    /**
     * Reconstructs line width from triangulated geometry.
     *
     * @returns Line width.
     */
    get width() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        if (this.geometryType === harp_datasource_protocol_1.GeometryType.ExtrudedLine) {
            const start = this.start + this.startCapSize;
            const positionArray = this.position.array;
            return harp_lines_1.reconstructLineWidth(positionArray, start);
        }
        return undefined;
    }
    clear() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const start = this.start;
        const end = this.end;
        for (let i = start; i < end; i++) {
            this.indices[i] = 0;
        }
        if (this.bufferGeometry.index !== null) {
            this.bufferGeometry.index.needsUpdate = true;
        }
    }
    getVertices() {
        harp_utils_1.assert(this.checkSetUp(), "RoIndexedBufferedGeometryLineAccessor not setup");
        const itemSize = this.itemSize;
        const start = this.start;
        const end = this.end;
        const result = new Float32Array((end - start) * itemSize);
        const positionArray = this.position.array;
        if (itemSize === 2) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
            }
        }
        if (itemSize === 3) {
            for (let i = start, j = 0; i < end; i++, j += itemSize) {
                const index = this.indices[i];
                result[j + 0] = positionArray[index * itemSize + 0];
                result[j + 1] = positionArray[index * itemSize + 1];
                result[j + 2] = positionArray[index * itemSize + 2];
            }
        }
        else {
            for (let i = start, j = 0; i < end; i++, j++) {
                const index = this.indices[i];
                for (let k = 0; k < itemSize; k++) {
                    result[j * itemSize + k] = positionArray[index * itemSize + k];
                }
            }
        }
        return result;
    }
}
exports.IndexedBufferedGeometryLineAccessor = IndexedBufferedGeometryLineAccessor;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryCreator.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryCreator.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileGeometryCreator = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const DepthPrePass_1 = __webpack_require__(/*! ../DepthPrePass */ "../harp-mapview/lib/DepthPrePass.ts");
const MapMaterialAdapter_1 = __webpack_require__(/*! ../MapMaterialAdapter */ "../harp-mapview/lib/MapMaterialAdapter.ts");
const PathBlockingElement_1 = __webpack_require__(/*! ../PathBlockingElement */ "../harp-mapview/lib/PathBlockingElement.ts");
const TextElementBuilder_1 = __webpack_require__(/*! ../text/TextElementBuilder */ "../harp-mapview/lib/text/TextElementBuilder.ts");
const AddGroundPlane_1 = __webpack_require__(/*! ./AddGroundPlane */ "../harp-mapview/lib/geometry/AddGroundPlane.ts");
const RegisterTileObject_1 = __webpack_require__(/*! ./RegisterTileObject */ "../harp-mapview/lib/geometry/RegisterTileObject.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometryCreator");
const tmpVector3 = new THREE.Vector3();
const tmpVector2 = new THREE.Vector2();
class AttachmentCache {
    constructor() {
        this.bufferAttributes = new Map();
        this.interleavedAttributes = new Map();
    }
}
class MemoCallExpr extends harp_datasource_protocol_1.CallExpr {
    constructor(expr) {
        super("memo", [expr]);
        this.m_cachedProperties = [];
        this.m_deps = Array.from(expr.dependencies().properties);
        this.descriptor = this;
    }
    call(context) {
        let changed = false;
        this.m_deps.forEach((d, i) => {
            const newValue = context.env.lookup(d);
            if (!changed && newValue !== this.m_cachedProperties[i]) {
                changed = true;
            }
            if (changed) {
                this.m_cachedProperties[i] = newValue;
            }
        });
        if (changed || this.m_cachedValue === undefined) {
            this.m_cachedValue = context.evaluate(this.args[0]);
        }
        return this.m_cachedValue;
    }
}
class AttachmentInfo {
    constructor(geometry, info, cache) {
        this.geometry = geometry;
        this.info = info;
        this.cache = cache;
    }
    getBufferAttribute(description) {
        if (this.cache.bufferAttributes.has(description)) {
            return this.cache.bufferAttributes.get(description);
        }
        const attribute = DecodedTileHelpers_1.getBufferAttribute(description);
        this.cache.bufferAttributes.set(description, attribute);
        return attribute;
    }
    getInterleavedBufferAttributes(description) {
        const interleavedAttributes = this.cache.interleavedAttributes.get(description);
        if (interleavedAttributes) {
            return interleavedAttributes;
        }
        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(description.type);
        const buffer = new ArrayCtor(description.buffer);
        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);
        const attrs = description.attributes.map(interleavedAttr => {
            const attribute = new THREE.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
            const name = interleavedAttr.name;
            return { name, attribute };
        });
        this.cache.interleavedAttributes.set(description, attrs);
        return attrs;
    }
}
function addToExtrudedMaterials(material, extrudedMaterials) {
    if (Array.isArray(material)) {
        const materials = material;
        extrudedMaterials.push(...materials);
    }
    else {
        extrudedMaterials.push(material);
    }
}
/**
 * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.
 * @internal
 */
class TileGeometryCreator {
    /**
     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.
     */
    constructor() {
        //
    }
    /**
     * The `instance` of the `TileGeometryCreator`.
     *
     * @returns TileGeometryCreator
     */
    static get instance() {
        return this.m_instance || (this.m_instance = new TileGeometryCreator());
    }
    /**
     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a
     * technique is identified as disabled, its property `enabled` is set to `false`.
     *
     * @param decodedTile - The decodedTile containing the actual tile map data.
     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be
     *      created.
     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be
     *      created.
     */
    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
        for (const technique of decodedTile.techniques) {
            const kind = technique.kind;
            // No info about kind, no way to filter it.
            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {
                technique._kindState = true;
                continue;
            }
            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or
            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.
            technique._kindState =
                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||
                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));
        }
        for (const srcGeometry of decodedTile.geometries) {
            for (const group of srcGeometry.groups) {
                group.createdOffsets = [];
            }
        }
    }
    /**
     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before
     * calling this method.
     *
     * @see [[TileGeometryCreator#initDecodedTile]]
     *
     * @param tile - The {@link Tile} to process.
     * @param decodedTile - The decodedTile containing the actual tile map data.
     * @returns Promise resolved when all textures are ready to render.
     */
    createAllGeometries(tile, decodedTile) {
        const filter = (technique) => {
            return technique._kindState !== false;
        };
        let texturesReady = Promise.resolve();
        const onNewTexture = (texturePromise) => {
            texturesReady = Promise.all([
                texturesReady,
                texturePromise
                    .then(texture => {
                    tile.addOwnedTexture(texture);
                    if (!texture.image) {
                        return Promise.resolve();
                    }
                    return new Promise(resolve => {
                        texture.onUpdate = () => {
                            texture.onUpdate = null;
                            resolve();
                        };
                        tile.mapView.renderer.initTexture(texture);
                    });
                })
                    .catch(() => { }) // Keep waiting for the other textures even if one fails.
            ]);
        };
        this.createObjects(tile, decodedTile, onNewTexture, filter);
        this.preparePois(tile, decodedTile);
        // TextElements do not get their geometry created by Tile, but are managed on a
        // higher level.
        const textFilter = (technique) => {
            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                !harp_datasource_protocol_1.isTextTechnique(technique)) {
                return false;
            }
            return filter(technique);
        };
        this.createTextElements(tile, decodedTile, textFilter);
        this.createLabelRejectionElements(tile, decodedTile);
        // HARP-7899, disable ground plane for globe
        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // The ground plane is required for when we zoom in and we fall back to the parent
            // (whilst the new tiles are loading), in that case the ground plane ensures that the
            // parent's geometry doesn't show through.
            AddGroundPlane_1.addGroundPlane(tile, -1);
        }
        return texturesReady;
    }
    createLabelRejectionElements(tile, decodedTile) {
        if (decodedTile.pathGeometries === undefined) {
            return;
        }
        for (const path of decodedTile.pathGeometries) {
            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));
        }
    }
    /**
     * Processes the given tile and assign default values for geometry kinds,
     * render orders and label priorities.
     *
     * @param {Tile} tile
     * @param {(GeometryKindSet | undefined)} enabledKinds
     * @param {(GeometryKindSet | undefined)} disabledKinds
     */
    processTechniques(tile, enabledKinds, disabledKinds) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        // Speedup and simplify following code: Test all techniques if they intersect with
        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be
        // ignored hereafter.
        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
        // compile the dynamic expressions.
        const exprPool = tile.dataSource.exprPool;
        decodedTile.techniques.forEach((technique) => {
            for (const propertyName in technique) {
                if (!technique.hasOwnProperty(propertyName)) {
                    continue;
                }
                const value = technique[propertyName];
                if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== "kind") {
                    // "kind" is reserved.
                    try {
                        let expr = harp_datasource_protocol_1.Expr.fromJSON(value);
                        if (expr.dependencies().volatile !== true) {
                            expr = new MemoCallExpr(harp_datasource_protocol_1.Expr.fromJSON(value));
                        }
                        technique[propertyName] = expr.intern(exprPool);
                    }
                    catch (error) {
                        logger.error("Failed to compile expression:", error);
                    }
                }
            }
        });
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile - The {@link Tile} to process paths on.
     * @param textPathGeometries - The original path geometries that may have defects.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
        const processedPaths = new Array();
        const newPaths = textPathGeometries.slice();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            const technique = decodedTile.techniques[textPath.technique];
            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||
                (textFilter !== undefined && !textFilter(technique))) {
                continue;
            }
            processedPaths.push(textPath);
        }
        return processedPaths;
    }
    /**
     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The
     * priorities of the {@link TextElement}s are updated to simplify label placement.
     *
     * @param tile - The {@link Tile} to create the testElements on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    createTextElements(tile, decodedTile, textFilter) {
        var _a;
        const mapView = tile.mapView;
        const worldOffsetX = tile.computeWorldOffsetX();
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const textElementBuilder = new TextElementBuilder_1.TextElementBuilder(discreteZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
        if (decodedTile.textPathGeometries !== undefined) {
            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
                }
                const textElement = textElementBuilder
                    .withTechnique(technique)
                    .build(textPath.text, path, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, textPath.objInfos, textPath.pathLengthSqr);
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float64Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                textElementBuilder.withTechnique(technique);
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i) + worldOffsetX;
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const attributes = (_a = text.objInfos) === null || _a === void 0 ? void 0 : _a[i];
                    const point = new THREE.Vector3(x, y, z);
                    const textElement = textElementBuilder.build(label, point, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, attributes);
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile - The {@link Tile} to create the geometry on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param onTextureCreated - Callback for each texture created, getting a promise that will be
     * resolved once the texture is loaded. Texture is not uploaded to GPU.
     * @param techniqueFilter -: Optional filter. Should return true for any technique that is
     *      applicable.
     */
    createObjects(tile, decodedTile, onTextureCreated, techniqueFilter) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const materials = [];
        const extrudedMaterials = [];
        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const objects = tile.objects;
        const viewRanges = mapView.viewRanges;
        const elevationEnabled = mapView.elevationProvider !== undefined;
        for (const attachment of this.getAttachments(decodedTile)) {
            const srcGeometry = attachment.geometry;
            const groups = attachment.info.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (group.createdOffsets === undefined) {
                    group.createdOffsets = [];
                }
                if (group.createdOffsets.includes(tile.offset) ||
                    technique._kindState === false ||
                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {
                    continue;
                }
                let count = group.count;
                group.createdOffsets.push(tile.offset);
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                    // Mark this group as created, so it does not get processed again.
                    groups[groupIndex].createdOffsets.push(tile.offset);
                }
                if (!DecodedTileHelpers_1.usesObject3D(technique)) {
                    continue;
                }
                const extrusionAnimationEnabled = (_a = animatedExtrusionHandler === null || animatedExtrusionHandler === void 0 ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) !== null && _a !== void 0 ? _a : false;
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    material = DecodedTileHelpers_1.createMaterial(mapView.renderer.capabilities, {
                        technique,
                        env: mapView.env,
                        fog: mapView.scene.fog !== null,
                        shadowsEnabled: mapView.shadowsEnabled
                    }, onTextureCreated);
                    if (material === undefined) {
                        continue;
                    }
                    if (extrusionAnimationEnabled && harp_materials_1.hasExtrusionFeature(material)) {
                        addToExtrudedMaterials(material, extrudedMaterials);
                    }
                    materials[techniqueIndex] = material;
                }
                const techniqueKind = technique.kind;
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                }
                const bufferGeometry = new THREE.BufferGeometry();
                (_b = srcGeometry.vertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(vertexAttribute => {
                    const buffer = attachment.getBufferAttribute(vertexAttribute);
                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);
                });
                (_c = srcGeometry.interleavedVertexAttributes) === null || _c === void 0 ? void 0 : _c.forEach(attr => {
                    attachment
                        .getInterleavedBufferAttributes(attr)
                        .forEach(({ name, attribute }) => bufferGeometry.setAttribute(name, attribute));
                });
                const index = (_d = attachment.info.index) !== null && _d !== void 0 ? _d : srcGeometry.index;
                if (index) {
                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));
                }
                if (!bufferGeometry.getAttribute("normal") && harp_datasource_protocol_1.needsVertexNormals(technique)) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    // TODO: Unify access to shader defines via SolidLineMaterial setters
                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));
                    const lineMaterial = material;
                    if (technique.clipping === true &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        tile.boundingBox.getSize(tmpVector3);
                        tmpVector2.set(tmpVector3.x, tmpVector3.y);
                        lineMaterial.clipTileSize = tmpVector2;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        harp_materials_1.setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
                    }
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                // When the source geometry is split in groups, we
                // should create objects with an array of materials.
                const hasFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                    srcGeometry.featureStarts &&
                    srcGeometry.featureStarts.length > 0;
                const object = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, hasFeatureGroups ? [material] : material, tile, elevationEnabled);
                object.renderOrder = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, mapView.env);
                if (attachment.info.uuid !== undefined) {
                    object.uuid = attachment.info.uuid;
                    object.userData.geometryId = attachment.info.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(mapView.env, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                this.addUserData(tile, srcGeometry, technique, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                    object.castShadow = mapView.shadowsEnabled;
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                else if (harp_datasource_protocol_1.isStandardTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) ||
                    harp_datasource_protocol_1.isStandardTechnique(technique) ||
                    harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    DepthPrePass_1.isRenderDepthPrePassEnabled(technique, discreteZoomEnv);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    this.addUserData(tile, srcGeometry, technique, depthPassMesh);
                    // Set geometry kind for depth pass mesh so that it gets the displacement map
                    // for elevation overlay.
                    RegisterTileObject_1.registerTileObject(tile, depthPassMesh, techniqueKind, {
                        technique,
                        pickability: harp_datasource_protocol_1.Pickability.transient
                    });
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                const techniquePickability = harp_datasource_protocol_1.transientToPickability(harp_datasource_protocol_1.getPropertyValue(technique.transient, mapView.env));
                // register all objects as pickable except solid lines with outlines, in that case
                // it's enough to make outlines pickable.
                RegisterTileObject_1.registerTileObject(tile, object, techniqueKind, {
                    technique,
                    pickability: hasSolidLinesOutlines
                        ? harp_datasource_protocol_1.Pickability.transient
                        : techniquePickability
                });
                objects.push(object);
                // Add the extruded polygon edges as a separate geometry.
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    attachment.info.edgeIndex !== undefined) {
                    // When the source geometry is split in groups, we
                    // should create objects with an array of materials.
                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                        srcGeometry.edgeFeatureStarts &&
                        srcGeometry.edgeFeatureStarts.length > 0;
                    const buildingTechnique = technique;
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.setAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
                    }
                    const normalAttribute = bufferGeometry.getAttribute("normal");
                    if (normalAttribute !== undefined) {
                        edgeGeometry.setAttribute("normal", normalAttribute);
                    }
                    const uvAttribute = bufferGeometry.getAttribute("uv");
                    if (uvAttribute !== undefined) {
                        edgeGeometry.setAttribute("uv", uvAttribute);
                    }
                    edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar,
                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined,
                        vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                        rendererCapabilities: mapView.renderer.capabilities
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, hasEdgeFeatureGroups ? [edgeMaterial] : edgeMaterial);
                    this.addUserData(tile, srcGeometry, technique, edgeObj);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);
                    }
                    RegisterTileObject_1.registerTileObject(tile, edgeObj, techniqueKind, {
                        technique,
                        pickability: harp_datasource_protocol_1.Pickability.transient
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(edgeMaterial, {
                        color: buildingTechnique.lineColor,
                        objectColor: buildingTechnique.color,
                        opacity: buildingTechnique.opacity,
                        lineWidth: (frameMapView) => {
                            // lineWidth for ExtrudedPolygonEdges only supports 0 or 1
                            const value = harp_datasource_protocol_1.getPropertyValue(buildingTechnique.lineWidth, frameMapView.env);
                            if (typeof value === "number") {
                                return THREE.MathUtils.clamp(value, 0, 1);
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    object.customDepthMaterial = new harp_materials_1.MapMeshDepthMaterial({
                        depthPacking: THREE.RGBADepthPacking
                    });
                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);
                }
                // Add the fill area edges as a separate geometry.
                if (harp_datasource_protocol_1.isFillTechnique(technique) && attachment.info.edgeIndex) {
                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                        srcGeometry.edgeFeatureStarts &&
                        srcGeometry.edgeFeatureStarts.length > 0;
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar,
                        vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                        rendererCapabilities: mapView.renderer.capabilities
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, hasEdgeFeatureGroups ? [outlineMaterial] : outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    this.addUserData(tile, srcGeometry, technique, outlineObj);
                    RegisterTileObject_1.registerTileObject(tile, outlineObj, techniqueKind, {
                        technique,
                        pickability: techniquePickability
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: fillTechnique.lineColor,
                        objectColor: fillTechnique.color,
                        opacity: fillTechnique.opacity
                    });
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    DecodedTileHelpers_1.applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, (_e = outlineTechnique.secondaryColor) !== null && _e !== void 0 ? _e : 0x000000, discreteZoomEnv);
                    if (outlineTechnique.secondaryCaps !== undefined) {
                        outlineMaterial.caps = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);
                    }
                    const outlineObj = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, outlineMaterial, tile, elevationEnabled);
                    outlineObj.renderOrder =
                        ((_f = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env)) !== null && _f !== void 0 ? _f : 0) - 0.0000001;
                    this.addUserData(tile, srcGeometry, technique, outlineObj);
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                    const secondaryWidth = DecodedTileHelpers_1.buildMetricValueEvaluator(outlineTechnique.secondaryWidth, outlineTechnique.metricUnit);
                    RegisterTileObject_1.registerTileObject(tile, outlineObj, techniqueKind, { technique });
                    const mainMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.get(material);
                    const outlineMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: outlineTechnique.secondaryColor,
                        opacity: outlineTechnique.opacity,
                        caps: outlineTechnique.secondaryCaps,
                        // Still handled above
                        lineWidth: (frameMapView) => {
                            if (!mainMaterialAdapter) {
                                return;
                            }
                            mainMaterialAdapter.ensureUpdated(frameMapView);
                            const mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;
                            const secondaryLineWidth = harp_datasource_protocol_1.getPropertyValue(secondaryWidth, mapView.env);
                            const opacity = outlineMaterialAdapter.currentStyledProperties
                                .opacity;
                            if (typeof mainLineWidth === "number" &&
                                typeof secondaryLineWidth === "number") {
                                if (secondaryLineWidth <= mainLineWidth &&
                                    (opacity === null || opacity === undefined || opacity === 1)) {
                                    // We could mark object as invisible somehow, not sure how
                                    // objectAdapter.markInvisible();
                                    return 0;
                                }
                                else {
                                    return secondaryLineWidth;
                                }
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                    objects.push(outlineObj);
                }
            }
        }
        if (extrudedMaterials.length > 0) {
            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);
        }
    }
    /**
     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.
     *
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     */
    *getAttachments(decodedTile) {
        const cache = new AttachmentCache();
        for (const geometry of decodedTile.geometries) {
            // the main attachment
            const mainAttachment = {
                index: geometry.index,
                edgeIndex: geometry.edgeIndex,
                uuid: geometry.uuid,
                groups: geometry.groups
            };
            yield new AttachmentInfo(geometry, mainAttachment, cache);
            if (geometry.attachments) {
                // the additional attachments
                for (const info of geometry.attachments) {
                    yield new AttachmentInfo(geometry, info, cache);
                }
            }
        }
    }
    setupTerrainMaterial(technique, material, terrainColor) {
        if (!technique.map || !technique.displacementMap) {
            // Render terrain using the given color.
            const stdMaterial = material;
            stdMaterial.color.set(terrainColor);
            // Remove displacement map, otherwise it would elevate terrain geometry and make it
            // twice as high as it should be.
            harp_materials_1.setDisplacementMapToMaterial(null, stdMaterial);
            return;
        }
        // Render terrain using height-based colors.
        material.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
            // We remove the displacement map from manipulating the vertices, it is
            // however still required for the pixel shader, so it can't be directly
            // removed.
            shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
        };
        material.displacementMap.needsUpdate = true;
    }
    addUserData(tile, srcGeometry, technique, object) {
        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
            harp_utils_1.assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
            harp_utils_1.assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
            const displacementMap = srcGeometry.objInfos[0];
            const tileDisplacementMap = {
                tileKey: tile.tileKey,
                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),
                displacementMap,
                geoBox: tile.geoBox
            };
            object.userData = tileDisplacementMap;
        }
        else {
            // Set the feature data for picking with `MapView.intersectMapObjects()` except for
            // solid-line which uses tile-based picking.
            const isOutline = object.type === "LineSegments" &&
                (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique));
            const featureData = {
                geometryType: srcGeometry.type,
                starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,
                objInfos: srcGeometry.objInfos
            };
            object.userData.feature = featureData;
            object.userData.technique = technique;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(env, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(env, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, env);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, env)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, env)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
exports.TileGeometryCreator = TileGeometryCreator;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryLoader.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryLoader.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileGeometryLoader = exports.TileGeometryLoaderState = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const MapView_1 = __webpack_require__(/*! ../MapView */ "../harp-mapview/lib/MapView.ts");
const Statistics_1 = __webpack_require__(/*! ../Statistics */ "../harp-mapview/lib/Statistics.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! ./TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
function addDiscardedTileToStats(tile) {
    const stats = Statistics_1.PerformanceStatistics.instance;
    if (stats.enabled) {
        const name = tile.dataSource.name;
        const level = tile.tileKey.level;
        const col = tile.tileKey.column;
        const row = tile.tileKey.row;
        const reason = tile.disposed ? `disposed` : `invisible`;
        stats.currentFrame.addMessage(`Decoded tile: ${name} # lvl=${level} col=${col} row=${row} DISCARDED - ${reason}`);
    }
}
/**
 * The state the {@link TileGeometryLoader}.
 */
var TileGeometryLoaderState;
(function (TileGeometryLoaderState) {
    TileGeometryLoaderState[TileGeometryLoaderState["Initialized"] = 0] = "Initialized";
    TileGeometryLoaderState[TileGeometryLoaderState["CreationQueued"] = 1] = "CreationQueued";
    TileGeometryLoaderState[TileGeometryLoaderState["CreatingGeometry"] = 2] = "CreatingGeometry";
    TileGeometryLoaderState[TileGeometryLoaderState["Finished"] = 3] = "Finished";
    TileGeometryLoaderState[TileGeometryLoaderState["Canceled"] = 4] = "Canceled";
    TileGeometryLoaderState[TileGeometryLoaderState["Disposed"] = 5] = "Disposed";
})(TileGeometryLoaderState = exports.TileGeometryLoaderState || (exports.TileGeometryLoaderState = {}));
/**
 * Loads the geometry for its {@link Tile}. Loads all geometry in a single step.
 * @internal
 */
class TileGeometryLoader {
    constructor(m_tile, m_taskQueue) {
        this.m_tile = m_tile;
        this.m_taskQueue = m_taskQueue;
        this.m_priority = 0;
        this.m_state = TileGeometryLoaderState.Initialized;
        this.m_finishedPromise = new Promise((resolve, reject) => {
            this.m_resolveFinishedPromise = resolve;
            this.m_rejectFinishedPromise = reject;
        });
    }
    /**
     * Make sure that all technique have their geometryKind set, either from the theme or their
     * default value.
     *
     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.
     *
     * @param {DecodedTile} decodedTile
     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.
     */
    static prepareAvailableGeometryKinds(decodedTile) {
        const foundSet = new harp_datasource_protocol_1.GeometryKindSet();
        for (const technique of decodedTile.techniques) {
            const geometryKind = TileGeometryLoader.compileGeometryKind(technique);
            if (geometryKind instanceof Set) {
                for (const kind of geometryKind) {
                    foundSet.add(kind);
                }
            }
            else {
                foundSet.add(geometryKind);
            }
        }
        return foundSet;
    }
    /**
     * Make sure that the technique has its geometryKind set, either from the theme or their default
     * value.
     *
     * @param {Technique} technique
     */
    static compileGeometryKind(technique) {
        let geometryKind = technique.kind;
        // Set default kind based on technique.
        if (geometryKind === undefined) {
            if (harp_datasource_protocol_1.isFillTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Area;
            }
            else if (harp_datasource_protocol_1.isLineTechnique(technique) ||
                harp_datasource_protocol_1.isSolidLineTechnique(technique) ||
                harp_datasource_protocol_1.isSegmentsTechnique(technique) ||
                harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Line;
            }
            else if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Building;
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique) ||
                harp_datasource_protocol_1.isLineMarkerTechnique(technique) ||
                harp_datasource_protocol_1.isTextTechnique(technique)) {
                geometryKind = harp_datasource_protocol_1.GeometryKind.Label;
            }
            else {
                geometryKind = harp_datasource_protocol_1.GeometryKind.All;
            }
            technique.kind = geometryKind;
        }
        else if (Array.isArray(geometryKind)) {
            geometryKind = technique.kind = new harp_datasource_protocol_1.GeometryKindSet(geometryKind);
        }
        return geometryKind;
    }
    set priority(value) {
        this.m_priority = value;
    }
    //This is not a getter as it need to be bound to this for the taskqueue
    getPriority() {
        return this.m_priority;
    }
    /**
     * The {@link Tile} this `TileGeometryLoader` is managing.
     */
    get tile() {
        return this.m_tile;
    }
    /**
     * `True` if a decoded Tile is set
     */
    get hasDecodedTile() {
        return this.m_decodedTile !== undefined;
    }
    /**
     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.
     */
    get isFinished() {
        return this.m_state === TileGeometryLoaderState.Finished;
    }
    /**
     * `True` if loader is finished, canceled or disposed.
     */
    get isSettled() {
        return this.isFinished || this.isCanceled || this.isDisposed;
    }
    /**
     * Returns a promise resolved when this `TileGeometryLoader` is in
     * `TileGeometryLoaderState.Finished` state, or rejected when it's in
     * `TileGeometryLoaderState.Cancelled` or `TileGeometryLoaderState.Disposed` states.
     */
    waitFinished() {
        return this.m_finishedPromise;
    }
    /**
     * Set the {@link @here/harp-datasource-protocol#DecodedTile} of the tile.
     *
     * @remarks
     * Is called after the decoded tile has been loaded, and
     * prepares its content for later processing in the 'updateXXX' methods.
     *
     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to
     *      this tile.
     * @returns {DecodedTile} The processed decoded tile.
     */
    setDecodedTile(decodedTile) {
        this.m_decodedTile = decodedTile;
        if (this.hasDecodedTile) {
            this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(this.m_decodedTile);
        }
        return this.m_decodedTile;
    }
    /**
     * The kinds of geometry stored in this {@link Tile}.
     */
    get availableGeometryKinds() {
        return this.m_availableGeometryKinds;
    }
    /**
     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.
     */
    update(enabledKinds, disabledKinds) {
        const tile = this.tile;
        // Geometry kinds have changed but some is already created, so reset
        if (this.tile.hasGeometry && !this.compareGeometryKinds(enabledKinds, disabledKinds)) {
            this.reset();
        }
        // First time this tile is handled, or reset has been requested.
        if ((this.m_state === TileGeometryLoaderState.Initialized ||
            this.m_state === TileGeometryLoaderState.Canceled) &&
            tile.decodedTile !== undefined) {
            if (this.m_state === TileGeometryLoaderState.Initialized) {
                TileGeometryCreator_1.TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);
                this.setGeometryKinds(enabledKinds, disabledKinds);
                this.setDecodedTile(tile.decodedTile);
            }
            this.queueGeometryCreation(enabledKinds, disabledKinds);
        }
    }
    /**
     * Cancel geometry loading.
     */
    cancel() {
        var _a;
        addDiscardedTileToStats(this.tile);
        this.m_state = TileGeometryLoaderState.Canceled;
        (_a = this.m_rejectFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    /**
     * Dispose of any resources.
     */
    dispose() {
        var _a;
        addDiscardedTileToStats(this.tile);
        this.clear();
        this.m_state = TileGeometryLoaderState.Disposed;
        (_a = this.m_rejectFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    /**
     * Reset the loader to its initial state and cancels any asynchronous work.
     * @remarks
     * This method prepares the loader to reload new geometry. Since the loader does not transition
     * to a final state, the promise returned by {@link TileGeometryLoader.waitFinished} is not
     * settled.
     */
    reset() {
        this.clear();
        if (this.isSettled) {
            this.m_finishedPromise = new Promise((resolve, reject) => {
                this.m_resolveFinishedPromise = resolve;
                this.m_rejectFinishedPromise = reject;
            });
        }
        this.m_state = TileGeometryLoaderState.Initialized;
    }
    /**
     * Finish geometry loading.
     */
    finish() {
        var _a;
        this.m_decodedTile = undefined;
        this.m_state = TileGeometryLoaderState.Finished;
        (_a = this.m_resolveFinishedPromise) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    clear() {
        var _a, _b, _c;
        (_a = this.m_availableGeometryKinds) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.m_enabledKinds) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this.m_disabledKinds) === null || _c === void 0 ? void 0 : _c.clear();
        this.m_decodedTile = undefined;
    }
    queueGeometryCreation(enabledKinds, disabledKinds) {
        if (this.m_state === TileGeometryLoaderState.CreationQueued) {
            return;
        }
        this.m_taskQueue.add({
            execute: this.createGeometry.bind(this, enabledKinds, disabledKinds),
            group: MapView_1.TileTaskGroups.CREATE,
            getPriority: this.getPriority.bind(this),
            isExpired: () => {
                return this.m_state !== TileGeometryLoaderState.CreationQueued;
            },
            estimatedProcessTime: () => {
                var _a, _b;
                //TODO: this seems to be close in many cases, but take some measures to confirm
                return ((_b = (_a = this.tile.decodedTile) === null || _a === void 0 ? void 0 : _a.decodeTime) !== null && _b !== void 0 ? _b : 30) / 6;
            }
        });
        this.m_state = TileGeometryLoaderState.CreationQueued;
    }
    async createGeometry(enabledKinds, disabledKinds) {
        if (this.m_state === TileGeometryLoaderState.CreatingGeometry) {
            return;
        }
        this.m_state = TileGeometryLoaderState.CreatingGeometry;
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        // Just a sanity check that satisfies compiler check below.
        if (decodedTile === undefined) {
            this.finish();
            return;
        }
        const stats = Statistics_1.PerformanceStatistics.instance;
        let now = 0;
        if (stats.enabled) {
            now = harp_utils_1.PerformanceTimer.now();
        }
        const geometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        tile.clear();
        // Set up techniques which should be processed.
        geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
        await geometryCreator.createAllGeometries(tile, decodedTile);
        if (stats.enabled) {
            this.addStats(stats, now);
        }
        this.finish();
        tile.dataSource.requestUpdate();
    }
    addStats(stats, now) {
        const tile = this.tile;
        const decodedTile = this.m_decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        const geometryCreationTime = harp_utils_1.PerformanceTimer.now() - now;
        const currentFrame = stats.currentFrame;
        // Account for the geometry creation in the current frame.
        currentFrame.addValue("render.fullFrameTime", geometryCreationTime);
        currentFrame.addValue("render.geometryCreationTime", geometryCreationTime);
        currentFrame.addValue("geometry.geometryCreationTime", geometryCreationTime);
        currentFrame.addValue("geometryCount.numGeometries", decodedTile.geometries.length);
        currentFrame.addValue("geometryCount.numTechniques", decodedTile.techniques.length);
        currentFrame.addValue("geometryCount.numPoiGeometries", decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0);
        currentFrame.addValue("geometryCount.numTextGeometries", decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0);
        currentFrame.addValue("geometryCount.numTextPathGeometries", decodedTile.textPathGeometries !== undefined ? decodedTile.textPathGeometries.length : 0);
        currentFrame.addValue("geometryCount.numPathGeometries", decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0);
        currentFrame.addMessage(
        // tslint:disable-next-line: max-line-length
        `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`);
    }
    /**
     * Stores geometry kinds used to load decoded tile geometry.
     *
     * This values are stored to detect geometry kind changes during loading.
     *
     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds - Set of geometry kinds that won't be rendered.
     */
    setGeometryKinds(enabledKinds, disabledKinds) {
        var _a, _b;
        if (enabledKinds !== undefined) {
            this.m_enabledKinds = Object.assign((_a = this.m_enabledKinds) !== null && _a !== void 0 ? _a : new harp_datasource_protocol_1.GeometryKindSet(), enabledKinds);
        }
        if (disabledKinds !== undefined) {
            this.m_disabledKinds = Object.assign((_b = this.m_disabledKinds) !== null && _b !== void 0 ? _b : new harp_datasource_protocol_1.GeometryKindSet(), disabledKinds);
        }
    }
    /**
     * Compare enabled and disabled geometry kinds with currently set.
     *
     * Method compares input sets with recently used geometry kinds in performance wise
     * manner, taking special care of undefined and zero size sets.
     *
     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.
     * @param disabledKinds - Set of geometry kinds that won't be rendered.
     * @return `true` only if sets are logically equal, meaning that undefined and empty sets
     * may result in same geometry (techniques kind) beeing rendered.
     */
    compareGeometryKinds(enabledKinds, disabledKinds) {
        const enabledSame = this.m_enabledKinds === enabledKinds;
        const disabledSame = this.m_disabledKinds === disabledKinds;
        // Same references, no need to compare.
        if (enabledSame && disabledSame) {
            return true;
        }
        const enabledEmpty = (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&
            (enabledKinds === undefined || enabledKinds.size === 0);
        const disabledEmpty = (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&
            (disabledKinds === undefined || disabledKinds.size === 0);
        // We deal only with empty, the same or undefined sets - fast return, no need to compare.
        if ((enabledEmpty && disabledEmpty) ||
            (enabledSame && disabledEmpty) ||
            (disabledSame && enabledEmpty)) {
            return true;
        }
        // It is enough that one the the sets are different, try to spot difference otherwise
        // return true. Compare only non-empty sets.
        if (!enabledEmpty) {
            // If one set undefined then other must be non-empty, for sure different.
            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!enabledKinds.has(this.m_enabledKinds)) {
                return false;
            }
        }
        if (!disabledEmpty) {
            // One set defined and non-empty other undefined, for sure different.
            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {
                return false;
            }
            // Both defined and non-empty, compare the sets.
            else if (!disabledKinds.has(this.m_disabledKinds)) {
                return false;
            }
        }
        // No difference found.
        return true;
    }
    /**
     * `True` if TileGeometryLoader was canceled
     */
    get isCanceled() {
        return this.m_state === TileGeometryLoaderState.Canceled;
    }
    /**
     * `True` if TileGeometryLoader was disposed
     */
    get isDisposed() {
        return this.m_state === TileGeometryLoaderState.Disposed;
    }
}
exports.TileGeometryLoader = TileGeometryLoader;


/***/ }),

/***/ "../harp-mapview/lib/geometry/TileGeometryManager.ts":
/*!***********************************************************!*\
  !*** ../harp-mapview/lib/geometry/TileGeometryManager.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileGeometryManager = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const MapObjectAdapter_1 = __webpack_require__(/*! ../MapObjectAdapter */ "../harp-mapview/lib/MapObjectAdapter.ts");
/**
 * Manages the content (the geometries) of a tile.
 * @internal
 */
class TileGeometryManager {
    /**
     * Creates an instance of `TileGeometryManager` with a reference to the {@link MapView}.
     */
    constructor(mapView) {
        this.mapView = mapView;
        /**
         * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they
         * are ignored.
         * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
         */
        this.enableFilterByKind = true;
        this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet();
        this.hiddenKinds = new harp_datasource_protocol_1.GeometryKindSet();
        /**
         * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the
         * visibility of the kinds is applied to their geometries.
         */
        this.m_visibilityCounter = 1;
    }
    /**
     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    get enabledGeometryKinds() {
        return this.enabledKinds;
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    set enabledGeometryKinds(kinds) {
        this.enabledKinds = kinds;
    }
    /**
     * The set of geometry kinds that is disabled. Their geometry will not be created after
     * decoding.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    get disabledGeometryKinds() {
        return this.disabledKinds;
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    set disabledGeometryKinds(kinds) {
        this.disabledKinds = kinds;
    }
    /**
     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden
     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    get hiddenGeometryKinds() {
        return this.hiddenKinds;
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    set hiddenGeometryKinds(kinds) {
        this.hiddenKinds = kinds;
        this.incrementVisibilityCounter();
    }
    get visibilityCounter() {
        return this.m_visibilityCounter;
    }
    /**
     * Process the {@link Tile}s for rendering. May alter the content of the tile per frame.
     */
    updateTiles(tiles) {
        let prio = 0;
        for (const tile of tiles) {
            //this assumes the tiles are ordered by priority, this is currently done in
            // the visible tile set with 0 as the highest priority
            const tilePriority = prio++;
            const updateDone = tile.updateGeometry(tilePriority, this.enableFilterByKind ? this.enabledGeometryKinds : undefined, this.enableFilterByKind ? this.disabledGeometryKinds : undefined);
            if (updateDone && this.m_tileUpdateCallback) {
                this.m_tileUpdateCallback(tile);
            }
        }
        // If the visibility status of the kinds changed since the last update, the new visibility
        // status is applied (again).
        if (this.updateTileObjectVisibility(tiles)) {
            this.mapView.update();
        }
    }
    /**
     * Clear the enabled, disabled and hidden sets.
     */
    clear() {
        this.enabledKinds.clear();
        this.disabledKinds.clear();
        this.hiddenKinds.clear();
    }
    /**
     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the enabled set.
     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in
     *      `false` to remove from that set.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    enableKind(kind, addOrRemoveToEnabledSet = true) {
        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);
    }
    /**
     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the disabled set.
     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in
     *      `false` to remove from that set.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    disableKind(kind, addOrRemoveToDisabledSet = true) {
        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);
    }
    /**
     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.
     *
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove
     *      from the hidden set.
     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show
     *      it again.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    hideKind(kind, addOrRemoveToHiddenSet = true) {
        let visibilityHasChanged = false;
        if (Array.isArray(kind) || kind instanceof Set) {
            for (const oneKind of kind) {
                const visibilityChange = this.addRemove(this.hiddenKinds, oneKind, addOrRemoveToHiddenSet);
                visibilityHasChanged = visibilityHasChanged || visibilityChange;
            }
        }
        else {
            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);
        }
        // Will be evaluated in the next update()
        if (visibilityHasChanged) {
            this.incrementVisibilityCounter();
        }
    }
    /**
     * Return all [[GeometryKind]]s that are contained in the tiles.
     *
     * @param {IterableIterator<Tile>} tiles The
     * @returns {GeometryKindSet}
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    getAvailableKinds(tiles) {
        const visibleKinds = new harp_datasource_protocol_1.GeometryKindSet();
        for (const tile of tiles) {
            const tileKinds = tile.loadedGeometryKinds;
            if (tileKinds !== undefined) {
                for (const kind of tileKinds) {
                    visibleKinds.add(kind);
                }
            }
        }
        return visibleKinds;
    }
    /**
     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified
     * tiles.
     *
     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.
     */
    updateTileObjectVisibility(tiles) {
        let needUpdate = false;
        for (const tile of tiles) {
            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {
                continue;
            }
            tile.visibilityCounter = this.visibilityCounter;
            for (const object of tile.objects) {
                const objectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
                const geometryKind = objectAdapter === null || objectAdapter === void 0 ? void 0 : objectAdapter.kind;
                if (geometryKind !== undefined) {
                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));
                    needUpdate = needUpdate || object.visible !== nowVisible;
                    object.visible = nowVisible;
                }
            }
        }
        return needUpdate;
    }
    /**
     * Sets a callback that will be called for every updated tile on [[updateTiles]].
     *
     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been
     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will
     * be cleared.
     */
    setTileUpdateCallback(callback) {
        this.m_tileUpdateCallback = callback;
    }
    incrementVisibilityCounter() {
        return ++this.m_visibilityCounter;
    }
    /**
     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    enableDisableKinds(set, kind, addToSet) {
        if (Array.isArray(kind)) {
            for (const oneKind of kind) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind instanceof Set) {
            const kindSet = kind;
            for (const oneKind of kindSet) {
                this.addRemove(set, oneKind, addToSet);
            }
        }
        else if (kind !== undefined) {
            this.addRemove(set, kind, addToSet);
        }
    }
    /**
     * Add or remove a single kind from the specified kind set.
     *
     * @hidden
     * @param {GeometryKindSet} set
     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind
     * @param {boolean} addToSet
     */
    addRemove(kindsSet, kind, addToSet) {
        if (addToSet) {
            if (!kindsSet.has(kind)) {
                kindsSet.add(kind);
                return true;
            }
        }
        else {
            if (kindsSet.has(kind)) {
                kindsSet.delete(kind);
                return true;
            }
        }
        return false;
    }
}
exports.TileGeometryManager = TileGeometryManager;


/***/ }),

/***/ "../harp-mapview/lib/geometry/VertexCache.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/geometry/VertexCache.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VertexCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
// Offsets for the fields stored in cache for each vertex.
var Field;
(function (Field) {
    Field[Field["VertexId"] = 0] = "VertexId";
    Field[Field["OlderIdx"] = 1] = "OlderIdx";
    Field[Field["NewerIdx"] = 2] = "NewerIdx";
    Field[Field["X"] = 3] = "X";
    Field[Field["Y"] = 4] = "Y";
    Field[Field["Z"] = 5] = "Z";
    Field[Field["Count"] = 6] = "Count";
})(Field || (Field = {}));
const Invalid = -1;
/**
 * Compact vertex LRU Cache for on the fly temporary mesh transformations.
 * @internal
 */
class VertexCache {
    /**
     * Creates a new cache with the specified maximum size.
     * @param maxVertexCount - The maximum number of vertices the cache will store.
     */
    constructor(maxVertexCount) {
        this.maxVertexCount = maxVertexCount;
        this.m_cache = []; // Stores all fields for every cached vertex (see Field).
        this.m_vertexCount = 0;
        this.m_oldestIdx = 0;
        this.m_newestIdx = 0;
        this.m_cache.length = this.maxVertexCount * Field.Count;
        this.clear();
    }
    /**
     * Clears the vertex cache.
     */
    clear() {
        this.m_cache.fill(Invalid);
        this.m_vertexCount = 0;
    }
    /**
     * Gets a vertex from cache.
     * @param vertexId - The id of the vertex to get.
     * @param vertex - The vertex coordinates will be set here if found.
     * @returns whether the vertex was found on cache.
     */
    get(vertexId, vertex) {
        const vertexIdx = this.find(vertexId);
        if (vertexIdx === undefined) {
            return false;
        }
        this.promoteEntry(vertexIdx);
        this.getVertex(vertexIdx, vertex);
        return true;
    }
    /**
     * Sets a vertex in cache. It's assumed there's no vertex with the same id already in cache.
     * @param vertexId - The vertex id.
     * @param vertex - The vertex coordinates.
     */
    set(vertexId, vertex) {
        let vertexIdx = Invalid;
        if (this.m_vertexCount < this.maxVertexCount) {
            vertexIdx = this.m_vertexCount * Field.Count;
            this.m_vertexCount++;
        }
        else {
            vertexIdx = this.m_oldestIdx;
        }
        if (this.m_vertexCount === 1) {
            this.m_oldestIdx = this.m_newestIdx = vertexIdx;
        }
        else {
            this.promoteEntry(vertexIdx);
        }
        this.setVertex(vertexIdx, vertexId, vertex);
    }
    find(vertexId) {
        const size = this.m_cache.length;
        for (let i = 0; i < size; i += Field.Count) {
            if (this.m_cache[i] === vertexId) {
                return i;
            }
        }
        return undefined;
    }
    promoteEntry(vertexIdx) {
        if (vertexIdx === this.m_newestIdx) {
            return;
        } // already newest, nothing to do
        // re-link newer and older items
        const newerIdx = this.getNewerIdx(vertexIdx);
        const olderIdx = this.getOlderIdx(vertexIdx);
        if (newerIdx !== Invalid) {
            harp_utils_1.assert(this.getOlderIdx(newerIdx) === vertexIdx);
            this.setOlderIdx(newerIdx, olderIdx);
        }
        if (olderIdx !== Invalid) {
            harp_utils_1.assert(this.getNewerIdx(olderIdx) === vertexIdx);
            this.setNewerIdx(olderIdx, newerIdx);
        }
        if (vertexIdx === this.m_oldestIdx) {
            this.m_oldestIdx = newerIdx;
        }
        // re-link ourselves
        this.setNewerIdx(vertexIdx, Invalid);
        this.setOlderIdx(vertexIdx, this.m_newestIdx);
        // finally, set ourselves as the newest entry
        harp_utils_1.assert(this.m_newestIdx !== Invalid);
        harp_utils_1.assert(this.getNewerIdx(this.m_newestIdx) === Invalid);
        this.setNewerIdx(this.m_newestIdx, vertexIdx);
        this.m_newestIdx = vertexIdx;
    }
    getOlderIdx(vertexIdx) {
        return this.m_cache[vertexIdx + Field.OlderIdx];
    }
    setOlderIdx(vertexIdx, olderIdx) {
        this.m_cache[vertexIdx + Field.OlderIdx] = olderIdx;
    }
    getNewerIdx(vertexIdx) {
        return this.m_cache[vertexIdx + Field.NewerIdx];
    }
    setNewerIdx(vertexIdx, newerIdx) {
        this.m_cache[vertexIdx + Field.NewerIdx] = newerIdx;
    }
    getVertex(vertexIdx, vertex) {
        vertex.x = this.m_cache[vertexIdx + Field.X];
        vertex.y = this.m_cache[vertexIdx + Field.Y];
        vertex.z = this.m_cache[vertexIdx + Field.Z];
    }
    setVertex(vertexIdx, vertexId, vertex) {
        this.m_cache[vertexIdx] = vertexId;
        this.m_cache[vertexIdx + Field.X] = vertex.x;
        this.m_cache[vertexIdx + Field.Y] = vertex.y;
        this.m_cache[vertexIdx + Field.Z] = vertex.z;
    }
}
exports.VertexCache = VertexCache;


/***/ }),

/***/ "../harp-mapview/lib/geometry/overlayOnElevation.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/geometry/overlayOnElevation.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.overlayOnElevation = exports.overlayTextElement = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Overlays the specified object's geometry on the elevation represented by the given displacement
 * map .
 *
 * @param object - The object to be overlaid.
 * @param displacementMap - Texture representing the elevation data used to overlay the object.
 */
function overlayObject(object, displacementMap) {
    if (!("material" in object)) {
        return;
    }
    const setDisplacementMap = harp_materials_1.setDisplacementMapToMaterial.bind(null, displacementMap);
    const material = object.material;
    if (Array.isArray(material)) {
        material.forEach(setDisplacementMap);
    }
    else if (material) {
        setDisplacementMap(material);
    }
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param worldCoords - World coordinates to overlay.
 * @param elevationProvider - Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPosition(worldCoords, elevationProvider, displacementMap, projection) {
    // TODO: Move calculation of text element geoCoordinates to decoder.
    const geoCoords = projection.unprojectPoint(worldCoords);
    if (displacementMap.geoBox.contains(geoCoords)) {
        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);
    }
    else {
        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);
        if (geoCoords.altitude === undefined) {
            return false;
        }
    }
    projection.projectPoint(geoCoords, worldCoords);
    return true;
}
/**
 * Overlays the specified coordinates on top of elevation data if available.
 *
 * @param path - World coordinates to overlay.
 * @param elevationProvider - Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation
 * data not available).
 */
function overlayPath(path, elevationProvider, displacementMap, projection) {
    for (const position of path) {
        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {
            return false;
        }
    }
    return true;
}
/**
 * Overlays a text element on top of elevation data if available.
 *
 * @param textElement - The text element whose geometry will be overlaid.
 * @param elevationProvider -  Used to sample elevation data.
 * @param displacementMap - Elevation data to be sampled.
 * @param projection - Projection from geo to world space.
 */
function overlayTextElement(textElement, elevationProvider, displacementMap, projection) {
    harp_utils_1.assert(!textElement.elevated);
    if (!displacementMap) {
        return;
    }
    textElement.elevated = textElement.path
        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)
        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);
}
exports.overlayTextElement = overlayTextElement;
/**
 * Overlays the geometry in the given tile on top of elevation data if available. The tile's
 * elevation may be updated with a more precise range.
 *
 * @param tile - The tile whose geometry will be overlaid.
 */
function overlayOnElevation(tile) {
    const elevationProvider = tile.mapView.elevationProvider;
    if (elevationProvider === undefined || tile.objects.length === 0) {
        return;
    }
    const firstObject = tile.objects[0];
    if (!firstObject.userData ||
        !firstObject.userData.kind ||
        !firstObject.userData.kind.find((kind) => {
            return kind !== harp_datasource_protocol_1.GeometryKind.All && kind !== harp_datasource_protocol_1.GeometryKind.Terrain;
        })) {
        return;
    }
    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);
    if (displacementMap === undefined) {
        return;
    }
    // TODO: HARP-8808 Apply displacement maps once per material.
    for (const object of tile.objects) {
        overlayObject(object, displacementMap.texture);
    }
}
exports.overlayOnElevation = overlayOnElevation;


/***/ }),

/***/ "../harp-mapview/lib/image/Image.ts":
/*!******************************************!*\
  !*** ../harp-mapview/lib/image/Image.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageItem = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MipMapGenerator_1 = __webpack_require__(/*! ./MipMapGenerator */ "../harp-mapview/lib/image/MipMapGenerator.ts");
const logger = harp_utils_1.LoggerManager.instance.create("loadImage");
const mipMapGenerator = new MipMapGenerator_1.MipMapGenerator();
/**
 * `ImageItem` is used to identify an image in the {@link ImageCache}.
 */
class ImageItem {
    /**
     * Create the `ImageItem`.
     *
     * @param url - URL of the image, or unique identifier.
     * @param image - Optional image if already loaded.
     */
    constructor(url, image) {
        this.url = url;
        this.image = image;
    }
    get loaded() {
        return this.image !== undefined && this.mipMaps !== undefined;
    }
    get loading() {
        return this.loadingPromise !== undefined;
    }
    /**
     * Load an {@link ImageItem}.
     *
     * @remarks
     * If the loading process is already running, it returns the current promise.
     *
     * @param imageItem - `ImageItem` containing the URL to load image from.
     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.
     */
    loadImage() {
        if (this.loaded) {
            return Promise.resolve(this);
        }
        if (this.loading) {
            return this.loadingPromise;
        }
        this.loadingPromise = new Promise((resolve, reject) => {
            if (this.image) {
                const image = this.image;
                if (image instanceof HTMLImageElement && !image.complete) {
                    image.addEventListener("load", this.finalizeImage.bind(this, image, resolve));
                    image.addEventListener("error", reject);
                }
                else {
                    this.finalizeImage(this.image, resolve);
                }
                return;
            }
            logger.debug(`Loading image: ${this.url}`);
            if (this.cancelled === true) {
                logger.debug(`Cancelled loading image: ${this.url}`);
                resolve(undefined);
            }
            else {
                new THREE.ImageLoader().load(this.url, (image) => {
                    if (this.cancelled === true) {
                        logger.debug(`Cancelled loading image: ${this.url}`);
                        resolve(undefined);
                        return;
                    }
                    this.finalizeImage(image, resolve);
                }, undefined, errorEvent => {
                    logger.error(`... loading image failed: ${this.url} : ${errorEvent}`);
                    this.loadingPromise = undefined;
                    reject(`... loading image failed: ${this.url} : ${errorEvent}`);
                });
            }
        });
        return this.loadingPromise;
    }
    finalizeImage(image, resolve) {
        this.image = image;
        this.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(this);
        this.loadingPromise = undefined;
        resolve(this);
    }
}
exports.ImageItem = ImageItem;


/***/ }),

/***/ "../harp-mapview/lib/image/ImageCache.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/image/ImageCache.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageCache = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const Image_1 = __webpack_require__(/*! ./Image */ "../harp-mapview/lib/image/Image.ts");
/**
 * Combines an {@link ImageItem} with a list of owners (which can be any object) that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem - The {@link ImageItem} referenced by the associated owners.
     * @param owner - First owner referencing the {@link ImageItem}.
     */
    constructor(imageItem, owner) {
        this.imageItem = imageItem;
        /**
         * The list of owners referencing the {@link ImageItem}.
         */
        this.owners = [];
        this.owners.push(owner);
    }
}
/**
 * @internal
 *
 * `ImageCache` is a singleton, so it can be used with multiple owners on a single page.
 *
 * @remarks
 * This allows to have an image loaded only once for multiple views.
 * THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding statistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object.
     *
     * @remarks
     * Not normally implemented for singletons, but good for debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param owner - Specify which {@link any} requests the image.
     * @param url - URL of image.
     * @param image - Optional {@link TexturizableImage}.
     */
    registerImage(owner, url, image) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem) {
            if (owner !== undefined && !imageCacheItem.owners.includes(owner)) {
                imageCacheItem.owners.push(owner);
            }
            return imageCacheItem.imageItem;
        }
        imageCacheItem = {
            imageItem: new Image_1.ImageItem(url, image),
            owners: [owner]
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Remove an image from the cache..
     *
     * @param url - URL of the image.
     * @param owner - Owner removing the image.
     * @returns `true` if image has been removed.
     */
    removeImage(url, owner) {
        const cacheItem = this.m_images.get(url);
        if (cacheItem !== undefined) {
            this.unlinkCacheItem(cacheItem, owner);
            return true;
        }
        return false;
    }
    /**
     * Find {@link ImageItem} for the specified URL.
     *
     * @param url - URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const cacheItem = this.m_images.get(url);
        if (cacheItem !== undefined) {
            return cacheItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all {@link ImageItem}s belonging to an owner.
     *
     * @remarks
     * May remove cached items if no owner is registered anymore.
     *
     * @param owner - specify to remove all items registered by {@link any}.
     * @returns Number of images removed.
     */
    clear(owner) {
        this.m_images.forEach(cacheItem => {
            this.unlinkCacheItem(cacheItem, owner);
        });
    }
    /**
     * Returns the number of all cached {@link ImageItem}s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Find the cached {@link ImageItem} by URL.
     *
     * @param url - URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Cancel loading an image.
     *
     * @param imageItem - Item to cancel loading.
     */
    cancelLoading(imageItem) {
        if (imageItem.loading) {
            // Notify that we are cancelling.
            imageItem.cancelled = true;
        }
    }
    /**
     * Remove the cacheItem from cache, unless the item is used by another owner, in that case the
     * link to the owner is removed from the item, just like a reference count.
     *
     * @param cacheItem The cache item to be removed.
     * @param owner - Specify which owner removes the image.
     * If no owner is specified, the cache item is removed even if it has owners.
     */
    unlinkCacheItem(cacheItem, owner) {
        const ownerIndex = cacheItem.owners.indexOf(owner);
        if (ownerIndex >= 0) {
            cacheItem.owners.splice(ownerIndex, 1);
        }
        if (cacheItem.owners.length === 0) {
            this.m_images.delete(cacheItem.imageItem.url);
            this.cancelLoading(cacheItem.imageItem);
        }
    }
}
exports.ImageCache = ImageCache;


/***/ }),

/***/ "../harp-mapview/lib/image/MapViewImageCache.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/image/MapViewImageCache.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewImageCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const ImageCache_1 = __webpack_require__(/*! ./ImageCache */ "../harp-mapview/lib/image/ImageCache.ts");
/**
 * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.
 *
 * @remarks
 * An image may have multiple names in a theme, the `MapViewImageCache` maps different names to the
 * same image URL, and allows to share the image by URL to different MapViews.
 * Within a MapView instance, the (optional) name is unique, so registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    constructor() {
        this.m_name2Url = new Map();
        this.m_urlNameCount = new Map();
    }
    addImage(name, urlOrImage, startLoading = true) {
        if (typeof urlOrImage === "string") {
            const url = urlOrImage;
            const imageItem = this.registerImage(name, url);
            return startLoading ? imageItem.loadImage() : imageItem;
        }
        const image = urlOrImage;
        return this.registerImage(name, undefined, image);
    }
    /**
     * Remove the image with this name from the cache.
     *
     * @param name - Name of the image.
     * @returns `true` if item has been removed.
     */
    removeImage(name) {
        const url = this.m_name2Url.get(name);
        if (url !== undefined) {
            this.m_name2Url.delete(name);
            let nameCount = 1;
            if (name !== url) {
                const result = this.m_urlNameCount.get(url);
                harp_utils_1.assert(result !== undefined);
                nameCount = result;
                harp_utils_1.assert(nameCount > 0);
            }
            if (nameCount > 1) {
                // There is another name sharing this URL.
                this.m_urlNameCount.set(url, nameCount - 1);
            }
            else {
                // URL was used by this image only, remove the image.
                this.m_urlNameCount.delete(url);
                ImageCache_1.ImageCache.instance.removeImage(url, this);
            }
            return true;
        }
        return false;
    }
    /**
     * Find {@link ImageItem} by its name.
     *
     * @param name - Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Remove all {@link ImageItem}s from the cache.
     *
     * @remarks
     * Also removes all {@link ImageItem}s that belong to this
     * {@link MapView} from the global {@link ImageCache}.
     * @returns Number of images removed.
     */
    clear() {
        ImageCache_1.ImageCache.instance.clear(this);
        this.m_name2Url.clear();
        this.m_urlNameCount.clear();
    }
    /**
     * Register an existing image by name. If the name already exists and error is thrown.
     *
     * @param name - Image name.
     * @param url - Optional image URL.
     * @param image - Optional {@link TexturizableImage}.
     */
    registerImage(name, url, image) {
        var _a;
        if (this.hasName(name)) {
            throw new Error("duplicate name in cache");
        }
        if (url === undefined) {
            // If no url given, an image must be provided directly. In this case the name is used
            // as url.
            harp_utils_1.assert(image !== undefined);
            url = name;
        }
        if (url !== name) {
            const nameCount = (_a = this.m_urlNameCount.get(url)) !== null && _a !== void 0 ? _a : 0;
            this.m_urlNameCount.set(url, nameCount + 1);
        }
        this.m_name2Url.set(name, url);
        return ImageCache_1.ImageCache.instance.registerImage(this, url, image);
    }
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
}
exports.MapViewImageCache = MapViewImageCache;


/***/ }),

/***/ "../harp-mapview/lib/image/MipMapGenerator.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/image/MipMapGenerator.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MipMapGenerator = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const isNode = typeof window === "undefined";
/**
 * Mip map generator resizes textures to next bigger power-of-two size by adding padding
 * and creates mip map levels.
 * @internal
 */
class MipMapGenerator {
    constructor() {
        if (!isNode) {
            this.m_paddingCanvas = document.createElement("canvas");
            this.m_paddingContext = this.m_paddingCanvas.getContext("2d");
            this.m_resizeCanvas = document.createElement("canvas");
            this.m_resizeContext = this.m_resizeCanvas.getContext("2d");
        }
    }
    /**
     * Gets size of an image padded to the next bigger power-of-two size
     * @param width - Width of image
     * @param height - Height of image
     */
    static getPaddedSize(width, height) {
        return {
            width: THREE.MathUtils.ceilPowerOfTwo(width),
            height: THREE.MathUtils.ceilPowerOfTwo(height)
        };
    }
    /**
     * Generate downsampled mip map levels from an image.
     * If the input image is not power-of-two the image is padded to the
     * next bigger power-of-two size.
     * @param image - Input image
     * @returns A list of images with mip maps of the input image
     */
    generateTextureAtlasMipMap(image) {
        if (isNode) {
            throw new Error("MipMapGenerator only works in browser.");
        }
        if (image.image === undefined) {
            throw new Error("Can not generate mip maps. Image data not loaded!");
        }
        const imageData = image.image;
        const mipMaps = [];
        // Add initial texture with padding as level 0
        const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(imageData.width, imageData.height);
        this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);
        mipMaps.push(this.m_paddingContext.getImageData(0, 0, paddedWidth, paddedHeight));
        let width = paddedWidth * 0.5;
        let height = paddedHeight * 0.5;
        // HARP-10765 WebGL complains if we don't generate down to a 1x1 texture (this was the case
        // previously when height != width), and thus the final texture generated was 2x1 texture
        // and not 1x1.
        while (width >= 1 || height >= 1) {
            const mipMapLevel = mipMaps.length;
            const previousImage = mipMaps[mipMapLevel - 1];
            // Resize previous mip map level
            mipMaps.push(this.resizeImage(previousImage, Math.max(width, 1), Math.max(height, 1)));
            width *= 0.5;
            height *= 0.5;
        }
        return mipMaps;
    }
    /**
     * Copy image to a canvas and add padding if necessary.
     * @param image - Input image.
     * @param width - Width of output image
     * @param height - Width of output image
     * @returns Canvas with image and padding.
     */
    copyImageWithPadding(image, width, height) {
        this.m_paddingCanvas.width = width;
        this.m_paddingCanvas.height = height;
        this.m_paddingContext.clearRect(0, 0, width, height);
        if (image instanceof ImageData) {
            this.m_paddingContext.putImageData(image, 0, 0);
        }
        else {
            this.m_paddingContext.drawImage(image, 0, 0);
        }
        // Add horizontal padding
        if (image.width !== width) {
            this.m_paddingContext.drawImage(this.m_paddingCanvas, image.width - 1, 0, 1, image.height, image.width, 0, width - image.width, image.height);
        }
        // Add vertical padding
        if (image.height !== height) {
            this.m_paddingContext.drawImage(this.m_paddingCanvas, 0, image.height - 1, width, 1, 0, image.height, width, height - image.height);
        }
        return this.m_paddingCanvas;
    }
    /**
     * Resize an image.
     *
     * Quality of resized image is best when
     * image.width and image.height are even numbers and the image
     * is resized by factor 0.5 or 2.
     * @param image - Input image
     * @param width - Width of output image
     * @param height - Height of output image
     * @return Resized image
     */
    resizeImage(image, width, height) {
        //  Copy image data to canvas because ImageData can't be resized directly
        const paddedImage = this.copyImageWithPadding(image, image.width, image.height);
        // Resize image to resize canvas
        this.m_resizeCanvas.width = width;
        this.m_resizeCanvas.height = height;
        this.m_resizeContext.clearRect(0, 0, width, height);
        this.m_resizeContext.drawImage(paddedImage, 0, 0, width, height);
        return this.m_resizeContext.getImageData(0, 0, width, height);
    }
}
exports.MipMapGenerator = MipMapGenerator;


/***/ }),

/***/ "../harp-mapview/lib/poi/BoxBuffer.ts":
/*!********************************************!*\
  !*** ../harp-mapview/lib/poi/BoxBuffer.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoxBuffer = exports.BoxBufferMesh = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const PixelPicker_1 = __webpack_require__(/*! ./PixelPicker */ "../harp-mapview/lib/poi/PixelPicker.ts");
/**
 * Initial number of boxes in BoxBuffer.
 */
const START_BOX_BUFFER_SIZE = 0;
/**
 * Maximum number of boxes in BoxBuffer.
 */
const MAX_BOX_BUFFER_SIZE = 32 * 1024;
/**
 * Number of vertices per box/glyph element: 4 corners.
 */
const NUM_VERTICES_PER_ELEMENT = 4;
/**
 * Number of indices added per box/glyph: 2 triangles, 6 indices.
 */
const NUM_INDICES_PER_ELEMENT = 6;
/**
 * Number of values per position.
 */
const NUM_POSITION_VALUES_PER_VERTEX = 3;
/**
 * Number of values per color.
 */
const NUM_COLOR_VALUES_PER_VERTEX = 4;
/**
 * Number of values per UV.
 */
const NUM_UV_VALUES_PER_VERTEX = 4;
/**
 * Number of values per index.
 */
const NUM_INDEX_VALUES_PER_VERTEX = 1;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and
 * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.
 */
class BoxBufferMesh extends THREE.Mesh {
    constructor(geometry, material) {
        super(geometry, material);
        this.type = "BoxBufferMesh";
    }
    /**
     * A mesh that has no positions and indices set is defined to be empty.
     *
     * @returns `True` if no indices have been added to the mesh.
     */
    get isEmpty() {
        if (this.geometry === undefined) {
            return true;
        }
        else {
            const bufferGeometry = this.geometry;
            return bufferGeometry.index === null || bufferGeometry.index.count === 0;
        }
    }
}
exports.BoxBufferMesh = BoxBufferMesh;
/**
 * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-
 * aligned boxes, like POIs.
 */
class BoxBuffer {
    /**
     * Creates a new `BoxBuffer`.
     *
     * @param m_material - Material to be used for [[Mesh]] of this `BoxBuffer`.
     * @param m_renderOrder - Optional renderOrder of this buffer.
     * @param startElementCount - Initial number of elements this `BoxBuffer` can hold.
     * @param m_maxElementCount - Maximum number of elements this `BoxBuffer` can hold.
     */
    constructor(m_material, m_renderOrder = 0, startElementCount = START_BOX_BUFFER_SIZE, m_maxElementCount = MAX_BOX_BUFFER_SIZE) {
        this.m_material = m_material;
        this.m_renderOrder = m_renderOrder;
        this.m_maxElementCount = m_maxElementCount;
        this.m_size = 0;
        this.resizeBuffer(startElementCount);
        this.m_pickInfos = new Array();
    }
    /**
     * Duplicate this `BoxBuffer` with same material and renderOrder.
     *
     * @returns A clone of this `BoxBuffer`.
     */
    clone() {
        return new BoxBuffer(this.m_material, this.m_renderOrder);
    }
    /**
     * Dispose of the geometry.
     */
    dispose() {
        if (this.m_geometry !== undefined) {
            this.m_geometry.dispose();
            this.m_geometry = undefined;
        }
        this.m_mesh = undefined;
    }
    /**
     * Return the current number of elements the buffer can hold.
     */
    get size() {
        return this.m_size;
    }
    /**
     * Clear's the `BoxBuffer` attribute buffers.
     */
    reset() {
        if (this.m_positionAttribute !== undefined) {
            this.m_positionAttribute.count = 0;
            this.m_colorAttribute.count = 0;
            this.m_uvAttribute.count = 0;
            this.m_indexAttribute.count = 0;
            this.m_pickInfos.length = 0;
        }
    }
    /**
     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer
     * can only add the glyph by increasing the buffer size, the resize() method is called, which
     * will then create a new geometry for the mesh.
     *
     * @param glyphCount - Number of glyphs to be added to the buffer.
     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.
     */
    canAddElements(glyphCount = 1) {
        const indexAttribute = this.m_indexAttribute;
        if (indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=
            indexAttribute.array.length) {
            // Too many elements for the current buffer, check if we can resize the buffer.
            if (indexAttribute.array.length >= this.m_maxElementCount * NUM_INDICES_PER_ELEMENT) {
                return false;
            }
            const newSize = Math.min(this.m_maxElementCount, this.size === 0 ? 256 : this.size * 2);
            this.resize(newSize);
        }
        return true;
    }
    /**
     * Returns this `BoxBuffer`'s attribute [[State]].
     */
    saveState() {
        const state = {
            positionAttributeCount: this.m_positionAttribute.count,
            colorAttributeCount: this.m_colorAttribute.count,
            uvAttributeCount: this.m_uvAttribute.count,
            indexAttributeCount: this.m_indexAttribute.count,
            pickInfoCount: this.m_pickInfos.length
        };
        return state;
    }
    /**
     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.
     *
     * @param state - [[State]] struct describing a previous attribute state.
     */
    restoreState(state) {
        this.m_positionAttribute.count = state.positionAttributeCount;
        this.m_colorAttribute.count = state.colorAttributeCount;
        this.m_uvAttribute.count = state.uvAttributeCount;
        this.m_indexAttribute.count = state.indexAttributeCount;
        this.m_pickInfos.length = state.pickInfoCount;
    }
    /**
     * Adds a new box to this `BoxBuffer`.
     *
     * @param screenBox - [[Math2D.Box]] holding screen coordinates for this box.
     * @param uvBox - [[Math2D.UvBox]] holding uv coordinates for this box.
     * @param color - Box's color.
     * @param opacity - Box's opacity.
     * @param distance - Box's distance to camera.
     * @param pickInfo - Box's picking information.
     */
    addBox(screenBox, uvBox, color, opacity, distance, pickInfo) {
        if (!this.canAddElements()) {
            return false;
        }
        const { s0, t0, s1, t1 } = uvBox;
        const { x, y, w, h } = screenBox;
        // Premultiply alpha into vertex colors
        const r = Math.round(color.r * opacity * 255);
        const g = Math.round(color.g * opacity * 255);
        const b = Math.round(color.b * opacity * 255);
        const a = Math.round(opacity * 255);
        const positionAttribute = this.m_positionAttribute;
        const colorAttribute = this.m_colorAttribute;
        const uvAttribute = this.m_uvAttribute;
        const indexAttribute = this.m_indexAttribute;
        const baseVertex = positionAttribute.count;
        const baseIndex = indexAttribute.count;
        positionAttribute.setXYZ(baseVertex, x, y, distance);
        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);
        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);
        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);
        colorAttribute.setXYZW(baseVertex, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);
        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);
        uvAttribute.setXY(baseVertex, s0, t0);
        uvAttribute.setXY(baseVertex + 1, s1, t0);
        uvAttribute.setXY(baseVertex + 2, s0, t1);
        uvAttribute.setXY(baseVertex + 3, s1, t1);
        indexAttribute.setX(baseIndex, baseVertex);
        indexAttribute.setX(baseIndex + 1, baseVertex + 1);
        indexAttribute.setX(baseIndex + 2, baseVertex + 2);
        indexAttribute.setX(baseIndex + 3, baseVertex + 2);
        indexAttribute.setX(baseIndex + 4, baseVertex + 1);
        indexAttribute.setX(baseIndex + 5, baseVertex + 3);
        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;
        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;
        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;
        indexAttribute.count += NUM_INDICES_PER_ELEMENT;
        this.m_pickInfos.push(pickInfo);
        return true;
    }
    /**
     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute
     * data.
     */
    updateBufferGeometry() {
        const positionAttribute = this.m_positionAttribute;
        const colorAttribute = this.m_colorAttribute;
        const uvAttribute = this.m_uvAttribute;
        const indexAttribute = this.m_indexAttribute;
        if (positionAttribute.count > 0) {
            positionAttribute.needsUpdate = true;
            positionAttribute.updateRange.offset = 0;
            positionAttribute.updateRange.count =
                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (colorAttribute.count > 0) {
            colorAttribute.needsUpdate = true;
            colorAttribute.updateRange.offset = 0;
            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (uvAttribute.count > 0) {
            uvAttribute.needsUpdate = true;
            uvAttribute.updateRange.offset = 0;
            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;
        }
        if (indexAttribute.count > 0) {
            indexAttribute.needsUpdate = true;
            indexAttribute.updateRange.offset = 0;
            indexAttribute.updateRange.count = indexAttribute.count;
        }
        if (this.m_geometry !== undefined) {
            this.m_geometry.clearGroups();
            this.m_geometry.addGroup(0, this.m_indexAttribute.count);
        }
    }
    /**
     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce
     * footprint.
     */
    cleanUp() {
        // If there is nothing in this buffer, resize it, it may never be used again.
        if (this.m_indexAttribute.count === 0 && this.size > START_BOX_BUFFER_SIZE) {
            this.clearAttributes();
        }
    }
    /**
     * Determine if the mesh is empty.
     */
    get isEmpty() {
        return this.m_mesh.isEmpty;
    }
    /**
     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are
     * resized. The mesh, once created, will not change, so it can always be added to the scene.
     */
    get mesh() {
        if (this.m_mesh === undefined) {
            this.resize();
        }
        return this.m_mesh;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     * @param image - Image to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, image) {
        const n = this.m_pickInfos.length;
        const pickInfos = this.m_pickInfos;
        const positions = this.m_positionAttribute;
        const screenX = screenPosition.x;
        const screenY = screenPosition.y;
        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {
            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;
            const minX = positions.getX(positionIndex);
            if (screenX < minX) {
                continue;
            }
            const maxX = positions.getX(positionIndex + 1);
            if (screenX > maxX) {
                continue;
            }
            const minY = positions.getY(positionIndex);
            if (screenY < minY) {
                continue;
            }
            const maxY = positions.getY(positionIndex + 2);
            if (screenY > maxY) {
                continue;
            }
            const box = new harp_utils_1.Math2D.Box(minX, minY, maxX - minX, maxY - minY);
            if (image !== undefined &&
                pickInfos[pickInfoIndex].poiInfo !== undefined &&
                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&
                this.isPixelTransparent(image, screenX, screenY, box, pickInfos[pickInfoIndex].poiInfo.uvBox, document.createElement("canvas"))) {
                continue;
            }
            if (pickInfos[pickInfoIndex] !== undefined) {
                pickCallback(pickInfos[pickInfoIndex]);
            }
        }
    }
    /**
     * Creates a new {@link @here/harp-datasource-protocol#Geometry} object
     * from all the attribute data stored in this `BoxBuffer`.
     *
     * @remarks
     * The [[Mesh]] object may be created if it is not initialized already.
     *
     * @param newSize - Optional number of elements to resize the buffer to.
     * @param forceResize - Optional flag to force a resize even if new size is smaller than before.
     */
    resize(newSize, forceResize) {
        if (this.m_geometry !== undefined) {
            this.m_geometry.dispose();
        }
        this.m_geometry = new THREE.BufferGeometry();
        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {
            this.resizeBuffer(newSize);
        }
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setIndex(this.m_indexAttribute);
        this.m_geometry.addGroup(0, this.m_indexAttribute.count);
        if (this.m_mesh === undefined) {
            this.m_mesh = new BoxBufferMesh(this.m_geometry, this.m_material);
            this.m_mesh.renderOrder = this.m_renderOrder;
        }
        else {
            this.m_mesh.geometry = this.m_geometry;
        }
        return this.m_mesh;
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.
     *
     * @param info - The info object to increment with the values from this `BoxBuffer`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_positionAttribute.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.m_colorAttribute.count * NUM_COLOR_VALUES_PER_VERTEX +
            this.m_uvAttribute.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +
            this.m_indexAttribute.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    /**
     * Check if a pixel is transparent or not.
     *
     * @param image - Image source.
     * @param xScreenPos - X position of the pixel.
     * @param yScreenPos - Y position of the pixel.
     * @param box - Bounding box of the image in screen coordinates.
     * @param uvBox - Uv box referred to the given bounding box.
     * @param canvas - Canvas element to draw the image if it's not a `ImageData` object.
     */
    isPixelTransparent(image, xScreenPos, yScreenPos, box, uvBox, canvas) {
        const { u, v } = PixelPicker_1.screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);
        const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;
        const x = width * u;
        const y = height * v;
        const pixel = PixelPicker_1.getPixelFromImage(x, y, image, canvas);
        return pixel !== undefined && pixel[3] === 0;
    }
    /**
     * Remove current attributes and arrays. Minimizes memory footprint.
     */
    clearAttributes() {
        this.m_positionAttribute = undefined;
        this.m_colorAttribute = undefined;
        this.m_uvAttribute = undefined;
        this.m_indexAttribute = undefined;
        this.resize(START_BOX_BUFFER_SIZE, true);
    }
    /**
     * Resize the attribute buffers. New value must be larger than the previous one.
     *
     * @param newSize - New number of elements in the buffer. Number has to be larger than the
     *      previous size.
     */
    resizeBuffer(newSize) {
        const newPositionArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX);
        if (this.m_positionAttribute !== undefined && this.m_positionAttribute.array.length > 0) {
            const positionAttributeCount = this.m_positionAttribute.count;
            newPositionArray.set(this.m_positionAttribute.array);
            this.m_positionAttribute.array = newPositionArray;
            this.m_positionAttribute.count = positionAttributeCount;
        }
        else {
            this.m_positionAttribute = new THREE.BufferAttribute(newPositionArray, NUM_POSITION_VALUES_PER_VERTEX);
            this.m_positionAttribute.count = 0;
            this.m_positionAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newColorArray = new Uint8Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX);
        if (this.m_colorAttribute !== undefined) {
            const colorAttributeCount = this.m_colorAttribute.count;
            newColorArray.set(this.m_colorAttribute.array);
            this.m_colorAttribute.array = newColorArray;
            this.m_colorAttribute.count = colorAttributeCount;
        }
        else {
            this.m_colorAttribute = new THREE.BufferAttribute(newColorArray, NUM_COLOR_VALUES_PER_VERTEX, true);
            this.m_colorAttribute.count = 0;
            this.m_colorAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const newUvArray = new Float32Array(newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX);
        if (this.m_uvAttribute !== undefined) {
            const uvAttributeCount = this.m_uvAttribute.count;
            newUvArray.set(this.m_uvAttribute.array);
            this.m_uvAttribute.array = newUvArray;
            this.m_uvAttribute.count = uvAttributeCount;
        }
        else {
            this.m_uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);
            this.m_uvAttribute.count = 0;
            this.m_uvAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;
        const newIndexArray = numIndexValues > 65535
            ? new Uint32Array(numIndexValues)
            : new Uint16Array(numIndexValues);
        if (this.m_indexAttribute !== undefined) {
            const indexAttributeCount = this.m_indexAttribute.count;
            newIndexArray.set(this.m_indexAttribute.array);
            this.m_indexAttribute.array = newIndexArray;
            this.m_indexAttribute.count = indexAttributeCount;
        }
        else {
            this.m_indexAttribute = new THREE.BufferAttribute(newIndexArray, NUM_INDEX_VALUES_PER_VERTEX);
            this.m_indexAttribute.count = 0;
            this.m_indexAttribute.setUsage(THREE.DynamicDrawUsage);
        }
        this.m_size = newSize;
    }
}
exports.BoxBuffer = BoxBuffer;


/***/ }),

/***/ "../harp-mapview/lib/poi/PixelPicker.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PixelPicker.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPixelFromImageData = exports.getPixelFromCanvasImageSource = exports.screenToUvCoordinates = exports.getPixelFromImage = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * It returns an array containing the channel colors for the pixel at the given coordinates.
 *
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param image - The image source.
 * @param canvas - Canvas element that will be used to draw the image, in case the imageData is an
 * ImageBitmap
 */
function getPixelFromImage(xPos, yPos, image, canvas) {
    if (image instanceof ImageData) {
        const stride = image.data.length / (image.height * image.width);
        return getPixelFromImageData(image, xPos, yPos, stride);
    }
    if (!canvas) {
        canvas = document.createElement("canvas");
    }
    return getPixelFromCanvasImageSource(image, xPos, yPos, canvas);
}
exports.getPixelFromImage = getPixelFromImage;
/**
 * Given the x and y position in screen coordinates inside the target box, it map them to the UV
 * coordinates.
 * @param screenX - X value in screen coordinates.
 * @param screenY - Y value in screen coordinates.
 * @param box - Bounding box in screen coordinates.
 * @param uvBox - Uv box referred to the given bounding box.
 */
function screenToUvCoordinates(screenX, screenY, box, uvBox) {
    const minX = box.x;
    const maxX = box.x + box.w;
    const minY = box.y;
    const maxY = box.y + box.h;
    const u = harp_utils_1.MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);
    const v = harp_utils_1.MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);
    return { u, v };
}
exports.screenToUvCoordinates = screenToUvCoordinates;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image - Image source.
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param canvas - HTML Canvas element on which the image is drawn.
 */
function getPixelFromCanvasImageSource(image, xPos, yPos, canvas) {
    const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;
    if (xPos > width || xPos < 0 || yPos > height || yPos < 0) {
        return undefined;
    }
    let pixelData;
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    if (context !== null) {
        context.drawImage(image, 0, 0);
        pixelData = context.getImageData(xPos, yPos, 1, 1).data;
    }
    return pixelData;
}
exports.getPixelFromCanvasImageSource = getPixelFromCanvasImageSource;
/**
 * It returns an Uint8ClampedArray containing the color channel values for the given pixel
 * coordinates. It returns undefined if the given coordinates are out of range.
 *
 * @param image - Image data in which the pixels are stored.
 * @param xPos - X value of the pixel.
 * @param yPos - Y value of the pixel.
 * @param stride - The stride value of the image data.
 */
function getPixelFromImageData(imgData, xPos, yPos, stride) {
    const getPixel = (imageData, index, strd) => {
        const i = index * strd;
        const d = imageData.data;
        const pixel = new Uint8ClampedArray(strd);
        for (let s = 0; s < strd; s++) {
            pixel[0] = d[i + s];
        }
        return pixel;
    };
    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {
        return undefined;
    }
    return getPixel(imgData, yPos * imgData.width + xPos, stride);
}
exports.getPixelFromImageData = getPixelFromImageData;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiBuilder.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiBuilder.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoiBuilder = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiBuilder");
function getImageTexture(technique, env) {
    return technique.imageTexture !== undefined
        ? harp_datasource_protocol_1.composeTechniqueTextureName(harp_datasource_protocol_1.getPropertyValue(technique.imageTexture, env), technique)
        : undefined;
}
/**
 * Constructs {@link PoiInfo} objects from {@link @here/harp-datasource-protocol/Technique} and
 * an icon.
 */
class PoiBuilder {
    /**
     * Constructor
     *
     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate
     * technique properties.
     */
    constructor(m_env) {
        this.m_env = m_env;
    }
    /**
     * Sets a technique that will be used to create PoiInfos on subsequent calls to
     * {@link PoiBuilder.build} until the next call to this method.
     *
     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.
     * @return This builder.
     */
    withTechnique(technique) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.m_imageTextureName = getImageTexture(technique, this.m_env);
        this.m_iconMinZoomLevel = (_b = harp_datasource_protocol_1.getPropertyValue((_a = technique.iconMinZoomLevel) !== null && _a !== void 0 ? _a : technique.minZoomLevel, this.m_env)) !== null && _b !== void 0 ? _b : undefined;
        this.m_iconMaxZoomLevel = (_d = harp_datasource_protocol_1.getPropertyValue((_c = technique.iconMaxZoomLevel) !== null && _c !== void 0 ? _c : technique.maxZoomLevel, this.m_env)) !== null && _d !== void 0 ? _d : undefined;
        this.m_textMinZoomLevel = (_f = harp_datasource_protocol_1.getPropertyValue((_e = technique.textMinZoomLevel) !== null && _e !== void 0 ? _e : technique.minZoomLevel, this.m_env)) !== null && _f !== void 0 ? _f : undefined;
        this.m_textMaxZoomLevel = (_h = harp_datasource_protocol_1.getPropertyValue((_g = technique.textMaxZoomLevel) !== null && _g !== void 0 ? _g : technique.maxZoomLevel, this.m_env)) !== null && _h !== void 0 ? _h : undefined;
        this.m_technique = technique;
        return this;
    }
    /**
     * Sets an icon that will be used to create PoiInfos on subsequent calls to
     * {@link PoiBuilder.build} until the next call to this method.
     *
     * @param imageTextureName - The name of the icon image. If undefined, the image defined by the
     * technique set on the last call to {@link PoiBuilder.withTechnique} wil be used.
     * @param shieldGroupIndex - Index to a shield group if the icon belongs to one.
     * @return This builder.
     */
    withIcon(imageTextureName, shieldGroupIndex) {
        if (imageTextureName !== undefined) {
            this.m_imageTextureName = imageTextureName;
        }
        this.m_shieldGroupIndex = shieldGroupIndex;
        return this;
    }
    /**
     * Creates a {@link PoiInfo} for the given {@link TextElement}.
     *
     * @param textElement - The text element the poi info will be attached to.
     * @return The created PoiInfo or undefined if no icon image was set for it.
     */
    build(textElement) {
        var _a, _b, _c, _d, _e;
        harp_utils_1.assert(this.m_technique !== undefined);
        const technique = this.m_technique;
        const env = this.m_env;
        const imageTextureName = this.m_imageTextureName;
        // The POI name to be used is taken from the data, since it will
        // specify the name of the texture to use.
        // The POI name in the technique may override the POI name from the
        // data.
        const poiName = technique.poiTable !== undefined ? (_a = technique.poiName) !== null && _a !== void 0 ? _a : imageTextureName : undefined;
        if (imageTextureName !== undefined && poiName !== undefined) {
            logger.warn("Possible duplicate POI icon definition via imageTextureName and poiTable!");
        }
        if (imageTextureName === undefined && poiName === undefined) {
            textElement.minZoomLevel = (_b = textElement.minZoomLevel) !== null && _b !== void 0 ? _b : this.m_textMinZoomLevel;
            textElement.maxZoomLevel = (_c = textElement.maxZoomLevel) !== null && _c !== void 0 ? _c : this.m_textMaxZoomLevel;
            return undefined;
        }
        const textIsOptional = technique.textIsOptional === true;
        const iconIsOptional = technique.iconIsOptional === true;
        const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);
        const iconMayOverlap = (_d = technique.iconMayOverlap) !== null && _d !== void 0 ? _d : technique.textMayOverlap;
        const iconReserveSpace = (_e = technique.iconReserveSpace) !== null && _e !== void 0 ? _e : technique.textReserveSpace;
        const iconColorRaw = harp_datasource_protocol_1.getPropertyValue(technique.iconColor, env);
        const iconColor = iconColorRaw !== null ? ColorCache_1.ColorCache.instance.getColor(iconColorRaw) : undefined;
        const poiInfo = {
            technique,
            imageTextureName,
            poiTableName: technique.poiTable,
            poiName,
            shieldGroupIndex: this.m_shieldGroupIndex,
            textElement,
            textIsOptional,
            iconIsOptional,
            renderTextDuringMovements,
            mayOverlap: iconMayOverlap,
            reserveSpace: iconReserveSpace,
            iconBrightness: technique.iconBrightness,
            iconColor,
            iconMinZoomLevel: this.m_iconMinZoomLevel,
            iconMaxZoomLevel: this.m_iconMaxZoomLevel,
            textMinZoomLevel: this.m_textMinZoomLevel,
            textMaxZoomLevel: this.m_textMaxZoomLevel
        };
        return poiInfo;
    }
}
exports.PoiBuilder = PoiBuilder;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiManager.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoiManager = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TextElementBuilder_1 = __webpack_require__(/*! ../text/TextElementBuilder */ "../harp-mapview/lib/text/TextElementBuilder.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiManager");
function getImageTexture(poiGeometry, index = 0) {
    if (poiGeometry.imageTextures) {
        const textureNameIndex = poiGeometry.imageTextures[index];
        if (textureNameIndex >= 0) {
            harp_utils_1.assert(poiGeometry.imageTextures.length > index);
            return poiGeometry.stringCatalog[textureNameIndex];
        }
    }
    return undefined;
}
function getAttributes(poiGeometry, index = 0) {
    return poiGeometry.objInfos ? poiGeometry.objInfos[index] : undefined;
}
function getPosition(positionAttribute, worldOffsetX, index = 0) {
    const position = new THREE.Vector3().fromBufferAttribute(positionAttribute, index);
    position.x += worldOffsetX;
    return position;
}
function getText(poiGeometry, index = 0) {
    var _a;
    harp_utils_1.assert(poiGeometry.texts.length > index);
    const stringIndex = poiGeometry.texts[index];
    harp_utils_1.assert(poiGeometry.stringCatalog.length > stringIndex);
    return (_a = poiGeometry.stringCatalog[stringIndex]) !== null && _a !== void 0 ? _a : "";
}
/**
 * POI manager class, responsible for loading the
 * {@link @here/harp-datasource-protocol#PoiGeometry} objects
 * from the {@link @here/harp-datasource-protocol#DecodedTile},
 * and preparing them for rendering.
 *
 * @remarks
 * Also loads and manages the texture atlases for the icons.
 */
class PoiManager {
    /**
     * The constructor of the `PoiManager`.
     *
     * @param mapView - The {@link MapView} instance that should display the POIs.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_imageTextures = new Map();
        this.m_poiShieldGroups = new Map();
    }
    /**
     * Warn about a missing POI table name, but only once.
     * @param poiTableName - POI mapping table name.
     * @param poiTable - POI table instance.
     */
    static notifyMissingPoiTable(poiTableName, poiTable) {
        if (poiTableName === undefined) {
            poiTableName = "undefined";
        }
        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {
            PoiManager.m_missingPoiTableName.set(poiTableName, true);
            if (poiTable !== undefined && !poiTable.loadedOk) {
                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);
            }
            else {
                logger.error(`updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`);
            }
        }
    }
    /**
     * Warn about a missing POI name, but only once.
     * @param poiName - name of POI.
     * @param poiTableName - POI mapping table name.
     */
    static notifyMissingPoi(poiName, poiTableName) {
        if (poiName === undefined) {
            poiName = "undefined";
        }
        const key = `${poiTableName}[${poiName}]`;
        if (PoiManager.m_missingPoiName.get(key) === undefined) {
            PoiManager.m_missingPoiName.set(key, true);
            logger.warn(`updatePoiFromPoiTable: ` +
                `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`);
        }
    }
    /**
     * Add all POIs from a decoded tile and store them as {@link TextElement}s in the {@link Tile}.
     *
     * Also handles LineMarkers, which is a recurring marker along a line (road).
     *
     * @param tile - Tile to add POIs to.
     * @param decodedTile - DecodedTile containing the raw
     *                      {@link @here/harp-datasource-protocol#PoiGeometry}
     *                      objects describing the POIs.
     */
    addPois(tile, decodedTile) {
        const poiGeometries = harp_utils_1.assertExists(decodedTile.poiGeometries);
        const worldOffsetX = tile.computeWorldOffsetX();
        const mapView = tile.mapView;
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const intZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const poiBuilder = new TextElementBuilder_1.TextElementBuilder(intZoomEnv, tile.textStyleCache, tile.dataSource.dataSourceOrder);
        for (const poiGeometry of poiGeometries) {
            harp_utils_1.assert(poiGeometry.technique !== undefined);
            const techniqueIndex = harp_utils_1.assertExists(poiGeometry.technique);
            const technique = decodedTile.techniques[techniqueIndex];
            if (technique._kindState === false ||
                (!harp_datasource_protocol_1.isLineMarkerTechnique(technique) && !harp_datasource_protocol_1.isPoiTechnique(technique))) {
                continue;
            }
            if (technique.showOnMap === false) {
                continue;
            }
            const positions = new THREE.BufferAttribute(new Float64Array(poiGeometry.positions.buffer), poiGeometry.positions.itemCount);
            poiBuilder.withTechnique(technique);
            if (harp_datasource_protocol_1.isLineMarkerTechnique(technique) && positions.count > 0) {
                this.addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
            }
            else if (harp_datasource_protocol_1.isPoiTechnique(technique)) {
                this.addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX);
            }
        }
    }
    /**
     * Load the texture atlas that defines the segments of the texture that should be used for
     * specific icons.
     *
     * @remarks
     * Creates an {@link @here/harp-datasource-protocol#ImageTexture}
     * for every element in the atlas, such that it can
     * be addressed in the theme file.
     *
     * @param imageName - Name of the image from the theme (NOT the url!).
     * @param atlas - URL of the JSON file defining the texture atlas.
     * @param abortSignal - Signal to Abort the loading of the Atlas Image
     */
    async addTextureAtlas(imageName, atlas, abortSignal) {
        const response = await fetch(atlas, { signal: abortSignal });
        if (!response.ok) {
            throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);
        }
        try {
            const jsonAtlas = await response.json();
            if (jsonAtlas === undefined) {
                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);
                return;
            }
            logger.debug(`addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`);
            for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {
                const imageTextureDef = jsonAtlas[textureName];
                const imageTexture = {
                    name: textureName,
                    image: imageName,
                    xOffset: imageTextureDef.x,
                    yOffset: imageTextureDef.y,
                    width: imageTextureDef.width,
                    height: imageTextureDef.height
                };
                this.addImageTexture(imageTexture);
            }
            this.mapView.update();
        }
        catch (error) {
            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${error}`);
        }
    }
    /**
     * Add an {@link @here/harp-datasource-protocol#ImageTexture} such that it
     * is available as a named entity for techniques in theme files.
     *
     * @param imageTexture - {@link @here/harp-datasource-protocol#ImageTexture}
     *                       that should be available for POIs.
     */
    addImageTexture(imageTexture) {
        if (imageTexture.name === undefined) {
            logger.error("addImageTexture: Name required", imageTexture);
            return;
        }
        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {
            logger.warn(`addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`);
        }
        this.m_imageTextures.set(imageTexture.name, imageTexture);
    }
    /**
     * Return the {@link @here/harp-datasource-protocol#ImageTexture}
     * registered under the specified name.
     *
     * @param name - Name of the {@link @here/harp-datasource-protocol#ImageTexture}.
     */
    getImageTexture(name) {
        return this.m_imageTextures.get(name);
    }
    /**
     * Update the {@link TextElement} with the information taken from the {@link PoiTable} which is
     * referenced in the {@link PoiInfo} of the pointLabel.
     *
     * If the requested {@link PoiTable} is not available yet, the function returns `false`.
     * If the {@link PoiTable} is not defined, or if the references POI has no entry in
     * the {@link PoiTable}, no action is taken, and the function returns `false`.
     *
     * If the {@link PoiTable} has been processed, it returns `true`, indicating that this function
     * doesn't have to be called again.
     *
     * @param pointLabel - The {@link TextElement} to update.
     *
     * @returns `true` if the {@link PoiTable} has been processed, and the
     *          function does not have to be called again.
     */
    updatePoiFromPoiTable(pointLabel) {
        var _a, _b, _c, _d, _e, _f;
        const poiInfo = pointLabel.poiInfo;
        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is
        // not possible, such as table key is not defined.
        if (!poiInfo || poiInfo.poiTableName === undefined || poiInfo.poiName === undefined) {
            return true;
        }
        // Try to acquire PoiTable
        const poiTableName = poiInfo.poiTableName;
        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);
        // Check if PoiTable is found, but its still loading.
        if (poiTable && poiTable.isLoading) {
            // The PoiTable is still loading, we have to try again.
            return false;
        }
        // Remove poiTableName to mark this POI as processed.
        poiInfo.poiTableName = undefined;
        // PoiTable not found or can not be loaded.
        if (!poiTable || !poiTable.loadedOk) {
            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);
            return true;
        }
        // Try to acquire PoiTableEntry.
        const poiName = poiInfo.poiName;
        const poiTableEntry = poiTable.getEntry(poiName);
        if (!poiTableEntry) {
            PoiManager.notifyMissingPoi(poiName, poiTableName);
            return true;
        }
        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {
            poiInfo.imageTextureName = harp_datasource_protocol_1.composeTechniqueTextureName(poiTableEntry.iconName, poiInfo.technique);
        }
        pointLabel.visible = (_a = poiTableEntry.visible) !== null && _a !== void 0 ? _a : pointLabel.visible;
        pointLabel.priority = (_b = poiTableEntry.priority) !== null && _b !== void 0 ? _b : pointLabel.priority;
        poiInfo.iconMinZoomLevel = (_c = poiTableEntry.iconMinLevel) !== null && _c !== void 0 ? _c : poiInfo.iconMinZoomLevel;
        poiInfo.iconMaxZoomLevel = (_d = poiTableEntry.iconMaxLevel) !== null && _d !== void 0 ? _d : poiInfo.iconMaxZoomLevel;
        poiInfo.textMinZoomLevel = (_e = poiTableEntry.textMinLevel) !== null && _e !== void 0 ? _e : poiInfo.textMinZoomLevel;
        poiInfo.textMaxZoomLevel = (_f = poiTableEntry.textMaxLevel) !== null && _f !== void 0 ? _f : poiInfo.textMaxZoomLevel;
        TextElementBuilder_1.TextElementBuilder.alignZoomLevelRanges(pointLabel);
        return true;
    }
    /**
     * Clear internal state. Applicable when switching themes.
     */
    clear() {
        this.m_imageTextures.clear();
        this.m_poiShieldGroups.clear();
    }
    /**
     * Add the LineMarker as a POI with multiple positions sharing the same `shieldGroupIndex`.
     */
    addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
        const text = getText(poiGeometry);
        const imageTextureName = getImageTexture(poiGeometry);
        // let the combined image texture name (name of image in atlas, not the URL) and
        // text of the shield be the group key, at worst scenario it may be: "undefined-"
        const groupKey = imageTextureName + "-" + text;
        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);
        if (shieldGroupIndex === undefined) {
            shieldGroupIndex = this.m_poiShieldGroups.size;
            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);
        }
        const positionArray = [];
        for (let i = 0; i < positions.count; i += 3) {
            positionArray.push(getPosition(positions, worldOffsetX, i));
        }
        const textElement = poiBuilder
            .withIcon(imageTextureName, shieldGroupIndex)
            .build(text, positionArray, tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry));
        tile.addTextElement(textElement);
    }
    /**
     * Create and add POI {@link TextElement}s to tile with a series of positions.
     */
    addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX) {
        var _a, _b;
        for (let i = 0; i < positions.count; ++i) {
            const offsetDirection = (_b = (_a = poiGeometry.offsetDirections) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : 0;
            const textElement = poiBuilder
                .withIcon(getImageTexture(poiGeometry, i))
                .build(getText(poiGeometry, i), getPosition(positions, worldOffsetX, i), tile.offset, tile.dataSource.name, tile.dataSource.dataSourceOrder, getAttributes(poiGeometry, i), undefined, offsetDirection);
            tile.addTextElement(textElement);
        }
    }
}
exports.PoiManager = PoiManager;
// Keep track of the missing POI table names, but only warn once.
PoiManager.m_missingPoiTableName = new Map();
PoiManager.m_missingPoiName = new Map();


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiRenderer.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/poi/PoiRenderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoiRenderer = exports.PoiBatchRegistry = exports.PoiBuffer = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MipMapGenerator_1 = __webpack_require__(/*! ../image/MipMapGenerator */ "../harp-mapview/lib/image/MipMapGenerator.ts");
const BoxBuffer_1 = __webpack_require__(/*! ./BoxBuffer */ "../harp-mapview/lib/poi/BoxBuffer.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
/**
 * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was
 * specified.
 */
const neutralColor = new THREE.Color(1, 1, 1);
/**
 * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.
 */
const tmpIconColor = new THREE.Color();
/**
 * @internal
 * Buffer for POIs sharing same material and render order, renderable in a single draw call
 * (WebGL limits apply, see {@link BoxBuffer}).
 */
class PoiBuffer {
    /**
     * Creates a `PoiBuffer`
     * @param buffer -
     * @param layer - The {@link TextCanvas} layer used to render the POIs.
     */
    constructor(buffer, layer, m_onDispose) {
        this.buffer = buffer;
        this.layer = layer;
        this.m_onDispose = m_onDispose;
        this.m_refCount = 0;
    }
    /**
     * Increases this `PoiBuffer`'s reference count.
     * @returns this `PoiBuffer`.
     */
    increaseRefCount() {
        ++this.m_refCount;
        return this;
    }
    /**
     * Decreases this `PoiBuffer`'s reference count. All resources will be disposed when the
     * reference count reaches 0.
     * @returns this `PoiBuffer`.
     */
    decreaseRefCount() {
        harp_utils_1.assert(this.m_refCount > 0);
        if (--this.m_refCount === 0) {
            this.dispose();
        }
        return this;
    }
    dispose() {
        this.layer.scene.remove(this.buffer.mesh);
        this.buffer.dispose();
        this.m_onDispose();
    }
}
exports.PoiBuffer = PoiBuffer;
/**
 * @internal
 *
 * The `PoiBatch` contains the geometry and the material for all POIs that share the same icon image
 * ({@link @here/harp-datasource-protocol#ImageTexture}).
 *
 * There is a `PoiBatch` for every icon in a texture atlas, since the size of the icon in the atlas
 * as well as the texture coordinates are specified in the `PoiBatch`.
 */
class PoiBatch {
    /**
     * Create the `PoiBatch`.
     *
     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} used for material
     * creation.
     * @param imageItem - The icon that will have his material shared.
     * @param m_onDispose - Callback executed when the `PoiBatch` is disposed.
     */
    constructor(m_rendererCapabilities, imageItem, m_onDispose) {
        this.m_rendererCapabilities = m_rendererCapabilities;
        this.imageItem = imageItem;
        this.m_onDispose = m_onDispose;
        // Texture images should be generated with premultiplied alpha
        const premultipliedAlpha = true;
        const texture = new THREE.Texture(this.imageItem.image, THREE.UVMapping, undefined, undefined, PoiBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter, PoiBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter, THREE.RGBAFormat);
        if (PoiBatch.trilinear && this.imageItem.mipMaps) {
            // Generate mipmaps for distance scaling of icon
            texture.mipmaps = this.imageItem.mipMaps;
            texture.image = texture.mipmaps[0];
        }
        texture.flipY = false;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.needsUpdate = true;
        this.m_material = new harp_materials_1.IconMaterial({
            rendererCapabilities: this.m_rendererCapabilities,
            map: texture
        });
        this.m_poiBuffers = new Map();
    }
    /**
     * Gets the {@link PoiBuffer} for a given layer, creating it if necessary.
     * @param layer - The {@link PoiLayer} to be used.
     * @returns The {@link PoiBuffer}.
     */
    getBuffer(layer) {
        let poiBuffer = this.m_poiBuffers.get(layer.id);
        if (poiBuffer) {
            return poiBuffer.increaseRefCount();
        }
        const boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, layer.id);
        const mesh = boxBuffer.mesh;
        mesh.frustumCulled = false;
        layer.scene.add(mesh);
        poiBuffer = new PoiBuffer(boxBuffer, layer, () => {
            this.disposeBuffer(layer.id);
        });
        this.m_poiBuffers.set(layer.id, poiBuffer);
        return poiBuffer.increaseRefCount();
    }
    /**
     * Clean the `PoiBatch`, remove all icon boxes. Called before starting a new frame.
     */
    reset() {
        for (const poiBuffer of this.m_poiBuffers.values()) {
            poiBuffer.buffer.reset();
        }
    }
    /**
     * Update the geometry with all the added boxes during the frame.
     */
    update() {
        for (const poiBuffer of this.m_poiBuffers.values()) {
            poiBuffer.buffer.updateBufferGeometry();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * boxes are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     * @param image - Image to test if the pixel is transparent
     */
    pickBoxes(screenPosition, pickCallback, image) {
        for (const poiBuffer of this.m_poiBuffers.values()) {
            poiBuffer.buffer.pickBoxes(screenPosition, pickCallback, image);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiBatch`.
     *
     * @param info - The info object to increment with the values from this `PoiBatch`.
     */
    updateMemoryUsage(info) {
        if (this.imageItem.image !== undefined) {
            const imageBytes = this.imageItem.image.width * this.imageItem.image.height * 4;
            info.heapSize += imageBytes;
            info.gpuSize += imageBytes;
        }
        for (const poiBuffer of this.m_poiBuffers.values()) {
            poiBuffer.buffer.updateMemoryUsage(info);
        }
    }
    dispose() {
        this.m_poiBuffers.clear();
        this.m_material.map.dispose();
        this.m_material.dispose();
        this.m_onDispose();
    }
    disposeBuffer(renderOrder) {
        harp_utils_1.assert(this.m_poiBuffers.size > 0);
        this.m_poiBuffers.delete(renderOrder);
        if (this.m_poiBuffers.size === 0) {
            this.dispose();
        }
    }
}
// Enable trilinear filtering to reduce flickering due to distance scaling
PoiBatch.trilinear = true;
/**
 * @internal
 * Contains all [[PoiBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiBatchRegistry {
    /**
     * Create the `PoiBatchRegistry`.
     *
     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} to be used.
     */
    constructor(m_rendererCapabilities) {
        this.m_rendererCapabilities = m_rendererCapabilities;
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiBatch]] for the POI at first usage.
     *
     * @param poiInfo - Describes the POI icon.
     * @param layer - The {@link PoiLayer} to render to.
     */
    registerPoi(poiInfo, layer) {
        var _a;
        const { imageItem, imageTexture } = poiInfo;
        if (!imageItem) {
            // No image found, therefore just return undefined. It will probably come in soon?
            return undefined;
        }
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it. If the imageTexture is not set, imageTextureName has the actual
        // image name.
        harp_utils_1.assert(poiInfo.imageTextureName !== undefined);
        const batchKey = (_a = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && _a !== void 0 ? _a : poiInfo.imageTextureName;
        let batch = this.m_batchMap.get(batchKey);
        if (batch === undefined) {
            batch = new PoiBatch(this.m_rendererCapabilities, imageItem, () => {
                this.deleteBatch(batchKey);
            });
            this.m_batchMap.set(batchKey, batch);
        }
        return batch.getBuffer(layer);
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenBox - Box to render icon into in 2D coordinates.
     * @param viewDistance - Box's distance to camera.
     * @param opacity - Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, viewDistance, opacity) {
        if (poiInfo.isValid === false || !poiInfo.buffer) {
            logger.warn("PoiBatchRegistry: trying to add poiInfo without buffer prepared: ", poiInfo.poiName);
            return;
        }
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        let color;
        if (poiInfo.iconBrightness !== undefined) {
            color = tmpIconColor.setScalar(poiInfo.iconBrightness);
            if (poiInfo.iconColor !== undefined) {
                color = tmpIconColor.multiply(poiInfo.iconColor);
            }
        }
        else if (poiInfo.iconColor !== undefined) {
            color = poiInfo.iconColor;
        }
        else {
            color = neutralColor;
        }
        poiInfo.buffer.buffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);
    }
    /**
     * Reset all batches, removing all content from the [[PoiBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.m_batchMap.values()) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.m_batchMap.values()) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link PoiInfo}s are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.m_batchMap.values()) {
            batch.pickBoxes(screenPosition, pickCallback, batch.imageItem.image);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiBatchRegistry`.
     *
     * @param info - The info object to increment with the values from this `PoiBatchRegistry`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.m_batchMap.values()) {
            batch.updateMemoryUsage(info);
        }
    }
    deleteBatch(batchKey) {
        this.m_batchMap.delete(batchKey);
    }
}
exports.PoiBatchRegistry = PoiBatchRegistry;
// keep track of the missing textures, we throw an error if the number of attempts goes over some
// threshold.
const missingTextureName = new Map();
const SEARCH_CACHE_ATTEMPTS = 5;
function findImageItem(poiInfo, imageCaches, imageTexture) {
    var _a;
    harp_utils_1.assert(poiInfo.imageTextureName !== undefined);
    const imageTextureName = imageTexture ? imageTexture.image : poiInfo.imageTextureName;
    for (const imageCache of imageCaches) {
        const imageItem = imageCache.findImageByName(imageTextureName);
        if (imageItem) {
            missingTextureName.delete(imageTextureName);
            return imageItem;
        }
    }
    // There is a texture missing in the cache, we attempt again, and then error out.
    const missingTextureCount = missingTextureName.get(imageTextureName);
    missingTextureName.set(imageTextureName, missingTextureCount ? missingTextureCount + 1 : 0);
    if (missingTextureName.get(imageTextureName) === SEARCH_CACHE_ATTEMPTS) {
        logger.error(`PoiRenderer::findImageItem: No imageItem found with name:
            '${(_a = imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.image) !== null && _a !== void 0 ? _a : imageTextureName}'
            after ${SEARCH_CACHE_ATTEMPTS} attempts.`);
    }
    return undefined;
}
/**
 * @internal
 * Manage POI rendering. Uses a [[PoiBatchRegistry]] to actually create the geometry that is being
 * rendered.
 */
class PoiRenderer {
    /**
     * Create the `PoiRenderer` for the specified {@link MapView}.
     *
     * @param m_renderer - The {@link THREE.WebGLRenderer} to be rendered to.
     * @param m_poiManager - The {@link PoiManager} to be used.
     * @param m_imageCaches - The {@link ImageCache}s to look for loaded images.
     */
    constructor(m_renderer, m_poiManager, m_imageCaches) {
        this.m_renderer = m_renderer;
        this.m_poiManager = m_poiManager;
        this.m_imageCaches = m_imageCaches;
        // temporary variable to save allocations
        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
        this.m_layers = [];
        this.m_poiBatchRegistry = new PoiBatchRegistry(this.renderer.capabilities);
    }
    /**
     * Compute screen box for icon. It is required that `prepareRender` has been successfully called
     * before `computeScreenBox` may be called.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenPosition - Position on screen (2D).
     * @param scale - Scale to apply to icon.
     * @param env - Current zoom level.
     * @param screenBox - Box that will be used to store the result.
     * @returns The computed screen box for the icon.
     */
    static computeIconScreenBox(poiInfo, screenPosition, scale, env, 
    /* out */ screenBox = new harp_utils_1.Math2D.Box()) {
        harp_utils_1.assert(poiInfo.buffer !== undefined);
        const width = poiInfo.computedWidth * scale;
        const height = poiInfo.computedHeight * scale;
        const technique = poiInfo.technique;
        const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
        const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
        const centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0) * scale;
        const centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0) * scale;
        screenBox.x = centerX - width / 2;
        screenBox.y = centerY - height / 2;
        screenBox.w = width;
        screenBox.h = height;
        return screenBox;
    }
    get renderer() {
        return this.m_renderer;
    }
    /**
     * Prepare the POI for rendering, and determine which {@link PoiBuffer} should be used. If a
     * {@link PoiBuffer} is assigned, the POI is ready to be rendered.
     *
     * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.
     * @param env - TODO! The current zoomLevel level of {@link MapView}
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    prepareRender(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined) {
            return false;
        }
        if (poiInfo.buffer === undefined) {
            this.preparePoi(pointLabel, env);
        }
        return poiInfo.buffer !== undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiBatchRegistry]]. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        this.m_poiBatchRegistry.reset();
    }
    /**
     * Add the icon. Icon will only be added if opacity > 0, otherwise only its space will be
     * allocated.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenPosition - Position on screen (2D):
     * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.
     * @param viewDistance - Box's distance to camera.
     * @param scale - Scaling factor to apply to text and icon.
     * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.
     * @param opacity - Opacity of icon to allow fade in/out.
     * @returns - `true` if icon has been actually rendered, `false` otherwise.
     */
    addPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
        harp_utils_1.assert(poiInfo.buffer !== undefined);
        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
        if (allocateScreenSpace) {
            screenCollisions.allocate(this.m_tempScreenBox);
        }
        if (opacity > 0) {
            if (!poiInfo.buffer) {
                this.preparePoi(poiInfo.textElement, env);
            }
            this.m_poiBatchRegistry.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
        }
    }
    /**
     * Update the geometry of all [[PoiBatch]]es. Called before rendering.
     */
    update() {
        this.m_poiBatchRegistry.update();
    }
    /**
     * @internal
     *
     * Adds a layer to the PoiRenderer
     * @param layerId
     */
    addLayer(layerId) {
        let result = this.getLayer(layerId);
        if (result === undefined) {
            result = {
                id: layerId,
                scene: new THREE.Scene()
            };
            this.m_layers.push(result);
            this.m_layers.sort((a, b) => {
                return a.id - b.id;
            });
        }
        return result;
    }
    /**
     * Retrieves a specific `Poi` rendering layer.
     *
     * @param layerId - Desired layer identifier.
     *
     * @returns Selected {@link PoiLayer}
     */
    getLayer(layerId) {
        return this.m_layers.find(layer => layer.id === layerId);
    }
    /**
     * @internal
     *
     * Returns all {@link PoiLayer}s of this {@link PoiRenderer}
     */
    get layers() {
        return this.m_layers;
    }
    /**
     * Renders the content of this `PoiRenderer`.
     *
     * @param camera - Orthographic camera.
     * @param layer - The Layer to be rendered.
     */
    render(camera, layer) {
        this.m_renderer.render(layer.scene, camera);
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link PoiInfo}s are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        this.m_poiBatchRegistry.pickTextElements(screenPosition, pickCallback);
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
     *
     * @param info - The info object to increment with the values from this `PoiRenderer`.
     */
    getMemoryUsage(info) {
        this.m_poiBatchRegistry.updateMemoryUsage(info);
    }
    /**
     * Register the POI at the [[PoiBatchRegistry]] which may require some setup, for example
     * loading of the actual image.
     */
    preparePoi(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (!poiInfo || !pointLabel.visible) {
            return;
        }
        if (poiInfo.buffer !== undefined || poiInfo.isValid === false) {
            // Already set up, nothing to be done here.
            return;
        }
        if (poiInfo.poiTableName !== undefined) {
            if (this.m_poiManager.updatePoiFromPoiTable(pointLabel)) {
                if (!pointLabel.visible) {
                    // PoiTable set this POI to not visible.
                    return;
                }
            }
            else {
                // PoiTable has not been loaded, but is required to determine visibility.
                return;
            }
        }
        const imageTextureName = poiInfo.imageTextureName;
        if (imageTextureName === undefined) {
            poiInfo.isValid = false;
            return;
        }
        const imageTexture = this.m_poiManager.getImageTexture(imageTextureName);
        const imageItem = findImageItem(poiInfo, this.m_imageCaches, imageTexture);
        if (!imageItem) {
            poiInfo.imageItem = null;
            return;
        }
        if (imageItem.loaded) {
            this.setupPoiInfo(poiInfo, imageItem, env, imageTexture);
            return;
        }
        if (imageItem.loading) {
            // already being loaded, will be rendered once available
            return;
        }
        imageItem
            .loadImage()
            .then(loadedImageItem => {
            // Skip setup if image was not loaded (cancelled).
            if (loadedImageItem === null || loadedImageItem === void 0 ? void 0 : loadedImageItem.image) {
                this.setupPoiInfo(poiInfo, loadedImageItem, env, imageTexture);
            }
        })
            .catch(error => {
            logger.error(`preparePoi: Failed to load imageItem: '${imageItem.url}`, error);
            poiInfo.isValid = false;
        });
    }
    /**
     * Setup texture and material for the batch.
     *
     * @param poiInfo - {@link PoiInfo} to initialize.
     * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},
     *                       defines used area in atlas.
     * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.
     * @param env - The current zoom level of {@link MapView}
     */
    setupPoiInfo(poiInfo, imageItem, env, imageTexture) {
        harp_utils_1.assert(poiInfo.uvBox === undefined);
        if (!imageItem.image) {
            logger.error("setupPoiInfo: No imageItem/imageData found");
            poiInfo.isValid = false;
            return;
        }
        const technique = poiInfo.technique;
        const imageWidth = imageItem.image.width;
        const imageHeight = imageItem.image.height;
        const paddedSize = MipMapGenerator_1.MipMapGenerator.getPaddedSize(imageWidth, imageHeight);
        const trilinearFiltering = PoiBatch.trilinear && imageItem.mipMaps;
        const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;
        const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;
        const iconWidth = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== undefined ? imageTexture.width : imageWidth;
        const iconHeight = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== undefined ? imageTexture.height : imageHeight;
        const width = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.width) !== undefined ? imageTexture.width : imageWidth;
        const height = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.height) !== undefined ? imageTexture.height : imageHeight;
        const xOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.xOffset) !== undefined ? imageTexture.xOffset : 0;
        const yOffset = (imageTexture === null || imageTexture === void 0 ? void 0 : imageTexture.yOffset) !== undefined ? imageTexture.yOffset : 0;
        const minS = xOffset / paddedImageWidth;
        const maxS = (xOffset + width) / paddedImageWidth;
        const minT = yOffset / paddedImageHeight;
        const maxT = (yOffset + height) / paddedImageHeight;
        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
        const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, env);
        if (screenWidth !== undefined && screenWidth !== null) {
            iconScaleV = iconScaleH = screenWidth / iconWidth;
        }
        const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, env);
        if (screenHeight !== undefined && screenHeight !== null) {
            iconScaleV = screenHeight / iconHeight;
            if (screenWidth !== undefined) {
                iconScaleH = iconScaleV;
            }
        }
        // compute stored values in imageTexture
        poiInfo.computedWidth = iconWidth * iconScaleH;
        poiInfo.computedHeight = iconHeight * iconScaleV;
        poiInfo.uvBox = {
            s0: minS,
            t0: maxT,
            s1: maxS,
            t1: minT
        };
        poiInfo.imageItem = imageItem;
        poiInfo.imageTexture = imageTexture;
        poiInfo.buffer = this.m_poiBatchRegistry.registerPoi(poiInfo, this.addLayer(poiInfo.renderOrder));
        poiInfo.isValid = true;
    }
}
exports.PoiRenderer = PoiRenderer;


/***/ }),

/***/ "../harp-mapview/lib/poi/PoiTableManager.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/poi/PoiTableManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoiTableManager = exports.PoiTable = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("PoiTable");
/**
 * Class to store and maintain individual POI information for the {@link PoiTable}.
 */
class PoiTableEntry {
    /**
     * Verify that the JSON description of the POI table entry is valid.
     *
     * @param jsonEntry - JSON description of the POI table entry.
     *
     * @returns `true` if the `jsonEntry` is valid.
     */
    static verifyJSON(jsonEntry) {
        let isOK = typeof jsonEntry.name === "string" &&
            jsonEntry.name.length > 0 &&
            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&
            (jsonEntry.stackMode === undefined ||
                jsonEntry.stackMode === "yes" ||
                jsonEntry.stackMode === "no" ||
                jsonEntry.stackMode === "parent") &&
            (jsonEntry.visible === undefined || typeof jsonEntry.visible === "boolean") &&
            (jsonEntry.priority === undefined || typeof jsonEntry.priority === "number") &&
            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === "number") &&
            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === "number") &&
            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === "number") &&
            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === "number");
        if (isOK && jsonEntry.altNames !== undefined) {
            const altNames = jsonEntry.altNames;
            // eslint-disable-next-line @typescript-eslint/no-for-in-array
            for (const str in altNames) {
                if (typeof str !== "string") {
                    isOK = false;
                    break;
                }
            }
        }
        return isOK;
    }
    /**
     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has
     * been verified with [[PoiTableEntry#verifyJSON]].
     *
     * @param jsonEntry - JSON description of the POI table entry. Expected to have been verified
     *                    with [[PoiTableEntry#verifyJSON]].
     */
    setup(jsonEntry) {
        this.name = jsonEntry.name;
        this.altNames = jsonEntry.altNames;
        this.iconName = jsonEntry.iconName;
        this.visible = jsonEntry.visible;
        this.priority = jsonEntry.priority;
        this.iconMinLevel = jsonEntry.iconMinLevel;
        this.iconMaxLevel = jsonEntry.iconMaxLevel;
        this.textMinLevel = jsonEntry.textMinLevel;
        this.textMaxLevel = jsonEntry.textMaxLevel;
        switch (jsonEntry.stackMode) {
            case "yes":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Show;
                break;
            case "no":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.Hide;
                break;
            case "parent":
                this.stackMode = harp_datasource_protocol_1.PoiStackMode.ShowParent;
                break;
            default:
        }
    }
}
/**
 * The `PoiTable` stores individual information for each POI type.
 *
 * @remarks
 * If a {@link TextElement} has a
 * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the
 * TextElement and its icon are read from the PoiTable.
 *
 * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the
 * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key
 * to look up the POIs in the {@link PoiTable}.
 *
 * On the side of the {@link PoiTable}, the key to look up the PoiTableEntry is either the property
 * "name" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names
 * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to
 * `true`, the `altNames` will be used.
 */
class PoiTable {
    /**
     * Creates an instance of PoiTable.
     *
     * @param {string} name Name of the `PoiTable`. Must be unique.
     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`
     *          to find a [[PoiTableEntry]] in the table.
     */
    constructor(name, useAltNamesForKey) {
        this.name = name;
        this.useAltNamesForKey = useAltNamesForKey;
        /**
         * Stores the list of [[PoiTableEntry]]s.
         */
        this.poiList = new Array();
        /**
         * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for
         * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of
         * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.
         * Value assigned to key it is the index to [[poiList]] array which contain actual
         * [[PoiTabelEntry]] objects.
         */
        this.poiDict = new Map();
        this.m_isLoading = false;
        this.m_loadedOk = undefined;
    }
    /**
     * Returns `true` if the table is currently being loaded, `false` otherwise.
     *
     * @readonly
     */
    get isLoading() {
        return this.m_isLoading;
    }
    /**
     * Returns `true` if the table has been loaded correctly, `false` otherwise.
     *
     * @readonly
     */
    get loadedOk() {
        return this.m_loadedOk === true;
    }
    /**
     * Gets [[PoiTableEntry]] for poi name specified.
     *
     * @param poiName - poi name or one of its alternative names if [[useAltNamesForKey]] is
     * set to `true`.
     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.
     */
    getEntry(poiName) {
        const entryIdx = this.poiDict.get(poiName);
        if (entryIdx !== undefined) {
            if (entryIdx < this.poiList.length) {
                return this.poiList[entryIdx];
            }
            else {
                throw new Error("Poi table entry index out of stored list!");
            }
        }
        return undefined;
    }
    /**
     * Start to load the PoiTable from the specified URL. Can only be called once per table.
     *
     * @param {string} poiTableUrl URL that points to the JSON file.
     * @param {AbortSignal} abortSignal Signal to abort the loading of the poi table file
     *
     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and
     *          the `PoiTable` has been set up.
     */
    async load(poiTableUrl, abortSignal) {
        if (this.m_loadedOk !== undefined) {
            // Only load once.
            return true;
        }
        this.m_loadedOk = false;
        const response = await fetch(poiTableUrl, { signal: abortSignal });
        if (!response.ok) {
            throw new Error(`load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`);
        }
        const jsonPoiTable = (await response.json());
        if (jsonPoiTable === undefined) {
            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);
            return true;
        }
        this.startLoading();
        try {
            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);
            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {
                for (const tableEntry of jsonPoiTable.poiList) {
                    if (PoiTableEntry.verifyJSON(tableEntry)) {
                        const newPoiEntry = new PoiTableEntry();
                        newPoiEntry.setup(tableEntry);
                        const entryIdx = this.poiList.push(newPoiEntry) - 1;
                        if (!this.useAltNamesForKey) {
                            // Use actual name of entry as the key
                            if (newPoiEntry.name === undefined) {
                                logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `. No name set in entry: ${tableEntry}.`);
                            }
                            else {
                                this.poiDict.set(newPoiEntry.name, entryIdx);
                            }
                        }
                        else {
                            if (newPoiEntry.altNames !== undefined &&
                                newPoiEntry.altNames.length > 0) {
                                // Use the list of alternative names as keys.
                                for (const altName of newPoiEntry.altNames) {
                                    this.poiDict.set(altName, entryIdx);
                                }
                            }
                            else {
                                logger.debug(`load: Invalid entry in POI table '${poiTableUrl}' : ` +
                                    `No alternative names set in entry: ${JSON.stringify(tableEntry)}.`);
                            }
                        }
                    }
                    else {
                        logger.warn(`load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(tableEntry)}`);
                    }
                }
            }
            this.m_loadedOk = true;
            this.finishedLoading();
        }
        catch (ex) {
            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);
            this.m_loadedOk = false;
            this.finishedLoading();
            return false;
        }
        return true;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishedLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTable = PoiTable;
/**
 * The `PoiTableManager` manages the list of [[PoiTables]] that
 * can be defined in the {@link @here/harp-datasource-protocol#Theme} sfile.
 */
class PoiTableManager {
    /**
     * Creates an instance of PoiTableManager.
     * @param {MapView} mapView Owning {@link MapView}.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_isLoading = false;
        this.m_poiTables = new Map();
        this.m_abortControllers = new Map();
    }
    /**
     * Load the {@link PoiTable}s that are stored in the {@link MapView}s
     * {@link @here/harp-datasource-protocol#Theme}.
     *
     * @remarks
     * Note that duplicate names of {@link PoiTable}s in the
     * {@link @here/harp-datasource-protocol#Theme} will lead to inaccessible {@link PoiTable}s.
     *
     * @param poiTables - {@link @here/harp-datasource-protocol#PoiTableRef[]}
     *                containing all {@link PoiTable}s to load.
     *
     * @returns Resolved once all the {@link PoiTable}s in
     *          the {@link @here/harp-datasource-protocol#Theme} have been loaded.
     */
    async loadPoiTables(poiTables) {
        const finished = new Promise(resolve => {
            this.clear();
            // Add the POI tables defined in the theme.
            if (poiTables !== undefined) {
                this.startLoading();
                // Gather promises to signal the success of having loaded them all
                const loadPromises = new Array();
                poiTables.forEach((poiTableRef) => {
                    var _a;
                    if (poiTableRef !== undefined &&
                        poiTableRef.name !== undefined &&
                        typeof poiTableRef.name === "string") {
                        const poiTable = new PoiTable(poiTableRef.name, poiTableRef.useAltNamesForKey !== false);
                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === "string") {
                            this.addTable(poiTable);
                            this.m_abortControllers.set(poiTableRef.name, new AbortController());
                            loadPromises.push(poiTable.load(poiTableRef.url, (_a = this.m_abortControllers.get(poiTableRef.name)) === null || _a === void 0 ? void 0 : _a.signal));
                        }
                        else {
                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);
                        }
                    }
                    else {
                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);
                    }
                });
                if (loadPromises.length > 0) {
                    Promise.all(loadPromises).finally(() => {
                        this.finishLoading();
                        resolve();
                    });
                }
                else {
                    this.finishLoading();
                    resolve();
                }
            }
            else {
                this.finishLoading();
                resolve();
            }
        });
        return finished;
    }
    /**
     * Clear the list of {@link PoiTable}s.
     */
    clear() {
        this.m_poiTables = new Map();
        this.m_abortControllers.forEach((abortController, name) => {
            abortController.abort();
            this.m_abortControllers.delete(name);
        });
    }
    /**
     * Return the map of {@link PoiTable}s.
     */
    get poiTables() {
        return this.m_poiTables;
    }
    /**
     * Manually add a {@link PoiTable}. Normally, the [[PoiTables]]s
     * are specified in the {@link @here/harp-datasource-protocol#Theme}.
     *
     * @remarks
     * Ensure that the name is unique.
     */
    addTable(poiTable) {
        this.m_poiTables.set(poiTable.name, poiTable);
    }
    /**
     * Retrieve a {@link PoiTable} by name.
     *
     * @param {(string | undefined)} poiTableName Name of the {@link PoiTable}.
     *
     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`
     *          otherwise.
     */
    getPoiTable(poiTableName) {
        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);
    }
    /**
     * Return `true` if the {@link PoiTable}s have finished loading.
     *
     * @readonly
     */
    get finishedLoading() {
        return !this.m_isLoading;
    }
    startLoading() {
        this.m_isLoading = true;
    }
    finishLoading() {
        this.m_isLoading = false;
    }
}
exports.PoiTableManager = PoiTableManager;


/***/ }),

/***/ "../harp-mapview/lib/text/FontCatalogLoader.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/text/FontCatalogLoader.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadFontCatalog = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("FontCatalogLoader");
async function loadFontCatalog(fontCatalogConfig, onSuccess, onError) {
    return await harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
        .then(onSuccess.bind(undefined, fontCatalogConfig.name))
        .catch((error) => {
        logger.error("Failed to load FontCatalog: ", fontCatalogConfig.name, error);
        if (onError) {
            onError(error);
        }
    });
}
exports.loadFontCatalog = loadFontCatalog;


/***/ }),

/***/ "../harp-mapview/lib/text/LayoutState.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/LayoutState.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayoutState = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
/**
 * Layout state of the text part of the `TextElement`.
 *
 * Used mainly for multi-anchor placement algorithm.
 * @hidden
 */
class LayoutState {
    constructor(placement) {
        this.m_hAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
        this.m_vAlign = harp_text_canvas_1.DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
        this.textPlacement = placement;
    }
    /**
     * Set layout based on theme style defined and optional text placement.
     *
     * @param placement - The optional new anchor placement.
     */
    set textPlacement(placement) {
        this.m_hAlign = harp_text_canvas_1.hAlignFromPlacement(placement.h);
        this.m_vAlign = harp_text_canvas_1.vAlignFromPlacement(placement.v);
    }
    /**
     * Acquire current placement setup.
     *
     * Function returns alternative or base placement depending on layout state.
     *
     * @returns The current anchor placement.
     */
    get textPlacement() {
        return {
            h: harp_text_canvas_1.hPlacementFromAlignment(this.m_hAlign),
            v: harp_text_canvas_1.vPlacementFromAlignment(this.m_vAlign)
        };
    }
    /**
     * Reset existing `LayoutState` to contain values from style/theme layout.
     */
    reset(layoutStyle) {
        this.m_hAlign = layoutStyle.horizontalAlignment;
        this.m_vAlign = layoutStyle.verticalAlignment;
    }
    get horizontalAlignment() {
        return this.m_hAlign;
    }
    get verticalAlignment() {
        return this.m_vAlign;
    }
}
exports.LayoutState = LayoutState;


/***/ }),

/***/ "../harp-mapview/lib/text/MapViewState.ts":
/*!************************************************!*\
  !*** ../harp-mapview/lib/text/MapViewState.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewState = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * View state obtained from a MapView instance.
 */
class MapViewState {
    constructor(m_mapView, m_renderedTilesChangeCheck) {
        this.m_mapView = m_mapView;
        this.m_renderedTilesChangeCheck = m_renderedTilesChangeCheck;
        this.m_lookAtVector = new THREE.Vector3();
    }
    get worldCenter() {
        return this.m_mapView.worldCenter;
    }
    get cameraIsMoving() {
        return this.m_mapView.cameraIsMoving;
    }
    get maxVisibilityDist() {
        return this.m_mapView.viewRanges.maximum;
    }
    get zoomLevel() {
        return this.m_mapView.zoomLevel;
    }
    get env() {
        return this.m_mapView.env;
    }
    get frameNumber() {
        return this.m_mapView.frameNumber;
    }
    get lookAtVector() {
        return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);
    }
    get lookAtDistance() {
        return this.m_mapView.targetDistance;
    }
    get isDynamic() {
        return this.m_mapView.isDynamicFrame;
    }
    get hiddenGeometryKinds() {
        return this.m_mapView.tileGeometryManager === undefined
            ? undefined
            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;
    }
    get renderedTilesChanged() {
        return this.m_renderedTilesChangeCheck();
    }
    get projection() {
        return this.m_mapView.projection;
    }
    get elevationProvider() {
        return this.m_mapView.elevationProvider;
    }
}
exports.MapViewState = MapViewState;


/***/ }),

/***/ "../harp-mapview/lib/text/Placement.ts":
/*!*********************************************!*\
  !*** ../harp-mapview/lib/text/Placement.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWorldPosition = exports.isPathLabelTooSmall = exports.placePathLabel = exports.placePointLabel = exports.placeIcon = exports.PlacementResult = exports.newPointLabelTextMarginPercent = exports.persistentPointLabelTextMargin = exports.checkReadyForPlacement = exports.PrePlacementResult = exports.getMaxViewDistance = exports.pointToPlaneDistance = exports.computeViewDistance = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "../harp-mapview/lib/poi/PoiRenderer.ts");
const ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ "../harp-mapview/lib/ScreenCollisions.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * Minimum number of pixels per character. Used during estimation if there is enough screen space
 * available to render a text.
 */
const MIN_AVERAGE_CHAR_WIDTH = 5;
/**
 * Functions related to text element placement.
 */
const tmpPosition = new THREE.Vector3(0, 0, 0);
const tmpCameraDir = new THREE.Vector3(0, 0, 0);
const tmpPointDir = new THREE.Vector3(0, 0, 0);
const COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)
/**
 * Checks whether the distance of the text element to the camera plane meets threshold criteria.
 *
 * @param textElement - The textElement of which the view distance will be checked, with coordinates
 * in world space.
 * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.
 * @param eyePos - The eye (or camera) position that will be used as reference to calculate
 * the distance.
 * @param eyeLookAt - The eye looking direction - normalized.
 * @param maxViewDistance - The maximum distance value.
 * @returns The text element view distance if it's lower than the maximum value, otherwise
 * `undefined`.
 */
function checkViewDistance(textElement, poiIndex, eyePos, eyeLookAt, projectionType, maxViewDistance) {
    const textDistance = computeViewDistance(textElement, poiIndex, eyePos, eyeLookAt);
    if (projectionType !== harp_geoutils_1.ProjectionType.Spherical) {
        return textDistance <= maxViewDistance ? textDistance : undefined;
    }
    // For sphere projection: Filter labels that are close to the horizon
    tmpPosition.copy(textElement.position).normalize();
    tmpCameraDir.copy(eyePos).normalize();
    const cosAlpha = tmpPosition.dot(tmpCameraDir);
    const viewDistance = cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance
        ? textDistance
        : undefined;
    return viewDistance;
}
/**
 * Computes distance of the specified text element to camera plane given with position and normal.
 *
 * The distance is measured as projection of the vector between `eyePosition` and text
 * onto the `eyeLookAt` vector, so it actually computes the distance to plane that
 * contains `eyePosition` and is described with `eyeLookAt` as normal.
 *
 * @note Used for measuring the distances to camera, results in the metric that describes
 * distance to camera near plane (assuming near = 0). Such metric is better as input for labels
 * scaling or fading factors then simple euclidean distance because it does not fluctuate during
 * simple camera panning.
 *
 * @param textElement - The textElement of which the view distance will be checked. It must have
 *                      coordinates in world space.
 * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.
 * @param eyePosition - The world eye coordinates used a reference position to calculate
 *                      the distance.
 * @param eyeLookAt - The eye looking direction or simply said projection plane normal.
 * @returns The text element view distance.
 */
function computeViewDistance(textElement, poiIndex, eyePosition, eyeLookAt) {
    let viewDistance;
    // Compute the distances as the distance along plane normal.
    const path = textElement.path;
    if (path && path.length > 1) {
        if (poiIndex !== undefined && path && path.length > poiIndex) {
            viewDistance = pointToPlaneDistance(path[poiIndex], eyePosition, eyeLookAt);
        }
        else {
            const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);
            const viewDistance1 = pointToPlaneDistance(path[path.length - 1], eyePosition, eyeLookAt);
            viewDistance = Math.min(viewDistance0, viewDistance1);
        }
    }
    else {
        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);
    }
    return viewDistance;
}
exports.computeViewDistance = computeViewDistance;
/**
 * Computes distance between the given point and a plane.
 *
 * May be used to measure distance of point labels to the camera projection (near) plane.
 *
 * @param pointPos - The position to measure distance to.
 * @param planePos - The position of any point on the plane.
 * @param planeNorm - The plane normal vector (have to be normalized already).
 */
function pointToPlaneDistance(pointPos, planePos, planeNorm) {
    const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);
    return labelCamVec.dot(planeNorm);
}
exports.pointToPlaneDistance = pointToPlaneDistance;
/**
 * Computes the maximum view distance for text elements as a ratio of the given view's maximum far
 * plane distance.
 * @param viewState - The view for which the maximum view distance will be calculated.
 * @param farDistanceLimitRatio - The ratio to apply to the maximum far plane distance.
 * @returns Maximum view distance.
 */
function getMaxViewDistance(viewState, farDistanceLimitRatio) {
    return viewState.maxVisibilityDist * farDistanceLimitRatio;
}
exports.getMaxViewDistance = getMaxViewDistance;
/**
 * State of fading.
 */
var PrePlacementResult;
(function (PrePlacementResult) {
    PrePlacementResult[PrePlacementResult["Ok"] = 0] = "Ok";
    PrePlacementResult[PrePlacementResult["NotReady"] = 1] = "NotReady";
    PrePlacementResult[PrePlacementResult["Invisible"] = 2] = "Invisible";
    PrePlacementResult[PrePlacementResult["TooFar"] = 3] = "TooFar";
    PrePlacementResult[PrePlacementResult["Duplicate"] = 4] = "Duplicate";
    PrePlacementResult[PrePlacementResult["Count"] = 5] = "Count";
})(PrePlacementResult = exports.PrePlacementResult || (exports.PrePlacementResult = {}));
const tmpPlacementPosition = new THREE.Vector3();
/**
 * Applies early rejection tests for a given text element meant to avoid trying to place labels
 * that are not visible, not ready, duplicates etc...
 * @param textElement - The Text element to check.
 * @param poiIndex - If TextElement is a line marker, the index into the line marker positions
 * @param viewState - The view for which the text element will be placed.
 * @param m_poiManager - To prepare pois for rendering.
 * @param maxViewDistance - If specified, text elements farther than this max distance will be
 *                          rejected.
 * @returns An object with the result code and the text element view distance
 * ( or `undefined` of the checks failed) as second.
 */
function checkReadyForPlacement(textElement, poiIndex, viewState, poiManager, maxViewDistance) {
    // eslint-disable-next-line prefer-const
    let viewDistance;
    if (!textElement.visible) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    // If a PoiTable is specified in the technique, the table is required to be
    // loaded before the POI can be rendered.
    if (!poiManager.updatePoiFromPoiTable(textElement)) {
        // PoiTable has not been loaded, but is required to determine
        // visibility.
        return { result: PrePlacementResult.NotReady, viewDistance };
    }
    // Text element visibility and zoom level ranges must be checked after calling
    // updatePoiFromPoiTable, since that function may change those values.
    if (!textElement.visible ||
        viewState.zoomLevel === textElement.maxZoomLevel ||
        !harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, textElement.minZoomLevel, textElement.maxZoomLevel)) {
        return { result: PrePlacementResult.Invisible, viewDistance };
    }
    viewDistance =
        maxViewDistance === undefined
            ? computeViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector)
            : checkViewDistance(textElement, poiIndex, viewState.worldCenter, viewState.lookAtVector, viewState.projection.type, maxViewDistance);
    if (viewDistance === undefined) {
        return { result: PrePlacementResult.TooFar, viewDistance };
    }
    return { result: PrePlacementResult.Ok, viewDistance };
}
exports.checkReadyForPlacement = checkReadyForPlacement;
/**
 * Computes the offset for a point text accordingly to text alignment (and icon, if any).
 * @param textElement - The text element of which the offset will computed. It must be a point
 * label with [[layoutStyle]] and [[bounds]] already computed.
 * @param textBounds - The text screen bounds.
 * @param placement - The relative anchor placement (may be different then original alignment).
 * @param scale - The scaling factor (due to distance, etc.).
 * @param env - The {@link @here/harp-datasource-protocol#Env} used
 *                  to evaluate technique attributes.
 * @param offset - The offset result.
 */
function computePointTextOffset(textElement, textBounds, placement, scale, env, offset = new THREE.Vector2()) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PoiLabel ||
        textElement.type === TextElementType_1.TextElementType.LineMarker);
    harp_utils_1.assert(textElement.layoutStyle !== undefined);
    offset.x = textElement.xOffset;
    offset.y = textElement.yOffset;
    switch (placement.h) {
        case harp_text_canvas_1.HorizontalPlacement.Left:
            // Already accounts for any margin that is already applied to the text element bounds.
            offset.x -= textBounds.max.x;
            break;
        case harp_text_canvas_1.HorizontalPlacement.Right:
            // Account for any margin applied as above.
            offset.x -= textBounds.min.x;
            break;
    }
    switch (placement.v) {
        case harp_text_canvas_1.VerticalPlacement.Top:
            offset.y -= textBounds.min.y;
            break;
        case harp_text_canvas_1.VerticalPlacement.Center:
            offset.y -= 0.5 * (textBounds.max.y + textBounds.min.y);
            break;
        case harp_text_canvas_1.VerticalPlacement.Bottom:
            // Accounts for vertical margin that may be applied to the text bounds.
            offset.y -= textBounds.max.y;
            break;
    }
    if (textElement.poiInfo !== undefined && TextElement_1.poiIsRenderable(textElement.poiInfo)) {
        harp_utils_1.assert(textElement.poiInfo.computedWidth !== undefined);
        harp_utils_1.assert(textElement.poiInfo.computedHeight !== undefined);
        // Apply offset moving text out of the icon
        offset.x += textElement.poiInfo.computedWidth * (0.5 + placement.h);
        offset.y += textElement.poiInfo.computedHeight * (0.5 + placement.v);
        // Reverse, mirror or project offsets on different axis depending on the placement
        // required only for alternative placements.
        const hAlign = harp_text_canvas_1.hPlacementFromAlignment(textElement.layoutStyle.horizontalAlignment);
        const vAlign = harp_text_canvas_1.vPlacementFromAlignment(textElement.layoutStyle.verticalAlignment);
        if (hAlign !== placement.h || vAlign !== placement.v) {
            // Read icon offset used.
            const technique = textElement.poiInfo.technique;
            let iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
            let iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
            iconXOffset = typeof iconXOffset === "number" ? iconXOffset : 0;
            iconYOffset = typeof iconYOffset === "number" ? iconYOffset : 0;
            // Now mirror the text offset relative to icon so manhattan distance is preserved, when
            // alternative position is taken, this ensures that text-icon relative position is
            // the same as in base alignment.
            const hAlignDiff = hAlign - placement.h;
            const vAlignDiff = vAlign - placement.v;
            const relOffsetX = iconXOffset - textElement.xOffset;
            const relOffsetY = iconYOffset - textElement.yOffset;
            const centerBased = hAlign === harp_text_canvas_1.HorizontalPlacement.Center || vAlign === harp_text_canvas_1.VerticalPlacement.Center;
            if (centerBased) {
                // Center based alternative placements.
                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;
                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);
                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;
                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);
            }
            else {
                // Corner alternative placements
                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;
                offset.y -=
                    2 *
                        Math.sign(vAlignDiff) *
                        Math.min(Math.abs(vAlignDiff), 0.5) *
                        Math.abs(relOffsetX);
                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;
                offset.x -=
                    2 *
                        Math.sign(hAlignDiff) *
                        Math.min(Math.abs(hAlignDiff), 0.5) *
                        Math.abs(relOffsetY);
            }
        }
    }
    offset.multiplyScalar(scale);
    return offset;
}
const tmpBox = new THREE.Box2();
const tmpBounds = new THREE.Box2();
const tmpBoxes = [];
const tmpMeasurementParams = {};
const tmpCollisionBoxes = [];
const tmpCollisionBox = new ScreenCollisions_1.CollisionBox();
const tmpScreenPosition = new THREE.Vector2();
const tmpTextOffset = new THREE.Vector2();
const tmp2DBox = new harp_utils_1.Math2D.Box();
const tmpCenter = new THREE.Vector2();
const tmpSize = new THREE.Vector2();
/**
 * The margin applied to the text bounds of every point label.
 */
exports.persistentPointLabelTextMargin = new THREE.Vector2(2, 2);
/**
 * Additional bounds scaling (described as percentage of full size) applied to the new labels.
 *
 * This additional scaling (margin) allows to account for slight camera position and
 * orientation changes, so new labels are placed only if there is enough space around them.
 * Such margin limits collisions with neighboring labels while doing small camera movements and
 * thus reduces labels flickering.
 */
exports.newPointLabelTextMarginPercent = 0.1;
var PlacementResult;
(function (PlacementResult) {
    PlacementResult[PlacementResult["Ok"] = 0] = "Ok";
    PlacementResult[PlacementResult["Rejected"] = 1] = "Rejected";
    PlacementResult[PlacementResult["Invisible"] = 2] = "Invisible";
})(PlacementResult = exports.PlacementResult || (exports.PlacementResult = {}));
/**
 * Places an icon on screen.
 * @param iconRenderState - The icon state.
 * @param poiInfo - Icon information necessary to compute its dimensions.
 * @param screenPosition - Screen position of the icon.
 * @param scaleFactor - Scaling factor to apply to the icon dimensions.
 * @param screenCollisions - Used to check the icon visibility and collisions.
 * @param env - Current map env.
 * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 */
function placeIcon(iconRenderState, poiInfo, screenPosition, scaleFactor, env, screenCollisions) {
    PoiRenderer_1.PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    const iconSpaceAvailable = poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);
    return !iconSpaceAvailable ? PlacementResult.Rejected : PlacementResult.Ok;
}
exports.placeIcon = placeIcon;
/**
 * Place a point label text using single or multiple alternative placement anchors.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env} used
 *              to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @param multiAnchor - The parameter decides if multi-anchor placement algorithm should be
 * used, be default [[false]] meaning try to place label using current alignment settings only.
 * @returns `PlacementResult.Ok` if point __label can be placed__ at the base or any optional
 * anchor point. `PlacementResult.Rejected` if there's a collision for all placements. Finally
 * `PlacementResult.Invisible` if it's text is not visible at any placement position.
 */
function placePointLabel(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition, multiAnchor = false) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    const layoutStyle = labelState.element.layoutStyle;
    // Check if alternative placements have been provided.
    multiAnchor =
        multiAnchor && layoutStyle.placements !== undefined && layoutStyle.placements.length > 1;
    // For single placement labels or labels with icon rejected, do only current anchor testing.
    if (!multiAnchor) {
        return placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
    }
    // Otherwise test also alternative text placements.
    else {
        return placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition);
    }
}
exports.placePointLabel = placePointLabel;
/**
 * Try to place a point label text using multiple optional placements.
 *
 * @note Function should be called only for labels with icons not rejected and for text alignments
 * different then [[HorizontalAlignment.Center]] and [[VerticalAlignment.Center]].
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if label can be placed at the base or optional anchor point,
 * `PlacementResult.Rejected` if there's a collision for all placements, `PlacementResult.Invisible`
 * if it's not visible at any placement position.
 *
 * @internal
 * @hidden
 */
function placePointLabelChoosingAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    const label = labelState.element;
    // Store label state - persistent or new label.
    const persistent = labelState.visible;
    // Start with last alignment settings if layout state was stored or
    // simply begin from layout defined in theme.
    const lastPlacement = labelState.textPlacement;
    const placements = label.layoutStyle.placements;
    const placementsNum = placements.length;
    // Find current anchor placement on the optional placements list.
    // Index of exact match.
    const matchIdx = placements.findIndex(p => p.h === lastPlacement.h && p.v === lastPlacement.v);
    harp_utils_1.assert(matchIdx >= 0);
    // Will be true if all text placements are invisible.
    let allInvisible = true;
    // Iterate all placements starting from current one.
    for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {
        const anchorPlacement = placements[i % placementsNum];
        // Bounds may be already calculated for persistent label, force re-calculation only
        // for alternative (new) placements.
        const isLastPlacement = i === matchIdx && persistent;
        // Compute label bounds, visibility or collision according to new layout settings.
        const placementResult = placePointLabelAtAnchor(labelState, screenPosition, anchorPlacement, scale, textCanvas, env, screenCollisions, !isLastPlacement, tmpPlacementPosition);
        if (placementResult === PlacementResult.Ok) {
            outScreenPosition.copy(tmpPlacementPosition);
            return PlacementResult.Ok;
        }
        // Store last successful (previous frame) position even if it's now rejected (to fade out).
        if (isLastPlacement) {
            outScreenPosition.copy(tmpPlacementPosition);
        }
        // Invisible = Persistent label out of screen or the new label that is colliding.
        allInvisible = allInvisible && placementResult === PlacementResult.Invisible;
    }
    return allInvisible
        ? // All text's placements out of the screen.
            PlacementResult.Invisible
        : // All placements are either colliding or out of screen .
            PlacementResult.Rejected;
}
/**
 * Places a point label on a specified text canvas using the alignment (anchor) currently set.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 *
 * @internal
 * @hidden
 */
function placePointLabelAtCurrentAnchor(labelState, screenPosition, scale, textCanvas, env, screenCollisions, outScreenPosition) {
    harp_utils_1.assert(labelState.element.layoutStyle !== undefined);
    // Use recently rendered (state stored) layout if available, otherwise theme based style.
    const lastPlacement = labelState.textPlacement;
    const result = placePointLabelAtAnchor(labelState, screenPosition, lastPlacement, scale, textCanvas, env, screenCollisions, !labelState.visible, outScreenPosition);
    return result;
}
/**
 * Auxiliary function that tries to place a point label on a text canvas using specified alignment.
 *
 * @param labelState - State of the point label to place.
 * @param screenPosition - Position of the label in screen coordinates
 * @param placement - Text placement relative to the label position.
 * @param scale - Scale factor to be applied to label dimensions.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param env - The {@link @here/harp-datasource-protocol#Env}
 *              used to evaluate technique attributes.
 * @param screenCollisions - Used to check collisions with other labels.
 * @param forceInvalidation - Set to true if text layout or other params has changed such as text
 * re-measurement is required and text buffer need to be invalidated.
 * @param outScreenPosition - The final label screen position after applying any offsets.
 * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's
 * a collision, `PlacementResult.Invisible` if it's not visible.
 *
 * @internal
 * @hidden
 */
function placePointLabelAtAnchor(labelState, screenPosition, placement, scale, textCanvas, env, screenCollisions, forceInvalidation, outScreenPosition) {
    const label = labelState.element;
    harp_utils_1.assert(label.glyphs !== undefined);
    harp_utils_1.assert(label.layoutStyle !== undefined);
    const measureText = !label.bounds || forceInvalidation;
    const labelBounds = measureText ? tmpBounds : label.bounds;
    if (measureText) {
        // Override text canvas layout style for measurement.
        applyTextPlacement(textCanvas, placement);
        tmpMeasurementParams.outputCharacterBounds = undefined;
        tmpMeasurementParams.path = undefined;
        tmpMeasurementParams.pathOverflow = false;
        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray;
        // Compute label bounds according to layout settings.
        textCanvas.measureText(label.glyphs, labelBounds, tmpMeasurementParams);
    }
    // Compute text offset from the anchor point
    const textOffset = computePointTextOffset(label, labelBounds, placement, scale, env, tmpTextOffset).add(screenPosition);
    // Update output screen position.
    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);
    // Apply additional persistent margin, keep in mind that text bounds just calculated
    // are not (0, 0, w, h) based, so their coords usually are also non-zero.
    // TODO: Make the margin configurable
    tmpBox.copy(labelBounds).expandByVector(exports.persistentPointLabelTextMargin).translate(textOffset);
    tmpBox.getCenter(tmpCenter);
    tmpBox.getSize(tmpSize);
    tmpSize.multiplyScalar(scale);
    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    // Check the text visibility if invisible finish immediately
    // regardless of the persistence state - no fading required.
    if (!screenCollisions.isVisible(tmp2DBox)) {
        return PlacementResult.Invisible;
    }
    if (measureText) {
        // Up-scaled label bounds are used only for new labels and only for collision check, this
        // is intentional to avoid processing labels out of the screen due to increased bounds,
        // such labels would be again invisible in the next frame.
        tmpBox.getSize(tmpSize);
        tmpSize.multiplyScalar(scale * (1 + exports.newPointLabelTextMarginPercent));
        tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);
    }
    // Check label's text collision. Collision is more important than visibility (now), because for
    // icon/text combinations the icon should be rendered if the text is out of bounds, but it may
    // _not_ be rendered if the text is colliding with another label.
    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {
        return PlacementResult.Rejected;
    }
    // Don't allocate space for rejected text. When zooming, this allows placement of a
    // lower priority text element that was displaced by a higher priority one (not
    // present in the new zoom level) before an even lower priority one takes the space.
    // Otherwise the lowest priority text will fade in and back out.
    // TODO: Add a unit test for this scenario.
    if (label.textReservesSpace) {
        screenCollisions.allocate(tmp2DBox);
    }
    // Glyphs arrangement have been changed remove text buffer object which needs to be
    // re-created.
    if (measureText) {
        label.textBufferObject = undefined;
        label.bounds = label.bounds ? label.bounds.copy(labelBounds) : labelBounds.clone();
    }
    else {
        // Override text canvas layout style for placement.
        applyTextPlacement(textCanvas, placement);
    }
    // Save current placement in label state.
    // TextElementState creates layout snapshot solely for alternative placements which saves
    // memory that could be wasted on unnecessary objects construction.
    labelState.textPlacement = placement;
    return PlacementResult.Ok;
}
/**
 * Applied modified text layout style to TextCanvas for further use.
 * @param textCanvas - TextCanvas reference.
 * @param placement - The text placement to be used.
 */
function applyTextPlacement(textCanvas, placement) {
    // Setup TextCanvas layout settings of the new placement as it is required for further
    // TextBufferObject creation and measurements in addText().
    textCanvas.textLayoutStyle.horizontalAlignment = harp_text_canvas_1.hAlignFromPlacement(placement.h);
    textCanvas.textLayoutStyle.verticalAlignment = harp_text_canvas_1.vAlignFromPlacement(placement.v);
}
/**
 * Places a path label along a given path on a specified text canvas.
 * @param labelState - The state of the path label to place.
 * @param textPath - The text path along which the label will be placed.
 * @param screenPosition - Position of the label in screen coordinates.
 * @param textCanvas - The text canvas where the label will be placed.
 * @param screenCollisions - Used to check collisions with other labels.
 * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's
 * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.
 */
function placePathLabel(labelState, textPath, screenPosition, textCanvas, screenCollisions) {
    // Recalculate the text bounds for this path label. If measurement fails, the whole
    // label doesn't fit the path and should be discarded.
    tmpMeasurementParams.path = textPath;
    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;
    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray;
    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but
    // without storing the result. If the measurement succeeds, the placement work is done
    // twice.
    // This could be done in one step (e.g measureAndAddText). Collision test could be injected
    // in the middle as a function.
    if (!textCanvas.measureText(labelState.element.glyphs, tmpBox, tmpMeasurementParams)) {
        return PlacementResult.Rejected;
    }
    // Coarse collision check.
    tmpCollisionBox.copy(tmpBox.translate(screenPosition));
    if (!screenCollisions.isVisible(tmpCollisionBox)) {
        return PlacementResult.Invisible;
    }
    let checkGlyphCollision = false;
    let candidateBoxes;
    if (!labelState.element.textMayOverlap) {
        candidateBoxes = screenCollisions.search(tmpCollisionBox);
        checkGlyphCollision = candidateBoxes.length > 0;
    }
    // Perform per-character collision checks.
    tmpCollisionBoxes.length = tmpBoxes.length;
    for (let i = 0; i < tmpBoxes.length; ++i) {
        const glyphBox = tmpBoxes[i].translate(screenPosition);
        let collisionBox = tmpCollisionBoxes[i];
        if (collisionBox === undefined) {
            collisionBox = new ScreenCollisions_1.CollisionBox(glyphBox);
            tmpCollisionBoxes[i] = collisionBox;
        }
        else {
            collisionBox.copy(glyphBox);
        }
        if (checkGlyphCollision &&
            screenCollisions.intersectsDetails(collisionBox, candidateBoxes)) {
            return PlacementResult.Rejected;
        }
    }
    // Allocate collision info if needed.
    if (labelState.element.textReservesSpace) {
        const collisionBox = new ScreenCollisions_1.DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());
        tmpCollisionBoxes.length = 0;
        screenCollisions.allocate(collisionBox);
    }
    return PlacementResult.Ok;
}
exports.placePathLabel = placePathLabel;
/**
 * Check if a given path label is too small to be rendered.
 * @param textElement - The text element to check.
 * @param screenProjector - Used to project coordinates from world to screen space.
 * @param outScreenPoints - Label path projected to screen space.
 * @returns `true` if label is too small, `false` otherwise.
 */
function isPathLabelTooSmall(textElement, screenProjector, outScreenPoints) {
    harp_utils_1.assert(textElement.type === TextElementType_1.TextElementType.PathLabel);
    // Get the screen points that define the label's segments and create a path with
    // them.
    outScreenPoints.length = 0;
    let anyPointVisible = false;
    for (const pt of textElement.points) {
        // Skip invisible points at the beginning of the path.
        const screenPoint = anyPointVisible
            ? screenProjector.project(pt, tmpScreenPosition)
            : screenProjector.projectToScreen(pt, tmpScreenPosition);
        if (screenPoint === undefined) {
            continue;
        }
        anyPointVisible = true;
        outScreenPoints.push(tmpScreenPosition.clone());
    }
    // TODO: (HARP-3515)
    //      The rendering of a path label that contains just a single point that is not
    //      visible is impossible, which is problematic with long paths.
    //      Fix: Skip/clip the invisible points at beginning and end of the path to get
    //      the visible part of the path.
    // If not a single point is visible, skip the path
    if (!anyPointVisible) {
        return true;
    }
    // Check/guess if the screen box can hold a string of that length. It is important
    // to guess that value without measuring the font first to save time.
    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;
    tmpBox.setFromPoints(outScreenPoints);
    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();
    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {
        textElement.dbgPathTooSmall = true;
        return true;
    }
    return false;
}
exports.isPathLabelTooSmall = isPathLabelTooSmall;
const tmpOrientedBox = new harp_geoutils_1.OrientedBox3();
/**
 * Calculates the world position of the supplied label. The label will be shifted if there is a
 * specified offsetDirection and value to shift it in.
 * @param poiLabel - The label to shift
 * @param projection - The projection, required to compute the correct direction offset for
 *                     spherical projections.
 * @param env - The environment to extract the worldOffset needed to shift the icon in world space,
 *              if configured in the style.
 * @param outWorldPosition - Preallocated vector to store the result in
 * @returns the [[outWorldPosition]] vector.
 */
function getWorldPosition(poiLabel, projection, env, outWorldPosition) {
    var _a, _b;
    const worldOffsetShiftValue = harp_datasource_protocol_1.getPropertyValue((_b = (_a = poiLabel.poiInfo) === null || _a === void 0 ? void 0 : _a.technique) === null || _b === void 0 ? void 0 : _b.worldOffset, env);
    outWorldPosition === null || outWorldPosition === void 0 ? void 0 : outWorldPosition.copy(poiLabel.position);
    if (worldOffsetShiftValue !== null &&
        worldOffsetShiftValue !== undefined &&
        poiLabel.offsetDirection !== undefined) {
        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);
        const offsetDirectionVector = tmpOrientedBox.yAxis;
        const offsetDirectionRad = THREE.MathUtils.degToRad(poiLabel.offsetDirection);
        // Negate to get the normal, i.e. the vector pointing to the sky.
        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);
        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);
    }
    return outWorldPosition;
}
exports.getWorldPosition = getWorldPosition;


/***/ }),

/***/ "../harp-mapview/lib/text/PlacementStats.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/text/PlacementStats.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlacementStats = void 0;
class PlacementStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    clear() {
        this.totalGroups = 0;
        this.resortedGroups = 0;
        this.total = 0;
        this.uninitialized = 0;
        this.tooFar = 0;
        this.numNotVisible = 0;
        this.numPathTooSmall = 0;
        this.numCannotAdd = 0;
        this.numRenderedPoiIcons = 0;
        this.numRenderedPoiTexts = 0;
        this.numPoiTextsInvisible = 0;
        this.numRenderedTextElements = 0;
    }
    log() {
        const numNotRendered = this.uninitialized +
            this.numPoiTextsInvisible +
            this.tooFar +
            this.numNotVisible +
            this.numCannotAdd;
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("Resorted groups", this.resortedGroups);
        this.m_logger.debug("Total labels", this.total);
        this.m_logger.debug("Rendered labels", this.numRenderedTextElements);
        this.m_logger.debug("Rejected labels", numNotRendered);
        this.m_logger.debug("Unitialized labels", this.uninitialized);
        this.m_logger.debug("Rendered poi icons", this.numRenderedPoiIcons);
        this.m_logger.debug("Rendered poi texts", this.numRenderedPoiTexts);
        this.m_logger.debug("Poi text invisible", this.numPoiTextsInvisible);
        this.m_logger.debug("Too far", this.tooFar);
        this.m_logger.debug("Not visible", this.numNotVisible);
        this.m_logger.debug("Path too small", this.numPathTooSmall);
        this.m_logger.debug("Rejected, max glyphs reached", this.numCannotAdd);
    }
}
exports.PlacementStats = PlacementStats;


/***/ }),

/***/ "../harp-mapview/lib/text/RenderState.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/RenderState.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenderState = exports.DEFAULT_FADE_TIME = exports.FadingState = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * State of fading.
 */
var FadingState;
(function (FadingState) {
    FadingState[FadingState["Undefined"] = 0] = "Undefined";
    FadingState[FadingState["FadingIn"] = 1] = "FadingIn";
    FadingState[FadingState["FadedIn"] = 2] = "FadedIn";
    FadingState[FadingState["FadingOut"] = -1] = "FadingOut";
    FadingState[FadingState["FadedOut"] = -2] = "FadedOut";
})(FadingState = exports.FadingState || (exports.FadingState = {}));
/**
 * Time to fade in/fade out the labels in milliseconds.
 */
exports.DEFAULT_FADE_TIME = 800;
/**
 * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements
 * in and out, to compute the opacity.
 *
 * @hidden
 */
class RenderState {
    /**
     * Create a `RenderState`.
     *
     * @param fadeTime - The duration of the fading in milliseconds.
     */
    constructor(fadeTime = exports.DEFAULT_FADE_TIME) {
        this.fadeTime = fadeTime;
        /**
         * Current fading value [0..1]
         */
        this.value = 0.0;
        /**
         * Timestamp the fading started.
         */
        this.startTime = 0;
        /**
         * Computed opacity depending on value.
         */
        this.opacity = 0.0;
        this.m_state = FadingState.Undefined;
    }
    /**
     * Reset existing `RenderState` to appear like a fresh state.
     */
    reset() {
        this.m_state = FadingState.Undefined;
        this.value = 0.0;
        this.startTime = 0.0;
        this.opacity = 0.0;
    }
    /**
     * @returns `true` if element state is `FadingState.Undefined`.
     */
    isUndefined() {
        return this.m_state === FadingState.Undefined;
    }
    /**
     * @returns `true` if element is either fading in or fading out.
     */
    isFading() {
        const fading = this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;
        return fading;
    }
    /**
     * @returns `true` if element is fading in.
     */
    isFadingIn() {
        const fadingIn = this.m_state === FadingState.FadingIn;
        return fadingIn;
    }
    /**
     * @returns `true` if element is fading out.
     */
    isFadingOut() {
        const fadingOut = this.m_state === FadingState.FadingOut;
        return fadingOut;
    }
    /**
     * @returns `true` if element is done with fading in.
     */
    isFadedIn() {
        const fadedIn = this.m_state === FadingState.FadedIn;
        return fadedIn;
    }
    /**
     * @returns `true` if element is done with fading out.
     */
    isFadedOut() {
        const fadedOut = this.m_state === FadingState.FadedOut;
        return fadedOut;
    }
    /**
     * @returns `true` if state is neither faded out nor undefined and the opacity is larger
     * than 0.
     */
    isVisible() {
        return (this.m_state !== FadingState.FadedOut &&
            this.m_state !== FadingState.Undefined &&
            this.opacity > 0);
    }
    /**
     * Updates the state to [[FadingState.FadingIn]].
     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains
     * unchanged.
     *
     * @param time - Current time.
     * @param disableFading - Optional flag to disable fading.
     */
    startFadeIn(time, disableFading) {
        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {
            return;
        }
        if (disableFading === true) {
            this.value = 1;
            this.opacity = 1;
            this.m_state = FadingState.FadedIn;
            this.startTime = time;
            return;
        }
        if (this.m_state === FadingState.FadingOut) {
            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.value = 1.0 - this.value;
            this.startTime = time - this.value * this.fadeTime;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 0;
        }
        this.m_state = FadingState.FadingIn;
    }
    /**
     * Updates the state to [[FadingState.FadingOut]].
     * If previous state is [[FadingState.FadingOut]], [[FadingState.FadedOut]] or
     * [[FadingState.Undefined]] it remains unchanged.
     *
     * @param time - Current time.
     */
    startFadeOut(time) {
        if (this.m_state === FadingState.FadingOut ||
            this.m_state === FadingState.FadedOut ||
            this.m_state === FadingState.Undefined) {
            return;
        }
        if (this.m_state === FadingState.FadingIn) {
            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get
            // a correct end time:
            this.startTime = time - this.value * this.fadeTime;
            this.value = 1.0 - this.value;
        }
        else {
            this.startTime = time;
            this.value = 0.0;
            this.opacity = 1;
        }
        this.m_state = FadingState.FadingOut;
    }
    /**
     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or
     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.
     * It does nothing if [[isFading]] !== `true`.
     *
     * @param time - Current time.
     * @param disableFading - `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {
            return;
        }
        if (this.startTime === 0) {
            this.startTime = time;
        }
        const fadingTime = time - this.startTime;
        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;
        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;
        if (disableFading || fadingTime >= this.fadeTime) {
            this.value = 1.0;
            this.opacity = endValue;
            this.m_state =
                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;
        }
        else {
            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value
            // increment).
            this.value = fadingTime / this.fadeTime;
            this.opacity = THREE.MathUtils.clamp(harp_utils_1.MathUtils.smootherStep(startValue, endValue, this.value), 0, 1);
            harp_utils_1.assert(this.isFading());
        }
    }
}
exports.RenderState = RenderState;


/***/ }),

/***/ "../harp-mapview/lib/text/SimplePath.ts":
/*!**********************************************!*\
  !*** ../harp-mapview/lib/text/SimplePath.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimplePath = exports.PathParam = exports.SimpleLineCurve = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * @hidden
 */
class SimpleLineCurve extends THREE.LineCurve {
    constructor(v1, v2) {
        super(v1, v2);
    }
    getLengths() {
        if (this.m_lengths === undefined) {
            this.m_lengths = [0, this.v2.distanceTo(this.v1)];
        }
        return this.m_lengths;
    }
}
exports.SimpleLineCurve = SimpleLineCurve;
/**
 * @hidden
 */
class PathParam {
    constructor(path, index, t) {
        this.path = path;
        this.index = index;
        this.t = t;
    }
    get curve() {
        return this.path.curves[this.index];
    }
    get point() {
        if (this.m_point === undefined) {
            this.m_point = this.curve.getPoint(this.t);
        }
        return this.m_point;
    }
}
exports.PathParam = PathParam;
/**
 * @hidden
 */
class SimplePath extends THREE.Path {
    constructor() {
        super();
    }
    getLengths() {
        if (this.m_cache) {
            return this.m_cache;
        }
        let sum = 0;
        const lengths = new Array();
        lengths.push(0);
        this.curves.forEach(curve => {
            const lineCurve = curve;
            sum += lineCurve.v1.distanceTo(lineCurve.v2);
            lengths.push(sum);
        });
        this.m_cache = lengths;
        return lengths;
    }
    getParamAt(t) {
        const distance = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        for (let index = 0; index < curveLengths.length; ++index) {
            if (curveLengths[index] < distance) {
                continue;
            }
            const diff = curveLengths[index] - distance;
            const curve = this.curves[index];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return new PathParam(this, index, u);
        }
        return null;
    }
}
exports.SimplePath = SimplePath;


/***/ }),

/***/ "../harp-mapview/lib/text/TextCanvasFactory.ts":
/*!*****************************************************!*\
  !*** ../harp-mapview/lib/text/TextCanvasFactory.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextCanvasFactory = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
class TextCanvasFactory {
    /**
     * Creates an instance of text canvas factory.
     * @param m_renderer -
     */
    constructor(m_renderer) {
        this.m_renderer = m_renderer;
        this.m_minGlyphCount = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.
        this.m_maxGlyphCount = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.
    }
    setGlyphCountLimits(min, max) {
        this.m_minGlyphCount = min;
        this.m_maxGlyphCount = max;
    }
    /**
     * Creates text canvas
     * @param fontCatalog - Initial [[FontCatalog]].
     * @param name - Optional name for the TextCavas
     */
    createTextCanvas(fontCatalog, name) {
        harp_utils_1.assert(this.m_maxGlyphCount > 0);
        return new harp_text_canvas_1.TextCanvas({
            renderer: this.m_renderer,
            fontCatalog,
            minGlyphCount: this.m_minGlyphCount,
            maxGlyphCount: this.m_maxGlyphCount,
            name
        });
    }
}
exports.TextCanvasFactory = TextCanvasFactory;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElement.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/TextElement.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElement = exports.LoadingState = exports.poiIsRenderable = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * Return 'true' if the POI has been successfully prepared for rendering.
 *
 * @param poiInfo - PoiInfo containing information for rendering the POI icon.
 * @internal
 */
function poiIsRenderable(poiInfo) {
    return poiInfo.buffer !== undefined;
}
exports.poiIsRenderable = poiIsRenderable;
/**
 * State of loading.
 */
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["Requested"] = 0] = "Requested";
    LoadingState[LoadingState["Loaded"] = 1] = "Loaded";
    LoadingState[LoadingState["Initialized"] = 2] = "Initialized";
})(LoadingState = exports.LoadingState || (exports.LoadingState = {}));
/**
 * `TextElement` is used to create 2D text elements (for example, labels).
 * @internal
 */
class TextElement {
    /**
     * Creates a new `TextElement`.
     *
     * @param text - The text to display.
     * @param points - The position or a list of points for a curved text, both in world space.
     * @param renderParams - `TextElement` text rendering parameters.
     * @param layoutParams - `TextElement` text layout parameters.
     * @param priority - The priority of the `TextElement. Elements with the highest priority get
     *              placed first, elements with priority of `0` are placed last, elements with a
     *              negative value are always rendered, ignoring priorities and allowing overrides.
     * @param xOffset - Optional X offset of this `TextElement` in screen coordinates.
     * @param yOffset - Optional Y offset of this `TextElement` in screen coordinates.
     * @param featureId - Optional string to identify feature (originated from {@link DataSource}).
     *                  Number ids are deprecated in favor of strings.
     * @param fadeNear - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label starts fading out (opacity decreases).
     * @param fadeFar - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the
     *              label becomes transparent. A value of <= 0.0 disables fading.
     * @param offsetDirection - Direction represented as an angle in degrees clockwise from north to
     * offset the icon in world space.
     */
    constructor(text, points, renderParams, layoutParams, priority = 0, xOffset = 0, yOffset = 0, featureId, style, fadeNear, fadeFar, tileOffset, offsetDirection, dataSourceName, dataSourceOrder) {
        this.text = text;
        this.points = points;
        this.renderParams = renderParams;
        this.layoutParams = layoutParams;
        this.priority = priority;
        this.xOffset = xOffset;
        this.yOffset = yOffset;
        this.featureId = featureId;
        this.style = style;
        this.fadeNear = fadeNear;
        this.fadeFar = fadeFar;
        this.tileOffset = tileOffset;
        this.offsetDirection = offsetDirection;
        this.dataSourceName = dataSourceName;
        this.dataSourceOrder = dataSourceOrder;
        /**
         * Determines visibility. If set to `false`, it will not be rendered.
         */
        this.visible = true;
        /**
         * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.
         */
        this.distanceScale = 0.5;
        /**
         * If specified, determines the render order between `TextElement`s. The number different
         * renderOrders should be as small as possible, because every specific `renderOrder` may result
         * in one or more draw calls.
         *
         * TextElements with the same integer `renderOrder` will be rendered in the same batch.
         *
         * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other
         * map elements.
         *
         * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a
         * lower `renderOrder`.
         */
        this.renderOrder = 0;
        /**
         * If set to `true` the geometry has been already overlaid on elevation.
         */
        this.elevated = false;
        if (renderParams instanceof harp_text_canvas_1.TextRenderStyle) {
            this.renderStyle = renderParams;
        }
        if (layoutParams instanceof harp_text_canvas_1.TextLayoutStyle) {
            this.layoutStyle = layoutParams;
        }
        this.type =
            points instanceof THREE.Vector3 ? TextElementType_1.TextElementType.PoiLabel : TextElementType_1.TextElementType.PathLabel;
    }
    /**
     * The text element position or the first point of the path used to render a curved text, both
     * in world space.
     */
    get position() {
        if (this.points instanceof Array) {
            const p = this.points[0];
            return p;
        }
        return this.points;
    }
    /**
     * The list of points in world space used to render the text along a path or `undefined`.
     */
    get path() {
        if (this.points instanceof Array) {
            return this.points;
        }
        return undefined;
    }
    /**
     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.
     *
     * @default `false`
     */
    get textMayOverlap() {
        return this.mayOverlap === true;
    }
    set textMayOverlap(mayOverlap) {
        this.mayOverlap = mayOverlap;
    }
    /**
     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not
     * be able to overlap.
     *
     * @default `true`
     */
    get textReservesSpace() {
        return this.reserveSpace !== false;
    }
    set textReservesSpace(reserveSpace) {
        this.reserveSpace = reserveSpace;
    }
    /**
     * Contains additional information about icon to be rendered along with text.
     */
    get poiInfo() {
        return this.m_poiInfo;
    }
    set poiInfo(poiInfo) {
        this.m_poiInfo = poiInfo;
        if (poiInfo !== undefined) {
            if (this.path !== undefined) {
                this.type = TextElementType_1.TextElementType.LineMarker;
            }
            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;
            poiInfo.renderOrder = poiRenderOrder;
        }
    }
    /**
     * @returns The style used to render this text element, undefined if not set yet.
     */
    get renderStyle() {
        return this.m_renderStyle;
    }
    /**
     * Sets style used for text rendering.
     * @param style - The style to use.
     */
    set renderStyle(style) {
        this.m_renderStyle = style;
    }
    /**
     * @returns The style used to layout this text element, undefined if not set yet.
     */
    get layoutStyle() {
        return this.m_layoutStyle;
    }
    /**
     * Sets the style used for text layout.
     * @param style - The style to use.
     */
    set layoutStyle(style) {
        this.m_layoutStyle = style;
    }
    /**
     * @returns Whether this text element has a valid feature id.
     */
    hasFeatureId() {
        if (this.featureId === undefined) {
            return false;
        }
        if (typeof this.featureId === "number") {
            return this.featureId !== 0;
        }
        return this.featureId.length > 0;
    }
    /**
     * Disposes of any allocated resources.
     */
    dispose() {
        var _a;
        const poiBuffer = (_a = this.poiInfo) === null || _a === void 0 ? void 0 : _a.buffer;
        if (poiBuffer) {
            poiBuffer.decreaseRefCount();
        }
    }
}
exports.TextElement = TextElement;
/**
 * Text elements with this priority are placed on screen before any others.
 */
TextElement.HIGHEST_PRIORITY = Number.MAX_SAFE_INTEGER;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementBuilder.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementBuilder.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementBuilder = void 0;
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const PoiBuilder_1 = __webpack_require__(/*! ../poi/PoiBuilder */ "../harp-mapview/lib/poi/PoiBuilder.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ./TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TextElementBuilder");
/**
 * Constructs {@link TextElement} objects from {@link @here/harp-datasource-protocol/Technique},
 * text, coordinates and optional icon.
 */
class TextElementBuilder {
    /**
     * Constructor
     *
     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate
     * technique properties.
     * @param m_styleCache - To cache instances of {@link @here/harp-text-canvas/TextRenderStyle}
     * and {@link @here/harp-text-canvas/TextLayoutStyle}.
     */
    constructor(m_env, m_styleCache, m_baseRenderOrder) {
        this.m_env = m_env;
        this.m_styleCache = m_styleCache;
        this.m_baseRenderOrder = m_baseRenderOrder;
        this.m_distanceScale = TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
        this.m_renderOrder = m_baseRenderOrder;
        if (Number.isInteger(m_baseRenderOrder)) {
            this.renderOrderUpBound = TextElementBuilder.RENDER_ORDER_UP_BOUND;
        }
        else {
            // If base render order is not an integer, lower render order upper bound to leave room
            // for the decimal places.
            const absBaseRenderOrder = Math.abs(m_baseRenderOrder);
            this.renderOrderUpBound =
                (absBaseRenderOrder - Math.floor(absBaseRenderOrder)) *
                    TextElementBuilder.RENDER_ORDER_UP_BOUND;
        }
        if (!this.isValidRenderOrder(m_baseRenderOrder)) {
            logger.warn(`Large base render order (${m_baseRenderOrder}) might cause precision issues.`);
        }
    }
    /**
     * Aligns a {@link TextElement}'s minZoomLevel and maxZoomLevel with values set in
     * {@link PoiInfo}.
     * @remarks Selects the smaller/larger one of the two min/max values for icon and text, because
     * the TextElement is a container for both.
     * @param textElement - The {@link TextElement} whose zoom level ranges will be aligned.
     */
    static alignZoomLevelRanges(textElement) {
        var _a, _b;
        if (!textElement.poiInfo) {
            return;
        }
        const poiInfo = textElement.poiInfo;
        textElement.minZoomLevel = (_a = textElement.minZoomLevel) !== null && _a !== void 0 ? _a : harp_utils_1.MathUtils.min2(poiInfo.iconMinZoomLevel, poiInfo.textMinZoomLevel);
        textElement.maxZoomLevel = (_b = textElement.maxZoomLevel) !== null && _b !== void 0 ? _b : harp_utils_1.MathUtils.max2(poiInfo.iconMaxZoomLevel, poiInfo.textMaxZoomLevel);
    }
    /**
     * Combines two render order numbers into a single one.
     * @param baseRenderOrder - The most significative part of the render order.
     * @param offset - The least significative part of the render order. It must be within the
     * interval (-RENDER_ORDER_UP_BOUND, RENDER_ORDER_UP_BOUND).
     * @return The combined render order.
     */
    static composeRenderOrder(baseRenderOrder, offset) {
        return baseRenderOrder * TextElementBuilder.RENDER_ORDER_UP_BOUND + offset;
    }
    /**
     * Sets a technique that will be used to create text elements on subsequent calls to
     * {@link TextElementBuilder.build} until the next call to this method.
     *
     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.
     * @return This builder.
     */
    withTechnique(technique) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.m_technique = technique;
        // Make sorting stable.
        this.m_priority = (_a = harp_datasource_protocol_1.getPropertyValue(technique.priority, this.m_env)) !== null && _a !== void 0 ? _a : 0;
        this.m_fadeNear = (_b = harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, this.m_env)) !== null && _b !== void 0 ? _b : undefined;
        this.m_fadeFar = (_c = harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, this.m_env)) !== null && _c !== void 0 ? _c : undefined;
        this.m_minZoomLevel = (_d = harp_datasource_protocol_1.getPropertyValue(technique.minZoomLevel, this.m_env)) !== null && _d !== void 0 ? _d : undefined;
        this.m_maxZoomLevel = (_e = harp_datasource_protocol_1.getPropertyValue(technique.maxZoomLevel, this.m_env)) !== null && _e !== void 0 ? _e : undefined;
        this.m_distanceScale = (_f = technique.distanceScale) !== null && _f !== void 0 ? _f : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
        this.m_renderStyle = this.m_styleCache.getRenderStyle(technique);
        this.m_layoutStype = this.m_styleCache.getLayoutStyle(technique);
        this.m_xOffset = harp_datasource_protocol_1.getPropertyValue(technique.xOffset, this.m_env);
        this.m_yOffset = harp_datasource_protocol_1.getPropertyValue(technique.yOffset, this.m_env);
        const techniqueRenderOrder = (_g = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, this.m_env)) !== null && _g !== void 0 ? _g : 0;
        if (!this.isValidRenderOrder(techniqueRenderOrder)) {
            const msg = `Unsupported large render order (${techniqueRenderOrder})`;
            logger.error(msg);
            harp_utils_1.assert(false, msg);
        }
        this.m_renderOrder = TextElementBuilder.composeRenderOrder(this.m_baseRenderOrder, techniqueRenderOrder);
        if (harp_datasource_protocol_1.isTextTechnique(technique)) {
            this.withTextTechnique(technique);
        }
        else {
            this.withPoiTechnique(technique);
        }
        return this;
    }
    /**
     * Sets an icon that will be used to create text elements on subsequent calls to
     * {@link TextElementBuilder.build} until the next call to this method.
     *
     * @param imageTextureName - The name of the icon image.
     * @param shieldGroupIndex - Index to the shield group.
     * @return This builder.
     */
    withIcon(imageTextureName, shieldGroupIndex) {
        harp_utils_1.assert(this.m_poiBuilder !== undefined);
        this.m_poiBuilder.withIcon(imageTextureName, shieldGroupIndex);
        return this;
    }
    /**
     * Creates a {@link TextElement} with the given properties.
     *
     * @param text - The text to be displayed.
     * @param points - The position(s) for the text element.
     * @param tileOffset - The TextElement's tile offset, see {@link Tile.offset}.
     * @param dataSourceName - The name of the data source.
     * @param attributes - TextElement attribute map.
     * @param pathLengthSqr - Precomputed path length squared for path labels.
     * @return The created text element.
     */
    build(text, points, tileOffset, dataSourceName, dataSourceOrder, attributes, pathLengthSqr, offsetDirection) {
        var _a;
        const featureId = harp_datasource_protocol_1.getFeatureId(attributes);
        harp_utils_1.assert(this.m_technique !== undefined);
        harp_utils_1.assert(this.m_renderStyle !== undefined);
        harp_utils_1.assert(this.m_layoutStype !== undefined);
        const technique = this.m_technique;
        const renderStyle = this.m_renderStyle;
        const layoutStyle = this.m_layoutStype;
        const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(text), points, renderStyle, layoutStyle, this.m_priority, this.m_xOffset, this.m_yOffset, featureId, technique.style, this.m_fadeNear, this.m_fadeFar, tileOffset, offsetDirection, dataSourceName, dataSourceOrder);
        textElement.minZoomLevel = this.m_minZoomLevel;
        textElement.maxZoomLevel = this.m_maxZoomLevel;
        textElement.distanceScale = this.m_distanceScale;
        textElement.mayOverlap = this.m_mayOverlap;
        textElement.reserveSpace = this.m_reserveSpace;
        textElement.kind = technique.kind;
        // Get the userData for text element picking.
        textElement.userData = attributes;
        textElement.textFadeTime =
            technique.textFadeTime !== undefined ? technique.textFadeTime * 1000 : undefined;
        textElement.pathLengthSqr = pathLengthSqr;
        textElement.alwaysOnTop = this.m_alwaysOnTop;
        textElement.renderOrder = this.m_renderOrder;
        textElement.poiInfo = (_a = this.m_poiBuilder) === null || _a === void 0 ? void 0 : _a.build(textElement);
        TextElementBuilder.alignZoomLevelRanges(textElement);
        return textElement;
    }
    withTextTechnique(technique) {
        this.m_mayOverlap = technique.mayOverlap === true;
        this.m_reserveSpace = technique.reserveSpace !== false;
        this.m_poiBuilder = undefined;
    }
    withPoiTechnique(technique) {
        this.m_mayOverlap = technique.textMayOverlap === true;
        this.m_reserveSpace = technique.textReserveSpace !== false;
        this.m_alwaysOnTop = technique.alwaysOnTop === true;
        if (!this.m_poiBuilder) {
            this.m_poiBuilder = new PoiBuilder_1.PoiBuilder(this.m_env);
        }
        this.m_poiBuilder.withTechnique(technique);
    }
    isValidRenderOrder(renderOrder) {
        return Math.abs(renderOrder) < this.renderOrderUpBound;
    }
}
exports.TextElementBuilder = TextElementBuilder;
// Upper bound for render order values coming from a technique. The lowest upper bound
// (`renderOrderUpBound`) will be smaller if `baseRenderOrder` is not an integer.
TextElementBuilder.RENDER_ORDER_UP_BOUND = 1e7;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroup.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroup.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementGroup = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Group of {@link TextElement} sharing same priority.
 */
class TextElementGroup extends harp_utils_1.PriorityListGroup {
}
exports.TextElementGroup = TextElementGroup;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroupPriorityList.ts":
/*!****************************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroupPriorityList.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementGroupPriorityList = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * List of {@link TextElement} groups sorted by priority.
 */
class TextElementGroupPriorityList extends harp_utils_1.GroupedPriorityList {
}
exports.TextElementGroupPriorityList = TextElementGroupPriorityList;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementGroupState.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementGroupState.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementGroupState = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TextElementState_1 = __webpack_require__(/*! ./TextElementState */ "../harp-mapview/lib/text/TextElementState.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * `TextElementGroupState` keeps the state of a text element group and each element in it while
 * they're being rendered.
 */
class TextElementGroupState {
    /**
     * Creates the state for specified group.
     * @param group - The group of which the state will be created.
     * @param tileKey - The key of the tile to which this group belongs.
     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].
     */
    constructor(group, tileKey, filter) {
        this.group = group;
        this.tileKey = tileKey;
        this.m_visited = false;
        harp_utils_1.assert(group.elements.length > 0);
        const length = group.elements.length;
        this.m_textElementStates = [];
        this.m_visited = true;
        // TODO: HARP-7648. Reduce number of allocations here:
        // a) Avoid creating the state for labels that don't pass early placement checks and make
        //    this checks more strict.
        // b) Break label state objects into a set of arrays held at group level, one for each
        //    primitive field in the label state.
        for (let i = 0; i < length; ++i) {
            const textElement = group.elements[i];
            if (textElement.type === TextElementType_1.TextElementType.LineMarker && textElement.path !== undefined) {
                const numPoints = textElement.path.length;
                for (let p = 0; p < numPoints; p++) {
                    const state = new TextElementState_1.TextElementState(textElement, p);
                    const textDistance = filter(state);
                    state.update(textDistance);
                    this.m_textElementStates.push(state);
                }
            }
            else {
                const state = new TextElementState_1.TextElementState(textElement);
                const textDistance = filter(state);
                state.update(textDistance);
                this.m_textElementStates.push(state);
            }
        }
    }
    /**
     * Indicates whether the group has been submitted to the
     * {@link TextElementsRenderer} in the current frame.
     */
    get visited() {
        return this.m_visited;
    }
    set visited(visited) {
        this.m_visited = visited;
    }
    /**
     * @returns the priority of the text elements in the group.
     */
    get priority() {
        return this.group.priority;
    }
    /**
     * Updates the fading state of all text elements within the group to the specified time.
     * @param time - The time to which the fading state will be updated.
     * @param disableFading - `true` if fading is disabled, `false` otherwise.
     */
    updateFading(time, disableFading) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined) {
                elementState.updateFading(time, disableFading);
            }
        }
    }
    /**
     * Calls the specified callback for every visible text elements in the group.
     * @param visibleElementsCallback - Functions that will be called for every visible text element
     * in the group.
     */
    traverseVisibleElements(visibleElementsCallback) {
        for (const elementState of this.m_textElementStates) {
            if (elementState !== undefined && elementState.visible) {
                visibleElementsCallback(elementState);
            }
        }
    }
    /**
     * Updates the states of elements within the group.
     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].
     */
    updateElements(filter) {
        for (const elementState of this.m_textElementStates) {
            const textDistance = filter(elementState);
            elementState.update(textDistance);
        }
    }
    get size() {
        return this.m_textElementStates.length;
    }
    /**
     * Returns text element states.
     * @returns Array of element states.
     */
    get textElementStates() {
        return this.m_textElementStates;
    }
}
exports.TextElementGroupState = TextElementGroupState;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementState.ts":
/*!****************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementState.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isLineMarkerElementState = exports.TextElementState = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const LayoutState_1 = __webpack_require__(/*! ./LayoutState */ "../harp-mapview/lib/text/LayoutState.ts");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "../harp-mapview/lib/text/RenderState.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
/**
 * `TextElementState` keeps the current state of a text element while it's being rendered.
 */
class TextElementState {
    /**
     *
     * @param element - TextElement this state represents
     * @param positionIndex - Optional index for TextElements of type LineMarker.
     */
    constructor(element, positionIndex) {
        this.element = element;
        this.m_lineMarkerIndex = positionIndex;
    }
    get initialized() {
        return this.m_textRenderState !== undefined || this.m_iconRenderState !== undefined;
    }
    /**
     * @returns `true` if any component of the element is visible, `false` otherwise.
     */
    get visible() {
        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {
            return true;
        }
        const iconRenderState = this.iconRenderState;
        if (iconRenderState !== undefined && iconRenderState.isVisible()) {
            return true;
        }
        return false;
    }
    /**
     * Return the last text placement used.
     *
     * If the text wasn't yet rendered or have no alternative placements it will fallback to
     * style/theme based placement.
     *
     * @returns [[TextPlacement]] object containing vertical/horizontal align.
     */
    get textPlacement() {
        const themeLayout = this.element.layoutStyle;
        const stateLayout = this.m_textLayoutState;
        // Would be good to test for persistence when getting state layout, but with this
        // most of the isolated placement unit tests will fail.
        const lastPlacement = stateLayout !== undefined
            ? stateLayout.textPlacement
            : {
                h: harp_text_canvas_1.hPlacementFromAlignment(themeLayout.horizontalAlignment),
                v: harp_text_canvas_1.vPlacementFromAlignment(themeLayout.verticalAlignment)
            };
        return lastPlacement;
    }
    /**
     * Set text placement to be used.
     *
     * This may be base text anchor placement as defined by style or alternative placement.
     *
     * @param placement - The new [[TextPlacement]] to be used.
     */
    set textPlacement(placement) {
        if (this.m_textLayoutState === undefined && this.isBaseTextPlacement(placement) === true) {
            // Do nothing, layout state is not required cause we leave the base placement.
            return;
        }
        if (this.m_textLayoutState === undefined) {
            // State is not yet defined, but we have placement to store, either alternative or
            // not yet specified in the context of layoutStyle.
            this.m_textLayoutState = new LayoutState_1.LayoutState(placement);
        }
        else {
            this.m_textLayoutState.textPlacement = placement;
        }
    }
    /**
     * Returns information if the text placement provided is the base one defined in style (theme).
     *
     * @param placement - The [[TextPlacement]] to check.
     * @returns [[true]] if the placement provided is exactly the same as in theme base layout,
     * [[false]] if it differs from the basic layout provided in style or
     * [[undefined]] if the layout style is not yet defined so it is hard to say.
     */
    isBaseTextPlacement(placement) {
        const themeLayout = this.element.layoutStyle;
        if (themeLayout !== undefined) {
            return (harp_text_canvas_1.hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment &&
                harp_text_canvas_1.vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment);
        }
        return undefined;
    }
    /**
     * Resets the element to an initialized state.
     */
    reset() {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.reset();
        }
        if (this.m_textLayoutState !== undefined) {
            if (this.element.layoutStyle !== undefined) {
                this.m_textLayoutState.reset(this.element.layoutStyle);
            }
            else {
                this.m_textLayoutState = undefined;
            }
        }
        if (this.iconRenderState) {
            this.m_iconRenderState.reset();
        }
        this.m_viewDistance = undefined;
        this.element.textBufferObject = undefined;
        this.element.bounds = undefined;
    }
    /**
     * Replaces given text element, inheriting its current state.
     * The predecessor text element state is erased.
     * @param predecessor - Text element state to be replaced.
     */
    replace(predecessor) {
        this.m_textRenderState = predecessor.m_textRenderState;
        this.m_textLayoutState = predecessor.m_textLayoutState;
        this.m_iconRenderState = predecessor.m_iconRenderState;
        predecessor.m_textRenderState = undefined;
        predecessor.m_textLayoutState = undefined;
        predecessor.m_iconRenderState = undefined;
        if (this.element.glyphs === undefined) {
            // Use the predecessor glyphs and case array until proper ones are computed.
            this.element.glyphs = predecessor.element.glyphs;
            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;
        }
        this.element.bounds = undefined;
        this.element.textBufferObject = undefined;
    }
    /**
     * Returns the last computed distance of the text element to the camera.
     * @returns Distance to camera.
     */
    get viewDistance() {
        return this.m_viewDistance;
    }
    /**
     * Updates the text element state.
     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    update(viewDistance) {
        if (!this.initialized && viewDistance !== undefined) {
            this.initializeRenderStates();
        }
        this.setViewDistance(viewDistance);
    }
    /**
     * Sets the distance of the element to the current view center.
     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to
     * be out of view.
     */
    setViewDistance(viewDistance) {
        this.m_viewDistance = viewDistance;
    }
    /**
     * Return the last distance that has been computed for sorting during placement. This may not be
     * the actual distance if the camera is moving, as the distance is computed only during
     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.
     *
     * @returns 0 or negative distance to camera.
     */
    get renderDistance() {
        return this.element.alwaysOnTop === true
            ? 0
            : this.m_viewDistance !== undefined
                ? -this.m_viewDistance
                : 0;
    }
    /**
     * @returns The text render state.
     */
    get textRenderState() {
        return this.m_textRenderState;
    }
    /**
     * Returns the icon render state for the case where the text element has only one icon.
     * @returns The icon render state if the text element has a single icon, otherwise undefined.
     */
    get iconRenderState() {
        return this.m_iconRenderState;
    }
    /**
     * Returns the index into the path of the TextElement if the TextElement is of type LineMarker,
     * `undefined` otherwise.
     */
    get lineMarkerIndex() {
        return this.m_lineMarkerIndex;
    }
    /**
     * Returns the position of the TextElement. If this TextElementState belongs to a TextElement
     * of type LineMarker, it returns the position of the marker at the references index in the
     * path of the TextElement.
     */
    get position() {
        return this.element.path !== undefined && this.m_lineMarkerIndex !== undefined
            ? this.element.path[this.m_lineMarkerIndex]
            : this.element.position;
    }
    /**
     * Updates the fading state to the specified time.
     * @param time - The current time.
     * @param disableFading - If `True` there will be no fading transitions, i.e., state will go
     * directly from FadedIn to FadedOut and vice versa.
     */
    updateFading(time, disableFading) {
        if (this.m_textRenderState !== undefined) {
            this.m_textRenderState.updateFading(time, disableFading);
        }
        if (this.iconRenderState !== undefined) {
            this.iconRenderState.updateFading(time, disableFading);
        }
    }
    /**
     * Initialize text and icon render states
     */
    initializeRenderStates() {
        var _a;
        harp_utils_1.assert(this.m_textRenderState === undefined);
        harp_utils_1.assert(this.m_textLayoutState === undefined);
        harp_utils_1.assert(this.m_iconRenderState === undefined);
        const { textFadeTime } = this.element;
        this.m_textRenderState = new RenderState_1.RenderState(textFadeTime);
        if (this.element.type === TextElementType_1.TextElementType.PoiLabel ||
            this.element.type === TextElementType_1.TextElementType.LineMarker) {
            // If there's no fade time for icon, use same as text to keep fading of text and icon
            // in sync.
            const techniqueIconFadeTime = (_a = this.element.poiInfo) === null || _a === void 0 ? void 0 : _a.technique.iconFadeTime;
            const iconFadeTime = techniqueIconFadeTime !== undefined ? techniqueIconFadeTime * 1000 : textFadeTime;
            this.m_iconRenderState = new RenderState_1.RenderState(iconFadeTime);
        }
    }
}
exports.TextElementState = TextElementState;
/**
 * Test if the TextElement this {@link TextElementState} refers to is of type LineMarker.
 * @param state - Text element state to test.
 */
function isLineMarkerElementState(state) {
    return state.m_lineMarkerIndex !== undefined;
}
exports.isLineMarkerElementState = isLineMarkerElementState;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementStateCache.ts":
/*!*********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementStateCache.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementStateCache = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const TextElementGroupState_1 = __webpack_require__(/*! ./TextElementGroupState */ "../harp-mapview/lib/text/TextElementGroupState.ts");
const TextElementState_1 = __webpack_require__(/*! ./TextElementState */ "../harp-mapview/lib/text/TextElementState.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsStateCache", { level: harp_utils_1.LogLevel.Log });
/**
 * Label distance tolerance squared in meters. Point labels with the same name that are closer in
 * world space than this value are treated as the same label. Used to identify duplicate labels in
 * overlapping tiles and label replacements at different storage levels.
 */
function getDedupSqDistTolerance(zoomLevel) {
    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.
    const minSqTol = 100;
    const minSqTolLevel = 13;
    const maxLevelDelta = 4;
    const levelDelta = Math.min(maxLevelDelta, minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel)));
    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a
    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum
    // tolerance zoom level.
    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)
    return minSqTol << (levelDelta << 2);
}
const tmpCachedDuplicate = {
    entries: [],
    index: -1
};
function getCacheKey(element) {
    return element.hasFeatureId() ? element.featureId : element.text;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their feature ids.
 * @param elementState - The state of the text element for which the duplicate will be found.
 * @param candidates - The list of candidates to check.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateById(elementState, candidates) {
    // Cached entries with same feature id found, find the entry with the same tile offset.
    const element = elementState.element;
    const duplicateIndex = candidates.findIndex(entry => entry.element.tileOffset === element.tileOffset);
    if (duplicateIndex === -1) {
        return -1;
    }
    const candidateElement = candidates[duplicateIndex];
    const candidate = candidateElement.element;
    harp_utils_1.assert(element.featureId === candidate.featureId);
    if (candidate.text !== element.text) {
        // Labels with different text shouldn't share the same feature id. This points to
        // an issue on the map data side. Submit a ticket to the corresponding map backend
        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),
        // indicating affected labels including tile keys, texts and feature id.
        logger.debug(`Text feature id ${element.featureId} collision between "${element.text} and \
             ${candidate.text}`);
        return undefined;
    }
    return duplicateIndex;
}
// Duplicate criteria for path labels. Candidates are better the longer their paths are.
function isBetterPathDuplicate(newCandidate, _newDistance, oldCandidate, _oldDistance) {
    if (newCandidate.pathLengthSqr === undefined) {
        return false;
    }
    if (oldCandidate.pathLengthSqr === undefined) {
        return false;
    }
    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;
}
// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being
// tested for duplicates.
function isBetterPointDuplicate(_newCandidate, newDistance, _oldCandidate, oldDistance) {
    return newDistance < oldDistance;
}
/**
 * Finds a duplicate for a text element among a list of candidates using their text and distances.
 * @param elementState - The state of the text element for which the duplicate will be found.
 * @param candidates - The list of candidates to check.
 * @param zoomLevel - Current zoom level.
 * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.
 */
function findDuplicateByText(elementState, candidates, zoomLevel) {
    const element = elementState.element;
    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);
    const entryCount = candidates.length;
    const elementPosition = elementState.position;
    const elementVisible = elementState.visible;
    const isLineMarker = TextElementState_1.isLineMarkerElementState(elementState);
    let dupIndex = -1;
    let duplicate;
    let dupDistSquared = Infinity;
    const isBetterDuplicate = element.type === TextElementType_1.TextElementType.PathLabel ? isBetterPathDuplicate : isBetterPointDuplicate;
    for (let i = 0; i < entryCount; ++i) {
        const candidateEntry = candidates[i];
        const cachedElement = candidateEntry.element;
        const areDiffType = element.type !== cachedElement.type ||
            isLineMarker !== TextElementState_1.isLineMarkerElementState(candidateEntry);
        const areBothVisible = elementVisible && candidateEntry.visible;
        if (areDiffType || areBothVisible) {
            // Two text elements with different type or visible at the same time are always
            // considered distinct.
            continue;
        }
        const distSquared = elementPosition.distanceToSquared(cachedElement.position);
        if (distSquared > maxSqDistError) {
            // Cached text element is too far away to be a duplicate.
            continue;
        }
        if (duplicate === undefined ||
            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)) {
            dupIndex = i;
            duplicate = cachedElement;
            dupDistSquared = distSquared;
        }
    }
    return dupIndex;
}
/**
 * Caches the state of text element groups currently rendered as well as the text element states
 * belonging to them, including their fading state and text deduplication information.
 */
class TextElementStateCache {
    constructor() {
        this.m_referenceMap = new Map();
        // Cache for point labels which may have duplicates in same tile or in neighboring tiles.
        this.m_textMap = new Map();
    }
    /**
     * Gets the state corresponding to a given text element group or sets a newly created state if
     * not found. It updates the states of the text elements belonging to the group using the
     * specified parameters.
     * @param textElementGroup - The group of which the state will be obtained.
     * @param tileKey - The key of the tile to which the group belongs.
     * @param textElementFilter - Filter used to decide if a text element must be initialized,
     * @see [[TextElementGroupState]] construction.
     * @returns Tuple with the group state as first element and a boolean indicating whether the
     * state was found in cache (`true`) or newly created (`false`) as second element.
     */
    getOrSet(textElementGroup, tileKey, textElementFilter) {
        let groupState = this.get(textElementGroup);
        if (groupState !== undefined) {
            groupState.updateElements(textElementFilter);
            return [groupState, true];
        }
        groupState = new TextElementGroupState_1.TextElementGroupState(textElementGroup, tileKey, textElementFilter);
        this.set(textElementGroup, groupState);
        return [groupState, false];
    }
    get size() {
        return this.m_referenceMap.size;
    }
    /**
     * @hidden
     * @returns Size of internal cache for deduplication for debugging purposes.
     */
    get cacheSize() {
        return this.m_textMap.size;
    }
    /**
     * @returns All text element group states in the cache by group priority.
     */
    get sortedGroupStates() {
        if (this.m_sortedGroupStates === undefined) {
            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());
            this.m_sortedGroupStates.sort((a, b) => {
                return b.group.priority - a.group.priority;
            });
        }
        harp_utils_1.assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);
        return this.m_sortedGroupStates;
    }
    /**
     * Updates state of all cached groups, discarding those that are not needed anymore.
     * @param time - The current time.
     * @param disableFading - `True` if fading is currently disabled, `false` otherwise.
     * @param findReplacements - `True` to replace each visible unvisited text element with a
     * visited duplicate.
     * @param zoomLevel - Current zoom level.
     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.
     */
    update(time, disableFading, findReplacements, zoomLevel) {
        const replaceCallback = findReplacements
            ? this.replaceElement.bind(this, zoomLevel)
            : undefined;
        let anyEviction = false;
        for (const [key, groupState] of this.m_referenceMap.entries()) {
            if (groupState.visited) {
                groupState.updateFading(time, disableFading);
            }
            else {
                if (findReplacements) {
                    groupState.traverseVisibleElements(replaceCallback);
                }
                this.m_referenceMap.delete(key);
                this.m_sortedGroupStates = undefined;
                anyEviction = true;
            }
        }
        return anyEviction;
    }
    /**
     * Clears visited state for all text element groups in cache.
     */
    clearVisited() {
        for (const groupState of this.m_referenceMap.values()) {
            groupState.visited = false;
        }
    }
    clearTextCache() {
        this.m_textMap.clear();
    }
    /**
     * Clears the whole cache contents.
     */
    clear() {
        this.m_referenceMap.clear();
        this.m_sortedGroupStates = undefined;
        this.m_textMap.clear();
    }
    /**
     * Removes duplicates for a given text element.
     *
     * @param zoomLevel - Current zoom level.
     * @param elementState - State of the text element to deduplicate.
     * @returns True if it's the remaining element after deduplication, false if it's been marked
     * as duplicate.
     */
    deduplicateElement(zoomLevel, elementState) {
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined) {
            // Text not found so far, add this element to cache.
            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);
            return true;
        }
        if (cacheResult.index === -1) {
            // No duplicate found among elements with same text,add this one to cache.
            cacheResult.entries.push(elementState);
            return true;
        }
        // Duplicate found, check whether there's a label already visible and keep that one.
        const cachedDuplicate = cacheResult.entries[cacheResult.index];
        if (!cachedDuplicate.visible && elementState.visible) {
            // New label is visible, substitute the cached label.
            cacheResult.entries[cacheResult.index] = elementState;
            cachedDuplicate.reset();
            return true;
        }
        return false;
    }
    /**
     * Replaces a visible unvisited text element with a visited duplicate.
     * @param zoomLevel - Current zoom level.
     * @param elementState - State of the text element to deduplicate.
     * @returns `true` if an item from the cache has been reused and its state has been replaced,
     * `false` otherwise.
     */
    replaceElement(zoomLevel, elementState) {
        harp_utils_1.assert(elementState.visible);
        const cacheResult = this.findDuplicate(elementState, zoomLevel);
        if (cacheResult === undefined || cacheResult.index === -1) {
            // No replacement found;
            return false;
        }
        const replacement = cacheResult.entries[cacheResult.index];
        harp_utils_1.assert(!replacement.visible);
        replacement.replace(elementState);
        return true;
    }
    /**
     * Gets the state corresponding to a given text element group.
     * @param textElementGroup - The group of which the state will be obtained.
     * @returns The group state if cached, otherwise `undefined`.
     */
    get(textElementGroup) {
        const groupState = this.m_referenceMap.get(textElementGroup);
        if (groupState !== undefined) {
            groupState.visited = true;
        }
        return groupState;
    }
    /**
     * Sets a specified state for a given text element group.
     * @param textElementGroup -  The group of which the state will be set.
     * @param textElementGroupState - The state to set for the group.
     */
    set(textElementGroup, textElementGroupState) {
        harp_utils_1.assert(textElementGroup.elements.length > 0);
        this.m_referenceMap.set(textElementGroup, textElementGroupState);
        this.m_sortedGroupStates = undefined;
    }
    findDuplicate(elementState, zoomLevel) {
        // Point labels may have duplicates (as can path labels), Identify them
        // and keep the one we already display.
        const element = elementState.element;
        const cachedEntries = this.m_textMap.get(getCacheKey(element));
        if (cachedEntries === undefined) {
            // No labels found with the same key.
            return undefined;
        }
        tmpCachedDuplicate.entries = cachedEntries;
        const index = element.hasFeatureId()
            ? findDuplicateById(elementState, cachedEntries)
            : findDuplicateByText(elementState, cachedEntries, zoomLevel);
        if (index === undefined) {
            // Feature id collision, try finding duplicates using text as key.
            element.featureId = undefined;
            return this.findDuplicate(elementState, zoomLevel);
        }
        tmpCachedDuplicate.index = index;
        return tmpCachedDuplicate;
    }
}
exports.TextElementStateCache = TextElementStateCache;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementType.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementType.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementType = void 0;
/**
 * Types of text elements.
 */
var TextElementType;
(function (TextElementType) {
    TextElementType[TextElementType["PoiLabel"] = 0] = "PoiLabel";
    TextElementType[TextElementType["PathLabel"] = 1] = "PathLabel";
    TextElementType[TextElementType["LineMarker"] = 2] = "LineMarker";
})(TextElementType = exports.TextElementType || (exports.TextElementType = {}));


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementsRenderer.ts":
/*!********************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementsRenderer.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementsRenderer = exports.DEFAULT_TEXT_DISTANCE_SCALE = exports.DEFAULT_FONT_CATALOG_NAME = void 0;
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const DebugContext_1 = __webpack_require__(/*! ../DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const overlayOnElevation_1 = __webpack_require__(/*! ../geometry/overlayOnElevation */ "../harp-mapview/lib/geometry/overlayOnElevation.ts");
const PickHandler_1 = __webpack_require__(/*! ../PickHandler */ "../harp-mapview/lib/PickHandler.ts");
const PoiRenderer_1 = __webpack_require__(/*! ../poi/PoiRenderer */ "../harp-mapview/lib/poi/PoiRenderer.ts");
const ScreenCollisions_1 = __webpack_require__(/*! ../ScreenCollisions */ "../harp-mapview/lib/ScreenCollisions.ts");
const FontCatalogLoader_1 = __webpack_require__(/*! ./FontCatalogLoader */ "../harp-mapview/lib/text/FontCatalogLoader.ts");
const Placement_1 = __webpack_require__(/*! ./Placement */ "../harp-mapview/lib/text/Placement.ts");
const PlacementStats_1 = __webpack_require__(/*! ./PlacementStats */ "../harp-mapview/lib/text/PlacementStats.ts");
const SimplePath_1 = __webpack_require__(/*! ./SimplePath */ "../harp-mapview/lib/text/SimplePath.ts");
const TextCanvasFactory_1 = __webpack_require__(/*! ./TextCanvasFactory */ "../harp-mapview/lib/text/TextCanvasFactory.ts");
const TextElement_1 = __webpack_require__(/*! ./TextElement */ "../harp-mapview/lib/text/TextElement.ts");
const TextElementsRendererOptions_1 = __webpack_require__(/*! ./TextElementsRendererOptions */ "../harp-mapview/lib/text/TextElementsRendererOptions.ts");
const TextElementStateCache_1 = __webpack_require__(/*! ./TextElementStateCache */ "../harp-mapview/lib/text/TextElementStateCache.ts");
const TextElementType_1 = __webpack_require__(/*! ./TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
const TextStyleCache_1 = __webpack_require__(/*! ./TextStyleCache */ "../harp-mapview/lib/text/TextStyleCache.ts");
const UpdateStats_1 = __webpack_require__(/*! ./UpdateStats */ "../harp-mapview/lib/text/UpdateStats.ts");
var Pass;
(function (Pass) {
    Pass[Pass["PersistentLabels"] = 0] = "PersistentLabels";
    Pass[Pass["NewLabels"] = 1] = "NewLabels";
})(Pass || (Pass = {}));
exports.DEFAULT_FONT_CATALOG_NAME = "default";
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 * @internal
 */
exports.DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
/**
 * Maximum number of recommended labels. If more labels are encountered, the "overloaded" mode is
 * set, which modifies the behavior of label placement and rendering, trying to keep delivering an
 * interactive performance. The overloaded mode should not be activated if the {@link MapView} is
 * rendering a static image (camera not moving and no animation running).
 */
const OVERLOAD_LABEL_LIMIT = 20000;
/**
 * If "overloaded" is `true`:
 *
 * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the
 * camera is not moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].
 */
const OVERLOAD_UPDATED_LABEL_LIMIT = 100;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].
 */
const OVERLOAD_UPDATE_TIME_LIMIT = 5;
/**
 * If "overloaded" is `true`:
 *
 * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not
 * moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].
 */
const OVERLOAD_PLACE_TIME_LIMIT = 10;
const logger = harp_utils_1.LoggerManager.instance.create("TextElementsRenderer", { level: harp_utils_1.LogLevel.Log });
// Development flag: Enable debug print.
const PRINT_LABEL_DEBUG_INFO = false;
const updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats_1.UpdateStats(logger) : undefined;
const placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats_1.PlacementStats(logger) : undefined;
const tempPosition = new THREE.Vector3();
const tempScreenPosition = new THREE.Vector2();
const tempScreenPoints = [];
const tempPoiScreenPosition = new THREE.Vector2();
const tmpTextBufferCreationParams = {};
const tmpAdditionParams = {};
const tmpBufferAdditionParams = {};
const cache = {
    vector2: [new THREE.Vector2()]
};
class TileTextElements {
    constructor(tile, group) {
        this.tile = tile;
        this.group = group;
    }
}
class TextElementLists {
    constructor(lists) {
        this.lists = lists;
    }
    get priority() {
        harp_utils_1.assert(this.lists.length > 0);
        // All text element lists here have the same priority.
        return this.lists[0].group.priority;
    }
    /**
     * Sum up the number of elements in all lists.
     */
    count() {
        let n = 0;
        for (const list of this.lists) {
            n += list.group.elements.length;
        }
        return n;
    }
}
function checkIfTextElementsChanged(dataSourceTileList) {
    let textElementsChanged = false;
    dataSourceTileList.forEach(({ renderedTiles }) => {
        renderedTiles.forEach(tile => {
            if (tile.textElementsChanged) {
                tile.textElementsChanged = false;
                textElementsChanged = true;
            }
        });
    });
    return textElementsChanged;
}
function hasTextElements(dataSourceTileList) {
    for (let i = 0; i < dataSourceTileList.length; i++) {
        for (const [_key, value] of dataSourceTileList[i].renderedTiles) {
            if (value.hasTextElements()) {
                return true;
            }
        }
    }
    return false;
}
function addTextToCanvas(textElement, canvas, screenPosition, path, pathOverflow) {
    tmpAdditionParams.path = path;
    tmpAdditionParams.pathOverflow = pathOverflow;
    tmpAdditionParams.layer = textElement.renderOrder;
    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;
    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addText(textElement.glyphs, screenPosition, tmpAdditionParams);
}
function addTextBufferToCanvas(textElementState, canvas, screenPosition, fadeFactor, scaleFactor) {
    const textElement = textElementState.element;
    const textRenderState = textElementState.textRenderState;
    const opacity = textRenderState.opacity * fadeFactor * textElement.renderStyle.opacity;
    if (opacity === 0) {
        return false;
    }
    // Compute the TextBufferObject when we know we're gonna render this label.
    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;
    if (textElement.textBufferObject === undefined) {
        textElement.textBufferObject = canvas.createTextBufferObject(textElement.glyphs, tmpTextBufferCreationParams);
    }
    const backgroundIsVisible = textElement.renderStyle.backgroundOpacity > 0 &&
        canvas.textRenderStyle.fontSize.backgroundSize > 0;
    tmpBufferAdditionParams.layer = textElement.renderOrder;
    tmpBufferAdditionParams.position = screenPosition;
    tmpBufferAdditionParams.scale = scaleFactor;
    tmpBufferAdditionParams.opacity = opacity;
    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible
        ? tmpBufferAdditionParams.opacity * textElement.renderStyle.backgroundOpacity
        : 0.0;
    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;
    canvas.addTextBufferObject(textElement.textBufferObject, tmpBufferAdditionParams);
    return true;
}
function shouldRenderPointText(labelState, viewState, options) {
    const textRenderState = labelState.textRenderState;
    const label = labelState.element;
    const poiInfo = label.poiInfo;
    harp_utils_1.assert(label.type !== TextElementType_1.TextElementType.PathLabel);
    const hasText = textRenderState !== undefined && label.text !== "";
    if (!hasText) {
        return false;
    }
    const visibleInZoomLevel = poiInfo === undefined ||
        harp_utils_1.MathUtils.isClamped(viewState.zoomLevel, poiInfo.textMinZoomLevel, poiInfo.textMaxZoomLevel);
    if (!visibleInZoomLevel) {
        return false;
    }
    const poiTextMaxDistance = Placement_1.getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels);
    const visibleAtDistance = label.ignoreDistance === true ||
        labelState.viewDistance === undefined ||
        (labelState.viewDistance < poiTextMaxDistance && labelState.viewDistance > 0);
    if (!visibleAtDistance) {
        return false;
    }
    // If there's an icon, render text only if icon is valid or optional.
    return !poiInfo || poiInfo.isValid === true || poiInfo.iconIsOptional === true;
}
function shouldRenderPoiText(labelState, viewState) {
    // Do not actually render (just allocate space) if camera is moving and
    // renderTextDuringMovements is not true.
    const poiInfo = labelState.element.poiInfo;
    return (!viewState.cameraIsMoving ||
        poiInfo === undefined ||
        poiInfo.renderTextDuringMovements === true);
}
function isPlacementTimeExceeded(startTime) {
    // startTime is set in overload mode.
    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {
        return false;
    }
    const endTime = harp_utils_1.PerformanceTimer.now();
    const elapsedTime = endTime - startTime;
    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {
        logger.debug("Placement time limit exceeded.");
        return true;
    }
    return false;
}
function createDefaultFontCatalogConfig(defaultFontCatalogUrl) {
    return {
        name: exports.DEFAULT_FONT_CATALOG_NAME,
        url: defaultFontCatalogUrl
    };
}
/**
 *
 * Internal class to manage all text rendering.
 */
class TextElementsRenderer {
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * {@link TextElement}s every frame.
     *
     * @param m_viewState - State of the view for which this renderer will draw text.
     * @param m_screenProjector - Projects 3D coordinates into screen space.
     * @param m_poiManager - To prepare pois for rendering.
     * @param m_renderer - The renderer to be used.
     * @param m_imageCaches - The Image Caches to look for Icons.
     * @param options - Configuration options for the text renderer. See
     * @param textCanvasFactory - Optional A TextCanvasFactory to override the default.
     * @param poiRenderer - Optional A PoiRenderer to override the default.
     * @param screenCollisions - Optional  ScreenCollisions to override the default.
     * [[TextElementsRendererOptions]].
     */
    constructor(m_viewState, m_screenProjector, m_poiManager, m_renderer, m_imageCaches, options, textCanvasFactory, poiRenderer, screenCollisions) {
        this.m_viewState = m_viewState;
        this.m_screenProjector = m_screenProjector;
        this.m_poiManager = m_poiManager;
        this.m_renderer = m_renderer;
        this.m_imageCaches = m_imageCaches;
        this.m_loadPromisesCount = 0;
        this.m_textCanvases = new Map();
        this.m_tmpVector = new THREE.Vector2();
        this.m_tmpVector3 = new THREE.Vector3();
        this.m_cameraLookAt = new THREE.Vector3();
        this.m_overloaded = false;
        this.m_cacheInvalidated = false;
        this.m_addNewLabels = true;
        this.m_forceNewLabelsPass = false;
        this.m_textElementStateCache = new TextElementStateCache_1.TextElementStateCache();
        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1);
        this.m_textStyleCache = new TextStyleCache_1.TextStyleCache();
        this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisions();
        /**
         * indicates if the TextElementsRenderer is still updating, includes fading, elevations etc
         */
        this.m_isUpdatePending = false;
        this.m_options = Object.assign({}, options);
        TextElementsRendererOptions_1.initializeDefaultOptions(this.m_options);
        if (screenCollisions) {
            this.m_screenCollisions = screenCollisions;
        }
        else if (this.m_options.collisionDebugCanvas !== undefined &&
            this.m_options.collisionDebugCanvas !== null) {
            this.m_screenCollisions = new ScreenCollisions_1.ScreenCollisionsDebug(this.m_options.collisionDebugCanvas);
        }
        this.m_textCanvasFactory = textCanvasFactory !== null && textCanvasFactory !== void 0 ? textCanvasFactory : new TextCanvasFactory_1.TextCanvasFactory(this.m_renderer);
        this.m_textCanvasFactory.setGlyphCountLimits(this.m_options.minNumGlyphs, this.m_options.maxNumGlyphs);
        this.m_poiRenderer = poiRenderer !== null && poiRenderer !== void 0 ? poiRenderer : new PoiRenderer_1.PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
        this.initializeCamera();
        this.initializeDefaultFontCatalog();
        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
    }
    /**
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable) {
        this.m_options.disableFading = disable;
    }
    get disableFading() {
        return this.m_options.disableFading === true;
    }
    get styleCache() {
        return this.m_textStyleCache;
    }
    get delayLabelsUntilMovementFinished() {
        return this.m_options.delayLabelsUntilMovementFinished === true;
    }
    set delayLabelsUntilMovementFinished(delay) {
        this.m_options.delayLabelsUntilMovementFinished = delay;
    }
    /**
     * If `true`, a replacement glyph ("?") is rendered for every missing glyph.
     */
    get showReplacementGlyphs() {
        return this.m_options.showReplacementGlyphs === true;
    }
    /**
     * If `true`, a replacement glyph ("?") is rendered for every missing glyph.
     */
    set showReplacementGlyphs(value) {
        this.m_options.showReplacementGlyphs = value;
        this.m_textCanvases.forEach(textCanvas => {
            if (textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.fontCatalog) {
                textCanvas.fontCatalog.showReplacementGlyphs = value;
            }
        });
    }
    restoreRenderers(renderer) {
        this.m_renderer = renderer;
        this.m_poiRenderer = new PoiRenderer_1.PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);
        //TODO: restore TextCanvasRenderers
    }
    /**
     * Updates the FontCatalogs used by this {@link TextElementsRenderer}.
     *
     * @param fontCatalogs - The new list of {@link FontCatalogConfig}s
     */
    async updateFontCatalogs(fontCatalogs) {
        if (this.m_defaultFontCatalogConfig) {
            if (!fontCatalogs ||
                fontCatalogs.findIndex(config => {
                    return config.name === exports.DEFAULT_FONT_CATALOG_NAME;
                }) === -1) {
                // not other default catalog available, keep the old one
                if (!fontCatalogs) {
                    fontCatalogs = [];
                }
                // Never remove the default Canvas if set per configuration
                fontCatalogs.unshift(this.m_defaultFontCatalogConfig);
            }
            else {
                if (this.m_textCanvases.has(exports.DEFAULT_FONT_CATALOG_NAME)) {
                    this.m_textCanvases.delete(exports.DEFAULT_FONT_CATALOG_NAME);
                }
            }
        }
        if (fontCatalogs && fontCatalogs.length > 0) {
            // Remove obsolete ones
            for (const [name] of this.m_textCanvases) {
                if (fontCatalogs.findIndex(catalog => {
                    return catalog.name === name;
                }) < 0) {
                    this.m_textCanvases.delete(name);
                }
            }
            // Add new catalogs
            for (const fontCatalog of fontCatalogs) {
                await this.addTextCanvas(fontCatalog);
            }
        }
        else {
            this.m_textCanvases.clear();
        }
        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
    }
    async updateTextStyles(textStyles, defaultTextStyle) {
        this.m_textStyleCache.updateTextStyles(textStyles, defaultTextStyle);
        await this.waitLoaded();
        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
        this.invalidateCache();
    }
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera - Orthographic camera to use.
     */
    renderText(farPlane) {
        this.m_camera.far = farPlane;
        this.updateGlyphDebugMesh();
        let previousLayer;
        this.m_poiRenderer.update();
        for (const poiLayer of this.m_poiRenderer.layers) {
            for (const [, textCanvas] of this.m_textCanvases) {
                textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, poiLayer.id, undefined, false);
            }
            this.m_poiRenderer.render(this.m_camera, poiLayer);
            previousLayer = poiLayer;
        }
        for (const [, textCanvas] of this.m_textCanvases) {
            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.render(this.m_camera, previousLayer === null || previousLayer === void 0 ? void 0 : previousLayer.id, undefined, undefined, false);
        }
    }
    /**
     * Forces update of text elements in the next call to [[placeText]].
     */
    invalidateCache() {
        this.m_cacheInvalidated = true;
    }
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted() {
        if (this.delayLabelsUntilMovementFinished) {
            this.m_addNewLabels = false;
        }
    }
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished() {
        this.invalidateCache();
        if (this.delayLabelsUntilMovementFinished) {
            this.m_addNewLabels = true;
        }
    }
    /**
     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded() {
        return this.m_overloaded;
    }
    /**
     * Places text elements for the current frame.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     * @param time - Current frame time.
     */
    placeText(dataSourceTileList, time) {
        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);
        const textElementsAvailable = this.hasOverlayText() || tileTextElementsChanged || hasTextElements(dataSourceTileList);
        this.m_isUpdatePending = false;
        if (!textElementsAvailable &&
            !this.m_cacheInvalidated &&
            !this.m_viewState.renderedTilesChanged) {
            return;
        }
        const updateTextElements = this.m_cacheInvalidated ||
            tileTextElementsChanged ||
            this.m_viewState.renderedTilesChanged;
        const findReplacements = updateTextElements && this.m_addNewLabels;
        if (findReplacements) {
            this.m_textElementStateCache.clearVisited();
            this.updateTextElements(dataSourceTileList);
        }
        const anyTextGroupEvicted = this.m_textElementStateCache.update(time, this.m_options.disableFading, findReplacements, this.m_viewState.zoomLevel);
        // TODO: this seems extremly suboptimal.. review if an update is possible
        this.reset();
        if (this.m_addNewLabels) {
            this.prepopulateScreenWithBlockingElements(dataSourceTileList);
        }
        // New text elements must be placed either if text elements were updated in this frame
        // or if any text element group was evicted. The second case happens when the group is not
        // visited anymore and all it's elements just became invisible, which means there's newly
        // available screen space where new text elements could be placed. A common scenario where
        // this happens is zooming in/out: text groups from the old level may still be fading out
        // after all groups in the new level were updated.
        const placeNewTextElements = (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;
        this.placeTextElements(time, placeNewTextElements);
        this.placeOverlayTextElements();
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    addOverlayText(textElements) {
        if (textElements.length === 0) {
            return;
        }
        this.m_overlayTextElements =
            this.m_overlayTextElements === undefined
                ? textElements.slice()
                : this.m_overlayTextElements.concat(textElements);
    }
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    clearOverlayText() {
        this.m_overlayTextElements = [];
    }
    /**
     * @returns Whether there's overlay text to be rendered.
     */
    hasOverlayText() {
        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;
    }
    get overlayText() {
        return this.m_overlayTextElements;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link TextElement}s are found, the order of the results is unspecified.
     *
     * Note: {@link TextElement}s with identical `featureId` or
     * identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickResults - Array filled with pick results.
     */
    pickTextElements(screenPosition, pickListener) {
        const pickHandler = (pickData, pickObjectType) => {
            if (pickData === undefined) {
                return;
            }
            const textElement = pickData;
            const pickResult = {
                type: pickObjectType,
                point: screenPosition,
                distance: 0,
                renderOrder: textElement.renderOrder,
                featureId: textElement.featureId,
                userData: textElement.userData,
                dataSourceName: textElement.dataSourceName,
                dataSourceOrder: textElement.dataSourceOrder,
                text: textElement.text
            };
            pickListener.addResult(pickResult);
        };
        for (const [, textCanvas] of this.m_textCanvases) {
            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.pickText(screenPosition, (pickData) => {
                pickHandler(pickData, PickHandler_1.PickObjectType.Text);
            });
        }
        this.m_poiRenderer.pickTextElements(screenPosition, (pickData) => {
            pickHandler(pickData, PickHandler_1.PickObjectType.Icon);
        });
    }
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading() {
        return this.m_loadPromisesCount > 0;
    }
    /**
     * `true` if TextElements are not placed finally but are still updating, including fading or
     * waiting for elevation.
     */
    get isUpdatePending() {
        return this.m_isUpdatePending;
    }
    /**
     * Waits till all pending resources from any `FontCatalog` are loaded.
     */
    async waitLoaded() {
        if (this.m_loadPromise !== undefined) {
            return await this.m_loadPromise;
        }
    }
    /**
     * Reset the current text render states of all visible tiles.
     *
     * @remarks
     * All {@link TextElement}s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates() {
        this.m_textElementStateCache.clear();
    }
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage() {
        const memoryUsage = {
            heapSize: 0,
            gpuSize: 0
        };
        for (const [, textCanvas] of this.m_textCanvases) {
            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.getMemoryUsage(memoryUsage);
        }
        this.m_poiRenderer.getMemoryUsage(memoryUsage);
        return memoryUsage;
    }
    async addDefaultTextCanvas() {
        if (this.m_textCanvases.has(exports.DEFAULT_FONT_CATALOG_NAME) ||
            !this.m_defaultFontCatalogConfig) {
            return;
        }
        await this.addTextCanvas(this.m_defaultFontCatalogConfig);
        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);
    }
    /**
     * Reset internal state at the beginning of a frame.
     */
    reset() {
        this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);
        this.m_screenCollisions.reset();
        for (const [, textCanvas] of this.m_textCanvases) {
            textCanvas === null || textCanvas === void 0 ? void 0 : textCanvas.clear();
        }
        this.m_poiRenderer.reset();
    }
    /**
     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].
     * @note These boxes have highest priority, so will block all other labels.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    prepopulateScreenWithBlockingElements(dataSourceTileList) {
        const boxes = [];
        dataSourceTileList.forEach(renderListEntry => {
            const startLinePointProj = new THREE.Vector3();
            const endLinePointProj = new THREE.Vector3();
            for (const tile of renderListEntry.renderedTiles.values()) {
                for (const pathBlockingElement of tile.blockingElements) {
                    if (pathBlockingElement.points.length < 2) {
                        continue;
                    }
                    this.m_screenProjector.project3(pathBlockingElement.points[0], startLinePointProj);
                    for (let i = 1; i < pathBlockingElement.points.length; i++) {
                        this.m_screenProjector.project3(pathBlockingElement.points[i], endLinePointProj);
                        const line = pathBlockingElement.screenSpaceLines[i - 1];
                        line.start.copy(startLinePointProj);
                        line.end.copy(endLinePointProj);
                        const lineWithBound = {
                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),
                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),
                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),
                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),
                            line
                        };
                        boxes.push(lineWithBound);
                        startLinePointProj.copy(endLinePointProj);
                    }
                }
            }
        });
        this.m_screenCollisions.allocateIBoxes(boxes);
    }
    /**
     * @returns True if whole group was processed for placement,
     * false otherwise (e.g. placement limit reached).
     */
    placeTextElementGroup(groupState, renderParams, maxNumPlacedLabels, pass) {
        var _a;
        // Unvisited text elements are never placed.
        harp_utils_1.assert(groupState.visited);
        const shieldGroups = [];
        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;
        const projection = this.m_viewState.projection;
        const elevationProvider = this.m_viewState.elevationProvider;
        const elevationMap = elevationProvider === null || elevationProvider === void 0 ? void 0 : elevationProvider.getDisplacementMap(groupState.tileKey);
        for (const textElementState of groupState.textElementStates) {
            if (pass === Pass.PersistentLabels) {
                if (placementStats) {
                    ++placementStats.total;
                }
            }
            // Limit labels only in new labels pass (Pass.NewLabels).
            else if (maxNumPlacedLabels !== undefined &&
                renderParams.numRenderedTextElements >= maxNumPlacedLabels) {
                logger.debug("Placement label limit exceeded.");
                return false;
            }
            // Skip all labels that are not initialized (didn't pass early placement tests)
            // or don't belong to this pass.
            if (!textElementState.initialized) {
                if (placementStats) {
                    ++placementStats.uninitialized;
                }
                continue;
            }
            if (textElementState.viewDistance === undefined || textElementState.viewDistance < 0) {
                if (placementStats) {
                    ++placementStats.tooFar;
                }
                continue;
            }
            const elementVisible = textElementState.visible;
            if ((pass === Pass.PersistentLabels && !elementVisible) ||
                (pass === Pass.NewLabels && elementVisible)) {
                continue;
            }
            const textElement = textElementState.element;
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.
            // Check if the label should be hidden.
            if (hiddenKinds !== undefined &&
                textElement.kind !== undefined &&
                hiddenKinds.hasOrIntersects(textElement.kind)) {
                continue;
            }
            if (elevationProvider !== undefined && !textElement.elevated) {
                if (!elevationMap) {
                    this.m_isUpdatePending = true;
                    this.m_forceNewLabelsPass = true;
                    continue;
                }
                overlayOnElevation_1.overlayTextElement(textElement, elevationProvider, elevationMap, projection);
            }
            const elementType = textElement.type;
            const isPathLabel = elementType === TextElementType_1.TextElementType.PathLabel;
            // For paths, check if the label may fit.
            if (isPathLabel) {
                if (Placement_1.isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {
                    if (placementStats) {
                        placementStats.numNotVisible++;
                    }
                    if (textElement.dbgPathTooSmall === true) {
                        if (placementStats) {
                            placementStats.numPathTooSmall++;
                        }
                    }
                    textElementState.reset();
                    continue;
                }
            }
            const forceNewPassOnLoaded = true;
            if (textCanvas) {
                // This ensures that textElement.renderStyle and textElement.layoutStyle are
                // already instantiated and initialized with theme style values.
                if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {
                    continue;
                }
                const layer = textCanvas.getLayer((_a = textElement.renderOrder) !== null && _a !== void 0 ? _a : harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
                // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
                if (layer !== undefined) {
                    if (layer.storage.drawCount + textElement.glyphs.length >
                        layer.storage.capacity) {
                        if (placementStats) {
                            ++placementStats.numCannotAdd;
                        }
                        logger.warn("layer glyph storage capacity exceeded.");
                        continue;
                    }
                }
                // Set the current style for the canvas.
                // This means text canvas has always references (not a copy) to text element styles.
                // The only exception is multi-anchor placement where layoutStyle need to be
                // modified and thus textCanvas will using its own copy of textElement.layoutStyle.
                // See: placePointLabel()
                textCanvas.textRenderStyle = textElement.renderStyle;
                textCanvas.textLayoutStyle = textElement.layoutStyle;
            }
            switch (elementType) {
                case TextElementType_1.TextElementType.PoiLabel:
                    this.addPoiLabel(textElementState, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.LineMarker:
                    this.addLineMarkerLabel(textElementState, shieldGroups, textCanvas, renderParams);
                    break;
                case TextElementType_1.TextElementType.PathLabel:
                    if (textCanvas) {
                        this.addPathLabel(textElementState, tempScreenPoints, textCanvas, renderParams);
                    }
            }
        }
        return true;
    }
    initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded) {
        // Trigger the glyph load if needed.
        if (textElement.loadingState === TextElement_1.LoadingState.Initialized) {
            return textElement.glyphs !== undefined;
        }
        harp_utils_1.assert(textElementStyle.textCanvas !== undefined);
        const textCanvas = textElementStyle.textCanvas;
        if (textElement.loadingState === undefined) {
            textElement.loadingState = TextElement_1.LoadingState.Requested;
            if (textElement.renderStyle === undefined) {
                textElement.renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, textElementStyle.renderParams), textElement.renderParams));
            }
            if (textElement.layoutStyle === undefined) {
                textElement.layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, textElementStyle.layoutParams), textElement.layoutParams));
            }
            if (textElement.text === "") {
                textElement.loadingState = TextElement_1.LoadingState.Loaded;
            }
            else {
                const newLoadPromise = textCanvas.fontCatalog
                    .loadCharset(textElement.text, textElement.renderStyle)
                    .then(() => {
                    --this.m_loadPromisesCount;
                    textElement.loadingState = TextElement_1.LoadingState.Loaded;
                    this.m_isUpdatePending = true;
                    this.m_forceNewLabelsPass =
                        this.m_forceNewLabelsPass || forceNewPassOnLoaded;
                });
                if (this.m_loadPromisesCount === 0) {
                    this.m_loadPromise = undefined;
                }
                ++this.m_loadPromisesCount;
                this.m_loadPromise =
                    this.m_loadPromise === undefined
                        ? newLoadPromise
                        : Promise.all([this.m_loadPromise, newLoadPromise]);
            }
        }
        if (textElement.loadingState === TextElement_1.LoadingState.Loaded) {
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            textElement.glyphCaseArray = [];
            textElement.bounds = undefined;
            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(textElement.text, textCanvas.textRenderStyle, textElement.glyphCaseArray);
            textElement.loadingState = TextElement_1.LoadingState.Initialized;
        }
        // Return true as soon as a text element has some glyphs assigned so that it's rendered.
        // The glyphs may be either the final ones or some temporal glyphs inherited from a
        // predecessor as part of the text element replacement process.
        // See TextElementState.replace().
        return textElement.glyphs !== undefined;
    }
    initializeCamera() {
        this.m_camera.position.z = 1;
        this.m_camera.near = 0;
    }
    updateCamera() {
        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);
        this.m_camera.left = width / -2;
        this.m_camera.right = width / 2;
        this.m_camera.bottom = height / -2;
        this.m_camera.top = height / 2;
        this.m_camera.updateProjectionMatrix();
        this.m_camera.updateMatrixWorld(false);
        this.m_screenCollisions.update(width, height);
    }
    initializeDefaultFontCatalog() {
        if (this.m_options.fontCatalog) {
            this.m_defaultFontCatalogConfig = createDefaultFontCatalogConfig(this.m_options.fontCatalog);
            this.addDefaultTextCanvas();
        }
    }
    async addTextCanvas(fontCatalogConfig) {
        const catalogCallback = (name, catalog) => {
            if (this.m_textCanvases.has(name)) {
                const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog, name);
                catalog.showReplacementGlyphs = this.showReplacementGlyphs;
                // Check if the textCanvas has not been removed in the meantime
                this.m_textCanvases.set(name, loadedTextCanvas);
            }
        };
        const errorCallback = () => {
            this.m_textCanvases.delete(fontCatalogConfig.name);
        };
        if (this.m_textCanvases.has(fontCatalogConfig.name)) {
            return Promise.resolve();
        }
        else {
            // Reserve map space, until loaded or error
            this.m_textCanvases.set(fontCatalogConfig.name, undefined);
            const newLoadPromise = FontCatalogLoader_1.loadFontCatalog(fontCatalogConfig, catalogCallback, errorCallback)
                .then(() => {
                --this.m_loadPromisesCount;
            })
                .catch(error => {
                logger.info("rendering without font catalog, only icons possible", error);
                --this.m_loadPromisesCount;
            });
            if (this.m_loadPromisesCount === 0) {
                this.m_loadPromise = undefined;
            }
            ++this.m_loadPromisesCount;
            this.m_loadPromise =
                this.m_loadPromise === undefined
                    ? newLoadPromise
                    : Promise.all([this.m_loadPromise, newLoadPromise]);
            return newLoadPromise;
        }
    }
    updateGlyphDebugMesh() {
        const debugGlyphs = DebugContext_1.debugContext.getValue("DEBUG_GLYPHS");
        if (debugGlyphs === undefined) {
            return;
        }
        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {
            this.initializeGlyphDebugMesh();
        }
        harp_utils_1.assert(this.m_debugGlyphTextureCacheMesh !== undefined);
        harp_utils_1.assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);
        this.m_debugGlyphTextureCacheMesh.visible = debugGlyphs;
        this.m_debugGlyphTextureCacheWireMesh.visible = debugGlyphs;
    }
    initializeGlyphDebugMesh() {
        if (this.m_textCanvases.size === 0) {
            return;
        }
        const defaultTextCanvas = this.m_textCanvases.values().next().value;
        const defaultFontCatalog = defaultTextCanvas.fontCatalog;
        // Initialize glyph-debugging mesh.
        const planeGeometry = new THREE.PlaneGeometry(defaultFontCatalog.textureSize.width / 2.5, defaultFontCatalog.textureSize.height / 2.5, defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth, defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight);
        const material = new THREE.MeshBasicMaterial({
            transparent: true,
            depthWrite: false,
            depthTest: false,
            map: defaultFontCatalog.texture
        });
        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);
        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;
        this.m_debugGlyphTextureCacheMesh.visible = false;
        this.m_debugGlyphTextureCacheMesh.name = "glyphDebug";
        const wireframe = new THREE.WireframeGeometry(planeGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({
            transparent: true,
            color: 0x999999,
            depthWrite: false,
            depthTest: false
        });
        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;
        this.m_debugGlyphTextureCacheWireMesh.visible = false;
        this.m_debugGlyphTextureCacheWireMesh.name = "glyphDebug";
        defaultTextCanvas
            .getLayer(harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER)
            .storage.scene.add(this.m_debugGlyphTextureCacheMesh, this.m_debugGlyphTextureCacheWireMesh);
    }
    /**
     * Visit all visible tiles and add/ their text elements to cache.
     *
     * @remarks
     * The update of {@link TextElement}s is a time consuming process,
     * and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered {@link TextElement}s are stored internally
     * until the next update is done
     * to speed up rendering when no camera movement was detected.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    updateTextElements(dataSourceTileList) {
        if (updateStats) {
            updateStats.clear();
        }
        this.m_textElementStateCache.clearTextCache();
        this.m_cacheInvalidated = false;
        this.checkIfOverloaded(dataSourceTileList);
        // Used with tile offset to compute the x coordinate offset for tiles.
        const updateStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        // TODO: HARP-7648. Skip all data sources that won't contain text.
        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones
        // across all data sources.
        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,
        // including fallbacks if necessary) instead of visible tiles (target tiles that might not
        // be decoded yet).
        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out
        // and back in) due to the delay in decoding the visible tiles.
        dataSourceTileList.forEach(tileList => {
            this.updateTextElementsFromSource(tileList.dataSource, tileList.storageLevel, Array.from(tileList.renderedTiles.values()), updateStartTime);
        });
        if (updateStats) {
            updateStats.log();
        }
    }
    updateTextElementsFromSource(tileDataSource, storageLevel, visibleTiles, updateStartTime) {
        if (updateStats) {
            updateStats.tiles += visibleTiles.length;
        }
        const sortedTiles = visibleTiles;
        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?
        sortedTiles.sort((a, b) => {
            return a.tileKey.mortonCode() - b.tileKey.mortonCode();
        });
        const sortedGroups = [];
        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);
        let numTextElementsUpdated = 0;
        for (const textElementLists of sortedGroups) {
            this.selectTextElementsToUpdateByDistance(textElementLists);
            // The value of updateStartTime is set if this.overloaded is true.
            if (updateStartTime !== undefined) {
                // If overloaded and all time is used up, exit early.
                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {
                    const endTime = harp_utils_1.PerformanceTimer.now();
                    const elapsedTime = endTime - updateStartTime;
                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {
                        logger.debug("Update time limit exceeded.");
                        break;
                    }
                }
                // Try not to update too many elements. They will be checked for visibility each
                // frame.
                numTextElementsUpdated += textElementLists.count();
                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {
                    logger.debug("Update label limit exceeded.");
                    break;
                }
            }
        }
    }
    prepareTextElementGroup(textElementGroup, tileKey, maxViewDistance) {
        if (textElementGroup.elements.length === 0) {
            return;
        }
        const textElementSelection = (textElementState) => {
            let { result, viewDistance } = Placement_1.checkReadyForPlacement(textElementState.element, textElementState.element.type === TextElementType_1.TextElementType.LineMarker
                ? textElementState.lineMarkerIndex
                : undefined, this.m_viewState, this.m_poiManager, maxViewDistance);
            if (result === Placement_1.PrePlacementResult.Ok &&
                !this.m_textElementStateCache.deduplicateElement(this.m_viewState.zoomLevel, textElementState)) {
                result = Placement_1.PrePlacementResult.Duplicate;
                viewDistance = undefined;
            }
            if (updateStats) {
                updateStats.totalLabels++;
                updateStats.results[result]++;
            }
            return viewDistance;
        };
        const [, found] = this.m_textElementStateCache.getOrSet(textElementGroup, tileKey, textElementSelection);
        if (updateStats) {
            ++updateStats.totalGroups;
            if (!found) {
                ++updateStats.newGroups;
            }
        }
    }
    createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups) {
        if (sortedTiles.length === 0) {
            return;
        }
        const tilesToRender = [];
        for (const tile of sortedTiles) {
            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {
                tilesToRender.push(tile);
            }
        }
        const groupedPriorityLists = new Map();
        for (const tile of tilesToRender) {
            for (const group of tile.textElementGroups.groups.values()) {
                if (group.elements.length === 0) {
                    continue;
                }
                const foundGroup = groupedPriorityLists.get(group.priority);
                if (foundGroup === undefined) {
                    groupedPriorityLists.set(group.priority, new TextElementLists([new TileTextElements(tile, group)]));
                }
                else {
                    foundGroup.lists.push(new TileTextElements(tile, group));
                }
            }
        }
        if (groupedPriorityLists.size === 0) {
            return;
        }
        for (const g of groupedPriorityLists) {
            const lists = g[1];
            sortedGroups.push(lists);
        }
        sortedGroups.sort((a, b) => {
            return b.priority - a.priority;
        });
        const printTextInfo = false;
        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {
            let outString = "";
            for (const textElementLists of sortedGroups) {
                let size = 0;
                for (const tileTextElements of textElementLists.lists) {
                    size += tileTextElements.group.elements.length;
                }
                outString += `priority ${textElementLists.priority} size: ${size}\n`;
            }
            logger.log(outString);
        }
    }
    selectTextElementsToUpdateByDistance(textElementLists) {
        const farDistanceLimitRatio = Math.max(this.m_options.maxDistanceRatioForTextLabels, this.m_options.maxDistanceRatioForPoiLabels);
        const maxViewDistance = Placement_1.getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);
        for (const tileTextElements of textElementLists.lists) {
            this.prepareTextElementGroup(tileTextElements.group, tileTextElements.tile.tileKey, maxViewDistance);
        }
    }
    placeTextElements(time, placeNewTextElements) {
        const renderParams = {
            numRenderedTextElements: 0,
            fadeAnimationRunning: false,
            time
        };
        const placeStartTime = this.overloaded && this.m_viewState.isDynamic ? harp_utils_1.PerformanceTimer.now() : undefined;
        if (placementStats) {
            placementStats.clear();
        }
        if (this.m_textElementStateCache.size === 0) {
            logger.debug("Text element cache empty.");
            return;
        }
        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;
        if (this.m_forceNewLabelsPass) {
            this.m_forceNewLabelsPass = false;
        }
        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;
        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected
        // candidates from previous frame if there's been no placement in this one.
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        let currentPriority = groupStates[0].priority;
        let currentPriorityBegin = 0;
        for (let i = 0; i < groupStates.length; ++i) {
            const textElementGroupState = groupStates[i];
            if (placementStats) {
                ++placementStats.totalGroups;
            }
            const newPriority = textElementGroupState.priority;
            if (placeNew && currentPriority !== newPriority) {
                // Place all new labels of the previous priority before placing the persistent
                // labels of this priority.
                this.placeNewTextElements(currentPriorityBegin, i, renderParams);
                if (isPlacementTimeExceeded(placeStartTime)) {
                    break;
                }
                currentPriority = newPriority;
                currentPriorityBegin = i;
            }
            if (!this.placeTextElementGroup(textElementGroupState, renderParams, maxNumPlacedTextElements, Pass.PersistentLabels)) {
                break;
            }
            if (isPlacementTimeExceeded(placeStartTime)) {
                break;
            }
        }
        if (placeNew) {
            // Place new text elements of the last priority.
            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);
        }
        if (placementStats) {
            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;
            placementStats.log();
        }
        if (renderParams.fadeAnimationRunning) {
            this.m_isUpdatePending = true;
        }
    }
    placeNewTextElements(beginGroupIndex, endGroupIndex, renderParams) {
        const groupStates = this.m_textElementStateCache.sortedGroupStates;
        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {
            if (!this.placeTextElementGroup(groupStates[i], renderParams, this.m_options.maxNumVisibleLabels, Pass.NewLabels)) {
                break;
            }
        }
    }
    placeOverlayTextElements() {
        var _a;
        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {
            return;
        }
        const screenSize = this.m_tmpVector.set(this.m_screenProjector.width, this.m_screenProjector.height);
        const screenXOrigin = -screenSize.width / 2.0;
        const screenYOrigin = screenSize.height / 2.0;
        // Place text elements one by one.
        for (const textElement of this.m_overlayTextElements) {
            // Get the TextElementStyle.
            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);
            const textCanvas = textElementStyle.textCanvas;
            if (textCanvas === undefined) {
                continue;
            }
            const forceNewPassOnLoaded = false;
            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);
            if (textElement.loadingState !== TextElement_1.LoadingState.Initialized) {
                continue;
            }
            const layer = textCanvas.getLayer((_a = textElement.renderOrder) !== null && _a !== void 0 ? _a : harp_text_canvas_1.DEFAULT_TEXT_CANVAS_LAYER);
            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.
            if (layer !== undefined) {
                if (layer.storage.drawCount + textElement.glyphs.length > layer.storage.capacity) {
                    continue;
                }
            }
            // Set the current style for the canvas.
            textCanvas.textRenderStyle = textElement.renderStyle;
            textCanvas.textLayoutStyle = textElement.layoutStyle;
            // Place text.
            let textPath;
            if (!(textElement.type === TextElementType_1.TextElementType.PathLabel)) {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;
                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                tempPosition.x = tempScreenPosition.x;
                tempPosition.y = tempScreenPosition.y;
                tempPosition.z = 0.0;
                addTextToCanvas(textElement, textCanvas, tempPosition);
            }
            else {
                // Adjust the label positioning.
                tempScreenPosition.x = screenXOrigin;
                tempScreenPosition.y = screenYOrigin;
                if (textElement.xOffset !== undefined) {
                    tempScreenPosition.x += textElement.xOffset;
                }
                if (textElement.yOffset !== undefined) {
                    tempScreenPosition.y -= textElement.yOffset;
                }
                // Get the screen points that define the label's segments and create a path with
                // them.
                // TODO: HARP-7648. Optimize array allocations.
                const screenPoints = [];
                for (const pt of textElement.path) {
                    const pX = tempScreenPosition.x + pt.x * screenSize.width;
                    const pY = tempScreenPosition.y - pt.y * screenSize.height;
                    screenPoints.push(new THREE.Vector2(pX, pY));
                }
                textPath = new SimplePath_1.SimplePath();
                for (let i = 0; i < screenPoints.length - 1; ++i) {
                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));
                }
                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);
            }
        }
    }
    getDistanceScalingFactor(label, distance, lookAtDistance) {
        // Distance scale is based on relation between camera focus point distance and
        // the actual label distance. For labels close to camera look at point the scale
        // remains unchanged, the farther is label from that point the smaller size it is
        // rendered in screen space. This method is unaffected by near and far clipping planes
        // distances, but may be improved by taking FOV into equation or customizing the
        // focus point screen position based on horizon, actual ground, tilt ets.
        let factor = lookAtDistance / distance;
        // The label.distanceScale property defines the influence ratio at which
        // distance affects the final scaling of label.
        factor = 1.0 + (factor - 1.0) * label.distanceScale;
        // Preserve the constraints
        factor = Math.max(factor, this.m_options.labelDistanceScaleMin);
        factor = Math.min(factor, this.m_options.labelDistanceScaleMax);
        return factor;
    }
    getDistanceFadingFactor(label, state, maxVisibilityDist) {
        let distanceFadeValue = 1.0;
        const textDistance = state.viewDistance;
        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {
            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;
            const fadeFar = label.fadeFar;
            if (fadeFar > fadeNear) {
                distanceFadeValue =
                    1.0 -
                        THREE.MathUtils.clamp((textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);
            }
        }
        return distanceFadeValue;
    }
    addPointLabel(labelState, position, screenPosition, textCanvas, renderParams) {
        var _a;
        const pointLabel = labelState.element;
        const textRenderState = labelState.textRenderState;
        const isLineMarker = pointLabel.type === TextElementType_1.TextElementType.LineMarker;
        const iconRenderState = labelState.iconRenderState;
        harp_utils_1.assert(iconRenderState !== undefined);
        // Find the label's original position.
        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;
        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;
        // Scale the text depending on the label's distance to the camera "zero" plane.
        const textDistance = Placement_1.pointToPlaneDistance(position, this.m_viewState.worldCenter, this.m_cameraLookAt);
        if (pointLabel.fadeFar !== undefined &&
            (pointLabel.fadeFar <= 0.0 ||
                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent.
            if (placementStats) {
                ++placementStats.tooFar;
            }
            return false;
        }
        labelState.setViewDistance(textDistance);
        // Check if there is need to check for screen space for the label's icon.
        const poiInfo = pointLabel.poiInfo;
        let iconRejected = false;
        // Check if icon should be rendered at this zoomLevel
        const renderIcon = poiInfo !== undefined &&
            harp_utils_1.MathUtils.isClamped(this.m_viewState.zoomLevel, poiInfo.iconMinZoomLevel, poiInfo.iconMaxZoomLevel) &&
            poiInfo.isValid !== false;
        const distanceScaleFactor = this.getDistanceScalingFactor(pointLabel, textDistance, this.m_viewState.lookAtDistance);
        const iconReady = renderIcon && this.m_poiRenderer.prepareRender(pointLabel, this.m_viewState.env);
        let iconInvisible = false;
        if (iconReady) {
            const result = Placement_1.placeIcon(iconRenderState, poiInfo, tempPoiScreenPosition, distanceScaleFactor, this.m_viewState.env, this.m_screenCollisions);
            iconInvisible = result === Placement_1.PlacementResult.Invisible;
            iconRejected = result === Placement_1.PlacementResult.Rejected;
            if (iconInvisible) {
                iconRenderState.reset();
            }
        }
        else if (renderIcon && (poiInfo === null || poiInfo === void 0 ? void 0 : poiInfo.imageItem) !== null) {
            this.m_forceNewLabelsPass = true;
            this.m_isUpdatePending = true;
        }
        const distanceFadeFactor = this.getDistanceFadingFactor(pointLabel, labelState, this.m_viewState.maxVisibilityDist);
        // Render the label's text...
        // textRenderState is always defined at this point.
        if (textCanvas && shouldRenderPointText(labelState, this.m_viewState, this.m_options)) {
            // For the new labels with rejected icons we don't need to go further.
            const newLabel = !labelState.visible;
            // Multi point (icons) features (line markers) will use single placement anchor, but
            // single point labels (POIs, etc.) may use multi-placement algorithm.
            const placeResult = iconRejected && newLabel
                ? Placement_1.PlacementResult.Rejected
                : Placement_1.placePointLabel(labelState, tempScreenPosition, distanceScaleFactor, textCanvas, this.m_viewState.env, this.m_screenCollisions, tempPosition, !isLineMarker);
            const textInvisible = placeResult === Placement_1.PlacementResult.Invisible;
            if (textInvisible) {
                if (placementStats) {
                    placementStats.numPoiTextsInvisible++;
                }
                if (!renderIcon || iconInvisible) {
                    labelState.reset();
                    return false;
                }
                textRenderState.reset();
            }
            const iconIsOptional = (poiInfo === null || poiInfo === void 0 ? void 0 : poiInfo.iconIsOptional) === true;
            // Rejected icons are only considered to hide the text if they are valid, so a missing
            // icon image will not keep the text from showing up.
            const requiredIconRejected = iconRejected && iconReady && !iconIsOptional;
            const textRejected = requiredIconRejected || placeResult === Placement_1.PlacementResult.Rejected;
            if (!iconRejected && !iconInvisible) {
                const textIsOptional = ((_a = pointLabel.poiInfo) === null || _a === void 0 ? void 0 : _a.textIsOptional) === true;
                iconRejected = textRejected && !textIsOptional;
            }
            if (textRejected) {
                textRenderState.startFadeOut(renderParams.time);
            }
            const textNeedsDraw = !textInvisible &&
                ((!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||
                    textRenderState.isFading());
            if (textNeedsDraw) {
                if (!textRejected) {
                    textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
                }
                renderParams.fadeAnimationRunning =
                    renderParams.fadeAnimationRunning || textRenderState.isFading();
                if (addTextBufferToCanvas(labelState, textCanvas, tempPosition, distanceFadeFactor, distanceScaleFactor) &&
                    placementStats) {
                    placementStats.numRenderedPoiTexts++;
                }
            }
        }
        // ... and render the icon (if any).
        if (iconReady && !iconInvisible) {
            if (iconRejected) {
                iconRenderState.startFadeOut(renderParams.time);
            }
            else {
                iconRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
            }
            renderParams.fadeAnimationRunning =
                renderParams.fadeAnimationRunning || iconRenderState.isFading();
            const opacity = iconRenderState.opacity * distanceFadeFactor;
            if (opacity > 0) {
                // Same as for text, don't allocate screen space for an icon that's fading out so
                // that any label blocked by it gets a chance to be placed as soon as any other
                // surrounding new labels.
                const allocateSpace = poiInfo.reserveSpace !== false && !iconRejected;
                this.m_poiRenderer.addPoi(poiInfo, tempPoiScreenPosition, this.m_screenCollisions, labelState.renderDistance, distanceScaleFactor, allocateSpace, opacity, this.m_viewState.env);
                if (placementStats) {
                    placementStats.numRenderedPoiIcons++;
                }
            }
        }
        renderParams.numRenderedTextElements++;
        return true;
    }
    addPoiLabel(labelState, textCanvas, renderParams) {
        const worldPosition = Placement_1.getWorldPosition(labelState.element, this.m_viewState.projection, this.m_viewState.env, this.m_tmpVector3);
        // Only process labels that are potentially within the frustum.
        if (!this.labelPotentiallyVisible(worldPosition, tempScreenPosition)) {
            return false;
        }
        // Add this POI as a point label.
        return this.addPointLabel(labelState, worldPosition, tempScreenPosition, textCanvas, renderParams);
    }
    addLineMarkerLabel(labelState, shieldGroups, textCanvas, renderParams) {
        var _a;
        const lineMarkerLabel = labelState.element;
        // Early exit if the line marker doesn't have the necessary data.
        const poiInfo = lineMarkerLabel.poiInfo;
        if (!((_a = this.m_poiRenderer) === null || _a === void 0 ? void 0 : _a.prepareRender(lineMarkerLabel, this.m_viewState.env))) {
            return;
        }
        // Initialize the shield group for this lineMarker.
        let shieldGroup;
        if (poiInfo.shieldGroupIndex !== undefined) {
            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];
            if (shieldGroup === undefined) {
                shieldGroup = [];
                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;
            }
        }
        const lineTechnique = poiInfo.technique;
        const minDistanceSqr = lineTechnique.minDistance !== undefined
            ? lineTechnique.minDistance * lineTechnique.minDistance
            : 0;
        // Process markers (with shield groups).
        if (minDistanceSqr > 0 && shieldGroup !== undefined) {
            let numShieldsVisible = 0;
            const point = labelState.position;
            // Only process potentially visible labels
            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {
                // Find a suitable location for the lineMarker to be placed at.
                let tooClose = false;
                for (let j = 0; j < shieldGroup.length; j += 2) {
                    const distanceSqr = harp_utils_1.Math2D.distSquared(shieldGroup[j], shieldGroup[j + 1], tempScreenPosition.x, tempScreenPosition.y);
                    tooClose = distanceSqr < minDistanceSqr;
                    if (tooClose) {
                        break;
                    }
                }
                // Place it as a point label if it's not to close to another marker in the
                // same shield group.
                if (!tooClose) {
                    if (this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams)) {
                        shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);
                        numShieldsVisible++;
                    }
                }
            }
            if (numShieldsVisible === 0) {
                // For road shields the shared textRenderState may only be reset if none of the
                // icons can be rendered.
                labelState.reset();
            }
        }
        // Process markers (without shield groups).
        else {
            const point = labelState.position;
            // Only process potentially visible labels
            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {
                this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams);
            }
        }
    }
    addPathLabel(labelState, screenPoints, textCanvas, renderParams) {
        // TODO: HARP-7649. Add fade out transitions for path labels.
        const textMaxDistance = Placement_1.getMaxViewDistance(this.m_viewState, this.m_options.maxDistanceRatioForTextLabels);
        const pathLabel = labelState.element;
        // Limit the text rendering of path labels in the far distance.
        if (!(pathLabel.ignoreDistance === true ||
            labelState.viewDistance === undefined ||
            labelState.viewDistance < textMaxDistance)) {
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        if (pathLabel.fadeFar !== undefined &&
            (pathLabel.fadeFar <= 0.0 ||
                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)) {
            // The label is farther away than fadeFar value, which means it is totally
            // transparent
            if (placementStats) {
                ++placementStats.tooFar;
            }
            labelState.textRenderState.reset();
            return false;
        }
        // Get the screen points that define the label's segments and create a path with
        // them.
        let textPath = new THREE.Path();
        tempScreenPosition.copy(screenPoints[0]);
        for (let i = 0; i < screenPoints.length - 1; ++i) {
            textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));
        }
        // Flip the path if the label is gonna be rendered downwards.
        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {
            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);
            textPath = new THREE.Path();
            for (let i = screenPoints.length - 1; i > 0; --i) {
                textPath.add(new SimplePath_1.SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));
            }
        }
        // Update the real rendering distance to have smooth fading and scaling
        labelState.setViewDistance(Placement_1.computeViewDistance(pathLabel, undefined, this.m_viewState.worldCenter, this.m_cameraLookAt));
        const textRenderDistance = -labelState.renderDistance;
        // Scale the text depending on the label's distance to the camera.
        const distanceScaleFactor = this.getDistanceScalingFactor(pathLabel, textRenderDistance, this.m_viewState.lookAtDistance);
        const prevSize = textCanvas.textRenderStyle.fontSize.size;
        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;
        if (Placement_1.placePathLabel(labelState, textPath, tempScreenPosition, textCanvas, this.m_screenCollisions) !== Placement_1.PlacementResult.Ok) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            if (placementStats) {
                ++placementStats.numNotVisible;
            }
            labelState.textRenderState.reset();
            return false;
        }
        labelState.textRenderState.startFadeIn(renderParams.time, this.m_options.disableFading);
        let opacity = pathLabel.renderStyle.opacity;
        if (labelState.textRenderState.isFading()) {
            opacity *= labelState.textRenderState.opacity;
            renderParams.fadeAnimationRunning = true;
        }
        if (labelState.textRenderState.opacity === 0) {
            textCanvas.textRenderStyle.fontSize.size = prevSize;
            return false;
        }
        const prevOpacity = textCanvas.textRenderStyle.opacity;
        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;
        const distanceFadeFactor = this.getDistanceFadingFactor(pathLabel, labelState, this.m_viewState.maxVisibilityDist);
        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;
        textCanvas.textRenderStyle.backgroundOpacity =
            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle.backgroundOpacity;
        tempPosition.z = labelState.renderDistance;
        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);
        renderParams.numRenderedTextElements++;
        // Restore previous style values for text elements using the same style.
        textCanvas.textRenderStyle.fontSize.size = prevSize;
        textCanvas.textRenderStyle.opacity = prevOpacity;
        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;
        return true;
    }
    checkIfOverloaded(dataSourceTileList) {
        // Count the number of TextElements in the scene to see if we have to switch to
        // "overloadMode".
        let numTextElementsInScene = 0;
        dataSourceTileList.forEach(renderListEntry => {
            for (const tile of renderListEntry.renderedTiles.values()) {
                numTextElementsInScene += tile.textElementGroups.count();
            }
        });
        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;
        if (newOverloaded && !this.m_overloaded) {
            logger.debug("Overloaded Mode enabled.");
        }
        this.m_overloaded = newOverloaded;
        return this.m_overloaded;
    }
    /**
     * Project point to screen and check if it is on screen or within a fixed distance to the
     * border.
     *
     * @param point center point of label.
     * @param outPoint projected screen point of label.
     */
    labelPotentiallyVisible(point, outPoint) {
        var _a;
        const maxDistance = THREE.MathUtils.clamp((_a = this.m_options.maxPoiDistanceToBorder) !== null && _a !== void 0 ? _a : 0, 0, 1);
        const projectionResult = this.m_screenProjector.projectAreaToScreen(point, maxDistance, maxDistance, outPoint);
        return projectionResult !== undefined;
    }
}
exports.TextElementsRenderer = TextElementsRenderer;


/***/ }),

/***/ "../harp-mapview/lib/text/TextElementsRendererOptions.ts":
/*!***************************************************************!*\
  !*** ../harp-mapview/lib/text/TextElementsRendererOptions.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeDefaultOptions = void 0;
/**
 * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the
 * far plane (1.0). May be synchronized with fog value ?
 */
const DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;
/**
 * Minimum scaling factor that may be applied to labels when their are distant from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;
/**
 * Maximum scaling factor that may be applied to labels due to their distance from focus point.
 */
const DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;
// Allowed distance to screen border for early rejection of POIs during placement. Its range is
// [0..1] of screen size.
// A value of 0 will lead to POI labels popping in at the border of the screen. A large value will
// lead to many labels being placed outside the screen, with all the required actions for measuring
// and loading glyphs impacting performance.
const DEFAULT_MAX_DISTANCE_TO_BORDER = 0.2;
const MIN_GLYPH_COUNT = 1024;
const MAX_GLYPH_COUNT = 32768;
/**
 * Initializes undefined text renderer options to default values.
 * @param options - The options to be initialized.
 */
function initializeDefaultOptions(options) {
    if (options.minNumGlyphs === undefined) {
        options.minNumGlyphs = MIN_GLYPH_COUNT;
    }
    if (options.maxNumGlyphs === undefined) {
        options.maxNumGlyphs = MAX_GLYPH_COUNT;
    }
    if (options.labelDistanceScaleMin === undefined) {
        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;
    }
    if (options.labelDistanceScaleMax === undefined) {
        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;
    }
    if (options.maxDistanceRatioForTextLabels === undefined) {
        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.maxDistanceRatioForPoiLabels === undefined) {
        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;
    }
    if (options.disableFading === undefined) {
        options.disableFading = false;
    }
    if (options.delayLabelsUntilMovementFinished === undefined) {
        options.delayLabelsUntilMovementFinished = true;
    }
    if (options.showReplacementGlyphs === undefined) {
        options.showReplacementGlyphs = false;
    }
    if (options.maxPoiDistanceToBorder === undefined) {
        options.maxPoiDistanceToBorder = DEFAULT_MAX_DISTANCE_TO_BORDER;
    }
}
exports.initializeDefaultOptions = initializeDefaultOptions;


/***/ }),

/***/ "../harp-mapview/lib/text/TextStyleCache.ts":
/*!**************************************************!*\
  !*** ../harp-mapview/lib/text/TextStyleCache.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextStyleCache = void 0;
/*
 * Copyright (C) 2018-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const ColorCache_1 = __webpack_require__(/*! ../ColorCache */ "../harp-mapview/lib/ColorCache.ts");
const DecodedTileHelpers_1 = __webpack_require__(/*! ../DecodedTileHelpers */ "../harp-mapview/lib/DecodedTileHelpers.ts");
const TextElementsRenderer_1 = __webpack_require__(/*! ./TextElementsRenderer */ "../harp-mapview/lib/text/TextElementsRenderer.ts");
const logger = harp_utils_1.LoggerManager.instance.create("TextStyleCache");
const defaultTextRenderStyle = new harp_text_canvas_1.TextRenderStyle({
    fontSize: {
        unit: harp_text_canvas_1.FontUnit.Pixel,
        size: 32,
        backgroundSize: 8
    },
    color: ColorCache_1.ColorCache.instance.getColor("#6d7477"),
    opacity: 1.0,
    backgroundColor: ColorCache_1.ColorCache.instance.getColor("#f7fbfd"),
    backgroundOpacity: 0.5
});
// By default text layout provides no options for placement, but single alignment.
const defaultTextLayoutStyle = new harp_text_canvas_1.TextLayoutStyle({
    verticalAlignment: harp_text_canvas_1.VerticalAlignment.Center,
    horizontalAlignment: harp_text_canvas_1.HorizontalAlignment.Center,
    placements: []
});
const DEFAULT_STYLE_NAME = "default";
class TextStyleCache {
    constructor() {
        this.m_textStyles = new Map();
        this.m_defaultStyle = {
            name: DEFAULT_STYLE_NAME,
            fontCatalog: undefined,
            renderParams: defaultTextRenderStyle.params,
            layoutParams: defaultTextLayoutStyle.params
        };
        this.updateDefaultTextStyle();
    }
    updateTextStyles(textStyleDefinitions, defaultTextStyleDefinition) {
        this.m_textStyles.clear();
        textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.forEach(element => {
            this.m_textStyles.set(element.name, this.createTextElementStyle(element, element.name));
        });
        this.updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions);
    }
    updateTextCanvases(textCanvases) {
        // Initialize default text style.
        this.initializeTextCanvas(this.m_defaultStyle, textCanvases);
        for (const [, style] of this.m_textStyles) {
            this.initializeTextCanvas(style, textCanvases);
        }
    }
    /**
     * Retrieves a {@link TextElementStyle} for {@link @here/harp-datasource-protocol#Theme}'s
     * [[TextStyle]] id.
     */
    getTextElementStyle(styleId) {
        let result;
        if (styleId === undefined) {
            result = this.m_defaultStyle;
        }
        else {
            result = this.m_textStyles.get(styleId);
            if (result === undefined) {
                result = this.m_defaultStyle;
            }
        }
        return result;
    }
    /**
     * Gets the appropriate {@link @here/harp-text-canvas#TextRenderStyle}
     * to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     */
    createRenderStyle(tile, technique) {
        const mapView = tile.mapView;
        const zoomLevel = mapView.zoomLevel;
        const discreteZoomLevel = Math.floor(zoomLevel);
        // Environment with $zoom forced to integer to achieve stable interpolated values.
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const defaultRenderParams = this.m_defaultStyle.renderParams;
        // Sets opacity to 1.0 if default and technique attribute are undefined.
        const defaultOpacity = harp_utils_1.getOptionValue(defaultRenderParams.opacity, 1.0);
        // Interpolate opacity but only on discreet zoom levels (step interpolation).
        let opacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.opacity, defaultOpacity), discreteZoomEnv);
        let color;
        // Store color (RGB) in cache and multiply opacity value with the color alpha channel.
        if (technique.color !== undefined) {
            let hexColor = DecodedTileHelpers_1.evaluateColorProperty(technique.color, discreteZoomEnv);
            if (hexColor !== undefined) {
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexColor);
                    opacity = opacity * alpha;
                    hexColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexColor);
                }
                color = ColorCache_1.ColorCache.instance.getColor(hexColor);
            }
        }
        // Sets background size to 0.0 if default and technique attribute is undefined.
        const defaultBackgroundSize = harp_utils_1.getOptionValue(defaultRenderParams.fontSize.backgroundSize, 0);
        const backgroundSize = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundSize, defaultBackgroundSize), discreteZoomEnv);
        const hasBackgroundDefined = technique.backgroundColor !== undefined &&
            technique.backgroundSize !== undefined &&
            backgroundSize > 0;
        // Sets background opacity to 1.0 if default and technique value is undefined while
        // background size and color is specified, otherwise set value in default render
        // params or 0.0 if neither set. Makes label opaque when backgroundColor and
        // backgroundSize are set.
        const defaultBackgroundOpacity = harp_utils_1.getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);
        let backgroundOpacity = harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.backgroundOpacity, hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity), discreteZoomEnv);
        let backgroundColor;
        // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.
        if (technique.backgroundColor !== undefined) {
            let hexBgColor = DecodedTileHelpers_1.evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);
            if (hexBgColor !== undefined) {
                if (harp_datasource_protocol_1.ColorUtils.hasAlphaInHex(hexBgColor)) {
                    const alpha = harp_datasource_protocol_1.ColorUtils.getAlphaFromHex(hexBgColor);
                    backgroundOpacity = backgroundOpacity * alpha;
                    hexBgColor = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(hexBgColor);
                }
                backgroundColor = ColorCache_1.ColorCache.instance.getColor(hexBgColor);
            }
        }
        const renderParams = {
            fontName: harp_utils_1.getOptionValue(technique.fontName, defaultRenderParams.fontName),
            fontSize: {
                unit: harp_text_canvas_1.FontUnit.Pixel,
                size: harp_datasource_protocol_1.getPropertyValue(harp_utils_1.getOptionValue(technique.size, defaultRenderParams.fontSize.size), discreteZoomEnv),
                backgroundSize
            },
            fontStyle: technique.fontStyle === "Regular" ||
                technique.fontStyle === "Bold" ||
                technique.fontStyle === "Italic" ||
                technique.fontStyle === "BoldItalic"
                ? harp_text_canvas_1.FontStyle[technique.fontStyle]
                : defaultRenderParams.fontStyle,
            fontVariant: technique.fontVariant === "Regular" ||
                technique.fontVariant === "AllCaps" ||
                technique.fontVariant === "SmallCaps"
                ? harp_text_canvas_1.FontVariant[technique.fontVariant]
                : defaultRenderParams.fontVariant,
            rotation: harp_utils_1.getOptionValue(technique.rotation, defaultRenderParams.rotation),
            color: harp_utils_1.getOptionValue(color, harp_utils_1.getOptionValue(defaultRenderParams.color, harp_text_canvas_1.DefaultTextStyle.DEFAULT_COLOR)),
            backgroundColor: harp_utils_1.getOptionValue(backgroundColor, harp_utils_1.getOptionValue(defaultRenderParams.backgroundColor, harp_text_canvas_1.DefaultTextStyle.DEFAULT_BACKGROUND_COLOR)),
            opacity,
            backgroundOpacity
        };
        const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;
        const renderStyle = new harp_text_canvas_1.TextRenderStyle(Object.assign(Object.assign({}, themeRenderParams), renderParams));
        return renderStyle;
    }
    /**
     * Create the appropriate {@link @here/harp-text-canvas#TextLayoutStyle}
     * to use for a label. Depends heavily on the label's
     * [[Technique]] and the current zoomLevel.
     *
     * @param tile - The {@link Tile} to process.
     * @param technique - Label's technique.
     */
    createLayoutStyle(tile, technique) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: floorZoomLevel }, mapView.env);
        const defaultLayoutParams = this.m_defaultStyle.layoutParams;
        const hAlignment = harp_datasource_protocol_1.getPropertyValue(technique.hAlignment, discreteZoomEnv);
        const vAlignment = harp_datasource_protocol_1.getPropertyValue(technique.vAlignment, discreteZoomEnv);
        // Text alternative placements are currently supported only for PoiTechnique.
        const textPlacements = harp_datasource_protocol_1.isPoiTechnique(technique)
            ? harp_datasource_protocol_1.getPropertyValue(technique.placements, discreteZoomEnv)
            : null;
        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(hAlignment, vAlignment, textPlacements);
        const wrapping = harp_datasource_protocol_1.getPropertyValue(technique.wrappingMode, discreteZoomEnv);
        const wrappingMode = wrapping === "None" || wrapping === "Character" || wrapping === "Word"
            ? harp_text_canvas_1.WrappingMode[wrapping]
            : defaultLayoutParams.wrappingMode;
        const layoutParams = {
            tracking: (_a = harp_datasource_protocol_1.getPropertyValue(technique.tracking, discreteZoomEnv)) !== null && _a !== void 0 ? _a : defaultLayoutParams.tracking,
            leading: (_b = harp_datasource_protocol_1.getPropertyValue(technique.leading, discreteZoomEnv)) !== null && _b !== void 0 ? _b : defaultLayoutParams.leading,
            maxLines: (_c = harp_datasource_protocol_1.getPropertyValue(technique.maxLines, discreteZoomEnv)) !== null && _c !== void 0 ? _c : defaultLayoutParams.maxLines,
            lineWidth: (_d = harp_datasource_protocol_1.getPropertyValue(technique.lineWidth, discreteZoomEnv)) !== null && _d !== void 0 ? _d : defaultLayoutParams.lineWidth,
            canvasRotation: (_e = harp_datasource_protocol_1.getPropertyValue(technique.canvasRotation, discreteZoomEnv)) !== null && _e !== void 0 ? _e : defaultLayoutParams.canvasRotation,
            lineRotation: (_f = harp_datasource_protocol_1.getPropertyValue(technique.lineRotation, discreteZoomEnv)) !== null && _f !== void 0 ? _f : defaultLayoutParams.lineRotation,
            wrappingMode,
            horizontalAlignment,
            verticalAlignment,
            placements
        };
        const themeLayoutParams = this.getTextElementStyle(technique.style);
        const layoutStyle = new harp_text_canvas_1.TextLayoutStyle(Object.assign(Object.assign({}, themeLayoutParams), layoutParams));
        return layoutStyle;
    }
    updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions) {
        var _a, _b;
        this.m_defaultStyle.fontCatalog = undefined;
        const style = (_b = (_a = textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions.find(definition => {
            return definition.name === DEFAULT_STYLE_NAME;
        })) !== null && _a !== void 0 ? _a : defaultTextStyleDefinition) !== null && _b !== void 0 ? _b : textStyleDefinitions === null || textStyleDefinitions === void 0 ? void 0 : textStyleDefinitions[0];
        if (style) {
            this.m_defaultStyle = this.createTextElementStyle(style, DEFAULT_STYLE_NAME);
        }
        this.m_defaultStyle.textCanvas = undefined;
    }
    initializeTextCanvas(style, textCanvases) {
        var _a;
        if (style.textCanvas) {
            return;
        }
        if (style.fontCatalog !== undefined) {
            const styledTextCanvas = textCanvases.get(style.fontCatalog);
            style.textCanvas = styledTextCanvas;
            if (textCanvases.has(style.fontCatalog) && !styledTextCanvas) {
                logger.info(`fontCatalog(${style.fontCatalog}), not yet loaded`);
                return;
            }
        }
        // specified canvas not found
        if (style.textCanvas === undefined) {
            if (style.fontCatalog !== undefined &&
                style.fontCatalog !== TextElementsRenderer_1.DEFAULT_FONT_CATALOG_NAME) {
                logger.warn(`FontCatalog '${style.fontCatalog}' set in TextStyle
                     '${style.name}' not found`);
            }
            // find another canvas to use then
            let alternativeTextCanvas = textCanvases.get(TextElementsRenderer_1.DEFAULT_FONT_CATALOG_NAME);
            if (!alternativeTextCanvas && textCanvases.size > 0) {
                for (const [, canvas] of textCanvases) {
                    if (canvas) {
                        alternativeTextCanvas = canvas;
                        break;
                    }
                }
            }
            // if an alternative canvas is found, use it
            if (alternativeTextCanvas) {
                style.textCanvas = alternativeTextCanvas;
                if (style.fontCatalog !== undefined) {
                    logger.info(`fontCatalog: '${style.fontCatalog}' not found,
                      using default fontCatalog(${(_a = style.textCanvas) === null || _a === void 0 ? void 0 : _a.name}).`);
                }
            }
        }
    }
    createTextElementStyle(style, styleName) {
        var _a;
        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(style.hAlignment, style.vAlignment, style.placements);
        return {
            name: styleName,
            fontCatalog: harp_utils_1.getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),
            renderParams: {
                fontName: style.fontName,
                fontSize: {
                    unit: harp_text_canvas_1.FontUnit.Pixel,
                    size: 32,
                    backgroundSize: (_a = style.backgroundSize) !== null && _a !== void 0 ? _a : 8
                },
                fontStyle: style.fontStyle === "Regular" ||
                    style.fontStyle === "Bold" ||
                    style.fontStyle === "Italic" ||
                    style.fontStyle === "BoldItalic"
                    ? harp_text_canvas_1.FontStyle[style.fontStyle]
                    : undefined,
                fontVariant: style.fontVariant === "Regular" ||
                    style.fontVariant === "AllCaps" ||
                    style.fontVariant === "SmallCaps"
                    ? harp_text_canvas_1.FontVariant[style.fontVariant]
                    : undefined,
                rotation: style.rotation,
                color: style.color !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.color)
                    : undefined,
                backgroundColor: style.backgroundColor !== undefined
                    ? ColorCache_1.ColorCache.instance.getColor(style.backgroundColor)
                    : undefined,
                opacity: style.opacity,
                backgroundOpacity: style.backgroundOpacity
            },
            layoutParams: {
                tracking: style.tracking,
                leading: style.leading,
                maxLines: style.maxLines,
                lineWidth: style.lineWidth,
                canvasRotation: style.canvasRotation,
                lineRotation: style.lineRotation,
                wrappingMode: style.wrappingMode === "None" ||
                    style.wrappingMode === "Character" ||
                    style.wrappingMode === "Word"
                    ? harp_text_canvas_1.WrappingMode[style.wrappingMode]
                    : harp_text_canvas_1.WrappingMode.Word,
                verticalAlignment,
                horizontalAlignment,
                placements
            }
        };
    }
}
exports.TextStyleCache = TextStyleCache;
function parseAlignmentAndPlacements(hAlignment, vAlignment, placementsTokens) {
    // Currently supported only for PoiTechnique.
    const placements = placementsTokens
        ? parseTechniquePlacements(placementsTokens)
        : undefined;
    return harp_text_canvas_1.resolvePlacementAndAlignment(parseTechniqueHAlignValue(hAlignment), parseTechniqueVAlignValue(vAlignment), placements);
}
function parseTechniqueHAlignValue(hAlignment) {
    return hAlignment === "Left" || hAlignment === "Center" || hAlignment === "Right"
        ? harp_text_canvas_1.HorizontalAlignment[hAlignment]
        : defaultTextLayoutStyle.horizontalAlignment;
}
function parseTechniqueVAlignValue(vAlignment) {
    return vAlignment === "Above" || vAlignment === "Center" || vAlignment === "Below"
        ? harp_text_canvas_1.VerticalAlignment[vAlignment]
        : defaultTextLayoutStyle.verticalAlignment;
}
function parseTechniquePlacements(placementsString) {
    // Parse placement properties if available.
    const placements = [];
    const placementsTokens = placementsString
        ? placementsString.toUpperCase().replace(" ", "").split(",")
        : [];
    placementsTokens.forEach(p => {
        const val = parseTechniquePlacementValue(p);
        if (val !== undefined) {
            placements.push(val);
        }
    });
    return placements;
}
function parseTechniquePlacementValue(p) {
    // May be only literal of single or two characters.
    if (p.length < 1 || p.length > 2) {
        return undefined;
    }
    // If no value is specified for vertical/horizontal placement it is by default center.
    const textPlacement = {
        h: harp_text_canvas_1.HorizontalPlacement.Center,
        v: harp_text_canvas_1.VerticalPlacement.Center
    };
    // Firstly try to find vertical placement.
    let modifier = p.charAt(0);
    let found = true;
    switch (modifier) {
        // Top / north
        case harp_datasource_protocol_1.PlacementToken.Top:
        case harp_datasource_protocol_1.PlacementToken.North:
            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Top;
            break;
        // Bottom / south
        case harp_datasource_protocol_1.PlacementToken.Bottom:
        case harp_datasource_protocol_1.PlacementToken.South:
            textPlacement.v = harp_text_canvas_1.VerticalPlacement.Bottom;
            break;
        default:
            found = false;
            if (p.length === 2) {
                // For 2 characters tag both vertical/horizontal should be defined.
                return undefined;
            }
    }
    if (found && p.length === 1) {
        return textPlacement;
    }
    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);
    switch (modifier) {
        // Right / east
        case harp_datasource_protocol_1.PlacementToken.Right:
        case harp_datasource_protocol_1.PlacementToken.East:
            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Right;
            break;
        // Left / west
        case harp_datasource_protocol_1.PlacementToken.Left:
        case harp_datasource_protocol_1.PlacementToken.West:
            textPlacement.h = harp_text_canvas_1.HorizontalPlacement.Left;
            break;
        default:
            // Either for single character or multi-char tag, we must surrender.
            return undefined;
    }
    return textPlacement;
}


/***/ }),

/***/ "../harp-mapview/lib/text/TileTextStyleCache.ts":
/*!******************************************************!*\
  !*** ../harp-mapview/lib/text/TileTextStyleCache.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TileTextStyleCache = void 0;
class TileTextStyleCache {
    constructor(tile) {
        this.textRenderStyles = [];
        this.textLayoutStyles = [];
        this.tile = tile;
    }
    clear() {
        this.textRenderStyles.length = 0;
        this.textLayoutStyles.length = 0;
    }
    getRenderStyle(technique) {
        let style = this.textRenderStyles[technique._index];
        if (style === undefined) {
            style = this.textRenderStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(this.tile, technique);
        }
        return style;
    }
    getLayoutStyle(technique) {
        let style = this.textLayoutStyles[technique._index];
        if (style === undefined) {
            style = this.textLayoutStyles[technique._index] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(this.tile, technique);
        }
        return style;
    }
}
exports.TileTextStyleCache = TileTextStyleCache;


/***/ }),

/***/ "../harp-mapview/lib/text/UpdateStats.ts":
/*!***********************************************!*\
  !*** ../harp-mapview/lib/text/UpdateStats.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStats = void 0;
const Placement_1 = __webpack_require__(/*! ./Placement */ "../harp-mapview/lib/text/Placement.ts");
class UpdateStats {
    constructor(m_logger) {
        this.m_logger = m_logger;
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results = new Array(Placement_1.PrePlacementResult.Count);
        this.results.fill(0);
    }
    clear() {
        this.tiles = 0;
        this.totalGroups = 0;
        this.newGroups = 0;
        this.totalLabels = 0;
        this.results.fill(0);
    }
    log() {
        this.m_logger.debug("Tiles", this.tiles);
        this.m_logger.debug("Total groups", this.totalGroups);
        this.m_logger.debug("New groups", this.newGroups);
        this.m_logger.debug("Total labels", this.totalLabels);
        this.m_logger.debug("Placed labels", this.results[Placement_1.PrePlacementResult.Ok]);
        this.m_logger.debug("Invisible", this.results[Placement_1.PrePlacementResult.Invisible]);
        this.m_logger.debug("Poi not ready", this.results[Placement_1.PrePlacementResult.NotReady]);
        this.m_logger.debug("Too far", this.results[Placement_1.PrePlacementResult.TooFar]);
        this.m_logger.debug("Duplicate", this.results[Placement_1.PrePlacementResult.Duplicate]);
    }
}
exports.UpdateStats = UpdateStats;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts":
/*!**********************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerBootstrapDefs.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isWorkerBootstrapResponse = exports.isWorkerBootstrapRequest = void 0;
function isWorkerBootstrapRequest(message) {
    return (message &&
        message.type === "worker-bootstrap-request" &&
        Array.isArray(message.dependencies));
}
exports.isWorkerBootstrapRequest = isWorkerBootstrapRequest;
function isWorkerBootstrapResponse(message) {
    return (message &&
        message.type === "worker-bootstrap-response" &&
        Array.isArray(message.resolvedDependencies));
}
exports.isWorkerBootstrapResponse = isWorkerBootstrapResponse;


/***/ }),

/***/ "../harp-mapview/lib/workers/WorkerLoader.ts":
/*!***************************************************!*\
  !*** ../harp-mapview/lib/workers/WorkerLoader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerLoader = void 0;
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const WorkerBootstrapDefs_1 = __webpack_require__(/*! ./WorkerBootstrapDefs */ "../harp-mapview/lib/workers/WorkerBootstrapDefs.ts");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerLoader");
/**
 * Set of `Worker` loading and initialization helpers:
 *  - starting Worker from URL with fallback to XHR+blob {@link WorkerLoader.startWorker}
 *  - waiting for proper worker initialization, see {@link WorkerLoader.waitWorkerInitialized}
 */
class WorkerLoader {
    /**
     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.
     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful
     * initialization.
     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to
     * [[startWorkerBlob]].
     *
     * We must resolve/reject promise at some time, so it is expected that any sane application will
     * be able to load worker code in some amount of time.
     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).
     *
     * This method is needed as browsers in general forbid to load worker if it's not on 'same
     * origin' regardless of Content-Security-Policy.
     *
     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows
     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but
     * this may change.
     *
     * Following snippet setups CSP, so workers can be started from blob urls:
     *
     *     <head>
     *         <meta http-equiv="Content-Security-Policy" content="child-src blob:">
     *     </head>
     *
     * Tested on:
     *   * Chrome 67 / Linux, Window, OSX, Android
     *   * Firefox 60 / Linux, Windows, OSX
     *   * Edge 41 / Windows
     *   * Safari 11 / OSX
     *   * Samsung Internet 7.2
     *
     * See
     *  * https://benohead.com/cross-domain-cross-browser-web-workers/
     *  * MapBox
     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin
     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658
     *    * https://github.com/mapbox/mapbox-gl-js/issues/559
     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058
     *
     * Findings:
     *
     * * Chrome reports CSP by exception when constructing [[Worker]] instance.
     * * Firefox reports CSP errors when loading in first event:
     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888
     * * Firefox 62, Chrome 67 obeys `<meta http-equiv="Content-Security-Policy">` with
     *   `worker-src blob:` but doesn't obey `worker-src URL` when used
     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported
     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)
     *
     * @param scriptUrl - web worker script URL
     * @param timeout - timeout in milliseconds, in which worker should set initial message
     *    (default 10 seconds)
     */
    static startWorker(scriptUrl, timeout = 10000) {
        if (scriptUrl.startsWith("blob:")) {
            return this.startWorkerImmediately(scriptUrl, timeout);
        }
        if (this.directlyFallbackToBlobBasedLoading) {
            return this.startWorkerBlob(scriptUrl, timeout);
        }
        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {
            if (typeof window !== "undefined") {
                const pageUrl = window.location.href;
                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;
                if (harp_utils_1.getUrlOrigin(fullScriptUrl) === harp_utils_1.getUrlOrigin(pageUrl)) {
                    throw error;
                }
                logger.log("#startWorker: cross-origin worker construction failed, trying load with blob");
                this.directlyFallbackToBlobBasedLoading = true;
                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);
            }
            else {
                throw error;
            }
        });
    }
    /**
     * Start worker, loading it immediately from `scriptUrl`. Waits (using
     * [[waitWorkerInitialized]]) for successful worker start.
     *
     * @param scriptUrl - web worker script URL
     */
    static startWorkerImmediately(scriptUrl, timeout) {
        try {
            const worker = new Worker(scriptUrl);
            return this.waitWorkerInitialized(worker, timeout);
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    /**
     * Start worker "via blob" by first loading worker script code with [[fetch]], creating `Blob`
     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for
     * successful worker start.
     *
     * @param scriptUrl - web worker script URL
     */
    static startWorkerBlob(scriptUrl, timeout) {
        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {
            return this.startWorkerImmediately(blobUrl, timeout);
        });
    }
    /**
     * Fetch script source as `Blob` url.
     *
     * Reuses results, if there are many simultaneous requests.
     *
     * @param scriptUrl - web worker script URL
     * @return promise that resolves to url of a `Blob` with script source code
     */
    static fetchScriptSourceToBlobUrl(scriptUrl) {
        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);
        if (loadingPromise !== undefined) {
            return loadingPromise;
        }
        loadingPromise = fetch(scriptUrl)
            .then(response => response.text())
            .catch(error => {
            throw new Error(`WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`);
        })
            .then(scriptSource => {
            this.sourceLoaderCache.delete(scriptUrl);
            const blob = new Blob([scriptSource], { type: "application/javascript" });
            return URL.createObjectURL(blob);
        });
        this.sourceLoaderCache.set(scriptUrl, loadingPromise);
        return loadingPromise;
    }
    /**
     * Waits for successful Web Worker start.
     *
     * Expects that worker script sends initial message.
     *
     * If first event is `message` then assumes that worker has been loaded sussesfully and promise
     * resolves to `worker` object passed as argument.
     *
     * If first event is 'error', then it is assumed that worker failed to load and promise is
     * rejected.
     *
     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's
     * `dispatchEvent`, so application code can also consume it as confirmation of successful
     * worker initialization.
     *
     * We must resolve/reject promise at some time, so it is expected that any sane application will
     * be able to load worker code in some amount of time.
     *
     * @param worker - [[Worker]] instance to be checked
     * @param timeout - timeout in milliseconds, in which worker should set initial message
     * @returns `Promise` that resolves to `worker` on success
     */
    static waitWorkerInitialized(worker, timeout) {
        return new Promise((resolve, reject) => {
            const firstMessageCallback = (event) => {
                const message = event.data;
                if (WorkerBootstrapDefs_1.isWorkerBootstrapRequest(message)) {
                    const dependencies = message.dependencies;
                    const resolvedDependencies = [];
                    for (const dependency of dependencies) {
                        const resolved = this.dependencyUrlMapping[dependency];
                        if (!resolved) {
                            cleanup();
                            reject(new Error(`#waitWorkerInitialized: Unable to resolve '${dependency}'` +
                                ` as needed by worker script.`));
                            return;
                        }
                        resolvedDependencies.push(resolved);
                    }
                    const response = {
                        type: "worker-bootstrap-response",
                        resolvedDependencies
                    };
                    worker.postMessage(response);
                    return;
                }
                cleanup();
                resolve(worker);
                // We've just consumed first message from worker before client has any chance to
                // even call `addEventListener` on it, so here after resolve, we wait next tick and
                // replay message so user has chance to intercept it in its own handler.
                setTimeout(() => {
                    worker.dispatchEvent(event);
                }, 0);
            };
            const errorCallback = (error) => {
                cleanup();
                // Error events do not carry any useful information on tested browsers, so we assume
                // that any error before 'firstMessageCallback' as failed Worker initialization.
                let message = "Error during worker initialization";
                if (error.message) {
                    message = message + `: ${error.message}`;
                }
                if (typeof error.filename === "string" && typeof error.lineno === "number") {
                    message = message + ` in ${error.filename}:${error.lineno}`;
                }
                reject(new Error(message));
            };
            const cleanup = () => {
                clearTimeout(timerId);
                worker.removeEventListener("message", firstMessageCallback);
                worker.removeEventListener("error", errorCallback);
            };
            worker.addEventListener("error", errorCallback);
            worker.addEventListener("message", firstMessageCallback);
            const timerId = setTimeout(() => {
                cleanup();
                reject(new Error("Timeout exceeded when waiting for first message from worker."));
            }, timeout);
        });
    }
}
exports.WorkerLoader = WorkerLoader;
WorkerLoader.directlyFallbackToBlobBasedLoading = false;
WorkerLoader.sourceLoaderCache = new Map();
WorkerLoader.dependencyUrlMapping = {};


/***/ }),

/***/ "../harp-materials/index.ts":
/*!**********************************!*\
  !*** ../harp-materials/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Materials defining the appearance of map objects.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/CirclePointsMaterial */ "../harp-materials/lib/CirclePointsMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/DisplacementFeature */ "../harp-materials/lib/DisplacementFeature.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/EdgeMaterial */ "../harp-materials/lib/EdgeMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GroundAtmosphereMaterial */ "../harp-materials/lib/GroundAtmosphereMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionLineMaterial */ "../harp-materials/lib/HighPrecisionLineMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/HighPrecisionPointMaterial */ "../harp-materials/lib/HighPrecisionPointMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/IconMaterial */ "../harp-materials/lib/IconMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/LuminosityHighPassShader */ "../harp-materials/lib/LuminosityHighPassShader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MSAAMaterial */ "../harp-materials/lib/MSAAMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/SepiaShader */ "../harp-materials/lib/SepiaShader.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/SkyAtmosphereMaterial */ "../harp-materials/lib/SkyAtmosphereMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/SolidLineMaterial */ "../harp-materials/lib/SolidLineMaterial.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Utils */ "../harp-materials/lib/Utils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/VignetteShader */ "../harp-materials/lib/VignetteShader.ts"), exports);


/***/ }),

/***/ "../harp-materials/lib/CirclePointsMaterial.ts":
/*!*****************************************************!*\
  !*** ../harp-materials/lib/CirclePointsMaterial.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CirclePointsMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const vertexShader = `
uniform float size;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuseColor, alpha);
}`;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters - The constructor's parameters. Always required except when cloning another
     */
    constructor(parameters) {
        const defaultColor = new THREE.Color();
        const defaultOpacity = 1.0;
        let sizeValue, colorValue, opacityValue;
        let shaderParameters;
        if (parameters) {
            const { size, color, opacity } = parameters, shaderParams = __rest(parameters, ["size", "color", "opacity"]);
            sizeValue = size;
            colorValue = color;
            opacityValue = opacity;
            shaderParams.name = "CirclePointsMaterial";
            shaderParams.vertexShader = vertexShader;
            shaderParams.fragmentShader = fragmentShader;
            shaderParams.uniforms = THREE.UniformsUtils.merge([
                {
                    size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
                    // HARP-17373: Original uniform name 'diffuse' due to shader compilation
                    // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.
                    diffuseColor: new THREE.Uniform(defaultColor),
                    opacity: new THREE.Uniform(defaultOpacity)
                },
                THREE.UniformsLib.fog
            ]);
            shaderParams.depthTest = false;
            shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });
            shaderParameters = shaderParams;
        }
        super(shaderParameters);
        // Blending needs to always be enabled to support smooth edges
        Utils_1.enforceBlending(this);
        this.type = "CirclePointsMaterial";
        this.setOpacity(defaultOpacity);
        if (sizeValue !== undefined) {
            this.size = sizeValue;
        }
        if (colorValue !== undefined) {
            this.color = colorValue;
        }
        if (opacityValue !== undefined) {
            this.setOpacity(opacityValue);
        }
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.uniforms.size.value;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.uniforms.size.value = size;
    }
    get color() {
        return this.uniforms.diffuseColor.value;
    }
    set color(value) {
        this.uniforms.diffuseColor.value.copy(value);
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;
CirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;


/***/ }),

/***/ "../harp-materials/lib/CopyMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/CopyMaterial.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyMaterial = exports.CopyShader = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The base shader to use for {@link @here/harp-mapview#MapView}'s
 * composing passes, like {@link MSAAMaterial}.
 */
exports.CopyShader = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform float opacity;
    uniform sampler2D tDiffuse;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        gl_FragColor = opacity * texel;
    }`
};
/**
 * The material is used for composing.
 */
class CopyMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `CopyMaterial`.
     *
     * @param uniforms - The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            name: "CopyMaterial",
            uniforms,
            vertexShader: exports.CopyShader.vertexShader,
            fragmentShader: exports.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: false,
            blending: THREE.NoBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.CopyMaterial = CopyMaterial;


/***/ }),

/***/ "../harp-materials/lib/DisplacementFeature.ts":
/*!****************************************************!*\
  !*** ../harp-materials/lib/DisplacementFeature.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setDisplacementMapToMaterial = exports.hasDisplacementFeature = void 0;
/**
 * Determines whether a given material supports displacement maps for elevation overlay.
 * @param material - The material to check.
 * @returns Whether the given material supports displacement maps for elevation overlay.
 */
function hasDisplacementFeature(material) {
    return "displacementMap" in material;
}
exports.hasDisplacementFeature = hasDisplacementFeature;
/**
 * Sets the displacement map to the given material.
 * @param displacementMap - Texture representing the elevation data used to overlay the object.
 * @param material - The Material to be updated.
 */
function setDisplacementMapToMaterial(displacementMap, material) {
    if (hasDisplacementFeature(material) && material.displacementMap !== displacementMap) {
        material.displacementMap = displacementMap;
        material.needsUpdate = true;
        if (material.displacementMap !== null) {
            material.displacementMap.needsUpdate = true;
        }
    }
}
exports.setDisplacementMapToMaterial = setDisplacementMapToMaterial;


/***/ }),

/***/ "../harp-materials/lib/EdgeMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/EdgeMaterial.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EdgeMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const vertexSource = `
#define EDGE_DEPTH_OFFSET 0.0001

#ifdef USE_COLOR
attribute vec4 color;
#else
uniform vec3 color;
#endif

// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are
// already defined
#ifndef SHADER_NAME
attribute vec3 position;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
#endif

uniform vec3 edgeColor;
uniform float edgeColorMix;

#ifdef USE_DISPLACEMENTMAP
attribute vec3 normal;
attribute vec2 uv;
uniform sampler2D displacementMap;
#endif

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {

    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    #ifdef USE_DISPLACEMENTMAP
    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;
    // After projection gl_Position contains clip space coordinates of each vertex
    // before perspective division (1 / w), thus only vertexes with -w < z < w should
    // be displayed and offset. We offset only those edges which z coordinate in NDC
    // space is between: -inf < z < 1
    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;
    gl_Position.z -= depthOffset;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
class EdgeMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `EdgeMaterial`.
     *
     * @param params - `EdgeMaterial` parameters. Always required except when cloning another
     * material.
     */
    constructor(params) {
        var _a;
        let shaderParams;
        if (params) {
            const defines = {};
            const hasExtrusion = params.extrusionRatio !== undefined &&
                params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&
                params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            if (params.displacementMap) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            if (hasExtrusion) {
                Utils_1.setShaderDefine(defines, "USE_EXTRUSION", true);
            }
            if (params.vertexColors === true) {
                Utils_1.setShaderDefine(defines, "USE_COLOR", true);
            }
            shaderParams = {
                name: "EdgeMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    color: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                    edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                    edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                    extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
                    displacementMap: new THREE.Uniform((_a = params.displacementMap) !== null && _a !== void 0 ? _a : new THREE.Texture())
                },
                depthWrite: false,
                defines,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
        Utils_1.enforceBlending(this);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                // Color may be set directly on object (omitting class setter), because we already
                // know that is does no require any special handling nor material update
                // (see: set color()).
                this.color.set(params.color);
            }
            if (params.colorMix !== undefined) {
                this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.extrusionRatio !== undefined) {
                this.extrusionRatio = params.extrusionRatio;
            }
        }
    }
    /**
     * The color of the object that is rendered
     * together with this edge.
     *
     * @remarks
     * The final color of the edge is computed by
     * interpolating the {@link edgeColor} with this color
     * using the {@link colorMix} factor.
     *
     * Note that {@link objectColor} is used only
     * when the geometry associated with this material
     * does not have a vertex color buffer.
     *
     */
    get objectColor() {
        return this.uniforms.color.value;
    }
    set objectColor(value) {
        this.uniforms.color.value.copy(value);
    }
    /**
     * Edge color.
     */
    get color() {
        return this.uniforms.edgeColor.value;
    }
    set color(value) {
        this.uniforms.edgeColor.value.copy(value);
    }
    get lineWidth() {
        return this.linewidth;
    }
    /**
     * Only lineWidth of 0 and 1 is supported.
     * lineWidth <= 0 will result in not visible lines, everything else into lines
     * visible with lineWidth 1
     */
    set lineWidth(value) {
        this.linewidth = value;
        if (this.linewidth <= 0) {
            this.visible = false;
        }
        else {
            this.visible = true;
        }
    }
    /**
     * Color mix value. Mixes between vertexColors and edgeColor.
     */
    get colorMix() {
        return this.uniforms.edgeColorMix.value;
    }
    set colorMix(value) {
        if (this.uniforms.edgeColorMix.value === value) {
            return;
        }
        this.uniforms.edgeColorMix.value = value;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        if (this.uniforms.fadeFar.value === value) {
            return;
        }
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get extrusionRatio() {
        return this.uniforms.extrusionRatio.value;
    }
    set extrusionRatio(value) {
        if (this.uniforms.extrusionRatio.value === value) {
            return;
        }
        this.uniforms.extrusionRatio.value = value;
        // NOTE: We could also disable shader extrusion chunks when it hits
        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.
        const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
        Utils_1.setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
}
exports.EdgeMaterial = EdgeMaterial;
EdgeMaterial.DEFAULT_COLOR = 0x000000;
EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;


/***/ }),

/***/ "../harp-materials/lib/GroundAtmosphereMaterial.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/GroundAtmosphereMaterial.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroundAtmosphereMaterial = exports.GroundAtmosphereShader = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ "../harp-materials/lib/ShaderChunks/AtmosphereChunks.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const EQUATORIAL_RADIUS = 6378137.0;
/**
 * `GroundAtmosphereShader`.
 *
 * Describes shading of atmosphere as seen from outer space.
 */
exports.GroundAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),
        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),
        // Environment settings:
        // atmosphere inner and outer radius, camera height
        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector3(
        // Maximum inner radius
        EQUATORIAL_RADIUS * 1.001, 
        // Maximum outer radius
        EQUATORIAL_RADIUS * 1.025, 
        // Camera height
        0)),
        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),
        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),
        offset: new THREE.Uniform(33.0),
        exponent: new THREE.Uniform(0.6),
        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far
    },
    vertexShader: `

    #define IMPROVE_INTERSECT_PRECISION 1
    #define IMPROVE_DOT_PRECISION 1

    precision highp float;
    precision highp int;

    attribute vec4 position;

    // Base mandatory uniforms
    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Km = 0.0015;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 25.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        1.0 / pow(0.650, 4.0), // Red
        1.0 / pow(0.570, 4.0), // Green
        1.0 / pow(0.475, 4.0)); // Blue

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for ground.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE.
    //
    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir)
    {
        // Retrieve environment variables
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be moved to const or define(s) at further optimizations:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

#if !defined(IMPROVE_DOT_PRECISION)
        vec3 v3Dir = normalize(v3Pos);
#endif

#ifdef CAMERA_IN_SPACE

        // Calculate first point of camera ray and sphere intersection.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection, setting it to
        // the length of ray passed through atmosphere
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;
        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);

#else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten
        // fFar -= 0.0;
        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);
#endif

#if defined(IMPROVE_DOT_PRECISION)
        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);
#else
        float fCameraAngle = dot(-v3Ray, v3Dir);
#endif
        float fCameraScale = scale(fCameraAngle);

#ifdef DYNAMIC_LIGHT
        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.
        #if defined(IMPROVE_DOT_PRECISION)
            // The light angle for given light source may be calculated as:
            // angle = dot(vLightDir, v3Dir) / length(v3Dir);
            // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)
            float fLightAngle = dot(vLightDir, v3Pos) / length(v3Pos);
        #else
            float fLightAngle = dot(vLightDir, v3Dir);
        #endif
#else
        float fLightAngle = 1.0;
#endif
        float fLightScale = scale(fLightAngle);

        float fCameraOffset = fDepth * fCameraScale;
        float fTemp = (fLightScale + fCameraScale);

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i = 0; i < nSamples; i++)
        {
            float fHeight = length(v3SamplePoint);
            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));
            float fScatter = fDepth * fTemp - fCameraOffset;
            // Compute color factors
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);
            // Move to the next point
            v3SamplePoint += v3SampleRay;
        }

        AtmosphereColor color;
        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);
        // Calculate the attenuation factor for the ground
        color.rayleigh = v3Attenuate;

        return color;
    }

    void main(void)
    {
        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;
        v_vertToOrigin = normalize(position.xyz);

        gl_Position = u_modelViewProjection * position;
    }
    `,
    fragmentShader: `

    // Exposure correction gives more subtle gradients on the ground.
    #define CORRECT_EXPOSURE 1
    #define FADE_DEPTH 1
    #define NIGHT_LOCAL 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;
    varying vec3 v_vertToOrigin;

    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        // GPU gems mix of ground solution, with custom alpha settings
        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;

        // Not needed for HDR frame buffer
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Interesting results with exposure factor: 2.0, 3.5, 4.0
        cRgb = correctExposure(cRgb, 3.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Base atmosphere opacity
        float fAtmosphereAlpha = 1.0;

        // Factor based on the distance of camera atmosphere and ground, results are:
        // 0.0 = camera on the ground surface,
        // 1.0 = at the outer edge of the atmosphere.
        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);
    #ifdef FADE_DEPTH
        // Fade alpha based on the distance of camera between atmosphere layers
        #ifdef FADE_DEPTH_LINEAR
            fAtmosphereAlpha *= fDepthFactor;
        #else
            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);
        #endif
    #endif

#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)
    #ifdef DYNAMIC_LIGHT
        // Adjust factor based on time of day, results are:
        // 0.0 = night,
        // 1.0 = day.
        #ifdef NIGHT_GLOBAL
            // Global night fade based on camera and light orientation
            float fNightFactor = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);
            fNightFactor = pow(fNightFactor, 0.5);
        #else // NIGHT_LOCAL
            float fNightFactor =
                clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0);
            fNightFactor = pow(fNightFactor, 0.8);
        #endif
    #else
        float fNightFactor = 1.0;
    #endif
#endif

    #ifdef FADE_NIGHT
        // Adjust alpha for night side of the globe
        fAtmosphereAlpha *= fNightFactor;
    #endif

    #ifdef DARKEN_NIGHT
        // Change the brightness depending on night / day side.
        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,
        // but it is much more GPU consuming.
        const float minBrightness = 0.5;
        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);
        cRgb *= fDarkenFactor;
    #endif

    #ifdef EXPOSURE_DEPTH
        // Control exposure depending from ground distance
        float exposureBoost = 3.0 - fDepthFactor;
        cRgb = correctExposure(cRgb, exposureBoost);
    #endif

        // Experimental fading out of focus point - similar to fresnel effect in top view.
        // This fade is handy to better expose cartographic/map features in screen center.
        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;
        fFocusFactor = pow(fFocusFactor, 2.5);
        fAtmosphereAlpha *= fFocusFactor;

        // Integrate all features
        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);
    }
    `
};
class GroundAtmosphereMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `GroundAtmosphereMaterial`.
     *
     * @param params - `GroundAtmosphereMaterial` parameters. Always required except when cloning
     * another material.
     */
    constructor(params) {
        let shaderParams;
        if (params) {
            const defines = {};
            defines.CAMERA_IN_SPACE = "";
            shaderParams = {
                name: "GroundAtmosphereMaterial",
                vertexShader: exports.GroundAtmosphereShader.vertexShader,
                fragmentShader: exports.GroundAtmosphereShader.fragmentShader,
                uniforms: exports.GroundAtmosphereShader.uniforms,
                transparent: true,
                depthTest: false,
                depthWrite: false,
                side: THREE.FrontSide,
                blending: THREE.NormalBlending,
                fog: false,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
    }
    setDynamicLighting(enableLighting) {
        Utils_1.setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
    }
    /**
     * Set maximum outer radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025
     */
    set outerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.y = radius;
    }
    get outerRadius() {
        return this.uniforms.u_atmosphereEnv.value.y;
    }
    /**
     * Set maximum inner radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.001.
     */
    set innerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.x = radius;
    }
    get innerRadius() {
        return this.uniforms.u_atmosphereEnv.value.x;
    }
    /**
     * Updates the uniform data of a material used to render an atmosphere.
     *
     * This includes only uniforms that may change frame by frame, other uniforms are
     * accessed with convenient material setters and getters.
     *
     * @param shaderMaterial - Material which uniforms will be updated.
     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.
     * @param lightDirection - The light directional vector in world space.
     * @param camera - Camera used in rendering.
     */
    updateUniforms(shaderMaterial, object, camera, lightDirection) {
        const cameraInfo = this.getCameraInfo(object, camera);
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_atmosphereEnv &&
                shaderMaterial.uniforms.u_hsvCorrection &&
                shaderMaterial.uniforms.u_eyePositionWorld &&
                shaderMaterial.uniforms.u_modelViewProjection &&
                shaderMaterial.uniforms.u_lightDirectionWorld) {
                const eyePos = cameraInfo.eyePos;
                const mvp = cameraInfo.modelViewProjection;
                const cameraHeight = cameraInfo.eyeHeight;
                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                const cameraInSpace = cameraHeight > this.outerRadius;
                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                shaderMaterial.needsUpdate =
                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
            }
            else {
                throw Error("Atmosphere material has missing uniforms");
            }
        }
        else {
            throw Error("Wrong object used, only Material objects are supported");
        }
    }
    /*
     * Calculate camera position used in vertex shader of atmosphere materials.
     *
     * @param object -
     * @param camera - Camera used to get the eye position.
     */
    getCameraInfo(object, camera, reverse = false) {
        if (reverse) {
            const modelMatrix = new THREE.Matrix4().identity();
            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            object.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            camera.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
        else {
            const modelMatrix = object.matrixWorld;
            const viewMatrix = camera.matrixWorldInverse;
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            camera.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            object.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            // Normally we would return simply camera position, but since camera is not moving in
            // the globe view only the world, we need to calculate eye relative to object position.
            eyePos.sub(objectPos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
    }
}
exports.GroundAtmosphereMaterial = GroundAtmosphereMaterial;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionLineMaterial.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionLineMaterial.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHighPrecisionLineMaterial = exports.HighPrecisionLineMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
attribute vec4 color;
varying vec3 vColor;
#endif

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 position;        // high part
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform float opacity;

#ifdef USE_COLOR
varying vec3 color;
#endif

void main() {
    #ifdef USE_COLOR
    gl_FragColor = vec4( diffuseColor * vColor, opacity );
    #else
    gl_FragColor = vec4( diffuseColor, opacity );
    #endif
}`;
/**
 * Material designed to render high precision lines (ideal for position-sensible data).
 */
class HighPrecisionLineMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `HighPrecisionLineMaterial`.
     *
     * @param params - `HighPrecisionLineMaterial` parameters.  Always required except when cloning
     * another material.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = params
            ? {
                name: "HighPrecisionLineMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    // HARP-17373: Original uniform name 'diffuse' due to shader compilation
                    // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.
                    diffuseColor: new THREE.Uniform(new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)),
                    opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),
                    u_mvp: new THREE.Uniform(new THREE.Matrix4()),
                    u_eyepos: new THREE.Uniform(new THREE.Vector3()),
                    u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
                },
                rendererCapabilities: params.rendererCapabilities
            }
            : undefined;
        Object.assign(shaderParams, params);
        super(shaderParams);
        this.type = "HighPrecisionLineMaterial";
        this.isHighPrecisionLineMaterial = true;
        // Apply initial parameter values.
        if (params) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
        }
        this.updateTransparencyFeature();
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuseColor.value;
    }
    set color(value) {
        this.uniforms.diffuseColor.value.copy(value);
    }
    updateTransparencyFeature() {
        this.transparent = this.opacity < 1.0 ? true : false;
    }
}
exports.HighPrecisionLineMaterial = HighPrecisionLineMaterial;
HighPrecisionLineMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionLineMaterial.DEFAULT_OPACITY = 1.0;
function isHighPrecisionLineMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionLineMaterial === true);
}
exports.isHighPrecisionLineMaterial = isHighPrecisionLineMaterial;


/***/ }),

/***/ "../harp-materials/lib/HighPrecisionPointMaterial.ts":
/*!***********************************************************!*\
  !*** ../harp-materials/lib/HighPrecisionPointMaterial.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHighPrecisionPointMaterial = exports.HighPrecisionPointMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const vertexSource = `
#ifdef USE_COLOR
varying vec3 vColor;
#endif

uniform float size;

// uniforms to implement double-precision
uniform mat4 u_mvp;             // combined modelView and projection matrix
uniform vec3 u_eyepos;          // eye position major
uniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)

// vertex attributes
attribute vec3 positionLow;     // low part

#include <high_precision_vert_func>

void main() {
    #ifdef USE_COLOR
    vColor = color.rgb;
    #endif

    vec3 pos = subtractDblEyePos(position);
    gl_Position = u_mvp * vec4(pos, 1.0);

    // ignore sizeAttenuation for now!
    gl_PointSize = size;
}`;
/**
 * Material designed to render high precision points (ideal for position-sensible data).
 */
class HighPrecisionPointMaterial extends THREE.PointsMaterial {
    /**
     * Constructs a new `HighPrecisionPointMaterial`.
     *
     * @param params - `HighPrecisionPointMaterial` parameters.
     */
    constructor(params) {
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        const shaderParams = params;
        super(shaderParams);
        this.type = "HighPrecisionPointMaterial";
        this.vertexShader = vertexSource;
        this.fragmentShader = THREE.ShaderChunk.points_frag;
        this.fog = false;
        this.uniforms = {
            // HARP-17373: Original uniform name 'diffuse' due to shader compilation
            // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.
            diffuseColor: new THREE.Uniform(new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)),
            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),
            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),
            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),
            map: new THREE.Uniform(new THREE.Texture()),
            uvTransform: new THREE.Uniform(new THREE.Matrix3()),
            u_mvp: new THREE.Uniform(new THREE.Matrix4()),
            u_eyepos: new THREE.Uniform(new THREE.Vector3()),
            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())
        };
        this.isHighPrecisionPointMaterial = true;
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                this.color.set(params.color);
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.size !== undefined) {
                this.size = params.size;
            }
            if (params.scale !== undefined) {
                this.scale = params.scale;
            }
            if (params.uvTransform !== undefined) {
                this.uvTransform = params.uvTransform;
            }
            if (params.map !== undefined) {
                this.map = params.map;
            }
        }
    }
    /**
     *  Point scale.
     */
    get scale() {
        return this.uniforms.scale.value;
    }
    set scale(value) {
        this.uniforms.scale.value = value;
    }
    /**
     * UV transformation matrix.
     */
    get uvTransform() {
        return this.uniforms.uvTransform.value;
    }
    set uvTransform(value) {
        this.uniforms.uvTransform.value = value;
    }
}
exports.HighPrecisionPointMaterial = HighPrecisionPointMaterial;
HighPrecisionPointMaterial.DEFAULT_COLOR = 0x000050;
HighPrecisionPointMaterial.DEFAULT_OPACITY = 1.0;
HighPrecisionPointMaterial.DEFAULT_SIZE = 1.0;
HighPrecisionPointMaterial.DEFAULT_SCALE = 1.0;
function isHighPrecisionPointMaterial(material) {
    return (material !== undefined &&
        material.isHighPrecisionPointMaterial === true);
}
exports.isHighPrecisionPointMaterial = isHighPrecisionPointMaterial;


/***/ }),

/***/ "../harp-materials/lib/IconMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/IconMaterial.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IconMaterial = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const vertexSource = `
attribute vec4 position;
attribute vec4 color;
attribute vec2 uv;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec4 vColor;
varying vec2 vUv;

void main() {
    vUv = uv;
    vColor = color;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform sampler2D map;

varying vec4 vColor;
varying vec2 vUv;

void main() {

    vec4 color = texture2D(map, vUv.xy);
    color *= vColor;
    if (color.a < 0.05) {
        discard;
    }
    gl_FragColor = color;
}`;
/**
 * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to
 * apply opacity.
 */
class IconMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `IconMaterial`.
     *
     * @param params - `IconMaterial` parameters. Always required except when cloning another
     * material.
     */
    constructor(params) {
        const shaderParams = params
            ? {
                name: "IconMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    map: new THREE.Uniform(params.map)
                },
                depthTest: false,
                depthWrite: false,
                transparent: true,
                vertexColors: true,
                premultipliedAlpha: true,
                rendererCapabilities: params.rendererCapabilities
            }
            : undefined;
        super(shaderParams);
    }
    /**
     * Icon texture map/atlas.
     */
    get map() {
        return this.uniforms.map.value;
    }
}
exports.IconMaterial = IconMaterial;


/***/ }),

/***/ "../harp-materials/lib/LuminosityHighPassShader.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/LuminosityHighPassShader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LuminosityHighPassShader = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.
 */
exports.LuminosityHighPassShader = {
    uniforms: {
        tDiffuse: { value: null },
        luminosityThreshold: { value: 1.0 },
        smoothWidth: { value: 1.0 },
        defaultColor: { value: new THREE.Color(0x000000) },
        defaultOpacity: { value: 0.0 }
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec3 defaultColor;
    uniform float defaultOpacity;
    uniform float luminosityThreshold;
    uniform float smoothWidth;
    varying vec2 vUv;
    void main() {
        vec4 texel = texture2D( tDiffuse, vUv );
        vec3 luma = vec3( 0.299, 0.587, 0.114 );
        float v = dot( texel.xyz, luma );
        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );
        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );
        gl_FragColor = mix( outputColor, texel, alpha );
    }`
};


/***/ }),

/***/ "../harp-materials/lib/MSAAMaterial.ts":
/*!*********************************************!*\
  !*** ../harp-materials/lib/MSAAMaterial.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MSAAMaterial = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const CopyMaterial_1 = __webpack_require__(/*! ./CopyMaterial */ "../harp-materials/lib/CopyMaterial.ts");
/**
 * The material to use for the quad of the {@link @here/harp-mapview#MSAARenderPass}
 * in the composing.
 */
class MSAAMaterial extends THREE.ShaderMaterial {
    /**
     * The constructor of `MSAAMaterial`.
     *
     * @param uniforms - The [[CopyShader]]'s uniforms.
     */
    constructor(uniforms) {
        super({
            uniforms,
            vertexShader: CopyMaterial_1.CopyShader.vertexShader,
            fragmentShader: CopyMaterial_1.CopyShader.fragmentShader,
            premultipliedAlpha: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            depthWrite: false
        });
    }
}
exports.MSAAMaterial = MSAAMaterial;


/***/ }),

/***/ "../harp-materials/lib/MapMeshMaterials.ts":
/*!*************************************************!*\
  !*** ../harp-materials/lib/MapMeshMaterials.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapMeshStandardMaterial = exports.MapMeshDepthMaterial = exports.MapMeshBasicMaterial = exports.ExtrusionFeatureMixin = exports.ExtrusionFeature = exports.FadingFeatureMixin = exports.FadingFeature = exports.DisplacementFeatureMixin = exports.hasExtrusionFeature = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ./MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const ExtrusionChunks_1 = __webpack_require__(/*! ./ShaderChunks/ExtrusionChunks */ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts");
const FadingChunks_1 = __webpack_require__(/*! ./ShaderChunks/FadingChunks */ "../harp-materials/lib/ShaderChunks/FadingChunks.ts");
const ShadowChunks_1 = __webpack_require__(/*! ./ShaderChunks/ShadowChunks */ "../harp-materials/lib/ShaderChunks/ShadowChunks.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const emptyTexture = new THREE.Texture();
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..maxVisibilityRange].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance - Distance from the camera (range: [0, 1]).
 * @param visibilityRange - object describing maximum and minimum visibility range - distances
 * from camera at which objects won't be rendered anymore.
 */
function cameraToWorldDistance(distance, visibilityRange) {
    return distance * visibilityRange.maximum;
}
/**
 * Provides common interface from mixin to internal material defines and shader uniforms.
 *
 * Call this function just after [THREE.Material] is constructed, so in derived classes after
 * super c-tor call.
 * @param mixin - The mixin that will add features to [[THREE.Material]].
 * @param material - The material that mixin feature is being applied.
 */
function linkMixinWithMaterial(mixin, material) {
    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.
    // In such case create it manually, such defines will be also injected to the shader
    // via generic THREE.js code - see THREE/WebGLProgram.js.
    if (material.defines === undefined) {
        material.defines = {};
    }
    // Link internal THREE.js material defines with mixin reference.
    // Those defines are usually created in Material c-tor, if not we have fallback above.
    mixin.shaderDefines = material.defines;
    // Prepare map for holding uniforms references from the actual shader, but check if
    // it was not already created with other mixin feature.
    if (mixin.shaderUniforms === undefined) {
        mixin.shaderUniforms = {};
    }
    // Shader uniforms may not be linked at this stage, they are injected available via Shader
    // object in onBeforeCompile callback, see: linkMixinWithShader().
}
/**
 * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.
 *
 * Function injects features (mixin) specific shader uniforms to material's shader, it also
 * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full
 * uniforms map (both feature specific and internal ones).
 * This function should be called before material's shader is pre-compiled, so the new uniforms
 * from the mixin feature are known to shader processor. The best place to use is
 * [[Material.onBeforeCompile]].
 * @param mixin - The mixin feature being applied to the material.
 * @param shader - The actual shader linked to the [[THREE.Material]].
 */
function linkMixinWithShader(mixin, shader) {
    Object.assign(shader.uniforms, mixin.shaderUniforms);
    mixin.shaderUniforms = shader.uniforms;
}
/**
 * Determines whether a given material supports extrusion.
 * @param material The material to check.
 * @returns Whether the given material supports extrusion.
 */
function hasExtrusionFeature(material) {
    return "extrusionRatio" in material;
}
exports.hasExtrusionFeature = hasExtrusionFeature;
// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge
// eslint-disable-next-line @typescript-eslint/no-redeclare
var DisplacementFeature;
(function (DisplacementFeature) {
    /**
     * Checks if feature is enabled (displacement map defined).
     *
     * @param displacementMaterial -
     */
    function isEnabled(displacementMaterial) {
        return displacementMaterial.displacementMap !== null;
    }
    DisplacementFeature.isEnabled = isEnabled;
    /**
     * Update the internals of the `DisplacementFeature` depending on the value of
     * [[displacementMap]].
     *
     * @param displacementMaterial - DisplacementFeature
     */
    function updateDisplacementFeature(displacementMaterial) {
        harp_utils_1.assert(displacementMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        const useDisplacementMap = isEnabled(displacementMaterial);
        // Whenever displacement feature state changes (between enabled/disabled) material will be
        // re-compiled, forcing new shader chunks to be added (or removed).
        const needsUpdate = Utils_1.setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
        displacementMaterial.needsUpdate = needsUpdate;
        // Update texture after change.
        if (useDisplacementMap) {
            const texture = displacementMaterial.displacementMap;
            texture.needsUpdate = true;
            displacementMaterial.shaderUniforms.displacementMap.value = texture;
        }
        else if (needsUpdate) {
            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
        }
    }
    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;
    /**
     * This function should be called on implementors of DisplacementFeature in the
     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to
     * apply displacement maps.
     *
     * @param displacementMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(displacementMaterial, shader) {
        if (!isEnabled(displacementMaterial)) {
            return;
        }
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are required for this material, we use one define working as a flag,
        // which enables/disables some chunks of shader code.
        linkMixinWithShader(displacementMaterial, shader);
        // Append the displacement map chunk to the vertex shader.
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    }
    DisplacementFeature.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
class DisplacementFeatureMixin {
    constructor() {
        this.m_displacementMap = null;
    }
    // This is here to keep tslint from reporting a missing property, the getter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    get displacementMap() {
        return this.m_displacementMap;
    }
    // This is here to keep tslint from reporting a missing property, the setter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    set displacementMap(map) {
        this.setDisplacementMap(map);
    }
    getDisplacementMap() {
        return this.m_displacementMap;
    }
    setDisplacementMap(map) {
        if (map !== this.m_displacementMap) {
            this.m_displacementMap = map;
            DisplacementFeature.updateDisplacementFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[displacementMap]]
     */
    addDisplacementProperties() {
        Object.defineProperty(this, "displacementMap", {
            get: () => {
                return this.getDisplacementMap();
            },
            set: val => {
                this.setDisplacementMap(val);
            }
        });
    }
    /**
     * Apply the displacementMap value from the parameters to the respective properties.
     */
    applyDisplacementParameters(params) {
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        const uniforms = this.shaderUniforms;
        uniforms.displacementMap = new THREE.Uniform(emptyTexture);
        uniforms.displacementScale = new THREE.Uniform(1);
        uniforms.displacementBias = new THREE.Uniform(0);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.displacementMap !== undefined) {
                this.setDisplacementMap(params.displacementMap);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            DisplacementFeature.onBeforeCompile(this, shader);
        });
        // Require material update at least once, because of new shader chunks added.
        this.needsUpdate = DisplacementFeature.isEnabled(this);
    }
    /**
     * Copy displacementMap from other DisplacementFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyDisplacementParameters(source) {
        this.setDisplacementMap(source.displacementMap);
        return this;
    }
}
exports.DisplacementFeatureMixin = DisplacementFeatureMixin;
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Checks if feature is enabled based on feature params.
     *
     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.
     * This function is crucial for shader switching (chunks injection), whenever feature state
     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)
     * whenever fading params are reasonable, even if it causes full fade in, no transparency.
     *
     * @param fadingMaterial - FadingFeature.
     */
    function isEnabled(fadingMaterial) {
        // NOTE: We could also check if full fade is not achieved, then feature could be
        // disabled, but causing material re-compile.
        return (fadingMaterial.fadeNear !== undefined &&
            fadingMaterial.fadeFar !== undefined &&
            fadingMaterial.fadeFar > 0);
    }
    FadingFeature.isEnabled = isEnabled;
    /**
     * Checks if feature is defined based on feature params.
     *
     * Fading feature will be defined if fadeNear and fadeFar are defined, their values
     * are not checked for reasonable values.
     *
     * @param fadingMaterial FadingFeature.
     */
    function isDefined(fadingMaterial) {
        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;
    }
    FadingFeature.isDefined = isDefined;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial - FadingFeature
     */
    function updateFadingFeature(fadingMaterial) {
        harp_utils_1.assert(fadingMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // Update entire material to add/remove shader fading chunks, this happens when we
        // enable/disable fading after material creation. Feature is marked via dummy define, which
        // informs about fading feature state, even if such define is not required to control
        // feature state, it makes it easy to check for shader changes.
        const useFading = isEnabled(fadingMaterial);
        const needsUpdate = Utils_1.setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
        // Enable/disable entire feature with material re-compile, this will also cause
        // new uniforms injection.
        fadingMaterial.needsUpdate = needsUpdate;
        // Check if shader uniforms references are already set in onBeforeCompile callback.
        harp_utils_1.assert(fadingMaterial.shaderUniforms.fadeNear !== undefined &&
            fadingMaterial.shaderUniforms.fadeFar !== undefined);
        // Update shader internal uniforms only if fading is enabled.
        if (useFading) {
            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
            if (needsUpdate) {
                Utils_1.enableBlending(fadingMaterial);
            }
        }
        // Perform one time update of uniforms to defaults when feature disabled (for clarity).
        else if (needsUpdate) {
            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;
            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;
            Utils_1.disableBlending(fadingMaterial);
        }
    }
    FadingFeature.updateFadingFeature = updateFadingFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (!isEnabled(fadingMaterial)) {
            return;
        }
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not required for this material, so the fading shader chunks
        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature
        // attached and easy control its state, but this define may be stripped out if needed.
        linkMixinWithShader(fadingMaterial, shader);
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As three.js is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object - [[THREE.Object3D]] to prepare for rendering.
     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for
     * actual camera setup.
     * @param fadeNear - The fadeNear value to set in the material.
     * @param fadeFar - The fadeFar value to set in the material.
     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback - If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, viewRanges);
            fadingMaterial.fadeFar =
                fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, viewRanges);
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        const needsUpdate = value !== this.m_fadeNear;
        if (needsUpdate) {
            this.m_fadeNear = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        const needsUpdate = value !== this.m_fadeFar;
        if (needsUpdate) {
            this.m_fadeFar = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        this.shaderUniforms.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
        this.shaderUniforms.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        });
        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.
        this.needsUpdate = FadingFeature.isEnabled(this);
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.
     *
     * @param extrusionMaterial -
     */
    function isEnabled(extrusionMaterial) {
        return (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN);
    }
    ExtrusionFeature.isEnabled = isEnabled;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial - ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        harp_utils_1.assert(extrusionMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // Setup shader define that when changed will force material re-compile.
        const useExtrusion = isEnabled(extrusionMaterial);
        // Use shader define as marker if feature is enabled/disabled, this is not necessary
        // required, but material requires update (re-compile) anyway to add/remove shader chunks.
        const needsUpdate = Utils_1.setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
        // Enable/disable entire feature with material re-compile.
        extrusionMaterial.needsUpdate = needsUpdate;
        // Update uniform with new value
        if (useExtrusion) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio;
        }
        // Reset uniform to default, one time only, when feature is disabled (just for clarity).
        else if (needsUpdate) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (!isEnabled(extrusionMaterial)) {
            return;
        }
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them. No defines are required to preprocess
        // shader chunks, but we utilize one just to note the feature is enabled/disabled
        // (easier debugging), this define may be easily stripped out or replaced with simple
        // boolean flag.
        linkMixinWithShader(extrusionMaterial, shader);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 *
 * @remarks
 * There is some special handling for the extrusionRatio property, which is animated via
 * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is
 * using [[extrusionRatio]] setter and getter to update
 * extrusion in a way that works well with the mixin and EdgeMaterial.
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        const needsUpdate = value !== this.m_extrusion;
        if (needsUpdate) {
            this.m_extrusion = value;
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        if (params && params.zFightingWorkaround === true) {
            this.shaderDefines.ZFIGHTING_WORKAROUND = "";
        }
        // Create uniform with default value, this ensures that it is always created,
        // so no need for checks in setters.
        this.shaderUniforms.extrusionRatio = new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        });
        this.needsUpdate = ExtrusionFeature.isEnabled(this);
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        if (source.extrusionRatio !== undefined) {
            this.setExtrusionRatio(source.extrusionRatio);
        }
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        this.addDisplacementProperties();
        this.applyDisplacementParameters(params);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        this.copyDisplacementParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    get displacementMap() {
        return null;
    }
    set displacementMap(value) {
        // to be overridden
    }
    setDisplacementMap(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    applyFadingParameters(params) {
        // to be overridden
    }
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
    addDisplacementProperties() {
        // to be overridden
    }
    applyDisplacementParameters(params) {
        // to be overridden
    }
    copyDisplacementParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
class MapMeshDepthMaterial extends THREE.MeshDepthMaterial {
    constructor(params) {
        super(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        // We need to set these to false, because otherwise three.js complains that there are
        // outputs of the vertex shader not used in the pixel shader, the properties in question
        // are `vExtrusionRatio` and `vExtrusionAxis`.
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: false }));
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in{@link ExtrusionFeatureMixin}, see below:
    //
    // applyMixinsWithoutProperties(...);
    //
    // Mixin declarations start ---------------------------------------------------------
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshDepthMaterial = MapMeshDepthMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params - `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        if ((params === null || params === void 0 ? void 0 : params.removeDiffuseLight) === true) {
            this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, shaderParameters => {
                const shader = shaderParameters;
                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace("#include <lights_physical_pars_fragment>", ShadowChunks_1.simpleLightingShadowChunk);
            });
        }
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    /**
     * This is needed to simplify the lighting calculation, currently there is no support for
     * switching this at runtime. It is required here to be a property because the parameters
     * are applied to this material, and if this isn't here, three.js will complain that the
     * property is missing.
     * @internal
     */
    get removeDiffuseLight() {
        return false;
    }
    /** @internal */
    set removeDiffuseLight(val) {
        // Stays empty.
    }
    addFadingProperties() {
        // to be overridden
    }
    applyFadingParameters(params) {
        // to be overridden
    }
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);


/***/ }),

/***/ "../harp-materials/lib/MapMeshMaterialsDefs.ts":
/*!*****************************************************!*\
  !*** ../harp-materials/lib/MapMeshMaterialsDefs.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtrusionFeatureDefs = void 0;
var ExtrusionFeatureDefs;
(function (ExtrusionFeatureDefs) {
    /**
     * Minimum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MIN = 0.0;
    /**
     * Maximum ratio value for extrusion effect
     */
    ExtrusionFeatureDefs.DEFAULT_RATIO_MAX = 1;
    /**
     * Buildings height used whenever no height-data is present or height is very small.
     *
     * Used to avoid z-fighting between ground plane and building.
     */
    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT = 0.1;
})(ExtrusionFeatureDefs = exports.ExtrusionFeatureDefs || (exports.ExtrusionFeatureDefs = {}));


/***/ }),

/***/ "../harp-materials/lib/RawShaderMaterial.ts":
/*!**************************************************!*\
  !*** ../harp-materials/lib/RawShaderMaterial.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawShaderMaterial = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
/**
 * Base class for all raw shader materials. Ensures WebGL2 compatibility for WebGL1 shaders.
 */
class RawShaderMaterial extends THREE.RawShaderMaterial {
    /**
     * The constructor of `RawShaderMaterial`.
     *
     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning
     * another material.
     */
    constructor(params) {
        const isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;
        const shaderParams = params
            ? Object.assign(Object.assign({}, params), { glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1, vertexShader: isWebGL2 && params.vertexShader
                    ? harp_utils_1.convertVertexShaderToWebGL2(params.vertexShader)
                    : params.vertexShader, fragmentShader: isWebGL2 && params.fragmentShader
                    ? harp_utils_1.convertFragmentShaderToWebGL2(params.fragmentShader)
                    : params.fragmentShader }) : undefined;
        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js
        // will log warnings.
        if (shaderParams) {
            delete shaderParams.rendererCapabilities;
        }
        super(shaderParams);
        this.invalidateFog();
        this.setOpacity(shaderParams === null || shaderParams === void 0 ? void 0 : shaderParams.opacity);
    }
    invalidateFog() {
        if (this.defines !== undefined && this.fog !== Utils_1.getShaderMaterialDefine(this, "USE_FOG")) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", this.fog);
        }
    }
    /**
     * To set the material's opacity property value and also update the opacity value of the uniforms if needed.
     * @param opacity If undefined, the value is not set
     */
    setOpacity(opacity) {
        var _a;
        if (opacity !== undefined) {
            // The base constructor may set the opacity property before,
            // therefore we don't check unequality of the current and new opacity value:
            this.opacity = opacity;
            if ((_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.opacity) {
                this.uniforms.opacity.value = opacity;
            }
        }
    }
}
exports.RawShaderMaterial = RawShaderMaterial;


/***/ }),

/***/ "../harp-materials/lib/SepiaShader.ts":
/*!********************************************!*\
  !*** ../harp-materials/lib/SepiaShader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SepiaShader = void 0;
/**
 * `SepiaShader`.
 */
exports.SepiaShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float amount;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec3 c = color.rgb;
            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );
            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );
        }`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/AtmosphereChunks.ts":
/*!**************************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/AtmosphereChunks.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.default = {
    atmosphere_vertex_utils: `

    const float RayleighScaleDepth = 0.25;

    struct AtmosphereColor
    {
        vec3 mie;
        vec3 rayleigh;
    };

    float scale(float cosAngle)
    {
        float x = 1.0 - cosAngle;
        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));
    }

    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x0 (first point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),
        // we change the equation that gives better results especially around the poles.
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Intersection points distances are defined as follows:
        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a
        // we search for x0:
        return 0.5 * (-fB - sqrt(fDet));
    }

    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {
        // Solve simple square equation for the x1 (second point of intersection).
#if defined(IMPROVE_INTERSECT_PRECISION)
        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);
#else
        float fB = 2.0 * dot(v3Pos, v3Ray);
#endif
        float fC = fCameraHeight2 - fOuterRadius2;
        // det = b^2 - 4*a*c, where a = 1
        float fDet = max(0.0, fB * fB - 4.0 * fC);
        // Compute second intersection distance:
        // x1 = (-b + sqrt(det)) / 2*a
        return 0.5 * (-fB + sqrt(fDet));
    }
    `,
    atmosphere_fragment_utils: `

    // Branch free RGB to HSV conversion.
    // Based on article:
    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
    // and optimized OpenGL SL algorithm
    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
    vec3 rgb2Hsv(vec3 c)
    {
        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        // Ternary operator may be used explicitly if compiler can use fast conditional move.
        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);
        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));
        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    // Branch free HSV to RGB conversion
    vec3 hsv2Rgb(vec3 c)
    {
        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);
        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);
    }

    vec3 correctExposure(vec3 rgb, float exposure)
    {
        const vec3 fullColor = vec3(1.0);
        return fullColor - exp(-exposure * rgb);
    }

    vec3 correctColor(vec3 rgb, vec3 hsvShift)
    {
        const float e = 0.0000001;
        // Convert rgb color to hsv
        vec3 hsv = rgb2Hsv(rgb);
        // Shift hue value with angle wrapping
        hsv.x = mod(hsv.x + hsvShift.x, 1.0);
        // Shift and clamp saturation
        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);
        // Change value if it is significant (greater then epsilon)
        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;
        // Convert shifted hsv back to rgb
        return hsv2Rgb(hsv);
    }
    `
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts":
/*!*************************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const MapMeshMaterialsDefs_1 = __webpack_require__(/*! ../MapMeshMaterialsDefs */ "../harp-materials/lib/MapMeshMaterialsDefs.ts");
const MIN_BUILDING_HEIGHT_SQUARED = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;
exports.default = {
    extrusion_pars_vertex: `
// Add define so we can check for it in the outline effect (see Outline.ts).
#define HAS_EXTRUSION_PARS_VERTEX
// Extrusion axis (xyz: vector, w: factor).
attribute vec4 extrusionAxis;
uniform float extrusionRatio;
#ifdef FLAT_SHADED
varying vec4 vExtrusionAxis;
#endif
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#endif
`,
    extrusion_vertex: `
#define HAS_EXTRUSION_VERTEX
#ifdef ZFIGHTING_WORKAROUND
// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.
const float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};
float extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);
vExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;
#else
float vExtrusionRatio = extrusionRatio;
#endif
transformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);
#ifdef FLAT_SHADED
vExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);
#endif
`,
    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded
    // geometries, computes the normal either with the extrusion axis or fragment derivatives based
    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).
    extrusion_normal_fragment_begin: `
#ifdef FLAT_SHADED
    // Flattened this divergent path to prevent undefined behaviour in the following derivatives
    // functions. For more info:
    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches

    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...
    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));
    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));
    vec3 normal = cross( fdx, fdy );
    if (vExtrusionAxis.w > 0.999999) {
        normal = vExtrusionAxis.xyz;
    }
    normal = normalize(normal);
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);
			bitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);
		#endif
	#endif
#endif
// non perturbed normal for clearcoat among others
vec3 geometryNormal = normal;
`,
    extrusion_pars_fragment: `
#ifdef ZFIGHTING_WORKAROUND
varying float vExtrusionRatio;
#else
uniform float extrusionRatio;
#endif
varying vec4 vExtrusionAxis;
`,
    extrusion_fragment: `
#ifndef ZFIGHTING_WORKAROUND
float vExtrusionRatio = extrusionRatio;
#endif
gl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/FadingChunks.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/FadingChunks.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * The shader chunks have their lines "#ifdef USE_FADING" commented out, because currently the
 * mesh materials use individually created shader strings based on the materials settings.
 * @see [[FadingMeshBasicMaterial]]
 **/
exports.default = {
    fading_pars_vertex: `
varying float fadingDepth;
`,
    fading_vertex: `
fadingDepth = -mvPosition.z;
`,
    fading_pars_fragment: `
varying float fadingDepth;
uniform float fadeNear;
uniform float fadeFar;
`,
    fading_fragment: `

// lerp with "hard" edges
//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);

// smooth transitions
float fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );

gl_FragColor.a *= 1.0 - fadingFactor;

// debugging color:
// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/LinesChunks.ts":
/*!*********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/LinesChunks.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineCapsModes = void 0;
/**
 * Lists supported line caps types/modes.
 */
var LineCapsModes;
(function (LineCapsModes) {
    LineCapsModes[LineCapsModes["CAPS_NONE"] = 0] = "CAPS_NONE";
    LineCapsModes[LineCapsModes["CAPS_SQUARE"] = 1] = "CAPS_SQUARE";
    LineCapsModes[LineCapsModes["CAPS_ROUND"] = 2] = "CAPS_ROUND";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_IN"] = 3] = "CAPS_TRIANGLE_IN";
    LineCapsModes[LineCapsModes["CAPS_TRIANGLE_OUT"] = 4] = "CAPS_TRIANGLE_OUT";
})(LineCapsModes = exports.LineCapsModes || (exports.LineCapsModes = {}));
exports.default = {
    extrude_line_vert_func: `
vec3 extrudeLine(
        in vec3 vertexPosition,
        in float linePosition,
        in float extrusionWidth,
        in vec4 bitangent,
        in vec3 tangent,
        in float tanHalfAngle,
        inout vec2 uv
    ) {
    vec3 result = vertexPosition;
    // Retrieve the angle between this segment and the previous one (stored in the bitangent w
    // component).
    float angle = bitangent.w;
    // Extrude according to the angle between segments to properly render narrow joints...
    if (angle != 0.0) {
        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);
        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;
    }
    // ... or extrude in a simple manner for segments that keep the same direction.
    else {
        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;
        uv.x = linePosition + uv.x * extrusionWidth;
    }
    uv.y *= extrusionWidth;
    return result;
}
`,
    round_edges_and_add_caps: `
#define CAPS_NONE ${LineCapsModes.CAPS_NONE}
#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}
#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}
#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}
#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}

float roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {
    // Compute the line's width to length ratio.
    float widthRatio = range.y / range.x;

    // Compute the inner segment distance (same for all cap mode).
    float dist = abs(coords.y);
    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);
    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);
    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));
    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));

    #if CAPS_MODE != CAPS_ROUND
    // Compute the caps mask.
    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);
    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);
    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);
    float capMask = capRangeMask * max(beginCapMask, endCapMask);

    // Compute the outer segment distance (specific for each cap mode).
    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;
    #if CAPS_MODE == CAPS_NONE
    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);
    #elif CAPS_MODE == CAPS_SQUARE
    dist = mix(dist, max(abs(coords.y), capDist), capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_OUT
    dist = mix(dist, abs(coords.y) + capDist, capMask);
    #elif CAPS_MODE == CAPS_TRIANGLE_IN
    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);
    #endif
    #endif // CAPS_MODE != CAPS_ROUND

    return dist;
}
`,
    tile_clip_func: `
void tileClip(vec2 tilePos, vec2 tileSize) {
    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))
        discard;
    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))
        discard;
}
`,
    high_precision_vert_func: `
vec3 subtractDblEyePos( const in vec3 pos ) {
    vec3 t1 = positionLow - u_eyepos_lowpart;
    vec3 e = t1 - positionLow;
    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;
    vec3 high_delta = t1 + t2;
    vec3 low_delta = t2 - (high_delta - t1);
    return (high_delta + low_delta);
}
`
};


/***/ }),

/***/ "../harp-materials/lib/ShaderChunks/ShadowChunks.ts":
/*!**********************************************************!*\
  !*** ../harp-materials/lib/ShaderChunks/ShadowChunks.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simpleLightingShadowChunk = void 0;
/**
 * This shader chunk replaces the default lighting in the standard material, the problem with this
 * is that the final pixel color is the addition of the material color and the light, this means
 * that the final map's rendered color is vastly different from that configured by the designers.
 * This chunk removes the extra highlight by providing just two colors, the material color when not
 * in shadow and a reduced color value when in shadow (currently 50% of the material's color).
 */
exports.simpleLightingShadowChunk = `
    struct PhysicalMaterial {
        vec3	diffuseColor;
        float	specularRoughness;
        vec3	specularColor;
    };

    #define DEFAULT_SPECULAR_COEFFICIENT 0.04

    void RE_Direct_Physical( const in IncidentLight directLight,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
        // directLight.color is the light color * shadow, internally three.js uses a step function, so
        // this value is either the light color or black. in order to lighten up the shadows, we
        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to
        // the material's diffuse color.
        #if defined(USE_SHADOWMAP)
            reflectedLight.directDiffuse = (0.5 * directLight.color +
                vec3(0.5,0.5,0.5)) * material.diffuseColor;
        #else
            reflectedLight.directDiffuse = material.diffuseColor;
        #endif
    }

    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight ) {
            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)
    }

    void RE_IndirectSpecular_Physical( const in vec3 radiance,
        const in vec3 irradiance,
        const in vec3 clearcoatRadiance,
        const in GeometricContext geometry,
        const in PhysicalMaterial material,
        inout ReflectedLight reflectedLight) {
            // Disable specular reflection of light.
    }

    #define RE_Direct               RE_Direct_Physical
    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical
    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical
`;


/***/ }),

/***/ "../harp-materials/lib/SkyAtmosphereMaterial.ts":
/*!******************************************************!*\
  !*** ../harp-materials/lib/SkyAtmosphereMaterial.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkyAtmosphereMaterial = exports.SkyAtmosphereShader = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const AtmosphereChunks_1 = __webpack_require__(/*! ./ShaderChunks/AtmosphereChunks */ "../harp-materials/lib/ShaderChunks/AtmosphereChunks.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const EQUATORIAL_RADIUS = 6378137.0;
/**
 * `SkyAtmosphereShader`.
 *
 * Describes shading of atmosphere as seen from outer space.
 */
exports.SkyAtmosphereShader = {
    uniforms: {
        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),
        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),
        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),
        // Environment settings:
        // atmosphere inner and outer radius, camera height
        u_atmosphereEnv: new THREE.Uniform(new THREE.Vector3(
        // Maximum inner radius
        EQUATORIAL_RADIUS, 
        // Maximum outer radius
        EQUATORIAL_RADIUS * 1.025, 
        // Camera height
        0.0)),
        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),
        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),
        offset: new THREE.Uniform(33.0),
        exponent: new THREE.Uniform(0.6),
        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)),
        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far
    },
    vertexShader: `
    precision highp float;
    precision highp int;

    attribute vec4 position;

    uniform mat4 u_modelViewProjection;
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_hsvCorrection;

    const float Pi = 3.141592653589793;
    const float Kr = 0.0025;
    const float Kr4PI = Kr * 4.0 * Pi;
    const float Km = 0.0015;
    const float Km4PI = Km * 4.0 * Pi;
    const float ESun = 15.0; // should be 15.0
    const float KmESun = Km * ESun;
    const float KrESun = Kr * ESun;
    const vec3 InvWavelength = vec3(
        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)
        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)
        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)

    const int nSamples = 2;
    const float fSamples = 2.0;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_1.default.atmosphere_vertex_utils}

    //
    // Computes rayleight and mia atmosphere factors for sky.
    //
    // Code based on GPU Gems article.
    //
    // Author: Sean O'Neil
    //
    // Copyright (c) 2004 Sean O'Neil
    //
    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering
    //
    // Further modifications by HERE
    //
    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir)
    {
        // Unpack attributes
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        // All that may be const or define(s) at further optimization:
        float fScale = 1.0 / (fOuterRadius - fInnerRadius);
        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);
        float fCameraHeight2 = fCameraHeight * fCameraHeight;
        float fOuterRadius2 = fOuterRadius * fOuterRadius;

        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)
        vec3 v3Ray = v3Pos - u_eyePositionWorld;
        float fFar = length(v3Ray);
        v3Ray /= fFar;

    #ifdef CAMERA_IN_SPACE

        // Calculate the closest intersection of the ray with the outer
        // atmosphere, this is the first point of the ray passing through the atmosphere dome.
        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);
        // Make far relative to first atmosphere intersection
        fFar -= fNear;

        // Compute the ray's starting position within the atmosphere, then
        // calculate its scattering offset
        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;

        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;
        float fStartDepth = exp(-1.0 / RayleighScaleDepth );
        float fStartOffset = fStartDepth * scale(fStartAngle);

    #else // CAMERA_IN_ATMOSPHERE

        // The ray starts already in atmosphere
        vec3 v3Start = u_eyePositionWorld;
        float height = length(v3Start);
        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));
        float fStartAngle = dot(v3Ray, v3Start) / height;
        float fStartOffset = depth * scale(fStartAngle);

    #endif

        // Initialize the scattering loop variables
        float fSampleLength = fFar / fSamples;
        float fScaledLength = fSampleLength * fScale;
        vec3 v3SampleRay = v3Ray * fSampleLength;
        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;

        // Now loop through the sample rays
        vec3 v3BaseColor = vec3(0.0);
        vec3 v3Attenuate = vec3(0.0);
        for(int i=0; i < nSamples; i++)
        {
            float height = length(v3SamplePoint);
            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));
            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;
            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;
            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));
            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));
            v3BaseColor += v3Attenuate * (depth * fScaledLength);
            v3SamplePoint += v3SampleRay;
        }

        // Scale the Mie and Rayleigh colors and set up output of the function
        AtmosphereColor color;
        color.mie = v3BaseColor * KmESun;
        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);
        return color;
    }

    void main(void)
    {
        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
        #else
            vec3 vLightDir = u_eyePositionWorld;
        #endif
        vLightDir = normalize(vLightDir);

        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir);
        v_mieColor = atmColor.mie;
        v_rayleighColor = atmColor.rayleigh;
        v_vertToCamera = u_eyePositionWorld - position.xyz;

        gl_Position = u_modelViewProjection * position;
    }
    `,
    fragmentShader: `
    // Because of harsh light distribution the exposure correction is always enabled for the sky.
    #define CORRECT_EXPOSURE 1

    precision highp float;
    precision highp int;

    #ifdef CORRECT_COLOR
    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness
    #endif

    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height
    uniform vec3 u_eyePositionWorld;
    uniform vec3 u_lightDirectionWorld;

    const float g = -0.95;
    const float g2 = g * g;

    varying vec3 v_rayleighColor;
    varying vec3 v_mieColor;
    varying vec3 v_vertToCamera;

    ${AtmosphereChunks_1.default.atmosphere_fragment_utils}

    void main(void)
    {
        float fInnerRadius = u_atmosphereEnv.x;
        float fOuterRadius = u_atmosphereEnv.y;
        float fCameraHeight = u_atmosphereEnv.z;

        #ifdef DYNAMIC_LIGHT
            vec3 vLightDir = u_lightDirectionWorld;
            // Alter alpha based on time of day (0.0 = night , 1.0 = day)
            float fNightAlpha = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);
        #else
            vec3 vLightDir = u_eyePositionWorld;
            float fNightAlpha = 1.0;
        #endif
        vLightDir = normalize(vLightDir);

        // NOTE:
        // For better precision normalization may be added on fragment (for mobile devices)
        // while in vertex shader may be left un-normalized
        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);
        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);
        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);
        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);

        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;

        // Sky produces very harsh lighting effect so exposure correction is always enabled.
    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)
        // Exposure factor may be exposed to uniform variable.
        cRgb = correctExposure(cRgb, 2.0);
    #endif

    #ifdef CORRECT_COLOR
        cRgb = correctColor(cRgb, u_hsvCorrection);
    #endif

        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)
        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /
            (fOuterRadius - fInnerRadius), 0.0, 1.0);
        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);

        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));
    }
    `
};
class SkyAtmosphereMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `SkyAtmosphereMaterial`.
     *
     * @param params - `SkyAtmosphereMaterial` parameters. Always required except when cloning
     * another material.
     */
    constructor(params) {
        let shaderParams;
        if (params) {
            // Import shader chunks
            const defines = {};
            defines.CAMERA_IN_SPACE = "";
            shaderParams = {
                name: "SkyAtmosphereMaterial",
                vertexShader: exports.SkyAtmosphereShader.vertexShader,
                fragmentShader: exports.SkyAtmosphereShader.fragmentShader,
                uniforms: exports.SkyAtmosphereShader.uniforms,
                transparent: true,
                depthTest: true,
                depthWrite: false,
                side: THREE.BackSide,
                blending: THREE.NormalBlending,
                fog: false,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
    }
    setDynamicLighting(enableLighting) {
        Utils_1.setShaderMaterialDefine(this, "DYNAMIC_LIGHT", enableLighting);
    }
    /**
     * Set maximum outer radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025
     */
    set outerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.y = radius;
    }
    get outerRadius() {
        return this.uniforms.u_atmosphereEnv.value.y;
    }
    /**
     * Set maximum inner radius of atmosphere.
     *
     * @default [[EarthConstants.EQUATORIAL_RADIUS]].
     */
    set innerRadius(radius) {
        this.uniforms.u_atmosphereEnv.value.x = radius;
    }
    get innerRadius() {
        return this.uniforms.u_atmosphereEnv.value.x;
    }
    /**
     * Updates the uniform data of a material used to render an atmosphere.
     *
     * This includes only uniforms that may change frame by frame, other uniforms are
     * accessed with convenient material setters and getters.
     *
     * @param shaderMaterial - Material which uniforms will be updated.
     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.
     * @param lightDirection - The light directional vector in world space.
     * @param camera - Camera used in rendering.
     */
    updateUniforms(shaderMaterial, object, camera, lightDirection) {
        const cameraInfo = this.getCameraInfo(object, camera);
        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {
            if (shaderMaterial.uniforms &&
                shaderMaterial.uniforms.u_atmosphereEnv &&
                shaderMaterial.uniforms.u_hsvCorrection &&
                shaderMaterial.uniforms.u_eyePositionWorld &&
                shaderMaterial.uniforms.u_modelViewProjection &&
                shaderMaterial.uniforms.u_lightDirectionWorld) {
                const eyePos = cameraInfo.eyePos;
                const mvp = cameraInfo.modelViewProjection;
                const cameraHeight = cameraInfo.eyeHeight;
                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);
                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);
                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;
                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();
                const cameraInSpace = cameraHeight > this.outerRadius;
                const needsUpdate0 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_SPACE", cameraInSpace);
                const needsUpdate1 = Utils_1.setShaderDefine(shaderMaterial.defines, "CAMERA_IN_ATMOSPHERE", !cameraInSpace);
                shaderMaterial.needsUpdate =
                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;
            }
            else {
                throw Error("Atmosphere material has missing uniforms");
            }
        }
        else {
            throw Error("Wrong object used, only Material objects are supported");
        }
    }
    /*
     * Calculate camera position used in vertex shader of atmosphere materials.
     *
     * @param object -
     * @param camera - Camera used to get the eye position.
     */
    getCameraInfo(object, camera, reverse = false) {
        if (reverse) {
            const modelMatrix = new THREE.Matrix4().identity();
            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            object.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            camera.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
        else {
            const modelMatrix = object.matrixWorld;
            const viewMatrix = camera.matrixWorldInverse;
            const projectionMatrix = camera.projectionMatrix;
            const mvpMatrix = new THREE.Matrix4();
            // MVP = Projection * View * Model
            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);
            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);
            const eyePos = new THREE.Vector3();
            camera.getWorldPosition(eyePos);
            const objectPos = new THREE.Vector3();
            object.getWorldPosition(objectPos);
            const eyeHeight = objectPos.distanceTo(eyePos);
            // Normally we would return simply camera position, but since camera is not moving in
            // the globe view only the world, we need to calculate eye relative to object position.
            eyePos.sub(objectPos);
            return {
                modelViewProjection: mvpMatrix,
                eyePos,
                eyeHeight
            };
        }
    }
}
exports.SkyAtmosphereMaterial = SkyAtmosphereMaterial;


/***/ }),

/***/ "../harp-materials/lib/SolidLineMaterial.ts":
/*!**************************************************!*\
  !*** ../harp-materials/lib/SolidLineMaterial.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SolidLineMaterial = exports.LineDashesModes = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const MapMeshMaterials_1 = __webpack_require__(/*! ./MapMeshMaterials */ "../harp-materials/lib/MapMeshMaterials.ts");
const RawShaderMaterial_1 = __webpack_require__(/*! ./RawShaderMaterial */ "../harp-materials/lib/RawShaderMaterial.ts");
const LinesChunks_1 = __webpack_require__(/*! ./ShaderChunks/LinesChunks */ "../harp-materials/lib/ShaderChunks/LinesChunks.ts");
const Utils_1 = __webpack_require__(/*! ./Utils */ "../harp-materials/lib/Utils.ts");
const LineCapsDefinesMapping = {
    None: LinesChunks_1.LineCapsModes.CAPS_NONE,
    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,
    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,
    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,
    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT
};
const DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {
    const defineKey = lineCapsName;
    const defineValue = LineCapsDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var LineDashesModes;
(function (LineDashesModes) {
    LineDashesModes[LineDashesModes["DASHES_SQUARE"] = 0] = "DASHES_SQUARE";
    LineDashesModes[LineDashesModes["DASHES_ROUND"] = 1] = "DASHES_ROUND";
    LineDashesModes[LineDashesModes["DASHES_DIAMOND"] = 2] = "DASHES_DIAMOND";
})(LineDashesModes = exports.LineDashesModes || (exports.LineDashesModes = {}));
const LineDashesDefinesMapping = {
    Square: LineDashesModes.DASHES_SQUARE,
    Round: LineDashesModes.DASHES_ROUND,
    Diamond: LineDashesModes.DASHES_DIAMOND
};
const DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {
    const defineKey = lineDashesName;
    const defineValue = LineDashesDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
/**
 * The vLength contains the actual line length, it's needed for the creation of line caps by
 * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`
 */
/**
 * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was
 * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on
 * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than
 * the full line length.
 */
const tmpColor = new THREE.Color();
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec3 extrusionCoord;
attribute vec3 position;
attribute vec4 biTangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform float offset;
uniform vec2 drawRange;

#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    // Calculate the segment.
    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;
    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;

    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.
    float linePos = mix(segment.x, segment.y, segmentPos);
    vec2 extrusionDir = sign(extrusionCoord.xy);
    // Precompute to avoid computing multiple times
    float tanHalfAngle = tan(biTangent.w / 2.0);
    float extrusionFactor = extrusionDir.y * tanHalfAngle;

    // Calculate the extruded vertex position (and scale the extrusion direction).
    vec3 pos = extrudeLine(
        position, linePos, extrusionWidth + outlineWidth, biTangent, tangent, tanHalfAngle,
        extrusionDir);

    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).
    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);
    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);

    // Adjust the segment to fit the drawRange.
    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;
    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {
        vCoords.zw += 1.0;
    }
    if (vCoords.z < drawRange.x) {
        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);
    }
    if (vCoords.w > drawRange.y) {
        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);
    }

    // Transform position.
    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    // Shift the line based on the offset, where the bitangent is the cross product of the average
    // of the two direction vectors (the previous and next segment directions) and the normal of
    // the line (facing into the sky). The w component is the angle between the two segments.
    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how
    // much we need to extend the offset. Note, orthough this looks complicated we are doing this
    // in the vertex shader, so it should not cause a performance issue.
    pos += biTangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Pass extruded position to fragment shader.
    #ifdef USE_TILE_CLIP
    vPosition = pos;
    #endif

    #ifdef USE_COLOR
    // Pass vertex color to fragment shader.
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuseColor;
uniform vec3 outlineColor;
uniform float opacity;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform vec2 tileSize;
uniform vec2 drawRange;

#ifdef USE_DASHED_LINE
uniform float dashSize;
uniform float gapSize;
uniform vec3 dashColor;

#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}
#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}
#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif

varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

#include <round_edges_and_add_caps>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {
    float alpha = opacity;
    vec3 outputDiffuse = diffuseColor;

    #ifdef USE_TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).
    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);
    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).
    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;

    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope
    // of distToChange increases (i.e. the line is further away).
    float width = fwidth(distToEdge);

    float s = opacity < 0.98
        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep
        : smoothstep(-width, width, distToEdge);

    if (opacity < 0.98 && 1.0 - s < opacity) {
        // drop the fragment when the line is using opacity.
        discard;
    }

    alpha *= 1.0 - s;

    #ifdef USE_DASHED_LINE
    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).
    float d = dashSize / vRange.x;
    float g = gapSize / vRange.x;
    float distToDashOrigin = mod(vCoords.x, d + g) / d;

    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the
    // dashBlendFactor similarly on how we did it for the line opacity.
    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);
    #if DASHES_MODE == DASHES_ROUND
    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));
    #elif DASHES_MODE == DASHES_DIAMOND
    distToDashEdge -= distToCenter * 0.5;
    #endif
    float dashWidth = fwidth(distToDashEdge);
    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);

    #ifdef USE_DASH_COLOR
    outputDiffuse = mix(diffuseColor, dashColor, dashBlendFactor);
    #endif
    #endif

    #ifdef USE_OUTLINE
    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and
    // compute the outlineBlendFactor (used to mix line and outline colors).
    float distToOutline = distToCenter - 1.0;
    float outlineWidth = fwidth(distToOutline);
    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);

    // Mix the colors using the different computed factors.
    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);
    outputDiffuse = mix(
      mix(
        mix(outlineColor, diffuseColor, colorBlendFactor),
        outputDiffuse,
        dashBlendFactor
      ),
      outlineColor,
      outlineBlendFactor
    );
    #else
    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);
    #endif
    #endif

    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    // Multiply the alpha by the dashBlendFactor.
    #if defined(USE_OUTLINE)
    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);
    #else
    alpha *= 1.0 - dashBlendFactor;
    #endif
    #endif

    #ifdef USE_COLOR
    gl_FragColor = vec4( outputDiffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( outputDiffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif


}`;
/**
 * Material designed to render solid variable-width lines.
 */
class SolidLineMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `SolidLineMaterial`.
     *
     * @param params - `SolidLineMaterial` parameters. Always required except when cloning another
     * material.
     */
    constructor(params) {
        var _a;
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        // Setup default defines.
        const defines = {
            CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND,
            DASHES_MODE: LineDashesModes.DASHES_SQUARE
        };
        // Prepare defines based on params passed in, before super class c-tor, this ensures
        // proper set for shader compilation, without need to re-compile.
        let fogParam = true;
        let opacityParam = 1.0;
        let displacementMap;
        let shaderParams;
        if (params) {
            fogParam = params.fog === true;
            if (fogParam) {
                Utils_1.setShaderDefine(defines, "USE_FOG", true);
            }
            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;
            displacementMap = params.displacementMap;
            if (displacementMap !== undefined) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;
            if (hasOutline) {
                Utils_1.setShaderDefine(defines, "USE_OUTLINE", true);
            }
            shaderParams = {
                name: "SolidLineMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: THREE.UniformsUtils.merge([
                    {
                        // HARP-17373: Original uniform name 'diffuse' due to shader compilation
                        // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.
                        diffuseColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                        outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
                        offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),
                        opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                        tileSize: new THREE.Uniform(new THREE.Vector2()),
                        fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                        fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                        displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),
                        drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
                        dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),
                        gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)
                    },
                    // We need the fog uniforms available when we use `fog` setter as the internal
                    // recompilation cannot add or remove uniforms.
                    THREE.UniformsLib.fog
                ]),
                defines,
                // No need to pass overridden `fog` and `opacity` params they will be set
                // after super c-tor call.
                fog: fogParam,
                opacity: opacityParam,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
        // Required to satisfy compiler error if fields has no initializer or are not definitely
        // assigned in the constructor, this also mimics ShaderMaterial set of defaults
        // for overridden props.
        this.fog = fogParam;
        this.setOpacity(opacityParam);
        // initialize the stencil pass
        this.stencilFunc = THREE.NotEqualStencilFunc;
        this.stencilZPass = THREE.ReplaceStencilOp;
        this.stencilRef = 1;
        this.stencilWrite = false;
        Utils_1.enforceBlending(this);
        this.extensions.derivatives = true;
        // Apply initial parameter values.
        if (params) {
            if (params.color !== undefined) {
                tmpColor.set(params.color);
                this.color = tmpColor;
            }
            if (params.outlineColor !== undefined) {
                tmpColor.set(params.outlineColor);
                this.outlineColor = tmpColor;
            }
            if (params.lineWidth !== undefined) {
                this.lineWidth = params.lineWidth;
            }
            if (params.outlineWidth !== undefined) {
                this.outlineWidth = params.outlineWidth;
            }
            if (params.opacity !== undefined) {
                this.setOpacity(params.opacity);
            }
            if (params.depthTest !== undefined) {
                this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== undefined) {
                this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.caps !== undefined) {
                this.caps = params.caps;
            }
            if (params.drawRangeStart !== undefined) {
                this.drawRangeStart = params.drawRangeStart;
            }
            if (params.drawRangeEnd !== undefined) {
                this.drawRangeEnd = params.drawRangeEnd;
            }
            if (params.dashes !== undefined) {
                this.dashes = params.dashes;
            }
            if (params.dashColor !== undefined) {
                tmpColor.set(params.dashColor);
                this.dashColor = tmpColor;
            }
            if (params.dashSize !== undefined) {
                this.dashSize = params.dashSize;
            }
            if (params.gapSize !== undefined) {
                this.gapSize = params.gapSize;
            }
            if (params.fog !== undefined) {
                this.fog = params.fog;
                this.invalidateFog();
            }
            this.offset = (_a = params.offset) !== null && _a !== void 0 ? _a : 0;
        }
    }
    /**
     * Sets the offset used to shift the line in world space perpendicular to the direction.
     */
    set offset(offset) {
        this.uniforms.offset.value = offset;
    }
    /**
     * @return The offset to shift the line in world space perpendicular to the direction.
     */
    get offset() {
        return this.uniforms.offset.value;
    }
    /**
     * The method to call to recompile a material to enable/disable outline effect
     *
     * @param enable - Whether we want to use outline.
     */
    set outline(enable) {
        Utils_1.setShaderMaterialDefine(this, "USE_OUTLINE", enable);
    }
    /**
     * Checks if outline is enabled.
     */
    get outline() {
        return Utils_1.getShaderMaterialDefine(this, "USE_OUTLINE") === true;
    }
    /** @override */
    setOpacity(opacity) {
        super.setOpacity(opacity);
        if (opacity !== undefined) {
            this.stencilWrite = opacity < 0.98;
        }
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuseColor.value;
    }
    set color(value) {
        this.uniforms.diffuseColor.value.copy(value);
    }
    /**
     * Outline color.
     *
     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.
     */
    get outlineColor() {
        return this.uniforms.outlineColor.value;
    }
    set outlineColor(value) {
        this.uniforms.outlineColor.value.copy(value);
    }
    /**
     * Dash color.
     *
     * @note The property [[gapSize]] need to be set to enable dashed line.
     */
    get dashColor() {
        return this.uniforms.dashColor.value;
    }
    set dashColor(value) {
        this.uniforms.dashColor.value.copy(value);
        Utils_1.setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
    }
    /**
     * Line width.
     */
    get lineWidth() {
        return this.uniforms.extrusionWidth.value * 2;
    }
    set lineWidth(value) {
        this.uniforms.extrusionWidth.value = value / 2;
    }
    /**
     * Outline width.
     */
    get outlineWidth() {
        return this.uniforms.outlineWidth.value;
    }
    set outlineWidth(value) {
        this.uniforms.outlineWidth.value = value;
        this.outline = value > 0.0;
    }
    /**
     * Size of the dashed segments.
     *
     * @note Ths [[gapSize]] need to be also set to enable dashed line.
     * @see gapSize.
     */
    get dashSize() {
        return this.uniforms.dashSize.value;
    }
    set dashSize(value) {
        this.uniforms.dashSize.value = value;
    }
    /**
     * Size of the gaps between dashed segments.
     *
     * @note You may also need to set [[dashSize]].
     * @see dashSize.
     */
    get gapSize() {
        return this.uniforms.gapSize.value;
    }
    set gapSize(value) {
        var _a, _b;
        this.uniforms.gapSize.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_DASHED_LINE", value > 0.0);
        if (((_b = (_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.gapSize) === null || _b === void 0 ? void 0 : _b.value) === 0) {
            this.stencilWrite = this.opacity < 0.98;
        }
    }
    /**
     * Caps mode.
     */
    get caps() {
        let result = "Round";
        const capsMode = Utils_1.getShaderMaterialDefine(this, "CAPS_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineCaps type.
        if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
            result = DefinesLineCapsMapping[capsMode];
        }
        return result;
    }
    set caps(value) {
        // Line caps mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineCapsDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value]);
        }
    }
    /**
     * Dashes mode.
     */
    get dashes() {
        let result = "Square";
        const dashesMode = Utils_1.getShaderMaterialDefine(this, "DASHES_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineDashes type.
        if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
            result = DefinesLineDashesMapping[dashesMode];
        }
        return result;
    }
    set dashes(value) {
        // Line dashes mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineDashesDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value]);
        }
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
    get drawRangeStart() {
        return this.uniforms.drawRange.value.x;
    }
    set drawRangeStart(value) {
        this.uniforms.drawRange.value.x = value;
    }
    get drawRangeEnd() {
        return this.uniforms.drawRange.value.y;
    }
    set drawRangeEnd(value) {
        this.uniforms.drawRange.value.y = value;
    }
    set clipTileSize(tileSize) {
        this.uniforms.tileSize.value.copy(tileSize);
        const useTileClip = tileSize.x > 0 && tileSize.y > 0;
        Utils_1.setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
    }
    get clipTileSize() {
        return this.uniforms.tileSize.value;
    }
    copy(other) {
        super.copy(other);
        this.invalidateFog();
        this.setOpacity(other.opacity);
        return this;
    }
}
exports.SolidLineMaterial = SolidLineMaterial;
SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
SolidLineMaterial.DEFAULT_WIDTH = 1.0;
SolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;
SolidLineMaterial.DEFAULT_OPACITY = 1.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;
SolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;
SolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;
SolidLineMaterial.DEFAULT_OFFSET = 0.0;


/***/ }),

/***/ "../harp-materials/lib/Utils.ts":
/*!**************************************!*\
  !*** ../harp-materials/lib/Utils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getShaderDefine = exports.setShaderDefine = exports.getShaderMaterialDefine = exports.setShaderMaterialDefine = exports.disableBlending = exports.enableBlending = exports.enforceBlending = exports.insertShaderInclude = exports.DEFINE_BOOL_FALSE = exports.DEFINE_BOOL_TRUE = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Values for boolean shader defines
 */
exports.DEFINE_BOOL_TRUE = "";
exports.DEFINE_BOOL_FALSE = undefined;
/**
 * Insert shader includes after another shader include.
 *
 * @param shaderContent - Original string.
 * @param shaderName - String to append to.
 * @param insertedShaderName - String to append after string `shaderA`.
 * @param addTab - If `true`, a tab character will be inserted before `shaderB`.
 */
function insertShaderInclude(shaderContent, shaderName, insertedShaderName, addTab) {
    const tabChar = addTab === true ? "\t" : "";
    const result = shaderContent.replace(`#include <${shaderName}>`, `#include <${shaderName}>
${tabChar}#include <${insertedShaderName}>`);
    return result;
}
exports.insertShaderInclude = insertShaderInclude;
/**
 * THREE.js is enabling blending only when transparent is `true` or when a blend mode
 * different than `NormalBlending` is set.
 * Since we don't want to set transparent to true and mess up the render order we set
 * `CustomBlending` with the same parameters as the `NormalBlending`.

 * @param material - `Material` that should use blending
 * @note This function should not be used in frame update after material has been passed to WebGL.
 * In such cases use [[enableBlending]] instead.
 */
function enforceBlending(material) {
    if (material.transparent) {
        // Nothing to do
        return;
    }
    enableBlending(material);
    material.forcedBlending = true;
}
exports.enforceBlending = enforceBlending;
/**
 * Enable alpha blending using THREE.CustomBlending setup.
 *
 * Function enables blending using one of predefined modes, for both color and alpha components:
 * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]
 * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled
 * for this material.
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @param material - The material or material parameters to modify.
 */
function enableBlending(material) {
    if (material.transparent === true || material.forcedBlending === true) {
        // Nothing to do
        return;
    }
    material.blending = THREE.CustomBlending;
    if (material.premultipliedAlpha === true) {
        material.blendSrc = THREE.OneFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
    else {
        material.blendSrc = THREE.SrcAlphaFactor;
        material.blendDst = THREE.OneMinusSrcAlphaFactor;
        material.blendSrcAlpha = THREE.OneFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }
}
exports.enableBlending = enableBlending;
/**
 * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].
 *
 * @note Blending mode change does not require material update.
 * @see THREE.Material.needsUpdate.
 * @see enableBlending.
 * @param material - The material or material parameters to modify.
 */
function disableBlending(material) {
    if (material.transparent === true || material.forcedBlending === true) {
        // Nothing to do
        return;
    }
    material.blending = THREE.NormalBlending;
}
exports.disableBlending = disableBlending;
/**
 * Setup material shader _define_ using two allowable semantics.
 *
 * Function accepts two types of values for shader preprocessor _define_:
 * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,
 * such defines may be handled in the shader using __#ifdef__ semantics:
 * ```
 * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)
 * // do something
 * #endif
 * ```
 *
 * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some
 * code or even set compile time constants affecting shaders math:
 * ```
 * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0
 * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)
 * #endif
 * ```
 * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.
 *
 * @param material - The [[THREE.ShaderMaterial]] which shader _define_ will be set.
 * @param key - Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.
 * @param value - The value to be set as number or boolean specifying if preprocessor define
 * should be defined or not.
 * @returns [[true]] if material has been forced to update (re-compile) due to define changes,
 * return [[false]] whenever define has not been changed.
 */
function setShaderMaterialDefine(material, key, value) {
    harp_utils_1.assert(material.defines !== undefined, "Do not use this function in ShaderMaterial derived c-tor.");
    const semanticValue = getShaderMaterialDefine(material, key);
    const needsUpdate = value !== semanticValue;
    // Nothing to change - early exit
    if (!needsUpdate) {
        return false;
    }
    setShaderDefine(material.defines, key, value);
    material.needsUpdate = needsUpdate;
    return true;
}
exports.setShaderMaterialDefine = setShaderMaterialDefine;
/**
 * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.
 *
 * The semantic used in entire engine assumes that preprocessor defines may have only binary
 * (defined / not defined) or numerical values, this ensures consistency in the shaders and
 * materials code.
 * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but
 * not numerical value it returns [[true]], otherwise returns number.
 * @see setShaderMaterialDefine.
 *
 * @param material - The material which shader defines are accessed.
 * @param key - The _define_ name (identifier).
 * @param fallbackValue - The value returned when material `defines` are not initialized yet,
 * specified by default as [[false]], provide your own default if you expect numeric value.
 */
function getShaderMaterialDefine(material, key, fallbackValue = false) {
    if (material.defines === undefined) {
        return fallbackValue;
    }
    return getShaderDefine(material.defines, key);
}
exports.getShaderMaterialDefine = getShaderMaterialDefine;
/**
 * Sets new value of 'define' regardless of current value set.
 *
 * Update `defines` map with new key and value, if key is already occupied it overrides its value.
 * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before
 * material is create (i.e. in c-tor).
 *
 * @param defines - Shader `defines` stored in key-value map.
 * @param key - The key used to identify _define_.
 * @param value - The value to be stored.
 * @returns [[true]] if define has actually changed, false is stayed the same.
 * @see setShaderMaterialDefine.
 */
function setShaderDefine(defines, key, value) {
    let updated = false;
    if (typeof value === "number") {
        updated = defines[key] !== value;
        defines[key] = value;
    }
    else if (value === true) {
        updated = defines[key] !== exports.DEFINE_BOOL_TRUE;
        defines[key] = exports.DEFINE_BOOL_TRUE;
    }
    else if (value === false && defines[key] !== undefined) {
        // Sets to DEFINE_BOOL_FALSE === undefined
        delete defines[key];
        updated = true;
    }
    return updated;
}
exports.setShaderDefine = setShaderDefine;
/**
 * Acquire shader 'define' value from `defines` map.
 *
 * If there is no value under [[key]] specified, function returns false, otherwise result is
 * true or numeric value if there is a number stored.
 * @param defines - The `defines` map.
 * @param key - The identifier of the _define_.
 */
function getShaderDefine(defines, key) {
    const currentValue = defines[key];
    const semanticValue = currentValue === exports.DEFINE_BOOL_FALSE
        ? false
        : currentValue === exports.DEFINE_BOOL_TRUE
            ? true
            : currentValue;
    return semanticValue;
}
exports.getShaderDefine = getShaderDefine;


/***/ }),

/***/ "../harp-materials/lib/VignetteShader.ts":
/*!***********************************************!*\
  !*** ../harp-materials/lib/VignetteShader.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VignetteShader = void 0;
/**
 * `VignetteShader`.
 */
exports.VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        offset: { value: 1.0 },
        darkness: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
    fragmentShader: `
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D( tDiffuse, vUv );
            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );
        }`
};


/***/ }),

/***/ "../harp-omv-datasource/index.ts":
/*!***************************************!*\
  !*** ../harp-omv-datasource/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoJsonDataProvider = exports.AuthenticationMethod = exports.APIFormat = void 0;
var harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts");
Object.defineProperty(exports, "APIFormat", ({ enumerable: true, get: function () { return harp_vectortile_datasource_1.APIFormat; } }));
Object.defineProperty(exports, "AuthenticationMethod", ({ enumerable: true, get: function () { return harp_vectortile_datasource_1.AuthenticationMethod; } }));
Object.defineProperty(exports, "GeoJsonDataProvider", ({ enumerable: true, get: function () { return harp_vectortile_datasource_1.GeoJsonDataProvider; } }));
__exportStar(__webpack_require__(/*! ./lib/OmvDataSource */ "../harp-omv-datasource/lib/OmvDataSource.ts"), exports);


/***/ }),

/***/ "../harp-omv-datasource/lib/OmvDataSource.ts":
/*!***************************************************!*\
  !*** ../harp-omv-datasource/lib/OmvDataSource.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmvDataSource = void 0;
const harp_vectortile_datasource_1 = __webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts");
/**
 * `OmvDataSource` is used for the visualization of vector tiles
 * provided in the OMV format.
 *
 * @example
 * ```typescript
 *    const dataSource = new OmvDataSource({
 *        baseUrl: "https://vector.hereapi.com/v2/vectortiles/base/mc",
 *        authenticationCode: apikey
 *    });
 *    mapView.addDataSource(dataSource);
 *   ```
 */
class OmvDataSource extends harp_vectortile_datasource_1.VectorTileDataSource {
}
exports.OmvDataSource = OmvDataSource;


/***/ }),

/***/ "../harp-text-canvas/index.ts":
/*!************************************!*\
  !*** ../harp-text-canvas/index.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * SDF based text rendering for TypeScript.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/rendering/FontCatalog */ "../harp-text-canvas/lib/rendering/FontCatalog.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TextCanvas */ "../harp-text-canvas/lib/TextCanvas.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/ContextualArabicConverter */ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts"), exports);


/***/ }),

/***/ "../harp-text-canvas/lib/TextCanvas.ts":
/*!*********************************************!*\
  !*** ../harp-text-canvas/lib/TextCanvas.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextCanvas = exports.DEFAULT_TEXT_CANVAS_LAYER = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const TextBufferObject_1 = __webpack_require__(/*! ./rendering/TextBufferObject */ "../harp-text-canvas/lib/rendering/TextBufferObject.ts");
const TextGeometry_1 = __webpack_require__(/*! ./rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ./rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const LineTypesetter_1 = __webpack_require__(/*! ./typesetting/LineTypesetter */ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts");
const PathTypesetter_1 = __webpack_require__(/*! ./typesetting/PathTypesetter */ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts");
const MaterialUtils_1 = __webpack_require__(/*! ./utils/MaterialUtils */ "../harp-text-canvas/lib/utils/MaterialUtils.ts");
const tempTextPosition = new THREE.Vector3();
const tempTextBounds = {
    array: [new THREE.Box2()],
    offset: 0
};
let tempVertexBuffer = new Float32Array();
/**
 * Default's [[TextCanvas]] layer identifier.
 */
exports.DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
class TextCanvas {
    /**
     * Constructs a new `TextCanvas`.
     *
     * @param params - `TextCanvas` construction parameters.
     *
     * @returns New `TextCanvas`.
     */
    constructor(params) {
        this.m_renderer = params.renderer;
        this.m_fontCatalog = params.fontCatalog;
        this.minGlyphCount = params.minGlyphCount;
        this.maxGlyphCount = params.maxGlyphCount;
        this.name = params.name;
        if (params.material === undefined) {
            this.m_ownsMaterial = true;
            this.m_material = MaterialUtils_1.createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                rendererCapabilities: this.m_renderer.capabilities
            });
        }
        else {
            this.m_ownsMaterial = false;
            this.m_material = params.material;
        }
        if (params.backgroundMaterial === undefined) {
            this.m_ownsBgMaterial = true;
            this.m_bgMaterial = MaterialUtils_1.createSdfTextMaterial({
                fontCatalog: params.fontCatalog,
                isBackground: true,
                rendererCapabilities: this.m_renderer.capabilities
            });
        }
        else {
            this.m_ownsBgMaterial = false;
            this.m_bgMaterial = params.backgroundMaterial;
        }
        this.m_defaultLayer = {
            id: exports.DEFAULT_TEXT_CANVAS_LAYER,
            storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
        };
        this.m_layers = [this.m_defaultLayer];
        this.m_currentTextRenderStyle = new TextStyle_1.TextRenderStyle().copy(TextCanvas.defaultTextRenderStyle);
        this.m_currentTextLayoutStyle = new TextStyle_1.TextLayoutStyle().copy(TextCanvas.defaultTextLayoutStyle);
        this.m_lineTypesetter = new LineTypesetter_1.LineTypesetter();
        this.m_pathTypesetter = new PathTypesetter_1.PathTypesetter();
    }
    /**
     * Currently active [[FontCatalog]].
     */
    get fontCatalog() {
        return this.m_fontCatalog;
    }
    set fontCatalog(value) {
        this.m_fontCatalog = value;
        const material = this.m_material;
        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        material.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        material.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
        const bgMaterial = this.m_bgMaterial;
        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;
        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(this.m_fontCatalog.textureSize.x, this.m_fontCatalog.textureSize.y, this.m_fontCatalog.size, this.m_fontCatalog.distanceRange);
        bgMaterial.defines.MSDF = this.m_fontCatalog.type === "msdf" ? 1.0 : 0.0;
    }
    /**
     * Currently active text rendering material.
     */
    get material() {
        return this.m_material;
    }
    set material(value) {
        if (this.m_ownsMaterial) {
            this.m_material.dispose();
            this.m_ownsMaterial = false;
        }
        this.m_material = value;
        for (const layer of this.m_layers) {
            layer.storage.mesh.material = this.m_material;
        }
    }
    /**
     * Currently active text background rendering material.
     */
    get backgroundMaterial() {
        return this.m_bgMaterial;
    }
    set backgroundMaterial(value) {
        if (this.m_ownsBgMaterial) {
            this.m_bgMaterial.dispose();
            this.m_ownsBgMaterial = false;
        }
        this.m_bgMaterial = value;
        for (const layer of this.m_layers) {
            layer.storage.backgroundMesh.material = this.m_bgMaterial;
        }
    }
    /**
     * Currently active text rendering style.
     */
    get textRenderStyle() {
        return this.m_currentTextRenderStyle;
    }
    set textRenderStyle(style) {
        this.m_currentTextRenderStyle.copy(style);
    }
    /**
     * Currently active text layout style.
     */
    get textLayoutStyle() {
        return this.m_currentTextLayoutStyle;
    }
    set textLayoutStyle(style) {
        this.m_currentTextLayoutStyle.copy(style);
    }
    /**
     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
     */
    clear() {
        for (const layer of this.m_layers) {
            layer.storage.clear();
        }
        this.m_currentTextRenderStyle.copy(TextCanvas.defaultTextRenderStyle);
        this.m_currentTextLayoutStyle.copy(TextCanvas.defaultTextLayoutStyle);
    }
    /**
     * Renders the content of this `TextCanvas`.
     *
     * @param camera - Orthographic camera.
     * @param lowerLayerId - Optional Id the first layer to be rendered has to be equal or above
     * @param higherLayerId - Optional Id the last layer to be rendered has to be below
     * @param target - Optional render target.
     * @param clear - Optional render target clear operation.
     */
    render(camera, lowerLayerId, higherLayerId, target, clear) {
        this.m_fontCatalog.update(this.m_renderer);
        let oldTarget = null;
        if (target !== undefined) {
            oldTarget = this.m_renderer.getRenderTarget();
            this.m_renderer.setRenderTarget(target);
        }
        if (clear === true) {
            this.m_renderer.clear(true);
        }
        for (let i = 0; i < this.m_layers.length; i++) {
            const layer = this.m_layers[i];
            if (layer.id >= (lowerLayerId !== null && lowerLayerId !== void 0 ? lowerLayerId : 0)) {
                if (higherLayerId === undefined || layer.id < higherLayerId) {
                    layer.storage.update();
                    this.m_renderer.render(layer.storage.scene, camera);
                }
                else {
                    break;
                }
            }
        }
        if (target !== undefined) {
            this.m_renderer.setRenderTarget(oldTarget);
        }
    }
    /**
     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
     * input `layerId`, it just returns this one instead.
     *
     * @param layerId - Desired layer identifier.
     *
     * @returns Created [[TextCanvasLayer]].
     */
    addLayer(layerId) {
        let result = this.getLayer(layerId);
        if (result === undefined) {
            result = {
                id: layerId,
                storage: new TextGeometry_1.TextGeometry(new THREE.Scene(), this.m_material, this.m_bgMaterial, this.minGlyphCount, this.maxGlyphCount)
            };
            this.m_layers.push(result);
            this.m_layers.sort((a, b) => {
                return a.id - b.id;
            });
        }
        return result;
    }
    /**
     * Retrieves a specific `TextCanvas` rendering layer.
     *
     * @param layerId - Desired layer identifier.
     *
     * @returns Selected [[TextCanvasLayer]].
     */
    getLayer(layerId) {
        return this.m_layers.find(layer => layer.id === layerId);
    }
    /**
     * Retrieves all `TextCanvas` rendering layers.
     *
     * @returns Array of [[TextCanvasLayer]]s.
     */
    getAllLayers() {
        return this.m_layers;
    }
    /**
     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
     * [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param outputBounds - Output text bounding box.
     * @param params - Optional measurement parameters.
     *
     * @returns Result of the measurement. If `false`, some error occurred during execution and the
     * input text couldn't be properly measured.
     */
    measureText(text, outputBounds, params) {
        tempTextPosition.set(0, 0, 0);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let outputCharacterBounds;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            outputCharacterBounds = params.outputCharacterBounds;
            if (params.path !== undefined) {
                const pathOrigin = params.path.getPoint(0);
                if (pathOrigin === null) {
                    return false;
                }
                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        return this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: outputBounds,
            individualBounds: outputCharacterBounds,
            letterCaseArray: upperCaseArray
        });
    }
    /**
     * Adds the input text to this `TextCanvas` in the specified screen position. The current
     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param position - Screen position.
     * @param params - Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addText(text, position, params) {
        tempTextPosition.copy(position);
        let path;
        let pathOverflow;
        let upperCaseArray;
        let targetLayer = this.m_defaultLayer;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            if (params.path !== undefined) {
                tempTextPosition.set(0, 0, tempTextPosition.z);
            }
            if (params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = this.placeText({
            input: text,
            textPath: path,
            textPathOverflow: pathOverflow,
            layer: targetLayer,
            letterCaseArray: upperCaseArray
        });
        if (result && params !== undefined) {
            if (params.updatePosition === true) {
                position.copy(tempTextPosition);
            }
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
     * result of performing the `addText` function for the input text in the screen origin.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param params - Optional creation parameters.
     *
     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
     * retrieved from the current [[FontCatalog]]).
     */
    createTextBufferObject(text, params) {
        tempTextPosition.set(0, 0, 0);
        let glyphArray;
        let upperCaseArray;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof text !== "string") {
            glyphArray = text;
            if (params !== undefined && params.letterCaseArray) {
                upperCaseArray = params.letterCaseArray;
            }
        }
        else {
            upperCaseArray = [];
            glyphArray = this.m_fontCatalog.getGlyphs(text, this.m_currentTextRenderStyle, smallCapsEnabled ? upperCaseArray : undefined);
            if (glyphArray === undefined) {
                return undefined;
            }
        }
        let path;
        let pathOverflow;
        let textBounds;
        let characterBounds;
        let renderStyle;
        let layoutStyle;
        if (params !== undefined) {
            path = params.path;
            pathOverflow = params.pathOverflow;
            if (params.outputBounds === true) {
                textBounds = new THREE.Box2();
            }
            if (params.outputCharacterBounds === true) {
                characterBounds = [];
            }
            if (params.storeStyles === true) {
                renderStyle = this.m_currentTextRenderStyle.clone();
                layoutStyle = this.m_currentTextLayoutStyle.clone();
            }
        }
        this.placeText({
            input: text,
            layer: this.m_defaultLayer,
            computeTextBuffer: true,
            textPath: path,
            textPathOverflow: pathOverflow,
            bounds: textBounds,
            individualBounds: characterBounds,
            letterCaseArray: upperCaseArray
        });
        return new TextBufferObject_1.TextBufferObject(glyphArray, new Float32Array(tempVertexBuffer), textBounds, characterBounds, renderStyle, layoutStyle);
    }
    /**
     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
     * be provided to override the attributes stored in the buffer.
     *
     * @param textBufferObject - [[TextBufferObject]] to add.
     * @param params - Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addTextBufferObject(textBufferObject, params) {
        var _a;
        let targetLayer = this.m_defaultLayer;
        let position;
        let scale;
        let rotation;
        let color;
        let opacity;
        let bgColor;
        let bgOpacity;
        if (params !== undefined) {
            if (params.layer !== undefined) {
                let tempLayer = this.getLayer(params.layer);
                if (tempLayer === undefined) {
                    tempLayer = this.addLayer(params.layer);
                }
                targetLayer = tempLayer;
            }
            position = (_a = params.position) === null || _a === void 0 ? void 0 : _a.clone();
            scale = params.scale;
            rotation = params.rotation;
            color = params.color;
            opacity = params.opacity;
            bgColor = params.backgroundColor;
            bgOpacity = params.backgroundOpacity;
        }
        const prevDrawCount = targetLayer.storage.drawCount;
        const result = targetLayer.storage.addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity);
        if (result && params !== undefined) {
            if (params.pickingData !== undefined) {
                targetLayer.storage.addPickingData(prevDrawCount, targetLayer.storage.drawCount, params.pickingData);
            }
        }
        else if (!result) {
            targetLayer.storage.m_drawCount = prevDrawCount;
        }
        return result;
    }
    /**
     * Executes the `pickCallback` for all previously stored picking data for text covering the
     * specified screen position.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickText(position, callback) {
        for (const layer of this.m_layers) {
            layer.storage.pick(position, callback);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
     *
     * @param info - The info object to increment with the values from this `TextCanvas`.
     */
    getMemoryUsage(info) {
        this.m_fontCatalog.updateMemoryUsage(info);
        for (const layer of this.m_layers) {
            layer.storage.updateMemoryUsage(info);
        }
    }
    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs
    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for
    // the input (as a whole or on a per-character basis).
    placeText(params) {
        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines === 0) {
            if (params.bounds !== undefined) {
                params.bounds.min.set(0, 0);
                params.bounds.max.set(0, 0);
            }
            if (params.individualBounds !== undefined) {
                params.individualBounds.length = 0;
            }
            return true;
        }
        let glyphArray;
        let smallCapsTransformations;
        const smallCapsEnabled = this.m_currentTextRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        if (typeof params.input !== "string") {
            glyphArray = params.input;
            if (params.letterCaseArray) {
                smallCapsTransformations = params.letterCaseArray;
            }
        }
        else {
            smallCapsTransformations = [];
            glyphArray = this.m_fontCatalog.getGlyphs(params.input, this.m_currentTextRenderStyle, smallCapsEnabled ? smallCapsTransformations : undefined);
            if (glyphArray === undefined) {
                return false;
            }
        }
        let glyphBounds;
        if (params.individualBounds !== undefined) {
            tempTextBounds.array = params.individualBounds;
            tempTextBounds.offset = 0;
            glyphBounds = tempTextBounds;
        }
        if (params.bounds !== undefined) {
            params.bounds.min.set(Infinity, Infinity);
            params.bounds.max.set(-Infinity, -Infinity);
        }
        if (params.computeTextBuffer === true) {
            tempVertexBuffer = new Float32Array(glyphArray.length * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT);
        }
        const isPath = params.textPath !== undefined;
        const typesettingParams = {
            glyphs: glyphArray,
            fontCatalog: this.m_fontCatalog,
            textRenderStyle: this.m_currentTextRenderStyle,
            textLayoutStyle: this.m_currentTextLayoutStyle,
            position: tempTextPosition,
            geometry: params.layer.storage,
            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,
            globalBounds: params.bounds,
            individualBounds: glyphBounds,
            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined
        };
        let result = true;
        if (isPath) {
            Object.assign(typesettingParams, {
                path: params.textPath,
                pathOverflow: params.textPathOverflow === true
            });
            result = this.m_pathTypesetter.arrangeGlyphs(typesettingParams);
        }
        else {
            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);
        }
        if (glyphBounds !== undefined) {
            glyphBounds.array.length = glyphBounds.offset;
        }
        return result;
    }
}
exports.TextCanvas = TextCanvas;
TextCanvas.defaultTextRenderStyle = new TextStyle_1.TextRenderStyle();
TextCanvas.defaultTextLayoutStyle = new TextStyle_1.TextLayoutStyle();


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/FontCatalog.ts":
/*!********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/FontCatalog.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FontCatalog = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const GlyphTextureCache_1 = __webpack_require__(/*! ./GlyphTextureCache */ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const ASSETS_PATH = "_Assets/";
const BOLD_ASSETS_PATH = "_BoldAssets/";
const ITALIC_ASSETS_PATH = "_ItalicAssets/";
const BOLD_ITALIC_ASSETS_PATH = "_BoldItalicAssets/";
const REPLACEMENT_PATH = "_Assets/Extra/";
/**
 * Collection of font assets used to render glyphs when using a [[TextCanvas]].
 *
 * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed
 * to cover the widest Unicode code point range possible. In order to manage all these assets
 * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and
 * assets for a block are only loaded once a glyph belonging to that block is requested.
 *
 * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture
 * resource, which can be sampled to render all currently loaded glyphs.
 *
 */
class FontCatalog {
    /**
     * @hidden
     * Creates a new FontCatalog.
     *
     * @param url - FontCatalog's URL.
     * @param name - FontCatalog's name.
     * @param type - FontCatalog's type (sdf or msdf).
     * @param size - FontCatalog's glyph size (pixels).
     * @param maxWidth - FontCatalog's maximum glyph width (pixels).
     * @param maxHeight - FontCatalog's maximum glyph height (pixels).
     * @param distanceRange - Distance range used to generate the SDF bitmaps.
     * @param fonts - Array of supported fonts.
     * @param unicodeBlocks - Array of supported Unicode blocks.
     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     * @param m_replacementGlyph - [[GlyphData]] to be used whenever a Unicode code point is not
     * supported by this `FontCatalog`.
     *
     * @returns New FontCatalog.
     */
    constructor(url, name, type, size, maxWidth, maxHeight, distanceRange, fonts, unicodeBlocks, maxCodePointCount, m_replacementGlyph) {
        this.url = url;
        this.name = name;
        this.type = type;
        this.size = size;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this.distanceRange = distanceRange;
        this.fonts = fonts;
        this.unicodeBlocks = unicodeBlocks;
        this.maxCodePointCount = maxCodePointCount;
        this.m_replacementGlyph = m_replacementGlyph;
        /** If `true`, a replacement glyph is returned for every missing glyph. */
        this.showReplacementGlyphs = false;
        this.m_glyphTextureCache = new GlyphTextureCache_1.GlyphTextureCache(maxCodePointCount, this.maxWidth + 1, this.maxHeight + 1);
        this.m_loadingJson = new Map();
        this.m_loadingPages = new Map();
        this.m_loadingGlyphs = new Map();
        this.m_loadedJson = new Map();
        this.m_loadedPages = new Map();
        this.m_loadedGlyphs = new Map();
    }
    /**
     * Loads a `FontCatalog`.
     *
     * @param url - Asset url.
     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s
     * internal texture can store simultaneously.
     *
     * @returns `FontCatalog` Promise.
     */
    static async load(path, maxCodePointCount) {
        const url = new URL(path, window.location.href);
        const fontCatalog = await FontCatalog.loadJSON(url.href);
        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);
        const replacementJson = await FontCatalog.loadJSON(replacementDirUrl.href + "Specials.json");
        const replacementTexture = await FontCatalog.loadTexture(replacementDirUrl.href + "Specials.png");
        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;
        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;
        replacementTexture.minFilter = THREE.NearestFilter;
        replacementTexture.needsUpdate = true;
        const replacementFont = fontCatalog.fonts.find((font) => font.name === "Extra");
        const replacementGlyph = new GlyphData_1.GlyphData(65533, "Specials", replacementJson.chars[0].width, replacementJson.chars[0].height, replacementJson.chars[0].xadvance, replacementJson.chars[0].xoffset, replacementJson.chars[0].yoffset, 0.0, 0.0, 1.0, 1.0, replacementTexture, replacementFont, true);
        const fontCatalogInfo = new FontCatalog(url.href.substr(0, url.href.lastIndexOf("/")), fontCatalog.name, fontCatalog.type, fontCatalog.size, fontCatalog.maxWidth, fontCatalog.maxHeight, fontCatalog.distanceRange, fontCatalog.fonts, fontCatalog.supportedBlocks, maxCodePointCount, replacementGlyph);
        return fontCatalogInfo;
    }
    static async loadTexture(url) {
        return await new Promise(resolve => {
            new THREE.TextureLoader().load(url, resolve);
        });
    }
    static async loadJSON(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`${url} Status Text:  ${response.statusText}`);
        }
        const rawJSON = await response.text();
        return JSON.parse(rawJSON);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.fonts.length = 0;
        this.unicodeBlocks.length = 0;
        this.m_glyphTextureCache.dispose();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Removes all loaded (and loading) assets.
     */
    clear() {
        this.m_glyphTextureCache.clear();
        this.m_loadingJson.clear();
        this.m_loadingPages.clear();
        this.m_loadingGlyphs.clear();
        this.m_loadedJson.clear();
        this.m_loadedPages.clear();
        this.m_loadedGlyphs.clear();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer - WebGLRenderer.
     */
    update(renderer) {
        this.m_glyphTextureCache.update(renderer);
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_glyphTextureCache.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_glyphTextureCache.textureSize;
    }
    /**
     * Current internal loading state.
     */
    get isLoading() {
        return (this.m_loadingJson.size > 0 ||
            this.m_loadingPages.size > 0 ||
            this.m_loadingGlyphs.size > 0);
    }
    /**
     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls
     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.
     *
     * @param block - Requested [[UnicodeBlock]].
     * @param font - [[Font]] to retrieve this Unicode block from.
     * @param fontStyle - [[FontStyle]] assets to load.
     * @param loadPages - If `true`, all pages in this Unicode block will also be loaded.
     *
     * @returns Loaded Unicode Block json.
     */
    async loadBlock(block, font, fontStyle, loadPages) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        let json = this.m_loadedJson.get(jsonPath);
        if (json === undefined) {
            let jsonPromise = this.m_loadingJson.get(jsonPath);
            if (jsonPromise === undefined) {
                try {
                    jsonPromise = FontCatalog.loadJSON(jsonPath);
                    this.m_loadingJson.set(jsonPath, jsonPromise);
                    json = await jsonPromise;
                    this.m_loadingJson.delete(jsonPath);
                    this.m_loadedJson.set(jsonPath, json);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.error(e);
                    this.m_loadingJson.delete(jsonPath);
                }
            }
            else {
                json = await jsonPromise;
            }
        }
        const pagePromises = [];
        if (loadPages === true) {
            for (const page of json.pages) {
                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));
            }
        }
        await Promise.all(pagePromises);
        return json;
    }
    /**
     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).
     * Safe to call when no assets for this block have been loaded.
     *
     * @param block - Requested [[UnicodeBlock]].
     * @param font - [[Font]] to remove this Unicode block from.
     * @param fontStyle - [[FontStyle]] assets to remove.
     */
    removeBlock(block, font, fontStyle) {
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, "_")}.json`;
        const json = this.m_loadedJson.get(jsonPath);
        if (json !== undefined) {
            for (const page of json.pages) {
                const pagePath = `${assetsPath}/${page}`;
                this.m_loadingPages.delete(pagePath);
                this.m_loadedPages.delete(pagePath);
            }
            this.m_loadingJson.delete(jsonPath);
            this.m_loadedJson.delete(jsonPath);
        }
    }
    /**
     * Loads all the required glyphs needed to render the input text. Character repetition will not
     * be considered, and only styled assets (with applied font selection, style and variants) will
     * be loaded.
     *
     * @param input - Input text.
     * @param style - Specific [[TextRenderStyle]] for which glyphs will be loaded.
     *
     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.
     */
    async loadCharset(input, style) {
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const shouldTransform = style.fontVariant === TextStyle_1.FontVariant.AllCaps ||
            style.fontVariant === TextStyle_1.FontVariant.SmallCaps;
        const charset = (shouldTransform ? input.toUpperCase() : input).replace(/[\s\S](?=([\s\S]+))/g, (c, s) => {
            return s.indexOf(c) + 1 ? "" : c;
        });
        const glyphPromises = [];
        for (const char of charset) {
            const codePoint = char.codePointAt(0);
            const font = this.getFont(codePoint, fontName);
            const fontHash = `${font.name}_${fontStyle}`;
            const glyphHash = `${fontHash}_${codePoint}`;
            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);
            if (fontGlyphMap === undefined) {
                fontGlyphMap = new Map();
                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);
            }
            const glyph = fontGlyphMap.get(codePoint);
            if (glyph === undefined) {
                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);
                if (glyphPromise === undefined) {
                    if (!font.charset.includes(String.fromCodePoint(codePoint))) {
                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);
                        fontGlyphMap.set(codePoint, replacementGlyph);
                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);
                        continue;
                    }
                    let charUnicodeBlock;
                    for (const block of this.unicodeBlocks) {
                        if (codePoint >= block.min && codePoint <= block.max) {
                            charUnicodeBlock = block;
                            break;
                        }
                    }
                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock, font);
                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);
                    glyphPromise.then((loadedGlyph) => {
                        this.m_loadingGlyphs.delete(glyphHash);
                        fontGlyphMap.set(codePoint, loadedGlyph);
                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);
                    });
                }
                glyphPromises.push(glyphPromise);
            }
            else if (!this.m_glyphTextureCache.has(glyphHash)) {
                glyphPromises.push(Promise.resolve(glyph));
                this.m_glyphTextureCache.add(glyphHash, glyph);
            }
        }
        return Promise.all(glyphPromises);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for a specific character.
     * Returns `undefined` if the assets for this glyph haven't been loaded yet.
     *
     * @param codePoint - Character's Unicode code point.
     * @param font - [[Font]] to get this glyph from.
     * @param fontStyle - Specific [[FontStyle]] to get glyphs for.
     *
     * @returns [[GlyphData]] for this code point.
     */
    getGlyph(codePoint, font, fontStyle) {
        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);
        if (fontGlyphMap === undefined) {
            return undefined;
        }
        return fontGlyphMap.get(codePoint);
    }
    /**
     * Retrieves the loaded [[GlyphData]] for the specified text.
     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.
     *
     * @param input - Input text.
     * @param style - Specific [[TextRenderStyle]] to get glyphs for.
     * @param letterCaseArray - Array containing the original letter case for the requested glyphs.
     *
     * @returns Array containing [[GlyphData]] for each character of the input text.
     */
    getGlyphs(input, style, letterCaseArray) {
        const result = [];
        const fontName = style.fontName;
        const fontStyle = style.fontStyle;
        const fontVariant = style.fontVariant;
        const shouldTransform = fontVariant === TextStyle_1.FontVariant.AllCaps || fontVariant === TextStyle_1.FontVariant.SmallCaps;
        for (const character of input) {
            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;
            for (const char of transformedCharacter) {
                const codePoint = char.codePointAt(0);
                const font = this.getFont(codePoint, fontName);
                const glyphData = this.getGlyph(codePoint, font, fontStyle);
                if (glyphData !== undefined &&
                    (!glyphData.isReplacement || this.showReplacementGlyphs)) {
                    result.push(glyphData);
                    if (letterCaseArray !== undefined) {
                        letterCaseArray.push(char !== character);
                    }
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Gets the best matched font for a specific character.
     *
     * @param codePoint - Character's Unicode code point.
     * @param fontName - Font name suggestion.
     *
     * @returns Best matched font.
     */
    getFont(codePoint, fontName) {
        let selectedFontName = this.fonts[0].name;
        for (const block of this.unicodeBlocks) {
            if (codePoint >= block.min && codePoint <= block.max) {
                selectedFontName =
                    fontName !== undefined &&
                        block.fonts.find(element => {
                            return element === fontName;
                        }) !== undefined
                        ? fontName
                        : block.fonts[0];
                break;
            }
        }
        return this.fonts.find(element => {
            return element.name === selectedFontName;
        });
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.
     *
     * @param info - The info object to increment with the values from this `FontCatalog`.
     */
    updateMemoryUsage(info) {
        let numBytes = 0;
        for (const block of this.unicodeBlocks) {
            numBytes += (block.max - block.min) * 2;
        }
        // Always stored in RGBA internally.
        let textureBytes = this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;
        for (const page in this.m_loadedPages.entries) {
            if (this.m_loadedPages.get(page) !== undefined) {
                const loadedPage = this.m_loadedPages.get(page);
                if (loadedPage !== undefined) {
                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;
                }
            }
        }
        info.heapSize += numBytes + textureBytes;
        info.gpuSize += textureBytes;
    }
    createReplacementGlyph(codePoint, char, font) {
        const replacementGlyph = this.m_replacementGlyph.clone();
        replacementGlyph.codePoint = codePoint;
        replacementGlyph.character = char;
        replacementGlyph.font = font;
        // Glyphs for ASCII control characters and such are not really replacement glyphs.
        replacementGlyph.isReplacement = UnicodeUtils_1.UnicodeUtils.isPrintable(codePoint);
        return replacementGlyph;
    }
    async loadAssets(codePoint, fontStyle, block, font) {
        const json = await this.loadBlock(block, font, fontStyle);
        if (json === undefined) {
            return this.m_replacementGlyph;
        }
        const sourceGlyphData = json.chars.find(char => char.id === codePoint);
        const assetsPath = this.getAssetsPath(fontStyle, font);
        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData.page]}`;
        const texture = await this.loadPage(texturePath);
        const glyphData = new GlyphData_1.GlyphData(sourceGlyphData.id, block.name, sourceGlyphData.width, sourceGlyphData.height, sourceGlyphData.xadvance, sourceGlyphData.xoffset, sourceGlyphData.yoffset, sourceGlyphData.x / texture.image.width, 1.0 - (sourceGlyphData.y + sourceGlyphData.height) / texture.image.height, (sourceGlyphData.x + sourceGlyphData.width) / texture.image.width, 1.0 - sourceGlyphData.y / texture.image.height, texture, font);
        return glyphData;
    }
    async loadPage(pagePath) {
        let page = this.m_loadedPages.get(pagePath);
        if (page === undefined) {
            let pagePromise = this.m_loadingPages.get(pagePath);
            if (pagePromise === undefined) {
                pagePromise = FontCatalog.loadTexture(pagePath);
                this.m_loadingPages.set(pagePath, pagePromise);
                page = await pagePromise;
                page.wrapS = THREE.ClampToEdgeWrapping;
                page.wrapT = THREE.ClampToEdgeWrapping;
                page.minFilter = THREE.NearestFilter;
                page.needsUpdate = true;
                if (this.m_loadingPages.delete(pagePath)) {
                    this.m_loadedPages.set(pagePath, page);
                }
                this.m_loadingPages.delete(pagePath);
            }
            else {
                page = await pagePromise;
            }
        }
        return page;
    }
    getAssetsPath(fontStyle, font) {
        let fontStylePath = ASSETS_PATH;
        switch (fontStyle) {
            case TextStyle_1.FontStyle.Bold:
                if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.Italic:
                if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                break;
            case TextStyle_1.FontStyle.BoldItalic:
                if (font.boldItalic !== undefined) {
                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;
                }
                else if (font.italic !== undefined) {
                    fontStylePath = ITALIC_ASSETS_PATH;
                }
                else if (font.bold !== undefined) {
                    fontStylePath = BOLD_ASSETS_PATH;
                }
                break;
        }
        return `${this.url}/${this.name}${fontStylePath}${font.name}`;
    }
}
exports.FontCatalog = FontCatalog;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphData.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphData.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlyphData = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Structure containing all the required information necessary to render a BMFont glyph using
 * [[TextCanvas]].
 */
class GlyphData {
    /**
     * Creates a new `GlyphData` object.
     *
     * @param codePoint - Unicode code point.
     * @param block - Unicode block.
     * @param width - Glyph' width.
     * @param height - Glyph' height.
     * @param advanceX - Amount of pixel to move after placing this glyph.
     * @param offsetX - Horizontal offset from the glyph' origin.
     * @param offsetY - Vertical offset from the glyph' origin.
     * @param u0 - Glyph' left texture coordinate.
     * @param v0 - Glyph' bottom texture coordinate.
     * @param u1 - Glyph' right texture coordinate.
     * @param v1 - Glyph' top texture coordinate.
     * @param texture - Glyph' source texture atlas page.
     * @param font - Glyph' font.
     * @param isReplacement - `true` if glyph is a replacement for a missing glyph.
     *
     * @returns New `GlyphData`.
     */
    constructor(codePoint, block, width, height, advanceX, offsetX, offsetY, u0, v0, u1, v1, texture, font, isReplacement = false) {
        this.codePoint = codePoint;
        this.block = block;
        this.width = width;
        this.height = height;
        this.advanceX = advanceX;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.texture = texture;
        this.font = font;
        this.isReplacement = isReplacement;
        /**
         * Array containing the positions for all corners of this glyph.
         */
        this.positions = [];
        /**
         * Array containing the source texture coordinates for all corners of this glyph.
         * Used to sample the original texture atlas pages.
         */
        this.sourceTextureCoordinates = [];
        /**
         * Array containing the dynamic texture coordinates for all corners of this glyph.
         * Used to sample the dynamic texture atlas page.
         */
        this.dynamicTextureCoordinates = [];
        /**
         * Source texture atlas' page copy index.
         */
        this.copyIndex = 0;
        /**
         * Flag indicating if glyph can be currently rendered.
         */
        this.isInCache = false;
        this.character = String.fromCodePoint(codePoint);
        this.direction = UnicodeUtils_1.UnicodeUtils.getDirection(codePoint, block);
        const left = this.offsetX;
        const right = left + this.width;
        const top = font.metrics.lineHeight - this.offsetY;
        const bottom = top - this.height;
        this.positions.push(new THREE.Vector3(left, bottom, 1.0), new THREE.Vector3(right, bottom, 1.0), new THREE.Vector3(left, top, 1.0), new THREE.Vector3(right, top, 1.0));
        this.sourceTextureCoordinates.push(new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1), new THREE.Vector2(u1, v1));
        this.dynamicTextureCoordinates.push(new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0));
    }
    /**
     * Clone this `GlyphData`.
     *
     * @returns Cloned `GlyphData`.
     */
    clone() {
        return new GlyphData(this.codePoint, this.block, this.width, this.height, this.advanceX, this.offsetX, this.offsetY, this.sourceTextureCoordinates[0].x, this.sourceTextureCoordinates[0].y, this.sourceTextureCoordinates[3].x, this.sourceTextureCoordinates[3].y, this.texture, this.font, this.isReplacement);
    }
}
exports.GlyphData = GlyphData;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/GlyphTextureCache.ts":
/*!**************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/GlyphTextureCache.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlyphTextureCache = void 0;
const harp_lrucache_1 = __webpack_require__(/*! @here/harp-lrucache */ "../harp-lrucache/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const GlyphData_1 = __webpack_require__(/*! ./GlyphData */ "../harp-text-canvas/lib/rendering/GlyphData.ts");
const TextMaterials_1 = __webpack_require__(/*! ./TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined
 * by the maximum number of texture units available on a pixel shader for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS
 */
const MAX_NUM_COPY_PAGES = 8;
/**
 * Maximum texture size supported. This amount is determined by the maximum texture size supported
 * for all devices:
 * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE
 */
const MAX_TEXTURE_SIZE = 4096;
/**
 * @hidden
 * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].
 * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.
 */
class GlyphTextureCache {
    /**
     * Creates a `GlyphTextureCache` object.
     *
     * @param capacity - Cache's maximum glyph capacity.
     * @param entryWidth - Maximum entry width.
     * @param entryHeight - Maximum entry height.
     *
     * @returns New `GlyphTextureCache`.
     */
    constructor(capacity, entryWidth, entryHeight) {
        this.capacity = capacity;
        this.entryWidth = entryWidth;
        this.entryHeight = entryHeight;
        const nRows = Math.floor(Math.sqrt(capacity));
        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;
        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;
        this.m_textureSize = new THREE.Vector2(this.m_cacheWidth * entryWidth, this.m_cacheHeight * entryHeight);
        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {
            // eslint-disable-next-line no-console
            console.warn("GlyphTextureCache texture size (" +
                this.m_textureSize.x +
                ", " +
                this.m_textureSize.y +
                ") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (" +
                MAX_TEXTURE_SIZE +
                ").\n" +
                "This could result in rendering errors on some devices.\n" +
                "Please consider reducing its capacity or input assets size.");
        }
        this.m_entryCache = new harp_lrucache_1.LRUCache(capacity);
        this.initCacheEntries();
        this.m_scene = new THREE.Scene();
        this.m_camera = new THREE.OrthographicCamera(0, this.m_textureSize.x, this.m_textureSize.y, 0);
        this.m_camera.position.z = 1;
        this.m_camera.updateMatrixWorld(false);
        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            depthBuffer: false,
            stencilBuffer: false
        });
        this.m_copyTextureSet = new Set();
        this.m_copyTransform = new THREE.Matrix3();
        this.m_copyPositions = [];
        this.m_copyPositions.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);
        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 3, 0);
        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(this.m_copyVertexBuffer, 2, 3);
        this.m_copyGeometry = new THREE.BufferGeometry();
        this.m_copyGeometry.setAttribute("position", this.m_copyPositionAttribute);
        this.m_copyGeometry.setAttribute("uv", this.m_copyUVAttribute);
        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_copyGeometry.setIndex(copyIndexBuffer);
        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry);
        this.m_copyMesh.frustumCulled = false;
        this.m_copyGeometryDrawCount = 0;
        this.m_clearPositionAttribute = new THREE.BufferAttribute(new Float32Array(capacity * 8), 2);
        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry = new THREE.BufferGeometry();
        this.m_clearGeometry.setAttribute("position", this.m_clearPositionAttribute);
        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);
        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_clearGeometry.setIndex(clearIndexBuffer);
        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry);
        this.m_clearMesh.frustumCulled = false;
        this.m_clearGeometryDrawCount = 0;
        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        var _a, _b;
        this.m_entryCache.clear();
        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);
        this.m_rt.dispose();
        (_a = this.m_clearMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this.m_copyMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
        this.m_copyTextureSet.clear();
        this.m_clearGeometry.dispose();
        this.m_copyGeometry.dispose();
    }
    /**
     * Internal WebGL Texture.
     */
    get texture() {
        return this.m_rt.texture;
    }
    /**
     * Internal WebGL Texture size.
     */
    get textureSize() {
        return this.m_textureSize;
    }
    /**
     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested
     * entry will be replaced.
     *
     * @param hash - Entry's hash.
     * @param glyph - Entry's glyph data.
     */
    add(hash, glyph) {
        const entry = this.m_entryCache.get(hash);
        if (entry !== undefined) {
            return;
        }
        const oldestEntry = this.m_entryCache.oldest;
        if (oldestEntry === null) {
            throw new Error("GlyphTextureCache is uninitialized!");
        }
        this.clearCacheEntry(oldestEntry.value);
        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);
    }
    /**
     * Checks if an entry is in the cache.
     *
     * @param hash - Entry's hash.
     *
     * @returns Test result.
     */
    has(hash) {
        return this.m_entryCache.has(hash);
    }
    /**
     * Retrieves an entry from the cache.
     *
     * @param hash - Entry's hash.
     *
     * @returns Retrieval result.
     */
    get(hash) {
        return this.m_entryCache.get(hash);
    }
    /**
     * Clears the internal LRUCache.
     */
    clear() {
        this.m_copyGeometryDrawCount = 0;
        this.m_clearGeometryDrawCount = 0;
        this.m_entryCache.clear();
        this.m_copyTextureSet.clear();
        this.initCacheEntries();
    }
    /**
     * Updates the internal WebGLRenderTarget.
     * The update will copy the newly introduced glyphs since the previous update.
     *
     * @param renderer - WebGLRenderer.
     */
    update(renderer) {
        let oldRenderTarget = null;
        const willClearGeometry = this.m_clearGeometryDrawCount > 0;
        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;
        if (willClearGeometry || willCopyGeometry) {
            oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(this.m_rt);
        }
        if (willClearGeometry) {
            if (!this.m_clearMaterial) {
                this.m_clearMaterial = new TextMaterials_1.GlyphClearMaterial({
                    rendererCapabilities: renderer.capabilities
                });
                this.m_clearMesh.material = this.m_clearMaterial;
            }
            if (this.m_clearGeometry.index === null) {
                throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
            }
            this.m_clearPositionAttribute.needsUpdate = true;
            this.m_clearPositionAttribute.updateRange.offset = 0;
            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;
            this.m_clearGeometry.index.needsUpdate = true;
            this.m_clearGeometry.index.updateRange.offset = 0;
            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;
            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);
            this.m_clearMesh.visible = true;
            this.m_copyMesh.visible = false;
            renderer.render(this.m_scene, this.m_camera);
            this.m_clearGeometryDrawCount = 0;
            this.m_clearMesh.visible = false;
        }
        if (willCopyGeometry) {
            if (!this.m_copyMaterial) {
                this.m_copyMaterial = new TextMaterials_1.GlyphCopyMaterial({
                    rendererCapabilities: renderer.capabilities
                });
                this.m_copyMesh.material = this.m_copyMaterial;
            }
            if (this.m_copyGeometry.index === null) {
                throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
            }
            this.m_copyVertexBuffer.needsUpdate = true;
            this.m_copyVertexBuffer.updateRange.offset = 0;
            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;
            this.m_copyGeometry.index.needsUpdate = true;
            this.m_copyGeometry.index.updateRange.offset = 0;
            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;
            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);
            this.m_copyMesh.visible = true;
            const srcPages = Array.from(this.m_copyTextureSet);
            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);
            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {
                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;
                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;
                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {
                    const pageIndex = pageOffset + i;
                    if (pageIndex < this.m_copyTextureSet.size) {
                        this.m_copyMaterial.uniforms["page" + i].value = srcPages[pageIndex];
                    }
                }
                renderer.render(this.m_scene, this.m_camera);
            }
            this.m_copyTextureSet.clear();
            this.m_copyGeometryDrawCount = 0;
        }
        if (willClearGeometry || willCopyGeometry) {
            renderer.setRenderTarget(oldRenderTarget);
        }
    }
    initCacheEntries() {
        const dummyMetrics = {
            size: 0,
            distanceRange: 0,
            base: 0,
            lineHeight: 0,
            lineGap: 0,
            capHeight: 0,
            xHeight: 0
        };
        const dummyFont = {
            name: "",
            metrics: dummyMetrics,
            charset: ""
        };
        const dummyGlyphData = new GlyphData_1.GlyphData(0, "", 0, 0, 0, 0, 0, 0, 0, 0, 0, THREE.Texture.DEFAULT_IMAGE, dummyFont);
        for (let i = 0; i < this.m_cacheHeight; i++) {
            for (let j = 0; j < this.m_cacheWidth; j++) {
                const dummyEntry = {
                    glyphData: dummyGlyphData,
                    location: new THREE.Vector2(j, i)
                };
                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);
            }
        }
    }
    copyGlyphToCache(hash, glyph, cacheLocation) {
        this.m_copyTextureSet.add(glyph.texture);
        let copyTextureIndex = 0;
        for (const value of this.m_copyTextureSet.values()) {
            if (value === glyph.texture) {
                break;
            }
            copyTextureIndex++;
        }
        glyph.copyIndex = copyTextureIndex;
        this.m_copyTransform.set(1.0, 0.0, cacheLocation.x * this.entryWidth - glyph.offsetX, 0.0, 1.0, cacheLocation.y * this.entryHeight - glyph.positions[0].y, 0.0, 0.0, 0.0);
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);
            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);
        }
        if (this.m_copyGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_copyGeometryDrawCount * 4;
        const baseIndex = this.m_copyGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_copyPositionAttribute.setXYZ(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y, glyph.copyIndex);
            this.m_copyUVAttribute.setXY(baseVertex + i, glyph.sourceTextureCoordinates[i].x, glyph.sourceTextureCoordinates[i].y);
        }
        if (this.m_copyGeometry.index === null) {
            throw new Error("GlyphTextureCache copy geometry index is uninitialized!");
        }
        this.m_copyGeometry.index.setX(baseIndex, baseVertex);
        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_copyGeometryDrawCount;
        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;
        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;
        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;
        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;
        glyph.dynamicTextureCoordinates[0].set(u0, v0);
        glyph.dynamicTextureCoordinates[1].set(u1, v0);
        glyph.dynamicTextureCoordinates[2].set(u0, v1);
        glyph.dynamicTextureCoordinates[3].set(u1, v1);
        glyph.isInCache = true;
        this.m_entryCache.set(hash, {
            glyphData: glyph,
            location: cacheLocation
        });
    }
    clearCacheEntry(entry) {
        entry.glyphData.isInCache = false;
        this.m_copyPositions[0].set(entry.location.x * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[1].set((entry.location.x + 1) * this.entryWidth, entry.location.y * this.entryHeight);
        this.m_copyPositions[2].set(entry.location.x * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        this.m_copyPositions[3].set((entry.location.x + 1) * this.entryWidth, (entry.location.y + 1) * this.entryHeight);
        if (this.m_clearGeometryDrawCount >= this.capacity) {
            return;
        }
        const baseVertex = this.m_clearGeometryDrawCount * 4;
        const baseIndex = this.m_clearGeometryDrawCount * 6;
        for (let i = 0; i < 4; ++i) {
            this.m_clearPositionAttribute.setXY(baseVertex + i, this.m_copyPositions[i].x, this.m_copyPositions[i].y);
        }
        if (this.m_clearGeometry.index === null) {
            throw new Error("GlyphTextureCache clear geometry index is uninitialized!");
        }
        this.m_clearGeometry.index.setX(baseIndex, baseVertex);
        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);
        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);
        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_clearGeometryDrawCount;
    }
}
exports.GlyphTextureCache = GlyphTextureCache;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextBufferObject.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextBufferObject.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2018-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextBufferObject = void 0;
/**
 * Object containing vertex buffer data generated by [[TextCanvas]].
 */
class TextBufferObject {
    /**
     * Constructs a new `TextBufferObject`.
     *
     * @param glyphs - Input glyphs.
     * @param buffer - Buffer containing the data generated by [[TextCanvas]].
     * @param bounds - Optional text bounds.
     * @param characterBounds - Optional character bounds.
     * @param textRenderStyle - [[TextRenderStyle]] applied by [[TextCanvas]].
     * @param textLayoutStyle - [[TextLayoutStyle]] applied by [[TextCanvas]].
     *
     * @returns New `TextBufferObject`.
     */
    constructor(glyphs, buffer, bounds, characterBounds, textRenderStyle, textLayoutStyle) {
        this.glyphs = glyphs;
        this.buffer = buffer;
        this.bounds = bounds;
        this.characterBounds = characterBounds;
        this.textRenderStyle = textRenderStyle;
        this.textLayoutStyle = textLayoutStyle;
    }
}
exports.TextBufferObject = TextBufferObject;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextGeometry.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextGeometry.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextGeometry = exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD = exports.VERTICES_PER_QUAD = exports.INDEX_BUFFER_STRIDE = exports.VERTEX_BUFFER_STRIDE = exports.MAX_CAPACITY = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const THREE = __webpack_require__(/*! three */ "three");
exports.MAX_CAPACITY = 65536;
exports.VERTEX_BUFFER_STRIDE = 16;
exports.INDEX_BUFFER_STRIDE = 1;
exports.VERTICES_PER_QUAD = 4;
exports.INDICES_PER_QUAD = 6;
exports.QUAD_VERTEX_MEMORY_FOOTPRINT = exports.VERTICES_PER_QUAD * exports.VERTEX_BUFFER_STRIDE;
exports.QUAD_INDEX_MEMORY_FOOTPRINT = exports.INDICES_PER_QUAD * exports.INDEX_BUFFER_STRIDE;
/**
 * Number of bytes for float in an Float32Array.
 */
const NUM_BYTES_PER_FLOAT = 4;
/**
 * Number of bytes for integer number in an UInt32Array.
 */
const NUM_BYTES_PER_INT32 = 4;
/**
 * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].
 */
class TextGeometry {
    /**
     * Creates a new `TextGeometry`.
     *
     * @param material - Material used to render foreground glyphs.
     * @param backgroundMaterial - Material used to render background glyphs.
     * @param initialSize - Initial amount of glyphs that can be stored.
     * @param capacity - Maximum glyph capacity.
     *
     * @returns New `TextGeometry`.
     */
    constructor(scene, material, backgroundMaterial, initialSize, capacity) {
        this.scene = scene;
        this.m_pickingDataArray = [];
        this.capacity = Math.min(capacity, exports.MAX_CAPACITY);
        this.m_currentCapacity = Math.min(initialSize, capacity);
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_vertexBuffer = new THREE.InterleavedBuffer(new Float32Array(this.m_currentCapacity * exports.QUAD_VERTEX_MEMORY_FOOTPRINT), exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        this.m_indexBuffer = new THREE.BufferAttribute(new Uint32Array(this.m_currentCapacity * exports.QUAD_INDEX_MEMORY_FOOTPRINT), exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_mesh = new THREE.Mesh(this.m_geometry, material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
    /**
     * Count of currently drawn glyphs.
     */
    get drawCount() {
        return this.m_drawCount;
    }
    /**
     * Mesh used to render foreground glyphs.
     */
    get mesh() {
        return this.m_mesh;
    }
    /**
     * Mesh used to render background glyphs.
     */
    get backgroundMesh() {
        return this.m_bgMesh;
    }
    /**
     * Release all allocated resources.
     */
    dispose() {
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_geometry.dispose();
    }
    /**
     * Clear the geometry.
     */
    clear() {
        this.m_drawCount = 0;
        this.m_updateOffset = 0;
        this.m_pickingDataArray.length = 0;
    }
    /**
     * Update the GPU resources to reflect the latest additions to the geometry.
     */
    update() {
        if (this.drawCount > this.m_updateOffset) {
            this.m_vertexBuffer.needsUpdate = true;
            this.m_vertexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_vertexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.needsUpdate = true;
            this.m_indexBuffer.updateRange.offset =
                this.m_updateOffset * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
            this.m_indexBuffer.updateRange.count =
                (this.m_drawCount - this.m_updateOffset) * exports.QUAD_INDEX_MEMORY_FOOTPRINT;
        }
        this.m_updateOffset = this.m_drawCount;
        this.m_geometry.setDrawRange(0, this.m_drawCount * exports.INDICES_PER_QUAD);
    }
    /**
     * Add a new glyph to the `TextGeometry`.
     *
     * @param glyphData - [[GlyphData]] holding the glyph description.
     * @param corners - Transformed glyph corners.
     * @param weight - Foreground glyph sampling weight.
     * @param bgWeight - Foreground glyph sampling weight.
     * @param mirrored - If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).
     * @param style - Currently set [[TextRenderStyle]].
     *
     * @returns Result of the addition.
     */
    add(glyphData, corners, weight, bgWeight, mirrored, style) {
        if (this.m_drawCount >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const baseVertex = this.m_drawCount * exports.VERTICES_PER_QUAD;
        const baseIndex = this.m_drawCount * exports.INDICES_PER_QUAD;
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            this.m_positionAttribute.setXYZW(baseVertex + i, corners[i].x, corners[i].y, corners[i].z, (mirrored ? -1.0 : 1.0) * style.rotation);
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            this.m_uvAttribute.setXYZW(baseVertex + i, glyphData.dynamicTextureCoordinates[mirroredUVIdx].x, glyphData.dynamicTextureCoordinates[mirroredUVIdx].y, weight, bgWeight);
            this.m_colorAttribute.setXYZW(baseVertex + i, style.color.r, style.color.g, style.color.b, style.opacity);
            this.m_bgColorAttribute.setXYZW(baseVertex + i, style.backgroundColor.r, style.backgroundColor.g, style.backgroundColor.b, style.backgroundOpacity);
        }
        this.m_indexBuffer.setX(baseIndex, baseVertex);
        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);
        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);
        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);
        ++this.m_drawCount;
        return true;
    }
    /**
     * Add a new glyph to a text buffer.
     *
     * @param buffer - Target buffer where glyph attributes will be stored.
     * @param offset - Offset of the target buffer.
     * @param glyphData - [[GlyphData]] holding the glyph description.
     * @param corners - Transformed glyph corners.
     * @param weight - Foreground glyph sampling weight.
     * @param bgWeight - Foreground glyph sampling weight.
     * @param mirrored - If `true`, UVs will be mirrored (needed for RTL punctuation).
     * @param style - Currently set [[TextRenderStyle]].
     */
    addToBuffer(buffer, offset, glyphData, corners, weight, bgWeight, mirrored, style) {
        for (let i = 0; i < exports.VERTICES_PER_QUAD; ++i) {
            const vertexOffset = offset + exports.VERTEX_BUFFER_STRIDE * i;
            buffer[vertexOffset] = corners[i].x;
            buffer[vertexOffset + 1] = corners[i].y;
            buffer[vertexOffset + 2] = corners[i].z;
            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;
            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;
            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;
            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;
            buffer[vertexOffset + 6] = weight;
            buffer[vertexOffset + 7] = bgWeight;
            buffer[vertexOffset + 8] = style.color.r;
            buffer[vertexOffset + 9] = style.color.g;
            buffer[vertexOffset + 10] = style.color.b;
            buffer[vertexOffset + 11] = style.opacity;
            buffer[vertexOffset + 12] = style.backgroundColor.r;
            buffer[vertexOffset + 13] = style.backgroundColor.g;
            buffer[vertexOffset + 14] = style.backgroundColor.b;
            buffer[vertexOffset + 15] = style.backgroundOpacity;
        }
    }
    /**
     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can
     * be passed to override the passed attribute data.
     *
     * @param textBufferObject - [[TextBufferObject]] containing computed glyphs.
     * @param position - Override position value.
     * @param scale - Override scale value.
     * @param rotation - Override rotation value.
     * @param color - Override color value.
     * @param opacity - Override opacity value.
     * @param bgColor - Override background color value.
     * @param bgOpacity - Override background opacity value.
     *
     * @returns Result of the addition.
     */
    addTextBufferObject(textBufferObject, position, scale, rotation, color, opacity, bgColor, bgOpacity) {
        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {
            return false;
        }
        else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {
            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);
            this.resizeBuffers(newSize);
        }
        const s = scale !== null && scale !== void 0 ? scale : 1.0;
        const r = rotation !== null && rotation !== void 0 ? rotation : 0.0;
        const cosR = Math.cos(r);
        const sinR = Math.sin(r);
        const offsetX = position !== undefined ? position.x : 0.0;
        const offsetY = position !== undefined ? position.y : 0.0;
        // Ignore z for rendering
        const offsetZ = 0.0;
        const buffer = textBufferObject.buffer;
        const rot = buffer[3];
        const rotSign = rot < 0 ? -1.0 : 1.0;
        const red = color !== undefined ? color.r : buffer[8];
        const green = color !== undefined ? color.g : buffer[9];
        const blue = color !== undefined ? color.b : buffer[10];
        const alpha = opacity !== undefined ? opacity : buffer[11];
        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];
        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];
        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];
        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];
        const targetOffset = this.m_drawCount * exports.VERTICES_PER_QUAD;
        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {
            const srcOffset = i * exports.QUAD_VERTEX_MEMORY_FOOTPRINT;
            const glyph = textBufferObject.glyphs[i];
            if (!glyph.isInCache) {
                return false;
            }
            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + exports.VERTEX_BUFFER_STRIDE + 4];
            const w = buffer[srcOffset + 6];
            const bw = buffer[srcOffset + 7];
            for (let j = 0; j < exports.VERTICES_PER_QUAD; ++j) {
                const x = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE];
                const y = buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 1];
                this.m_positionAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, x * s * cosR + y * s * -sinR + offsetX, x * s * sinR + y * s * cosR + offsetY, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 2] + offsetZ, buffer[srcOffset + j * exports.VERTEX_BUFFER_STRIDE + 3] + rotSign * r);
                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;
                this.m_uvAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, glyph.dynamicTextureCoordinates[mirroredUVIdx].x, glyph.dynamicTextureCoordinates[mirroredUVIdx].y, w, (bw - w) / s + w);
                this.m_colorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, red, green, blue, alpha);
                this.m_bgColorAttribute.setXYZW(targetOffset + i * exports.VERTICES_PER_QUAD + j, bgRed, bgGreen, bgBlue, bgAlpha);
            }
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 1, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 2, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 3, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 2);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 4, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 1);
            this.m_indexBuffer.setX((this.m_drawCount + i) * exports.INDICES_PER_QUAD + 5, (this.m_drawCount + i) * exports.VERTICES_PER_QUAD + 3);
        }
        this.m_drawCount += textBufferObject.glyphs.length;
        return true;
    }
    /**
     * Adds picking data for glyphs from the specified start until the last glyph added.
     *
     * @param startIdx - First glyph index that this picking data is associated to.
     * @param endIdx - Last glyph index that this picking data is associated to.
     * @param pickingData - Picking data to be added.
     */
    addPickingData(startIdx, endIdx, pickingData) {
        if (this.m_pickingDataArray.length >= this.m_currentCapacity) {
            return false;
        }
        this.m_pickingDataArray.push({
            start: Math.min(startIdx, this.capacity),
            end: Math.min(endIdx, this.capacity),
            data: pickingData
        });
        return true;
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs
     * are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pick(screenPosition, pickCallback) {
        for (const pickingData of this.m_pickingDataArray) {
            if (pickingData === undefined) {
                return;
            }
            for (let i = pickingData.start; i < pickingData.end; ++i) {
                const positionIndex = i * exports.VERTICES_PER_QUAD;
                const minX = Math.min(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x < minX) {
                    continue;
                }
                const maxX = Math.max(this.m_positionAttribute.getX(positionIndex + 2), this.m_positionAttribute.getX(positionIndex + 1));
                if (screenPosition.x > maxX) {
                    continue;
                }
                const minY = Math.min(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y < minY) {
                    continue;
                }
                const maxY = Math.max(this.m_positionAttribute.getY(positionIndex + 2), this.m_positionAttribute.getY(positionIndex + 1));
                if (screenPosition.y > maxY) {
                    continue;
                }
                pickCallback(pickingData.data);
                break;
            }
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.
     *
     * @param info - The info object to increment with the values from this `TextGeometry`.
     */
    updateMemoryUsage(info) {
        const numBytes = this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +
            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;
        info.heapSize += numBytes;
        info.gpuSize += numBytes;
    }
    resizeBuffers(size) {
        this.m_currentCapacity = size;
        const newVertexBuffer = new Float32Array(size * exports.QUAD_VERTEX_MEMORY_FOOTPRINT);
        newVertexBuffer.set(this.m_vertexBuffer.array);
        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, exports.VERTEX_BUFFER_STRIDE);
        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);
        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);
        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);
        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);
        const newIndexBuffer = new Uint32Array(size * exports.QUAD_INDEX_MEMORY_FOOTPRINT);
        newIndexBuffer.set(this.m_indexBuffer.array);
        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, exports.INDEX_BUFFER_STRIDE);
        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);
        this.m_geometry.dispose();
        this.m_geometry = new THREE.BufferGeometry();
        this.m_geometry.setAttribute("position", this.m_positionAttribute);
        this.m_geometry.setAttribute("uv", this.m_uvAttribute);
        this.m_geometry.setAttribute("color", this.m_colorAttribute);
        this.m_geometry.setAttribute("bgColor", this.m_bgColorAttribute);
        this.m_geometry.setIndex(this.m_indexBuffer);
        this.m_pickingDataArray.length = this.m_currentCapacity;
        this.scene.remove(this.m_bgMesh, this.m_mesh);
        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);
        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);
        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;
        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;
        this.m_mesh.frustumCulled = false;
        this.m_bgMesh.frustumCulled = false;
        this.scene.add(this.m_bgMesh, this.m_mesh);
    }
}
exports.TextGeometry = TextGeometry;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextMaterials.ts":
/*!**********************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextMaterials.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdfTextMaterial = exports.GlyphCopyMaterial = exports.GlyphClearMaterial = void 0;
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const SdfShaderChunks = {
    sdf_attributes: `
        attribute vec4 position;
        attribute vec4 uv;
        attribute vec4 color;
        attribute vec4 bgColor;
        `,
    sdf_varying: `
        varying vec4 vColor;
        varying float vWeight;
        varying vec2 vUv;
        varying float vRotation;
        `,
    sdf_varying_computation: `
        #if BG_TEXT
        vColor = bgColor;
        vWeight = uv.w;
        #else
        vColor = color;
        vWeight = uv.z;
        #endif
        vUv = vec2(uv.xy);
        vRotation = position.w;
        `,
    sdf_frag_uniforms: `
        uniform sampler2D sdfTexture;
        uniform vec4 sdfParams;
        `,
    sdf_sampling_functions: `
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }

        float getDistance(vec2 uvOffset) {
            vec3 texSample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;
            #if MSDF
            return median(texSample.r, texSample.g, texSample.b);
            #else
            return texSample.r;
            #endif
        }

        float getOpacity(vec2 uvOffset, float weight) {
            vec2 uv = vUv + uvOffset;
            vec2 rotatedUVs = abs(vec2(
                cos(vRotation) * uv.x - sin(vRotation) * uv.y,
                sin(vRotation) * uv.x + cos(vRotation) * uv.y));

            float dx = dFdx(rotatedUVs.x) * sdfParams.x;
            float dy = dFdy(rotatedUVs.y) * sdfParams.y;
            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );

            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;
            return clamp(dist * toPixels + 0.5, 0.0, 1.0);
        }
        `
};
Object.assign(THREE.ShaderChunk, SdfShaderChunks);
const clearVertexSource = `
    attribute vec2 position;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const clearFragmentSource = `
    precision highp float;
    precision highp int;

    void main() {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }`;
const copyVertexSource = `
    attribute vec3 position;
    attribute vec2 uv;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 vUv;

    void main() {
        vUv = vec3(uv.xy, position.z);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);
    }`;
const copyFragmentSource = `
    precision highp float;
    precision highp int;

    uniform float pageOffset;
    uniform sampler2D page0;
    uniform sampler2D page1;
    uniform sampler2D page2;
    uniform sampler2D page3;
    uniform sampler2D page4;
    uniform sampler2D page5;
    uniform sampler2D page6;
    uniform sampler2D page7;

    varying vec3 vUv;

    void main() {
        vec4 texSample = vec4(0.0);
        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;
        else if (vUv.z < pageOffset + 1.0) texSample = texture2D(page0, vUv.xy);
        else if (vUv.z < pageOffset + 2.0) texSample = texture2D(page1, vUv.xy);
        else if (vUv.z < pageOffset + 3.0) texSample = texture2D(page2, vUv.xy);
        else if (vUv.z < pageOffset + 4.0) texSample = texture2D(page3, vUv.xy);
        else if (vUv.z < pageOffset + 5.0) texSample = texture2D(page4, vUv.xy);
        else if (vUv.z < pageOffset + 6.0) texSample = texture2D(page5, vUv.xy);
        else if (vUv.z < pageOffset + 7.0) texSample = texture2D(page6, vUv.xy);
        else texSample = texture2D(page7, vUv.xy);

        gl_FragColor = texSample;
    }`;
const sdfTextVertexSource = `
    #include <sdf_attributes>
    #include <sdf_varying>

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    void main() {
        #include <sdf_varying_computation>
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    }`;
const sdfTextFragmentSource = `
    precision highp float;
    precision highp int;

    #include <sdf_varying>
    #include <sdf_frag_uniforms>
    #include <sdf_sampling_functions>

    void main() {
        vec4 color = vColor;
        color.a *= getOpacity(vec2(0.0), vWeight);
        if (color.a < 0.05) {
            discard;
        }
        gl_FragColor = color;
    }`;
class RawShaderMaterial extends THREE.RawShaderMaterial {
    /**
     * The constructor of `RawShaderMaterial`.
     *
     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning
     * another material.
     */
    constructor(params) {
        const isWebGL2 = (params === null || params === void 0 ? void 0 : params.rendererCapabilities.isWebGL2) === true;
        const shaderParams = params
            ? Object.assign(Object.assign({}, params), { glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1, vertexShader: isWebGL2 && params.vertexShader
                    ? harp_utils_1.convertVertexShaderToWebGL2(params.vertexShader)
                    : params.vertexShader, fragmentShader: isWebGL2 && params.fragmentShader
                    ? harp_utils_1.convertFragmentShaderToWebGL2(params.fragmentShader)
                    : params.fragmentShader }) : undefined;
        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js
        // will log warnings.
        if (shaderParams) {
            delete shaderParams.rendererCapabilities;
        }
        super(shaderParams);
    }
}
/**
 * @hidden
 * Material used for clearing glyphs from a [[GlyphTextureCache]].
 */
class GlyphClearMaterial extends RawShaderMaterial {
    /**
     * Creates a new `GlyphClearMaterial`.
     * @param params - Material parameters. Always required except when cloning another
     * material.
     * @returns New `GlyphClearMaterial`.
     */
    constructor(params) {
        const shaderParams = params
            ? {
                name: "GlyphClearMaterial",
                vertexShader: clearVertexSource,
                fragmentShader: clearFragmentSource,
                uniforms: {},
                depthTest: false,
                depthWrite: false,
                rendererCapabilities: params.rendererCapabilities
            }
            : undefined;
        super(shaderParams);
    }
}
exports.GlyphClearMaterial = GlyphClearMaterial;
/**
 * @hidden
 * Material used for copying glyphs into a [[GlyphTextureCache]].
 */
class GlyphCopyMaterial extends RawShaderMaterial {
    /**
     * Creates a new `GlyphCopyMaterial`.
     * @param params - Material parameters. Always required except when cloning another
     * material.
     * @returns New `GlyphCopyMaterial`.
     */
    constructor(params) {
        const shaderParams = params
            ? {
                name: "GlyphCopyMaterial",
                vertexShader: copyVertexSource,
                fragmentShader: copyFragmentSource,
                uniforms: {
                    pageOffset: new THREE.Uniform(0.0),
                    page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),
                    page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)
                },
                depthTest: false,
                depthWrite: false,
                rendererCapabilities: params.rendererCapabilities
            }
            : undefined;
        super(shaderParams);
    }
}
exports.GlyphCopyMaterial = GlyphCopyMaterial;
/**
 * Material designed to render transformable, high quality SDF text.
 */
class SdfTextMaterial extends RawShaderMaterial {
    /**
     * Creates a new `SdfTextMaterial`.
     *
     * @param params - Material parameters. Always required except when cloning another
     * material.
     * @returns New `SdfTextMaterial`.
     */
    constructor(params) {
        const shaderParams = params
            ? {
                name: "SdfTextMaterial",
                vertexShader: params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,
                fragmentShader: params.fragmentSource !== undefined
                    ? params.fragmentSource
                    : sdfTextFragmentSource,
                uniforms: {
                    sdfTexture: new THREE.Uniform(params.texture),
                    sdfParams: new THREE.Uniform(new THREE.Vector4(params.textureSize.x, params.textureSize.y, params.size, params.distanceRange))
                },
                defines: {
                    MSDF: params.isMsdf ? 1.0 : 0.0,
                    BG_TEXT: params.isBackground ? 1.0 : 0.0
                },
                depthTest: true,
                depthWrite: false,
                side: THREE.DoubleSide,
                transparent: true,
                rendererCapabilities: params.rendererCapabilities
            }
            : undefined;
        super(shaderParams);
        this.extensions.derivatives = true;
    }
}
exports.SdfTextMaterial = SdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/rendering/TextStyle.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/rendering/TextStyle.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvePlacementAndAlignment = exports.TextLayoutStyle = exports.TextRenderStyle = exports.DefaultTextStyle = exports.vPlacementFromAlignment = exports.hPlacementFromAlignment = exports.vAlignFromPlacement = exports.hAlignFromPlacement = exports.WrappingMode = exports.HorizontalPlacement = exports.VerticalPlacement = exports.HorizontalAlignment = exports.VerticalAlignment = exports.FontVariant = exports.FontStyle = exports.FontUnit = void 0;
const THREE = __webpack_require__(/*! three */ "three");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Vertical position of text area relative to the placement context (point, line).
 */
var VerticalPlacement;
(function (VerticalPlacement) {
    VerticalPlacement[VerticalPlacement["Top"] = 0] = "Top";
    VerticalPlacement[VerticalPlacement["Center"] = -0.5] = "Center";
    VerticalPlacement[VerticalPlacement["Bottom"] = -1] = "Bottom";
})(VerticalPlacement = exports.VerticalPlacement || (exports.VerticalPlacement = {}));
/**
 * Horizontal position of text element relative to the placement context (point, line).
 *
 * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,
 * cause when you place text on the right side of point (or icon) it will be left-aligned.
 */
var HorizontalPlacement;
(function (HorizontalPlacement) {
    HorizontalPlacement[HorizontalPlacement["Left"] = -1] = "Left";
    HorizontalPlacement[HorizontalPlacement["Center"] = -0.5] = "Center";
    HorizontalPlacement[HorizontalPlacement["Right"] = 0] = "Right";
})(HorizontalPlacement = exports.HorizontalPlacement || (exports.HorizontalPlacement = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].
 * Horizontal alignments are exactly opposite to the placements.
 */
function hAlignFromPlacement(hP) {
    return hP;
}
exports.hAlignFromPlacement = hAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].
 */
function vAlignFromPlacement(vP) {
    return vP;
}
exports.vAlignFromPlacement = vAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].
 * Horizontal placements are exactly opposite to the alignment values.
 */
function hPlacementFromAlignment(hA) {
    return hA;
}
exports.hPlacementFromAlignment = hPlacementFromAlignment;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].
 */
function vPlacementFromAlignment(vA) {
    return vA;
}
exports.vPlacementFromAlignment = vPlacementFromAlignment;
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
    DefaultTextStyle.DEFAULT_PLACEMENTS = [];
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? Object.assign({}, params.fontSize) : {
                unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
            },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color.clone()
                : DefaultTextStyle.DEFAULT_COLOR.clone(),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor.clone()
                : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = Object.assign({}, value);
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color.copy(value);
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor.copy(value);
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this [[TextRenderStyle]].
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns Cloned [[TextRenderStyle]].
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextRenderStyle]] properties into this object instance.
     *
     * @param source - The source object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(source) {
        // Given that all source and this params are always defined:
        this.m_params.fontName = source.fontName;
        this.m_params.fontSize = Object.assign({}, source.fontSize);
        this.m_params.fontStyle = source.fontStyle;
        this.m_params.fontVariant = source.fontVariant;
        this.m_params.rotation = source.rotation;
        this.m_params.color.copy(source.color);
        this.m_params.backgroundColor.copy(source.backgroundColor);
        this.m_params.opacity = source.opacity;
        this.m_params.backgroundOpacity = source.backgroundOpacity;
        return this;
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        // Solve alignment and placement dependencies and fallbacks.
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements);
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment,
            horizontalAlignment,
            placements
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Text placement options relative to label anchor (origin).
     *
     * @note [[TextPlacement]]s options may override alignment settings.
     */
    get placements() {
        return this.m_params.placements;
    }
    set placements(value) {
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value);
        this.m_params.horizontalAlignment = horizontalAlignment;
        this.m_params.verticalAlignment = verticalAlignment;
        this.m_params.placements = placements;
    }
    /**
     * Clone this [[TextLayoutStyle]].
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns Cloned [[TextLayoutStyle]].
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextLayoutStyle]] properties into this object instance.
     *
     * @param other - The object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(other) {
        this.params = Object.assign({}, other.params);
        return this;
    }
}
exports.TextLayoutStyle = TextLayoutStyle;
/**
 * Deduce alignment and placement attributes depending on the availability.
 *
 * If placement is defined it may override alignment settings, if no attributes are
 * provided they may be retrieved from defaults.
 *
 * @param hAlignment - The optional horizontal alignment.
 * @param vAlignment - The vertical alignment - optional.
 * @param placementsOpt - Possible text placements - optional.
 * @internal
 */
function resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {
    var _a;
    // Make a deep copy or create new array from defaults.
    const placements = (_a = placementsOpt === null || placementsOpt === void 0 ? void 0 : placementsOpt.map(v => (Object.assign({}, v)))) !== null && _a !== void 0 ? _a : DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => (Object.assign({}, v)));
    // Ignore alignment attributes when placements attributes are defined or provide default
    // values if none of them are provided.
    // NOTE: Alignment override may be removed if we decide to support both attributes.
    const horizontalAlignment = placements.length > 0
        ? hAlignFromPlacement(placements[0].h)
        : hAlignment !== null && hAlignment !== void 0 ? hAlignment : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
    const verticalAlignment = placements.length > 0
        ? vAlignFromPlacement(placements[0].v)
        : vAlignment !== null && vAlignment !== void 0 ? vAlignment : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
    return { horizontalAlignment, verticalAlignment, placements };
}
exports.resolvePlacementAndAlignment = resolvePlacementAndAlignment;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/LineTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/LineTypesetter.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineTypesetter = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * [[Typesetter]] implementation that handles multi-line complex layout text.
 */
class LineTypesetter {
    /**
     * Creates a `LineTypesetter` object.
     *
     * @returns New `LineTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
    }
    /**
     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple
     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,
     * such as:
     * - Maximum line width.
     * - Word and character wrapping.
     * - Maximum number of lines.
     * - Vertical and horizontal alignment.
     * - Leading (spacing between lines).
     *
     * @param params - Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_currentParams.position.y +=
            this.m_currentParams.textLayoutStyle.verticalAlignment *
                this.m_currentParams.glyphs[0].font.metrics.capHeight *
                this.m_tempScale;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // Compute line origin and height.
        const origin = this.m_currentParams.position.x;
        const lineHeight = this.m_currentParams.glyphs[0].font.metrics.lineHeight +
            this.m_currentParams.textLayoutStyle.leading;
        // Initialize line-breaking and wrapping variables.
        let lineStartIdx = 0;
        let glyphWrapIdx = 0;
        let wordWrapIdx = 0;
        let lineStartX = 0;
        let lineCurrX = 0;
        let glyphWrapX = 0;
        let wordWrapX = 0;
        let lineCount = 0;
        let isBidirectionalLine = false;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {
                break;
            }
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            const isNewLine = UnicodeUtils_1.UnicodeUtils.isNewLine(glyphData.codePoint);
            const isWhiteSpace = UnicodeUtils_1.UnicodeUtils.isWhiteSpace(glyphData.codePoint);
            // Check if this line should be treated as bidirectional.
            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectionalLine = true;
            }
            // Advance the line's current X offset (only for printable characters).
            if (UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                lineCurrX +=
                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                        this.m_tempScale *
                        (this.m_tempSmallCaps
                            ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                            : 1.0);
            }
            // If this is the first character in a line, update the line's X offset values (needed
            // to properly center and wrap).
            if (i === lineStartIdx) {
                lineStartX = lineCurrX;
                glyphWrapX = lineCurrX;
                wordWrapX = lineCurrX;
            }
            // Check if should break the current line.
            if (isNewLine ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Character &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||
                (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&
                    wordWrapX !== lineStartX)) {
                // Perform wrapping.
                if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None) {
                    let wrapPointIdx = glyphWrapIdx;
                    let wrapPointX = glyphWrapX;
                    // Only wrap words when more than a single word fits into the current line.
                    if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                        wordWrapX !== lineStartX) {
                        wrapPointIdx = wordWrapIdx;
                        wrapPointX = wordWrapX;
                    }
                    lineCurrX = wrapPointX;
                    i = Math.min(isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx, this.m_currentParams.glyphs.length - 1);
                }
                // Calculate the correct starting position for the line base on alignment, and place
                // all glyphs in it.
                const lineAlignment = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;
                this.m_currentParams.position.x =
                    this.m_currentParams.position.x + lineCurrX * lineAlignment;
                if (!this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)) {
                    return false;
                }
                // Update the line position.
                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;
                this.m_currentParams.position.x = origin;
                // Find the beginning of a new line (removing trailing white spaces).
                while (i !== lineStartIdx &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)) {
                    ++i;
                }
                lineStartIdx = i + 1;
                if (lineStartIdx === this.m_currentParams.glyphs.length) {
                    break;
                }
                // Only reset the line's direction when a new line character is found (to keep
                // correct bidirectional behaviour when a bidirectional run is placed between
                // multiple lines).
                if (isNewLine) {
                    this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, lineStartIdx);
                    this.m_tempRunDirection = this.m_tempLineDirection;
                }
                // Reset the line placement parameters.
                lineStartX = 0;
                lineCurrX = 0;
                glyphWrapIdx = lineStartIdx;
                glyphWrapX = 0;
                wordWrapIdx = lineStartIdx;
                wordWrapX = 0;
                isBidirectionalLine = false;
                lineCount++;
            }
            // If not, should if we should record any new wrapping points.
            else if (this.m_currentParams.textLayoutStyle.wrappingMode !== TextStyle_1.WrappingMode.None &&
                !isWhiteSpace) {
                // Update the per-glyph wrapping point.
                glyphWrapIdx = i;
                glyphWrapX = lineCurrX;
                // Update the word wrapping point (only if mode is correctly set and we are
                // currently placed at the end of a word).
                if (this.m_currentParams.textLayoutStyle.wrappingMode === TextStyle_1.WrappingMode.Word &&
                    i + 1 < this.m_currentParams.glyphs.length &&
                    (UnicodeUtils_1.UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||
                        UnicodeUtils_1.UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))) {
                    wordWrapIdx = i;
                    wordWrapX = lineCurrX;
                }
            }
        }
        // If we still haven't placed all characters, place a final line.
        if (lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&
            lineStartIdx <= this.m_currentParams.glyphs.length - 1) {
            const offset = this.m_tempLineDirection === UnicodeUtils_1.UnicodeUtils.Direction.RTL && isBidirectionalLine
                ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment
                : this.m_currentParams.textLayoutStyle.horizontalAlignment;
            this.m_currentParams.position.setX(this.m_currentParams.position.x + lineCurrX * offset);
            if (!this.placeLine(lineStartIdx, this.m_currentParams.glyphs.length - 1, this.m_tempLineDirection, isBidirectionalLine)) {
                return false;
            }
        }
        return true;
    }
    // Place characters alongside a line. Text direction is taken into account, and text is broken
    // into directional runs.
    placeLine(startIdx, endIdx, direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(startIdx, endIdx, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        // Initialize line placement parameters.
        const isRTL = direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
        const origin = position.x;
        let offset = 0;
        let runStart = startIdx;
        for (let i = startIdx; i <= endIdx; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (isRTL) {
                    position.x = origin + offset;
                }
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                if (!isRTL) {
                    position.x = origin + offset;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (isRTL) {
                        position.x = origin + offset;
                    }
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    if (!isRTL) {
                        position.x = origin + offset;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
            // Advance the offset position in the line.
            offset +=
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(glyphDataArray, smallCapsArray, i, textRenderStyle.fontVariant)
                        : 1.0) *
                    direction;
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart <= endIdx) {
            if (isRTL) {
                position.x = origin + offset;
            }
            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {
                return false;
            }
            if (!isRTL) {
                position.x = origin + offset;
            }
        }
        return true;
    }
    // Place a directional run of index inside a line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, position, glyphScale, textLayoutStyle.canvasRotation, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Advance the current position and proceed to next glyph in the run.
            position.set(position.x +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.cos(textLayoutStyle.lineRotation), position.y +
                (glyphData.advanceX + textLayoutStyle.tracking) *
                    glyphScale *
                    Math.sin(textLayoutStyle.lineRotation), position.z);
        }
        return true;
    }
}
exports.LineTypesetter = LineTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/typesetting/PathTypesetter.ts":
/*!*************************************************************!*\
  !*** ../harp-text-canvas/lib/typesetting/PathTypesetter.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PathTypesetter = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const TextGeometry_1 = __webpack_require__(/*! ../rendering/TextGeometry */ "../harp-text-canvas/lib/rendering/TextGeometry.ts");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const TypesettingUtils_1 = __webpack_require__(/*! ../utils/TypesettingUtils */ "../harp-text-canvas/lib/utils/TypesettingUtils.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * [[Typesetter]] implementation that arranges glyphs alongside a specified path.
 */
class PathTypesetter {
    /**
     * Creates a `PathTypesetter` object.
     *
     * @returns New `PathTypesetter`.
     */
    constructor() {
        this.m_tempTransform = new THREE.Matrix3();
        this.m_tempCorners = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ];
        this.m_tempLineDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempRunDirection = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        this.m_tempPixelSize = 1.0;
        this.m_tempPixelBgSize = 1.0;
        this.m_tempScale = 1.0;
        this.m_tempSmallCaps = false;
        this.m_tempPathPosition = new THREE.Vector3();
        this.m_tempPathLength = 0.0;
        this.m_tempPathOffset = 0.0;
    }
    /**
     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single
     * bidirectional line that follows the specified path. Characters will be orientated and placed
     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and
     * [[HorizontalAlignment]].
     *
     * @param params - Typesetting parameters.
     *
     * @returns If `false`, some error occurred during execution and the output should be dismissed.
     */
    arrangeGlyphs(params) {
        // Initializes common typesetting parameters (used across all functions in this class).
        this.m_currentParams = params;
        this.m_tempLineDirection = TypesettingUtils_1.TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);
        this.m_tempRunDirection = this.m_tempLineDirection;
        this.m_tempPixelSize = TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.size, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size);
        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;
        this.m_tempPixelBgSize = Math.min(TypesettingUtils_1.TypesettingUtils.getPixelSize(this.m_currentParams.textRenderStyle.fontSize.backgroundSize, this.m_currentParams.textRenderStyle.fontSize.unit, this.m_currentParams.fontCatalog.size), this.m_currentParams.fontCatalog.distanceRange * this.m_tempScale);
        this.m_tempSmallCaps = this.m_currentParams.smallCapsArray !== undefined;
        this.m_tempPathLength = this.m_currentParams.path.getLength();
        this.m_tempPathOffset = 0.0;
        const isOnlyMeasured = this.m_currentParams.globalBounds !== undefined &&
            this.m_currentParams.vertexBuffer === undefined;
        // To be able to properly set the horizontal alignment on a path, we need to first retrieve
        // how much of the path the input text covers, so we can calculate the correct initial
        // offset.
        let isBidirectional = false;
        let pathWidth = 0.0;
        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {
            const glyphData = this.m_currentParams.glyphs[i];
            if (!glyphData.isInCache && !isOnlyMeasured) {
                return false;
            }
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {
                isBidirectional = true;
            }
            pathWidth +=
                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *
                    this.m_tempScale *
                    (this.m_tempSmallCaps
                        ? TypesettingUtils_1.TypesettingUtils.getSmallCapsScale(this.m_currentParams.glyphs, this.m_currentParams.smallCapsArray, i, this.m_currentParams.textRenderStyle.fontVariant)
                        : 1.0);
        }
        this.m_tempPathOffset = Math.min(Math.max(-this.m_currentParams.textLayoutStyle.horizontalAlignment +
            (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /
                this.m_tempPathLength, 0), 1);
        // Place the input text as a single path line.
        return this.placeLine(this.m_tempLineDirection, isBidirectional);
    }
    // Place characters alongside a path line. Text direction is taken into account, and text is
    // broken into directional runs.
    placeLine(direction, isBidirectional) {
        // If the line is not bidirectional, place it as a single directional run.
        if (!isBidirectional) {
            return this.placeRun(0, this.m_currentParams.glyphs.length - 1, direction);
        }
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        // Initialize line placement parameters.
        let runStart = 0;
        for (let i = runStart; i < glyphDataArray.length; ++i) {
            const glyphData = glyphDataArray[i];
            // If the current glyph changes the line direction, place the current run.
            if (glyphData.direction === -this.m_tempRunDirection) {
                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                    return false;
                }
                runStart = i;
                this.m_tempRunDirection *= -1.0;
            }
            // If the current glyph has neutral direction (i.e. white space) and we're in the middle
            // of a run with direction opposite to the line's main direction, check for the closest
            // strong direction in the run.
            else if (glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                this.m_tempRunDirection === -direction) {
                let neutralIdx = i;
                while (neutralIdx + 1 < glyphDataArray.length &&
                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1) {
                    ++neutralIdx;
                }
                // If the closest strong direction in the run is not the current run's direction,
                // place the current run.
                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {
                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {
                        return false;
                    }
                    runStart = i;
                    this.m_tempRunDirection *= -1.0;
                }
            }
        }
        // If we still haven't placed all characters in the line, place a final run.
        if (runStart < glyphDataArray.length) {
            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {
                return false;
            }
        }
        return true;
    }
    // Place a directional run of index inside a path line.
    placeRun(startIdx, endIdx, direction) {
        // Gather common typesetting parameters.
        const glyphDataArray = this.m_currentParams.glyphs;
        const smallCapsArray = this.m_currentParams.smallCapsArray;
        const fontCatalog = this.m_currentParams.fontCatalog;
        const textRenderStyle = this.m_currentParams.textRenderStyle;
        const textLayoutStyle = this.m_currentParams.textLayoutStyle;
        const position = this.m_currentParams.position;
        const geometry = this.m_currentParams.geometry;
        const globalBounds = this.m_currentParams.globalBounds;
        const individualBounds = this.m_currentParams.individualBounds;
        const vertexBuffer = this.m_currentParams.vertexBuffer;
        const path = this.m_currentParams.path;
        const defaultGlyphRotation = textRenderStyle.rotation;
        const normalDisplacement = textLayoutStyle.verticalAlignment *
            glyphDataArray[0].font.metrics.capHeight *
            this.m_tempScale;
        // Move through the glyph array following the run's direction (as the order of the glyphs in
        // memory might not match the order on glyphs on scree).
        const start = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? startIdx : endIdx;
        const end = direction === UnicodeUtils_1.UnicodeUtils.Direction.LTR ? endIdx : startIdx;
        for (let i = start; direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL ? i >= end : i <= end; i += direction) {
            // Only process printable characters.
            const glyphData = glyphDataArray[i];
            if (!UnicodeUtils_1.UnicodeUtils.isPrintable(glyphData.codePoint)) {
                continue;
            }
            // When placing a RTL run, we need to check for weak runs (numerical runs of characters
            // that don't change the overall run direction, but should always be displayed as LTR
            // text).
            if (startIdx !== endIdx &&
                i !== 0 &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
                glyphData.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak) {
                let weakRunStart = i;
                let weakGlyph = glyphDataArray[weakRunStart - 1];
                while (weakRunStart !== startIdx &&
                    (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Weak ||
                        (weakGlyph.direction === UnicodeUtils_1.UnicodeUtils.Direction.Neutral &&
                            !UnicodeUtils_1.UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))) {
                    --weakRunStart;
                    weakGlyph = glyphDataArray[weakRunStart - 1];
                }
                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils_1.UnicodeUtils.Direction.LTR);
                i = weakRunStart;
                continue;
            }
            // Compute various rendering parameters for this glyph.
            const glyphFont = glyphData.font;
            const glyphFontMetrics = glyphFont.metrics;
            const fontStyle = textRenderStyle.fontStyle;
            const isBoldEmulated = (fontStyle === TextStyle_1.FontStyle.Bold && glyphFont.bold === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.bold === undefined &&
                    glyphFont.boldItalic === undefined);
            const isItalicEmulated = (fontStyle === TextStyle_1.FontStyle.Italic && glyphFont.italic === undefined) ||
                (fontStyle === TextStyle_1.FontStyle.BoldItalic &&
                    glyphFont.italic === undefined &&
                    glyphFont.boldItalic === undefined);
            const isSmallCaps = this.m_tempSmallCaps
                ? smallCapsArray[i] && textRenderStyle.fontVariant === TextStyle_1.FontVariant.SmallCaps
                : false;
            const smallCapsScale = isSmallCaps
                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight
                : 1.0;
            const glyphScale = this.m_tempScale * smallCapsScale;
            const emulationWeight = ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *
                (fontCatalog.size / fontCatalog.distanceRange);
            const bgWeight = (0.5 * this.m_tempPixelBgSize) /
                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));
            const isMirrored = UnicodeUtils_1.UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&
                direction === UnicodeUtils_1.UnicodeUtils.Direction.RTL;
            const verticalOffset = glyphFontMetrics.lineHeight -
                glyphFontMetrics.base -
                glyphFontMetrics.distanceRange * 0.5;
            // Update the current interpolated path position and angle.
            const textPoint = path.getPoint(this.m_tempPathOffset);
            if (textPoint === null) {
                return this.m_currentParams.pathOverflow;
            }
            const tangent = path.getTangent(this.m_tempPathOffset);
            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(normalDisplacement);
            const angle = Math.atan2(tangent.y, tangent.x);
            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);
            textRenderStyle.rotation = defaultGlyphRotation + angle;
            // Compute the glyphs transformation matrix and apply to all corners of a glyph.
            TypesettingUtils_1.TypesettingUtils.computeGlyphTransform(this.m_tempTransform, this.m_tempPathPosition, glyphScale, 0.0, textRenderStyle.rotation);
            for (let j = 0; j < 4; ++j) {
                const glyphVertexPosition = glyphData.positions[j];
                const horizontalOffset = isItalicEmulated && j > 1
                    ? TypesettingUtils_1.TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size
                    : 0.0;
                this.m_tempCorners[j].set(glyphVertexPosition.x + horizontalOffset, glyphVertexPosition.y - verticalOffset, glyphVertexPosition.z);
                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);
                this.m_tempCorners[j].x -= position.x;
                this.m_tempCorners[j].y -= position.y;
            }
            // Depending on the typesetting options, add the computed glyph to the TextGeometry or
            // update the text bounds.
            if (globalBounds === undefined && vertexBuffer === undefined) {
                if (!geometry.add(glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle)) {
                    return false;
                }
            }
            else {
                if (globalBounds !== undefined) {
                    TypesettingUtils_1.TypesettingUtils.updateBounds(this.m_tempCorners, globalBounds, individualBounds);
                }
                if (vertexBuffer !== undefined) {
                    geometry.addToBuffer(vertexBuffer, i * TextGeometry_1.QUAD_VERTEX_MEMORY_FOOTPRINT, glyphData, this.m_tempCorners, emulationWeight, emulationWeight + bgWeight, isMirrored, textRenderStyle);
                }
            }
            // Restore the original glyph rotation.
            textRenderStyle.rotation = defaultGlyphRotation;
            // Advance the current position and proceed to next glyph in the run.
            this.m_tempPathOffset +=
                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /
                    this.m_tempPathLength;
        }
        return true;
    }
}
exports.PathTypesetter = PathTypesetter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/ContextualArabicConverter.ts":
/*!******************************************************************!*\
  !*** ../harp-text-canvas/lib/utils/ContextualArabicConverter.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextualArabicConverter = void 0;
var ContextualForm;
(function (ContextualForm) {
    ContextualForm[ContextualForm["Initial"] = 0] = "Initial";
    ContextualForm[ContextualForm["Medial"] = 1] = "Medial";
    ContextualForm[ContextualForm["Final"] = 2] = "Final";
})(ContextualForm || (ContextualForm = {}));
var CombinedForm;
(function (CombinedForm) {
    CombinedForm[CombinedForm["Isolated"] = 0] = "Isolated";
    CombinedForm[CombinedForm["Connected"] = 1] = "Connected";
})(CombinedForm || (CombinedForm = {}));
/**
 * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms
 * (in Unicode Block 'Arabic Presentation Forms-B').
 */
class ContextualArabicConverter {
    constructor() {
        this.m_singleCharactersMap = new Map();
        this.m_combinedCharactersMap = new Map();
        // Single characters.
        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA
        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA
        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE
        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA
        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW
        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA
        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF
        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH
        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA
        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH
        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH
        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM
        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH
        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH
        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL
        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL
        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH
        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN
        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN
        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN
        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD
        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD
        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH
        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH
        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN
        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN
        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL
        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH
        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF
        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF
        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM
        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM
        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON
        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH
        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW
        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA
        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH
        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH
        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh
        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh
        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh
        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf
        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh
        // Combined characters.
        this.m_combinedCharactersMap.set(0x0644, new Map());
        // LAM_ALEF_MADDA
        this.m_combinedCharactersMap.get(0x0644).set(0x0622, [0xfef5, 0xfef6]);
        // LAM_ALEF_HAMZA_ABOVE
        this.m_combinedCharactersMap.get(0x0644).set(0x0623, [0xfef7, 0xfef8]);
        // LAM_ALEF_HAMZA_BELOW
        this.m_combinedCharactersMap.get(0x0644).set(0x0625, [0xfef9, 0xfefa]);
        // LAM_ALEF
        this.m_combinedCharactersMap.get(0x0644).set(0x0627, [0xfefb, 0xfefc]);
        // Neutral characters.
        this.m_neutralCharacters = [
            0x0610,
            0x0612,
            0x0613,
            0x0614,
            0x0615,
            0x064b,
            0x064c,
            0x064d,
            0x064e,
            0x064f,
            0x0650,
            0x0651,
            0x0652,
            0x0653,
            0x0654,
            0x0655,
            0x0656,
            0x0657,
            0x0658,
            0x0670,
            0x06d6,
            0x06d7,
            0x06d8,
            0x06d9,
            0x06da,
            0x06db,
            0x06dc,
            0x06df,
            0x06e0,
            0x06e1,
            0x06e2,
            0x06e3,
            0x06e4,
            0x06e7,
            0x06e8,
            0x06ea,
            0x06eb,
            0x06ec,
            0x06ed // ARABIC SMALL LOW MEEM
        ];
    }
    static get instance() {
        if (this.m_instance === undefined) {
            this.m_instance = new ContextualArabicConverter();
        }
        return this.m_instance;
    }
    /**
     * Converts isolated arabic characters into their contextual form.
     *
     * @param input - String with isolated arabic characters.
     */
    convert(input) {
        let output = "";
        for (let i = 0; i < input.length; ++i) {
            const currentCodePoint = input.charCodeAt(i);
            // Only process arabic characters in the map.
            if (this.isArabicCharacter(currentCodePoint)) {
                // Find the first previous non-neutral character.
                let prevIndex = i - 1;
                for (; prevIndex >= 0; --prevIndex) {
                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {
                        break;
                    }
                }
                // Check if the previous character has ligatures with following characters.
                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;
                if (prevCodePoint !== undefined) {
                    const prevMap = this.getCharacterMap(prevCodePoint);
                    if (prevMap === undefined ||
                        (prevMap[ContextualForm.Initial] === undefined &&
                            prevMap[ContextualForm.Medial] === undefined)) {
                        prevCodePoint = undefined;
                    }
                }
                // Find the first next non-neutral character.
                let nextIndex = i + 1;
                for (; nextIndex < input.length; ++nextIndex) {
                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {
                        break;
                    }
                }
                // Check if the next character has ligatures with previous characters.
                let nextCodePoint = nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;
                if (nextCodePoint !== undefined) {
                    const nextMap = this.getCharacterMap(nextCodePoint);
                    if (nextMap === undefined ||
                        (nextMap[ContextualForm.Medial] === undefined &&
                            nextMap[ContextualForm.Final] === undefined)) {
                        nextCodePoint = undefined;
                    }
                }
                // Check for Lam Alef combinated forms.
                if (currentCodePoint === 0x0644 &&
                    nextCodePoint !== undefined &&
                    (nextCodePoint === 0x0622 ||
                        nextCodePoint === 0x0623 ||
                        nextCodePoint === 0x0625 ||
                        nextCodePoint === 0x0627)) {
                    const combinedMap = this.getCombinedCharacterMap(currentCodePoint, nextCodePoint);
                    if (prevCodePoint !== undefined) {
                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]);
                    }
                    else {
                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]);
                    }
                    // Skip the next character and continue.
                    ++i;
                    continue;
                }
                // Check for single character contextual forms.
                const map = this.getCharacterMap(currentCodePoint);
                // Intermediate.
                if (prevCodePoint !== undefined &&
                    nextCodePoint !== undefined &&
                    map[ContextualForm.Medial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Medial]);
                }
                // Final.
                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Final]);
                }
                // Initial.
                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {
                    output += String.fromCharCode(map[ContextualForm.Initial]);
                }
                // Isolated.
                else {
                    output += String.fromCharCode(currentCodePoint);
                }
            }
            else {
                output += String.fromCharCode(currentCodePoint);
            }
        }
        return output;
    }
    isArabicCharacter(codePoint) {
        return this.m_singleCharactersMap.has(codePoint);
    }
    getCharacterMap(codePoint) {
        return this.m_singleCharactersMap.get(codePoint);
    }
    getCombinedCharacterMap(codePoint, nextCodePoint) {
        const map = this.m_combinedCharactersMap.get(codePoint);
        if (map !== undefined) {
            return map.get(nextCodePoint);
        }
        return undefined;
    }
    isNeutral(codePoint) {
        for (const character of this.m_neutralCharacters) {
            if (character === codePoint) {
                return true;
            }
        }
        return false;
    }
}
exports.ContextualArabicConverter = ContextualArabicConverter;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/MaterialUtils.ts":
/*!******************************************************!*\
  !*** ../harp-text-canvas/lib/utils/MaterialUtils.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSdfTextMaterial = void 0;
const TextMaterials_1 = __webpack_require__(/*! ../rendering/TextMaterials */ "../harp-text-canvas/lib/rendering/TextMaterials.ts");
/**
 * Helper function designed to create [[SdfTextMaterials]] that can be rendered using
 * [[TextCanvas]].
 *
 * @param params - Material parameters.
 *
 * @returns New `SdfTextMaterial`.
 */
function createSdfTextMaterial(params) {
    return new TextMaterials_1.SdfTextMaterial({
        texture: params.fontCatalog.texture,
        textureSize: params.fontCatalog.textureSize,
        size: params.fontCatalog.size,
        distanceRange: params.fontCatalog.distanceRange,
        isMsdf: params.fontCatalog.type === "msdf",
        isBackground: params.isBackground === true,
        vertexSource: params.vertexSource,
        fragmentSource: params.fragmentSource,
        rendererCapabilities: params.rendererCapabilities
    });
}
exports.createSdfTextMaterial = createSdfTextMaterial;


/***/ }),

/***/ "../harp-text-canvas/lib/utils/TypesettingUtils.ts":
/*!*********************************************************!*\
  !*** ../harp-text-canvas/lib/utils/TypesettingUtils.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypesettingUtils = void 0;
const THREE = __webpack_require__(/*! three */ "three");
const TextStyle_1 = __webpack_require__(/*! ../rendering/TextStyle */ "../harp-text-canvas/lib/rendering/TextStyle.ts");
const UnicodeUtils_1 = __webpack_require__(/*! ../utils/UnicodeUtils */ "../harp-text-canvas/lib/utils/UnicodeUtils.ts");
/**
 * Collection of different constants and utility functions used by [[Typesetter]]s.
 */
var TypesettingUtils;
(function (TypesettingUtils) {
    /**
     * Ratio between EMs and Pixels.
     */
    TypesettingUtils.EM_TO_PX = 16.0;
    /**
     * Ratio between Points and Pixels.
     */
    TypesettingUtils.PT_TO_PX = 1.25;
    /**
     * Angle used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_ANGLE = 0.174533;
    /**
     * Horizontal offset used when emulating italic fonts (oblique).
     */
    TypesettingUtils.OBLIQUE_OFFSET = Math.tan(TypesettingUtils.OBLIQUE_ANGLE);
    /**
     * Convert between any size specified in any [[FontUnit]] to pixels.
     *
     * @param size - Font size (specified in `unit`).
     * @param unit - Size unit.
     * @param originalSize - Original size (pixels)
     *
     * @returns Pixel size.
     */
    function getPixelSize(size, unit, originalSize) {
        let result = size;
        switch (unit) {
            case TextStyle_1.FontUnit.Em:
                result *= TypesettingUtils.EM_TO_PX;
                break;
            case TextStyle_1.FontUnit.Point:
                result *= TypesettingUtils.PT_TO_PX;
                break;
            case TextStyle_1.FontUnit.Percent:
                result *= (1.0 / 100) * originalSize;
                break;
        }
        return result;
    }
    TypesettingUtils.getPixelSize = getPixelSize;
    /**
     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.
     *
     * @param glyphs - Array containing [[TransformedGlyphData]].
     * @param index - Index to `glyphDataArray`.
     * @param fontVariant - Currently active [[FontVariant]].
     *
     * @returns Glyph `SmallCaps` scale.
     */
    function getSmallCapsScale(glyphs, smallCapsTransformations, index, fontVariant) {
        const isSmallCaps = smallCapsTransformations[index] && fontVariant === TextStyle_1.FontVariant.SmallCaps;
        return isSmallCaps
            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight
            : 1.0;
    }
    TypesettingUtils.getSmallCapsScale = getSmallCapsScale;
    /**
     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].
     *
     * @param glyphs - Array containing [[GlyphData]].
     * @param offset - `glyphDataArray` offset.
     *
     * @returns Strong direction.
     */
    function getDirection(glyphs, offset) {
        let result = UnicodeUtils_1.UnicodeUtils.Direction.LTR;
        let index = offset;
        while (glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.LTR &&
            glyphs[index].direction !== UnicodeUtils_1.UnicodeUtils.Direction.RTL &&
            index < glyphs.length - 1) {
            ++index;
        }
        if (Math.abs(glyphs[index].direction) === 1.0) {
            result = glyphs[index].direction;
        }
        return result;
    }
    TypesettingUtils.getDirection = getDirection;
    /**
     * Computes the transformation matrix for a glyph.
     *
     * @param transform - Matrix used to store the results.
     * @param position - Glyph' position.
     * @param scale - Glyph' scale.
     * @param rotation - [[TextCanvas]] rotation.
     * @param localRotation - Glyph' local rotation.
     */
    function computeGlyphTransform(transform, position, scale, rotation, localRotation) {
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(rotation);
        const localCosAngle = Math.cos(localRotation);
        const localSinAngle = Math.sin(localRotation);
        transform.set(scale * localCosAngle, scale * -localSinAngle, cosAngle * position.x - sinAngle * position.y, scale * localSinAngle, scale * localCosAngle, sinAngle * position.x + cosAngle * position.y, 0, 0, 1.0);
    }
    TypesettingUtils.computeGlyphTransform = computeGlyphTransform;
    /**
     * Updates the supplied bounds with the computed screen-space corners for a given glyph.
     *
     * @param corners - Glyph' corners.
     * @param globalBounds - Global text bounds.
     * @param individualBounds - Individual per-character bounds.
     */
    function updateBounds(corners, globalBounds, individualBounds) {
        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
        if (individualBounds !== undefined) {
            if (individualBounds.array[individualBounds.offset] !== undefined) {
                individualBounds.array[individualBounds.offset].min.set(minX, minY);
                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);
            }
            else {
                individualBounds.array.push(new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)));
            }
            ++individualBounds.offset;
        }
        globalBounds.min.set(Math.min(globalBounds.min.x, minX), Math.min(globalBounds.min.y, minY));
        globalBounds.max.set(Math.max(globalBounds.max.x, maxX), Math.max(globalBounds.max.y, maxY));
    }
    TypesettingUtils.updateBounds = updateBounds;
})(TypesettingUtils = exports.TypesettingUtils || (exports.TypesettingUtils = {}));


/***/ }),

/***/ "../harp-text-canvas/lib/utils/UnicodeUtils.ts":
/*!*****************************************************!*\
  !*** ../harp-text-canvas/lib/utils/UnicodeUtils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnicodeUtils = void 0;
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [
        [0x000a, 0x000d],
        [0x0085, 0x0085],
        [0x2028, 0x2029]
    ];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [
        [0x0000, 0x001f],
        [0x007f, 0x009f]
    ];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [
        [0x0030, 0x0039],
        [0x0660, 0x0669],
        [0x06f0, 0x06f9]
    ];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint - Character's Unicode code point.
     * @param block - Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));


/***/ }),

/***/ "../harp-transfer-manager/index.ts":
/*!*****************************************!*\
  !*** ../harp-transfer-manager/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Provides a manager that orchestrates downloading URLs, particularly static map resources.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./src/TransferManager */ "../harp-transfer-manager/src/TransferManager.ts"), exports);


/***/ }),

/***/ "../harp-transfer-manager/src/DeferredPromise.ts":
/*!*******************************************************!*\
  !*** ../harp-transfer-manager/src/DeferredPromise.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeferredPromise = void 0;
/**
 *
 * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.
 * This class allows wrapping other promises or long running functions for later execution.
 * @internal
 * @hidden
 */
class DeferredPromise {
    /**
     * Constructs a new [[DeferredPromise]]
     * @param executor - Async function that should be executed at a later point in time.
     */
    constructor(executor) {
        this.executor = executor;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFunc = resolve;
            this.rejectFunc = reject;
        });
    }
    /**
     * When `exec` is called the deferred executor function is executed.
     */
    exec() {
        this.executor()
            .then(result => this.resolveFunc(result))
            .catch(error => this.rejectFunc(error));
    }
}
exports.DeferredPromise = DeferredPromise;


/***/ }),

/***/ "../harp-transfer-manager/src/TransferManager.ts":
/*!*******************************************************!*\
  !*** ../harp-transfer-manager/src/TransferManager.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransferManager = void 0;
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const DeferredPromise_1 = __webpack_require__(/*! ./DeferredPromise */ "../harp-transfer-manager/src/DeferredPromise.ts");
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
class TransferManager {
    /**
     * Constructs a new [[TransferManager]].
     *
     * @param fetchFunction - The default fetch function to use.
     * @param maxRetries - The maximum amount to try to re-fetch a resource.
     */
    constructor(fetchFunction = fetch, maxRetries = 5) {
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        this.activeDownloadCount = 0;
        this.downloadQueue = new Array();
        this.activeDownloads = new Map();
    }
    /**
     * Returns a default instance of [[TransferManager]].
     */
    static instance() {
        return TransferManager.defaultInstance;
    }
    static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
        try {
            if (retryCount < maxRetries) {
                const response = await fetchFunction(url, init);
                // Return response when successful or empty
                if (response.status === 200 || response.status === 204) {
                    return response;
                }
                else if (response.status >= 400 && response.status < 500) {
                    // Prevent further retries in case of a client error code
                    retryCount = maxRetries;
                    const responseText = await response.text();
                    throw new Error(responseText);
                }
            }
            else {
                throw new Error("Max number of retries reached");
            }
        }
        catch (err) {
            if (err.hasOwnProperty("isCancelled") ||
                err.name === "AbortError" ||
                retryCount >= maxRetries) {
                throw err;
            }
        }
        return await TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init));
    }
    static waitFor(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    /**
     * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same string URL to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url - The URL or RequestInfo to download
     * @param init - Optional extra parameters for the download.
     */
    downloadJson(url, init) {
        return this.downloadAs(response => response.json(), url, init);
    }
    /**
     * Downloads a binary object. Merges downloads of string URLS if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same string URL to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url - The URL or RequestInfo to download
     * @param init - Optional extra parameters for the download
     */
    downloadArrayBuffer(url, init) {
        return this.download(url, init).then(response => response.arrayBuffer());
    }
    /**
     * Downloads a URL and returns the response.
     *
     * Does not merge multiple requests to the same URL.
     *
     * @param url - The URL or RequestInfo to download.
     * @param init - Optional extra parameters for the download.
     */
    download(url, init) {
        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
            const deferred = new DeferredPromise_1.DeferredPromise(() => this.doDownload(url, init));
            this.downloadQueue.push(deferred);
            return deferred.promise;
        }
        return this.doDownload(url, init);
    }
    async doDownload(url, init) {
        try {
            ++this.activeDownloadCount;
            const response = await TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);
            this.onDownloadDone();
            return response;
        }
        catch (error) {
            this.onDownloadDone();
            throw error;
        }
    }
    onDownloadDone() {
        --this.activeDownloadCount;
        this.execDeferredDownload();
    }
    execDeferredDownload() {
        const future = this.downloadQueue.pop();
        if (future === undefined) {
            return;
        }
        future.exec();
    }
    downloadAs(converter, url, init) {
        const cacheKey = url;
        const pendingFetch = this.activeDownloads.get(cacheKey);
        if (pendingFetch !== undefined) {
            return Promise.resolve(pendingFetch);
        }
        const newFetch = this.download(url, init)
            .then(response => {
            this.activeDownloads.delete(cacheKey);
            if (response.ok) {
                return converter(response);
            }
            throw new Error(JSON.stringify(response));
        })
            .catch(err => {
            this.activeDownloads.delete(cacheKey);
            throw err;
        });
        this.activeDownloads.set(cacheKey, newFetch);
        return newFetch;
    }
}
exports.TransferManager = TransferManager;
/**
 * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
 * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
 * so on.
 */
TransferManager.retryTimeout = 500;
/**
 * The amount of maximum parallel downloads to allow.
 */
TransferManager.maxParallelDownloads = 16;
TransferManager.defaultInstance = new TransferManager();


/***/ }),

/***/ "../harp-utils/index-common.ts":
/*!*************************************!*\
  !*** ../harp-utils/index-common.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./lib/DOMUtils */ "../harp-utils/lib/DOMUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GroupedPriorityList */ "../harp-utils/lib/GroupedPriorityList.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Logger */ "../harp-utils/lib/Logger/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Math2D */ "../harp-utils/lib/Math2D.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/MathUtils */ "../harp-utils/lib/MathUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Mixins */ "../harp-utils/lib/Mixins.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/assert */ "../harp-utils/lib/assert.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/CachedResource */ "../harp-utils/lib/CachedResource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ContextLogger */ "../harp-utils/lib/ContextLogger.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/PerformanceTimer */ "../harp-utils/lib/PerformanceTimer.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/ObjectUtils */ "../harp-utils/lib/ObjectUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/OptionsUtils */ "../harp-utils/lib/OptionsUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/TaskQueue */ "../harp-utils/lib/TaskQueue.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/UriResolver */ "../harp-utils/lib/UriResolver.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/UrlUtils */ "../harp-utils/lib/UrlUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/Functions */ "../harp-utils/lib/Functions.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/SampleBilinear */ "../harp-utils/lib/SampleBilinear.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/AuthenticationUtils */ "../harp-utils/lib/AuthenticationUtils.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GlslUtils */ "../harp-utils/lib/GlslUtils.ts"), exports);


/***/ }),

/***/ "../harp-utils/index.ts":
/*!******************************!*\
  !*** ../harp-utils/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Provides utilities: logging and debugging.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./index-common */ "../harp-utils/index-common.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/UrlPlatformUtils */ "../harp-utils/lib/UrlPlatformUtils.ts"), exports);


/***/ }),

/***/ "../harp-utils/lib/AuthenticationUtils.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/AuthenticationUtils.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-utils/lib/CachedResource.ts":
/*!*******************************************!*\
  !*** ../harp-utils/lib/CachedResource.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-utils/lib/ContextLogger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/ContextLogger.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextLogger = void 0;
/**
 * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`
 * before first actual log message.
 */
class ContextLogger {
    /**
     * Construct a context-aware logger that logs to `m_logger`.
     */
    constructor(m_logger, headerMessage) {
        this.m_logger = m_logger;
        this.headerMessage = headerMessage;
        this.context = [];
        this.m_headerLogged = false;
        // They, are public member functions it's just tslint who doesn't understand this.
        this.warn = this.createLogMethod("warn");
        this.info = this.createLogMethod("info");
        this.error = this.createLogMethod("error");
    }
    /**
     * Push "attribute-like" context.
     *
     * Following log messages will be prefixed with `name` or `.name` depending on current context.
     */
    pushAttr(name) {
        this.context.push(`${this.context.length > 0 ? "." : ""}${name}`);
    }
    /**
     * Push "index-like" context.
     *
     * Following log messages will be prefixed with `[index]`.
     */
    pushIndex(index) {
        this.context.push(`[${index}]`);
    }
    pop() {
        this.context.pop();
    }
    createLogMethod(severity) {
        return (message, ...rest) => {
            if (!this.m_headerLogged) {
                this.m_logger.info(this.headerMessage);
                this.m_headerLogged = true;
            }
            this.m_logger[severity](`${this.context.join("")}: ${message}`, ...rest);
        };
    }
}
exports.ContextLogger = ContextLogger;


/***/ }),

/***/ "../harp-utils/lib/DOMUtils.ts":
/*!*************************************!*\
  !*** ../harp-utils/lib/DOMUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DOMUtils = void 0;
var DOMUtils;
(function (DOMUtils) {
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages() {
        if (navigator.languages !== undefined && navigator.languages.length > 0) {
            const languageList = [];
            for (const lang of navigator.languages) {
                languageList.push(getIsoLanguageCode(lang));
            }
            return languageList;
        }
        if (navigator.language !== undefined) {
            return [getIsoLanguageCode(navigator.language)];
        }
        return undefined;
    }
    DOMUtils.getBrowserLanguages = getBrowserLanguages;
    /**
     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)
     */
    function getIsoLanguageCode(language) {
        return language.substring(0, 2);
    }
})(DOMUtils = exports.DOMUtils || (exports.DOMUtils = {}));


/***/ }),

/***/ "../harp-utils/lib/Functions.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/Functions.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chainCallbacks = void 0;
/**
 * Chains two functions for further assigning as one wrapped callback function
 */
function chainCallbacks(f1, f2) {
    return function (...args) {
        if (f1) {
            f1.apply(this, args);
        }
        return f2.apply(this, args);
    };
}
exports.chainCallbacks = chainCallbacks;


/***/ }),

/***/ "../harp-utils/lib/GlslUtils.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/GlslUtils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertFragmentShaderToWebGL2 = exports.convertVertexShaderToWebGL2 = void 0;
/**
 * Converts webgl1-compatible vertex shader glsl code to webgl2.
 *
 * @param vertexShader - String containing the vertex shader glsl code.
 * @returns the converted glsl code.
 */
function convertVertexShaderToWebGL2(vertexShader) {
    return (["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") +
        "\n" +
        vertexShader);
}
exports.convertVertexShaderToWebGL2 = convertVertexShaderToWebGL2;
/**
 * Converts webgl1-compatible fragment shader glsl code to webgl2.
 *
 * @param fragmentShader - String containing the fragment shader glsl code.
 * @returns the converted glsl code.
 */
function convertFragmentShaderToWebGL2(fragmentShader) {
    return ([
        "#define varying in",
        "out highp vec4 pc_fragColor;",
        "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
    ].join("\n") +
        "\n" +
        fragmentShader);
}
exports.convertFragmentShaderToWebGL2 = convertFragmentShaderToWebGL2;


/***/ }),

/***/ "../harp-utils/lib/GroupedPriorityList.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/GroupedPriorityList.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupedPriorityList = exports.PriorityListGroup = void 0;
/**
 * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same
 * (integer) priority.
 */
class PriorityListGroup {
    constructor(priority, elements = new Array()) {
        this.priority = priority;
        this.elements = elements;
    }
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone() {
        return new PriorityListGroup(this.priority, this.elements.slice());
    }
    /**
     * Removes an element from the group.
     * @param element - The element to remove.
     * @returns true if the element was removed, false if it was not found in the group.
     */
    remove(element) {
        const foundIndex = this.elements.indexOf(element);
        if (foundIndex === -1) {
            return false;
        }
        this.elements.splice(foundIndex, 1);
        return true;
    }
}
exports.PriorityListGroup = PriorityListGroup;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
class GroupedPriorityList {
    constructor() {
        this.groups = new Map();
    }
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element - Element to be added.
     */
    add(element) {
        this.getGroup(element.priority).elements.push(element);
    }
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element - Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element) {
        const group = this.findGroup(element.priority);
        if (group !== undefined && group.remove(element)) {
            if (group.elements.length === 0) {
                this.groups.delete(group.priority);
            }
            return true;
        }
        return false;
    }
    /**
     * Remove all internal {@link PriorityListGroup}s.
     */
    clear() {
        this.groups.clear();
    }
    /**
     * Merge another {@link GroupedPriorityList} into this one.
     *
     * @param other - Other group to merge.
     */
    merge(other) {
        for (const otherGroup of other.groups) {
            const group = this.findGroup(otherGroup[1].priority);
            if (group === undefined) {
                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());
                continue;
            }
            group.elements = group.elements.concat(otherGroup[1].elements);
        }
        return this;
    }
    clone() {
        const clone = new GroupedPriorityList();
        for (const [priority, group] of this.groups) {
            clone.groups.set(priority, group.clone());
        }
        return clone;
    }
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun) {
        for (const group of this.groups) {
            group[1].elements.forEach(fun);
        }
    }
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count() {
        let n = 0;
        for (const group of this.groups) {
            n += group[1].elements.length;
        }
        return n;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    findGroup(priority) {
        const normalizedPriority = Math.floor(priority);
        const group = this.groups.get(normalizedPriority);
        return group;
    }
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    getGroup(priority) {
        let group = this.findGroup(priority);
        if (group === undefined) {
            const normalizedPriority = Math.floor(priority);
            group = new PriorityListGroup(normalizedPriority);
            this.groups.set(group.priority, group);
        }
        return group;
    }
}
exports.GroupedPriorityList = GroupedPriorityList;


/***/ }),

/***/ "../harp-utils/lib/Logger/ConsoleChannel.ts":
/*!**************************************************!*\
  !*** ../harp-utils/lib/Logger/ConsoleChannel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleChannel = void 0;
/**
 * Class for the default console channel.
 */
class ConsoleChannel {
    error(message, ...optionalParams) {
        console.error(message, ...optionalParams);
    }
    debug(message, ...optionalParams) {
        console.debug(message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        console.info(message, ...optionalParams);
    }
    log(message, ...optionalParams) {
        console.log(message, ...optionalParams);
    }
    trace(message, ...optionalParams) {
        console.trace(message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        console.warn(message, ...optionalParams);
    }
}
exports.ConsoleChannel = ConsoleChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/IChannel.ts":
/*!********************************************!*\
  !*** ../harp-utils/lib/Logger/IChannel.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../harp-utils/lib/Logger/ILogger.ts":
/*!*******************************************!*\
  !*** ../harp-utils/lib/Logger/ILogger.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerOptions = exports.LogLevel = void 0;
/**
 * Enum log levels
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Log"] = 2] = "Log";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warn"] = 4] = "Warn";
    LogLevel[LogLevel["Error"] = 5] = "Error";
    LogLevel[LogLevel["None"] = 6] = "None";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/**
 * Logger options to configure logger
 */
class LoggerOptions {
}
exports.LoggerOptions = LoggerOptions;


/***/ }),

/***/ "../harp-utils/lib/Logger/Logger.ts":
/*!******************************************!*\
  !*** ../harp-utils/lib/Logger/Logger.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
/**
 * Logger class.
 */
class Logger {
    constructor(name, m_channel, options) {
        this.name = name;
        this.m_channel = m_channel;
        this.enabled = true;
        this.level = ILogger_1.LogLevel.Trace;
        if (options !== undefined) {
            this.update(options);
        }
    }
    error(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Error) {
            this.m_channel.error(this.prefix, message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Debug) {
            this.m_channel.debug(this.prefix, message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Info) {
            this.m_channel.info(this.prefix, message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Log) {
            this.m_channel.log(this.prefix, message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Trace) {
            this.m_channel.trace(this.prefix, message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.enabled && this.level <= ILogger_1.LogLevel.Warn) {
            this.m_channel.warn(this.prefix, message, ...optionalParams);
        }
    }
    update(options) {
        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;
        this.level = options.level === undefined ? this.level : options.level;
    }
    get prefix() {
        return this.name + ":";
    }
}
exports.Logger = Logger;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManager.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManager.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerManager = void 0;
const LoggerManagerImpl_1 = __webpack_require__(/*! ./LoggerManagerImpl */ "../harp-utils/lib/Logger/LoggerManagerImpl.ts");
/**
 * The LoggerManager class implements a singleton object that handles logging.
 *
 * Example:
 *
 * ```typescript
 *
 * const logger = LoggerManager.instance.create("MyFontLoaderClass");
 * if (missingFonts.length > 0) {
 *     logger.error("These fonts can not be loaded: ", missingFonts);
 * } else {
 *     logger.log("All fonts have been loaded.");
 * }
 * ```
 */
class LoggerManager {
    static get instance() {
        return this.m_instance || (this.m_instance = new LoggerManagerImpl_1.LoggerManagerImpl());
    }
}
exports.LoggerManager = LoggerManager;


/***/ }),

/***/ "../harp-utils/lib/Logger/LoggerManagerImpl.ts":
/*!*****************************************************!*\
  !*** ../harp-utils/lib/Logger/LoggerManagerImpl.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerManagerImpl = void 0;
const ConsoleChannel_1 = __webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts");
const Logger_1 = __webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts");
const WorkerChannel_1 = __webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts");
/**
 * LoggerManagerImpl is the class for the singleton instance of the logger manager.
 * It handles channels and loggers.
 */
class LoggerManagerImpl {
    constructor() {
        this.m_loggers = [];
        this.channel =
            typeof self === "undefined" || typeof self.document !== "undefined"
                ? new ConsoleChannel_1.ConsoleChannel()
                : new WorkerChannel_1.WorkerChannel();
    }
    getLoggerNames() {
        return this.m_loggers.map(logger => logger.name);
    }
    getLogger(name) {
        return this.m_loggers.find(logger => logger.name === name);
    }
    create(loggerName, options = {}) {
        if (this.m_levelSetForAll !== undefined &&
            (options.level === undefined || options.level < this.m_levelSetForAll)) {
            options.level = this.m_levelSetForAll;
        }
        const logger = new Logger_1.Logger(loggerName, this.channel, options);
        this.m_loggers.push(logger);
        return logger;
    }
    dispose(logger) {
        const found = this.m_loggers.indexOf(logger);
        if (found < 0) {
            throw new Error(`Cannot unregister "${logger}" : no such logger registered.`);
        }
        this.m_loggers.splice(found, 1);
    }
    updateAll(options) {
        for (const logger of this.m_loggers) {
            logger.update(options);
        }
    }
    update(loggerName, config) {
        for (const logger of this.m_loggers) {
            if (logger.name === loggerName) {
                logger.update(config);
            }
        }
    }
    enableAll(enabled) {
        for (const logger of this.m_loggers) {
            logger.enabled = enabled;
        }
    }
    enable(loggerName, value) {
        this.update(loggerName, { enabled: value });
    }
    setLogLevelForAll(level) {
        this.m_levelSetForAll = level;
        for (const logger of this.m_loggers) {
            logger.level = level;
        }
    }
    setLogLevel(loggerName, level) {
        this.update(loggerName, { level });
    }
    setChannel(channel) {
        this.channel = channel;
    }
}
exports.LoggerManagerImpl = LoggerManagerImpl;


/***/ }),

/***/ "../harp-utils/lib/Logger/MultiChannel.ts":
/*!************************************************!*\
  !*** ../harp-utils/lib/Logger/MultiChannel.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultiChannel = void 0;
/**
 * Class allowing mixing several channels.
 */
class MultiChannel {
    constructor(...channels) {
        this.channels = [];
        this.channels = channels;
    }
    error(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        for (const channel of this.channels) {
            channel.warn(message, ...optionalParams);
        }
    }
}
exports.MultiChannel = MultiChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/WorkerChannel.ts":
/*!*************************************************!*\
  !*** ../harp-utils/lib/Logger/WorkerChannel.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerChannel = exports.WORKERCHANNEL_MSG_TYPE = void 0;
const ILogger_1 = __webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts");
exports.WORKERCHANNEL_MSG_TYPE = "worker-channel-message";
/**
 * The class for the worker channel.
 */
class WorkerChannel {
    error(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Error
        };
        self.postMessage(workerMessage);
    }
    debug(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Debug
        };
        self.postMessage(workerMessage);
    }
    info(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Info
        };
        self.postMessage(workerMessage);
    }
    log(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Log
        };
        self.postMessage(workerMessage);
    }
    trace(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Trace
        };
        self.postMessage(workerMessage);
    }
    warn(message, ...optionalParams) {
        const workerMessage = {
            message: [message, ...optionalParams],
            type: exports.WORKERCHANNEL_MSG_TYPE,
            level: ILogger_1.LogLevel.Warn
        };
        self.postMessage(workerMessage);
    }
}
exports.WorkerChannel = WorkerChannel;


/***/ }),

/***/ "../harp-utils/lib/Logger/index.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/Logger/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./ConsoleChannel */ "../harp-utils/lib/Logger/ConsoleChannel.ts"), exports);
__exportStar(__webpack_require__(/*! ./IChannel */ "../harp-utils/lib/Logger/IChannel.ts"), exports);
__exportStar(__webpack_require__(/*! ./ILogger */ "../harp-utils/lib/Logger/ILogger.ts"), exports);
__exportStar(__webpack_require__(/*! ./Logger */ "../harp-utils/lib/Logger/Logger.ts"), exports);
__exportStar(__webpack_require__(/*! ./LoggerManager */ "../harp-utils/lib/Logger/LoggerManager.ts"), exports);
__exportStar(__webpack_require__(/*! ./MultiChannel */ "../harp-utils/lib/Logger/MultiChannel.ts"), exports);
__exportStar(__webpack_require__(/*! ./WorkerChannel */ "../harp-utils/lib/Logger/WorkerChannel.ts"), exports);


/***/ }),

/***/ "../harp-utils/lib/Math2D.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Math2D.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Math2D = void 0;
var Math2D;
(function (Math2D) {
    /**
     * Alternative 2D box object with less memory impact (four numbers instead of two min/max
     * objects with two numbers each). Should be faster.
     */
    class Box {
        /**
         * Alternative 2D box object with less memory impact (four numbers instead of two min/max
         * objects with two numbers each). Should be faster.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        constructor(x = 0, y = 0, w = 0, h = 0) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Set new values to all properties of the box.
         *
         * @param x - New X value.
         * @param y - New y value.
         * @param w - New w value.
         * @param h - New h value.
         */
        set(x, y, w, h) {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        /**
         * Copy values from another box.
         *
         * @param box - Another box.
         */
        copy(box) {
            this.x = box.x;
            this.y = box.y;
            this.w = box.w;
            this.h = box.h;
        }
        /**
         * Test box for inclusion of point.
         *
         * @param x - X coordinate of point.
         * @param y - Y coordinate of point.
         */
        contains(x, y) {
            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;
        }
        /**
         * Test box for inclusion of another box.
         *
         * @param other - Box 2 to test for inclusion.
         */
        containsBox(other) {
            const xmax = other.x + other.w;
            const ymax = other.y + other.h;
            return (this.contains(other.x, other.y) &&
                this.contains(xmax, other.y) &&
                this.contains(other.x, ymax) &&
                this.contains(xmax, ymax));
        }
        /**
         * Test two boxes for intersection.
         *
         * @param other - Box 2 to test for intersection.
         */
        intersects(other) {
            return (this.x <= other.x + other.w &&
                this.x + this.w >= other.x &&
                this.y <= other.y + other.h &&
                this.y + this.h >= other.y);
        }
    }
    Math2D.Box = Box;
    /**
     * Compute squared distance between two 2D points `a` and `b`.
     *
     * @param ax - Point a.x
     * @param ay - Point a.y
     * @param bx - Point b.x
     * @param by - Point b.y
     * @returns Squared distance between the two points
     */
    function distSquared(ax, ay, bx, by) {
        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);
    }
    Math2D.distSquared = distSquared;
    /**
     * Computes the squared length of a line.
     *
     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.
     */
    function computeSquaredLineLength(line) {
        let squaredLineLength = 0;
        const length = line.length - 4;
        for (let i = 0; i < length; i += 3) {
            const xDiff = line[i + 3] - line[i];
            const yDiff = line[i + 4] - line[i + 1];
            squaredLineLength += xDiff * xDiff + yDiff * yDiff;
        }
        return squaredLineLength;
    }
    Math2D.computeSquaredLineLength = computeSquaredLineLength;
    /**
     * Compute squared distance between a 2D point and a 2D line segment.
     *
     * @param px - Test point X
     * @param py - Test point y
     * @param l0x - Line segment start X
     * @param l0y - Line segment start Y
     * @param l1x - Line segment end X
     * @param l1y - Line segment end Y
     * @returns Squared distance between point and line segment
     */
    function distToSegmentSquared(px, py, l0x, l0y, l1x, l1y) {
        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);
        if (lineLengthSuared === 0) {
            return distSquared(px, py, l0x, l0y);
        }
        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;
        t = Math.max(0, Math.min(1, t));
        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));
    }
    Math2D.distToSegmentSquared = distToSegmentSquared;
    /**
     * Finds the intersections of a line and a circle.
     *
     * @param xLine1 - abscissa of first line point.
     * @param yLine1 - ordinate of second line point.
     * @param xLine2 - abscissa of second line point.
     * @param yLine2 - ordinate of second line point.
     * @param radius - circle radius.
     * @param xCenter - abscissa of circle center.
     * @param yCenter - ordinate of circle center.
     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2
     * if it's secant) or undefined if there's no intersection.
     */
    function intersectLineAndCircle(xLine1, yLine1, xLine2, yLine2, radius, xCenter = 0, yCenter = 0) {
        // Line equation: dy*x - dx*y = c, c = dy*x1 - dx*y1 = x1*y2 - x2*y1
        // Circle equation: (x-xCenter)^2 + (y-yCenter)^2 = r^2
        // 1. Translate circle center to origin of coordinates:
        // u = x - xCenter
        // v = y - yCenter
        // circle: u^2 + v^2 = r^2
        // line: dy*u - dx*v = cp, cp = c - dy*xCenter - dx*yCenter
        // 2. Intersections are solutions of a quadratic equation:
        // ui = (cp*dy +/- sign(dy)*dx*discriminant / dSq
        // vi = (-cp*dx +/- |dy|*discriminant / dSq
        // discriminant = r^2*dSq - cp^2, dSq = dx^2 + dy^2
        // The sign of the discriminant indicates the number of intersections.
        // 3. Translate intersection coordinates back to original space:
        // xi = xCenter + ui
        // yi = yCenter + yi
        const epsilon = 1e-10;
        const dx = xLine2 - xLine1;
        const dy = yLine2 - yLine1;
        const dSq = dx * dx + dy * dy;
        const rSq = radius * radius;
        const c = xLine1 * yLine2 - xLine2 * yLine1;
        const cp = c - dy * xCenter + dx * yCenter;
        const discriminantSquared = rSq * dSq - cp * cp;
        if (discriminantSquared < -epsilon) {
            // no intersection
            return undefined;
        }
        const xMid = cp * dy;
        const yMid = -cp * dx;
        if (discriminantSquared < epsilon) {
            // 1 intersection (tangent line)
            return { x1: xCenter + xMid / dSq, y1: yCenter + yMid / dSq };
        }
        const discriminant = Math.sqrt(discriminantSquared);
        // 2 intersections (secant line)
        const signDy = dy < 0 ? -1 : 1;
        const absDy = Math.abs(dy);
        const xDist = signDy * dx * discriminant;
        const yDist = absDy * discriminant;
        return {
            x1: xCenter + (xMid + xDist) / dSq,
            y1: yCenter + (yMid + yDist) / dSq,
            x2: xCenter + (xMid - xDist) / dSq,
            y2: yCenter + (yMid - yDist) / dSq
        };
    }
    Math2D.intersectLineAndCircle = intersectLineAndCircle;
    /**
     * Computes the intersection point between two lines.
     *
     * @remarks
     * This functions computes the
     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
     *    | line-line intersection} of two lines given two points on each line.
     *
     * @param x1 - x coordinate of the first point of the first line.
     * @param y1 - y coordinate of the first point of the first line.
     * @param x2 - x coordinate of the second point of the first line.
     * @param y2 - y coordinate of the second point of the first line.
     * @param x3 - x coordinate of the first point of the second line.
     * @param y3 - y coordinate of the first point of the second line.
     * @param x4 - x coordinate of the second point of the second line.
     * @param y4 - y coordinate of the second point of the second line.
     * @param result - The resulting point.
     */
    function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4, result = { x: 0, y: 0 }) {
        const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (d === 0) {
            return undefined;
        }
        const px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
        const py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
        result.x = px;
        result.y = py;
        return result;
    }
    Math2D.intersectLines = intersectLines;
})(Math2D = exports.Math2D || (exports.Math2D = {}));


/***/ }),

/***/ "../harp-utils/lib/MathUtils.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/MathUtils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathUtils = void 0;
var MathUtils;
(function (MathUtils) {
    /**
     * Ensures that input value fits in a given range.
     *
     * @param value - The value to be clamped.
     * @param min - Minimum value.
     * @param max - Maximum value.
     *
     * @returns Clamped value.
     */
    function clamp(value, min, max) {
        return value < min ? min : value > max ? max : value;
    }
    MathUtils.clamp = clamp;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    function smoothStep(edge0, edge1, x) {
        // Scale, bias and saturate x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * (3 - 2 * x);
    }
    MathUtils.smoothStep = smoothStep;
    /**
     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation
     * factor x. `0 <= x <= 1`.
     *
     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and
     * `x = 1`:
     *
     * @see https://en.wikipedia.org/wiki/Smoothstep
     *
     * @param edge0 -
     * @param edge1 -
     * @param x -
     */
    function smootherStep(edge0, edge1, x) {
        // Scale, and clamp x to 0..1 range
        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
        // Evaluate polynomial
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    MathUtils.smootherStep = smootherStep;
    /**
     * Maps a number from one range to another.
     *
     * @param val - The incoming value to be converted.
     * @param inMin - Lower bound of the value's current range.
     * @param inMax - Upper bound of the value's current range.
     * @param outMin - Lower bound of the value's target range.
     * @param outMax - Upper bound of the value's target range.
     */
    function map(val, inMin, inMax, outMin, outMax) {
        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    }
    MathUtils.map = map;
    /**
     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    function min2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.min(result, b);
        }
        return result;
    }
    MathUtils.min2 = min2;
    /**
     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case
     * the result is undefined. If only one of the numbers is undefined, the other number is
     * returned.
     *
     * @param a - First number.
     * @param b - Second number.
     */
    function max2(a, b) {
        let result;
        if (a !== undefined) {
            result = a;
        }
        if (b !== undefined) {
            result = result === undefined ? b : Math.max(result, b);
        }
        return result;
    }
    MathUtils.max2 = max2;
    /**
     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be
     * undefined, in which case their value is ignored.
     *
     * @param value - Value to check.
     * @param lowerBound - The lower bound to check the value against.
     * @param upperBound - The upper bound to check the value against.
     *
     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`
     *          otherwise.
     */
    function isClamped(value, lowerBound, upperBound) {
        if (lowerBound !== undefined && value < lowerBound) {
            return false;
        }
        if (upperBound !== undefined && value > upperBound) {
            return false;
        }
        return true;
    }
    MathUtils.isClamped = isClamped;
    /**
     * Smoothly interpolates between two values using cubic formula
     *
     * @param startValue -
     * @param endValue -
     * @param time -
     * @returns Result of the interpolation within the range of `[startValue, endValue]`
     */
    function easeInOutCubic(startValue, endValue, time) {
        const timeValue = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        return startValue + (endValue - startValue) * timeValue;
    }
    MathUtils.easeInOutCubic = easeInOutCubic;
})(MathUtils = exports.MathUtils || (exports.MathUtils = {}));


/***/ }),

/***/ "../harp-utils/lib/Mixins.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/Mixins.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyMixinsWithoutProperties = exports.applyMixins = void 0;
/**
 * Copy methods and properties from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods and properties into.
 * @param baseCtors - Class to take all methods and properties from.
 */
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        });
    });
}
exports.applyMixins = applyMixins;
/**
 * Copy methods from one prototype into another.
 *
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 *
 * @param derivedCtor - Class to mix methods into.
 * @param baseCtors - Class to take all methods from.
 */
function applyMixinsWithoutProperties(derivedCtor, baseCtors) {
    baseCtors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (descriptor !== undefined &&
                descriptor.get === undefined &&
                name !== "constructor") {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            }
        });
    });
}
exports.applyMixinsWithoutProperties = applyMixinsWithoutProperties;


/***/ }),

/***/ "../harp-utils/lib/ObjectUtils.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/ObjectUtils.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pick = exports.cloneDeep = void 0;
/**
 * Deep clone of object.
 *
 * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,
 * object), `Date` and `RegExp`s and cycles.
 *
 * Throws error if enounters object with `prototype` assuming that in general class instances
 * cannot be reliably cloned by generic algorithm.
 */
function cloneDeep(obj) {
    const cache = new Map();
    function cloneInternal(src) {
        if (src === null) {
            return null;
        }
        else if (typeof src === "object") {
            const cached = cache.get(src);
            if (cached !== undefined) {
                return cached;
            }
            if (Array.isArray(src)) {
                const result = [];
                cache.set(src, result);
                result.length = src.length;
                for (let i = 0; i < result.length; ++i) {
                    result[i] = cloneInternal(src[i]);
                }
                return result;
            }
            else if (src instanceof Date) {
                const result = new Date(src.getTime());
                cache.set(src, result);
                return result;
            }
            else if (src instanceof RegExp) {
                const result = new RegExp(src.source, src.flags);
                cache.set(src, result);
                return result;
            }
            else if (src.constructor !== Object) {
                throw new Error("cloneDeep doesn't support objects with custom prototypes");
            }
            else {
                const result = {};
                cache.set(src, result);
                for (const key in src) {
                    if (src.hasOwnProperty(key)) {
                        result[key] = cloneInternal(src[key]);
                    }
                }
                return result;
            }
        }
        else {
            // string, number, boolean, undefined and functions are returned as is
            return src;
        }
    }
    const r = cloneInternal(obj);
    cache.clear();
    return r;
}
exports.cloneDeep = cloneDeep;
/**
 * Pick `props` from `object.
 *
 * Runtime version of `Pick<T,K>`.
 */
function pick(object, props) {
    const result = {};
    for (const propName of props) {
        if (object.hasOwnProperty(propName)) {
            result[propName] = object[propName];
        }
    }
    return result;
}
exports.pick = pick;


/***/ }),

/***/ "../harp-utils/lib/OptionsUtils.ts":
/*!*****************************************!*\
  !*** ../harp-utils/lib/OptionsUtils.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOptionValue = void 0;
function getOptionValue(...values) {
    for (const candidate of values) {
        if (candidate !== undefined && candidate !== null) {
            return candidate;
        }
    }
    return undefined;
}
exports.getOptionValue = getOptionValue;


/***/ }),

/***/ "../harp-utils/lib/PerformanceTimer.ts":
/*!*********************************************!*\
  !*** ../harp-utils/lib/PerformanceTimer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformanceTimer = void 0;
/**
 * See:
 * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now
 */
class PerformanceTimer {
    /**
     * Returns timestamp in milliseconds since page load.
     *
     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,
     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two
     * samples.
     *
     * Example:
     * ```typescript
     * const now = PerformanceTimer.now();
     * // call some expensive function for which you want to check the duration.
     * const end = PerformanceTimer.now();
     * const elapsedTime = end - now;
     * ```
     */
    static now() {
        return PerformanceTimer.nowFunc();
    }
    static getNowFunc() {
        if (typeof performance !== "undefined" && typeof performance.now !== "undefined") {
            return () => performance.now();
        }
        // fall back to Date.getTime()
        return () => {
            return new Date().getTime();
        };
    }
}
exports.PerformanceTimer = PerformanceTimer;
PerformanceTimer.instance = new PerformanceTimer();
PerformanceTimer.nowFunc = PerformanceTimer.getNowFunc();


/***/ }),

/***/ "../harp-utils/lib/SampleBilinear.ts":
/*!*******************************************!*\
  !*** ../harp-utils/lib/SampleBilinear.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sampleBilinear = void 0;
/**
 * Returns a bilinear-interpolated texture sample for a given texture.
 * @param texture - Two-dimensional texture to sample.
 * @param width - Texture width.
 * @param height - Texture height.
 * @param u - Number between 0 and 1 representing the location to sample in the width dimension.
 * @param v - Number between 0 and 1 representing the location to sample in the height dimension.
 */
function sampleBilinear(texture, width, height, u, v) {
    const maxXIndex = width - 1;
    const maxYIndex = height - 1;
    // Compute the x and y coordinates relative to the mesh size.
    const xIndex = u * maxXIndex;
    const xIndexFloor = Math.floor(xIndex);
    const yIndex = v * maxYIndex;
    const yIndexFloor = Math.floor(yIndex);
    const swIndex = yIndexFloor * width + xIndexFloor;
    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;
    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;
    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;
    const swElevation = texture[swIndex];
    const seElevation = texture[seIndex];
    const nwElevation = texture[nwIndex];
    const neElevation = texture[neIndex];
    // Get the fractional components to do bilinear interpolation.
    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;
    const xFracInverse = 1 - xFrac;
    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;
    const yFracInverse = 1 - yFrac;
    // The interpolation is the sum of the four closest neighbours each
    // multiplied by the diagonal areas.
    const result = swElevation * xFracInverse * yFracInverse +
        seElevation * xFrac * yFracInverse +
        nwElevation * xFracInverse * yFrac +
        neElevation * xFrac * yFrac;
    return result;
}
exports.sampleBilinear = sampleBilinear;


/***/ }),

/***/ "../harp-utils/lib/TaskQueue.ts":
/*!**************************************!*\
  !*** ../harp-utils/lib/TaskQueue.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskQueue = void 0;
/**
 * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.
 *
 * @remarks
 *
 * @example
 * Sample Usage
 * ```
 *  const taskQueue = new TaskQueue({
 *      group: ["group1"]
 *  })
 *  taskQueue.add({
 *     group: "group1",
 *     execute: () => {
 *         console.log("task of group1 executed");
 *     },
 *     getPrio: () => {
 *         return 0;
 *     }
 *   });
 *
 * taskQueue.update();
 * taskQueue.processNext("group1");
 *
 *  ```
 */
class TaskQueue {
    constructor(m_options) {
        var _a;
        this.m_options = m_options;
        this.m_taskLists = new Map();
        (_a = this.m_options.groups) === null || _a === void 0 ? void 0 : _a.forEach(group => {
            this.m_taskLists.set(group, []);
        });
        if (this.m_options.prioSortFn) {
            this.sort = this.m_options.prioSortFn;
        }
    }
    /**
     * Updates the lists in the queue depending on their priority functions and removes
     * expired Tasks, based on their isExpired functions result.
     *
     * @param group The Group to update, if not set all groups will be updated.
     */
    update(group) {
        if (group === undefined) {
            this.m_taskLists.forEach(taskList => {
                this.updateTaskList(taskList);
            });
        }
        else {
            const taskList = this.getTaskList(group);
            if (taskList) {
                this.updateTaskList(taskList);
            }
        }
    }
    /**
     * Adds a Task to the Queue
     *
     * @param task
     * @returns true if succesfully added, otherwise false
     */
    add(task) {
        var _a;
        if (this.m_taskLists.has(task.group)) {
            const taskList = this.m_taskLists.get(task.group);
            if (!(taskList === null || taskList === void 0 ? void 0 : taskList.includes(task))) {
                (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.push(task);
                return true;
            }
        }
        return false;
    }
    /**
     * Removes a Task from the Queue
     *
     * @param task
     * @returns true if succesfully removed, otherwise false
     */
    remove(task) {
        var _a, _b;
        if (this.m_taskLists.has(task.group)) {
            const index = (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.indexOf(task);
            if (index !== -1) {
                (_b = this.m_taskLists.get(task.group)) === null || _b === void 0 ? void 0 : _b.splice(index, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the number of remaining tasks.
     *
     * @param group if group is set, it will return only the remaining tasks for this group,
     * otherwise it will return the complete amount of tasks left.
     */
    numItemsLeft(group) {
        var _a, _b;
        let numLeft = 0;
        if (group === undefined) {
            this.m_taskLists.forEach(tasklist => {
                numLeft += tasklist.length;
            });
        }
        else {
            numLeft += (_b = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        }
        return numLeft;
    }
    /**
     * Processes the next Tasks for a group
     *
     * @param group The group the Tasks are pulled from.
     * @param shouldProcess A condition that, if set will be executed before the task is processed,
     * if returns true, the task will run
     * @param n The amount of tasks that should be pulled, @defaults to 1
     * @returns false if thte list was empty
     */
    processNext(group, shouldProcess, n = 1) {
        if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {
            return false;
        }
        for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {
            const nextTask = this.pull(group, true);
            if (nextTask !== undefined) {
                //if a condition is set, execute it
                if (!shouldProcess || (shouldProcess === null || shouldProcess === void 0 ? void 0 : shouldProcess(nextTask))) {
                    nextTask.execute();
                }
                else {
                    //as the task was not executed but already pulled, add it back
                    //TODO: dont even pull it if it will not execute, this currently
                    // interferes with the skipping and removal of expired tasks on this.pull
                    this.add(nextTask);
                }
            }
        }
        return true;
    }
    clear() {
        this.m_taskLists.clear();
    }
    pull(group, checkIfExpired = false) {
        var _a, _b;
        const taskList = this.getTaskList(group);
        let nextTask;
        if (taskList) {
            nextTask = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.pop();
            if (checkIfExpired && nextTask && ((_b = nextTask.isExpired) === null || _b === void 0 ? void 0 : _b.call(nextTask))) {
                return this.pull(group, checkIfExpired);
            }
        }
        return nextTask;
    }
    sort(a, b) {
        // the highest number in the beginning as the last in the array with
        // highest priority which equals 0 will start to be processed
        return b.getPriority() - a.getPriority();
    }
    getTaskList(group) {
        return this.m_taskLists.get(group);
    }
    updateTaskList(taskList) {
        var _a;
        for (let i = 0; i < taskList.length; i++) {
            const task = taskList[i];
            if ((_a = task === null || task === void 0 ? void 0 : task.isExpired) === null || _a === void 0 ? void 0 : _a.call(task)) {
                taskList.splice(i, 1);
                i--;
            }
        }
        taskList.sort(this.sort);
    }
}
exports.TaskQueue = TaskQueue;


/***/ }),

/***/ "../harp-utils/lib/UriResolver.ts":
/*!****************************************!*\
  !*** ../harp-utils/lib/UriResolver.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.composeUriResolvers = exports.RelativeUriResolver = exports.PrefixMapUriResolver = void 0;
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "../harp-utils/lib/UrlUtils.ts");
/**
 * Basic, import-map like {@link UriResolver}.
 *
 * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.
 *
 * In definitions, `key` is matched against input uri with following strategy:
 *  - `key` without trailing `/` -> `key` and input `uri` must be identical
 *  - `key` with trailing `/`, -> `key` is treated as "package prefix", so `uri` must start with
 *    `key`
 *
 * Example:
 * ```
 * {
 *     "local://poiMasterList": "/assets/poiMasterList.json"
 *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`
 *     "local://icons/": "/assets/icons/"
 *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to
 *        // `/assets/icons/ANYPATH
 * }
 * ```
 * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).
 */
class PrefixMapUriResolver {
    constructor(definitions) {
        this.definitions = definitions;
    }
    resolveUri(uri) {
        return Object.keys(this.definitions).reduce((r, key) => {
            if (key.endsWith("/") && r.startsWith(key)) {
                const newPrefix = this.definitions[key];
                return newPrefix + r.substr(key.length);
            }
            else if (r === key) {
                return this.definitions[key];
            }
            return r;
        }, uri);
    }
}
exports.PrefixMapUriResolver = PrefixMapUriResolver;
/**
 * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.
 */
class RelativeUriResolver {
    constructor(parentUri) {
        this.parentUri = parentUri;
    }
    resolveUri(uri) {
        return UrlUtils_1.resolveReferenceUri(this.parentUri, uri);
    }
}
exports.RelativeUriResolver = RelativeUriResolver;
/**
 * Compose URI resolvers.
 *
 * Creates new {@link UriResolver} that applies resolvers in orders or arguments.
 *
 * Example:
 *
 *     const themeUrl = ...; // url of parent object
 *     const childUrlResolver = composeUrlResolvers(
 *           new RelativeUriResolver(themeUrl),
 *           defaultUrlResolver
 *     );
 */
function composeUriResolvers(...resolvers) {
    return {
        resolveUri(originalUrl) {
            return resolvers.reduce((url, resolver) => {
                if (resolver !== undefined) {
                    return resolver.resolveUri(url);
                }
                else {
                    return url;
                }
            }, originalUrl);
        }
    };
}
exports.composeUriResolvers = composeUriResolvers;


/***/ }),

/***/ "../harp-utils/lib/UrlPlatformUtils.ts":
/*!*********************************************!*\
  !*** ../harp-utils/lib/UrlPlatformUtils.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAppBaseUrl = void 0;
const UrlUtils_1 = __webpack_require__(/*! ./UrlUtils */ "../harp-utils/lib/UrlUtils.ts");
/**
 * Get base URL for from where relative URLs will be loaded.
 *
 * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL
 * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).
 *
 * * In node, it resolves to `file://${process.cwd()}`.
 */
function getAppBaseUrl() {
    if (typeof window === "undefined") {
        return `file://${process.cwd()}/`;
    }
    return UrlUtils_1.baseUrl(window.location.href);
}
exports.getAppBaseUrl = getAppBaseUrl;


/***/ }),

/***/ "../harp-utils/lib/UrlUtils.ts":
/*!*************************************!*\
  !*** ../harp-utils/lib/UrlUtils.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUrlHostAndProtocol = exports.getUrlOrigin = exports.baseUrl = exports.resolveReferenceUri = void 0;
/**
 * Resolve URI of referenced object w.r.t parent URI.
 *
 * Resolves `childUri` as it would be loaded from location specified by `parentUri`.
 *
 * If `childUri` is absolute, then it is returned unchanged.
 * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.
 *
 * See [[baseUri]] for reference how base URL of `parentUri` is determined.
 *
 * Supports `http:`, `https:`, `file:`, `data:` schemes.
 *
 * Examples:
 *
 *     // normal case, child is sibling
 *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent is "folder", so child is just located in this folder
 *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png
 *
 *     // parent looks like leaf, so last component is stripped
 *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png
 *
 *     // origin-absolute URL, takes only origin from parent
 *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json
 *
 * @param parentUri - URI of parent resource
 * @param childUri - URI of child as referenced from parent resource
 * @return `childUrl` as if anchored in location of `parentUrl`
 */
function resolveReferenceUri(parentUri, childUri) {
    if (absoluteUrlWithOriginRe.test(childUri)) {
        return childUri;
    }
    else if (childUri.startsWith("/")) {
        const origin = getUrlOrigin(parentUri);
        return origin + childUri;
    }
    else {
        if (childUri.startsWith("./")) {
            childUri = childUri.substr(2);
        }
        const parentBaseUrl = baseUrl(parentUri);
        return parentBaseUrl + childUri;
    }
}
exports.resolveReferenceUri = resolveReferenceUri;
const absoluteUrlWithOriginRe = new RegExp("^(((?:[a-z]+:)?//)|(file:/)|(data:))", "i");
/**
 * Returns base URL of given resource URL.
 *
 * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if
 * `url` ends with name component it is treated as "leaf", so last path component is removed.
 *
 * Standalone files (without any folder structure) are considered relative to `./`.
 *
 * Examples:
 * ```
 *     https://foo.com/themes/a.json -> https://foo.com/themes/
 *     https://foo.com/themes/ -> https://foo.com/themes/
 *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf
 *     themes/day.json -> themes/
 *     themes -> ./
 * ```
 */
function baseUrl(url) {
    if (url === undefined) {
        return "./";
    }
    let idx = url.indexOf("#");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.indexOf("?");
    if (idx !== -1) {
        url = url.slice(0, idx);
    }
    idx = url.lastIndexOf("/");
    if (idx === -1) {
        return "./";
    }
    else {
        return url.substring(0, idx + 1);
    }
}
exports.baseUrl = baseUrl;
/**
 * Get `origin` part of URL.
 *
 * @example
 *    https://example.com/foo -> https://example.com
 *    //example.com:8080/ -> //example.com:8080
 *    file:///etc/hosts ->
 *
 * @param url - input URL
 * @return origin of given URL
 */
function getUrlOrigin(url) {
    if (url === undefined) {
        return "";
    }
    const parsed = getUrlHostAndProtocol(url);
    if (parsed.protocol === "file:") {
        return "file://";
    }
    else if (parsed.host && parsed.protocol) {
        return parsed.protocol + "//" + parsed.host;
    }
    else if (parsed.host) {
        return "//" + parsed.host;
    }
    else if (parsed.protocol) {
        return parsed.protocol + "//";
    }
    else {
        return "";
    }
}
exports.getUrlOrigin = getUrlOrigin;
/**
 * Parse `host` and `protocol` part from URL.
 */
function getUrlHostAndProtocol(url) {
    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\/\/([^\/]*)/, "i");
    const match = url.match(urlOriginRe);
    if (!match) {
        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);
    }
    return {
        protocol: match[1],
        host: match[2]
    };
}
exports.getUrlHostAndProtocol = getUrlHostAndProtocol;


/***/ }),

/***/ "../harp-utils/lib/assert.ts":
/*!***********************************!*\
  !*** ../harp-utils/lib/assert.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertExists = exports.assert = void 0;
// cache value, because access to process.env.NODE_ENV is SLOW!
const isProduction = "development" === "production";
//TODO: Make assertHandler configurable
/**
 * Implementation of assert as a development help
 *
 * Note - this is deliberately a global function so that minimizers remove the
 * entire call when building for production.
 *
 * @hidden
 * @param condition - Condition to match, if false, throws an Error(message)
 * @param message - Optional message, defaults to "ASSERTION failed"
 */
function assert(condition, message) {
    if (!isProduction) {
        if (!condition) {
            throw new Error(message !== undefined ? message : "ASSERTION failed");
        }
    }
}
exports.assert = assert;
function assertExists(element, message) {
    if (!isProduction) {
        if (element === undefined || element === null) {
            throw new Error(message !== undefined ? message : "ASSERTION failed: Element is undefined or null");
        }
    }
    return element;
}
exports.assertExists = assertExists;


/***/ }),

/***/ "../harp-vectortile-datasource/index.ts":
/*!**********************************************!*\
  !*** ../harp-vectortile-datasource/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * HERE OMV Data source.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/OmvDataFilter */ "../harp-vectortile-datasource/lib/OmvDataFilter.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/VectorTileDataSource */ "../harp-vectortile-datasource/lib/VectorTileDataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvDecoderDefs */ "../harp-vectortile-datasource/lib/OmvDecoderDefs.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvDebugLabelsTile */ "../harp-vectortile-datasource/lib/OmvDebugLabelsTile.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/OmvRestClient */ "../harp-vectortile-datasource/lib/OmvRestClient.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/GeoJsonDataProvider */ "../harp-vectortile-datasource/lib/GeoJsonDataProvider.ts"), exports);


/***/ }),

/***/ "../harp-vectortile-datasource/lib/GeoJsonDataProvider.ts":
/*!****************************************************************!*\
  !*** ../harp-vectortile-datasource/lib/GeoJsonDataProvider.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeoJsonDataProvider = void 0;
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-vectortile-datasource/lib/OmvDecoderDefs.ts");
const logger = harp_utils_1.LoggerManager.instance.create("GeoJsonDataProvider");
const INVALIDATED = "invalidated";
let missingTilerServiceInfoEmitted = false;
/**
 * GeoJson {@link @here/harp-mapview-decoder@DataProvider}.
 *
 * @remarks
 * Automatically handles tiling and simplification of static GeoJson.
 */
class GeoJsonDataProvider extends harp_mapview_decoder_1.DataProvider {
    /**
     * Constructs a new `GeoJsonDataProvider`.
     *
     * @param name - Name to be used to reference this `DataProvider`
     * @param input - URL of the GeoJSON, or a GeoJSON.
     * @param options - Optional
     * @returns New `GeoJsonDataProvider`.
     */
    constructor(name, input, options) {
        var _a;
        super();
        this.name = name;
        this.input = input;
        this.m_registered = false;
        this.m_tiler = (_a = options === null || options === void 0 ? void 0 : options.tiler) !== null && _a !== void 0 ? _a : harp_mapview_1.ConcurrentTilerFacade.getTiler(OmvDecoderDefs_1.GEOJSON_TILER_SERVICE_TYPE, options === null || options === void 0 ? void 0 : options.workerTilerUrl, options === null || options === void 0 ? void 0 : options.workerConnectionTimeout);
    }
    async connect() {
        try {
            await this.m_tiler.connect();
        }
        catch (error) {
            if (harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingTilerServiceInfoEmitted) {
                logger.info("Unable to start GeoJson tiler service in worker. Use " +
                    " 'OmvTilerService.start();' in decoder script.");
                missingTilerServiceInfoEmitted = true;
            }
            throw error;
        }
        await this.m_tiler.registerIndex(this.name, this.input);
        this.m_registered = true;
    }
    updateInput(input) {
        this.input = input;
        this.m_tiler.updateIndex(this.name, this.input);
        this.dispatchEvent({ type: INVALIDATED });
    }
    ready() {
        return this.m_registered;
    }
    async getTile(tileKey) {
        return await this.m_tiler.getTile(this.name, tileKey);
    }
    onDidInvalidate(listener) {
        this.addEventListener(INVALIDATED, listener);
        return () => this.removeEventListener(INVALIDATED, listener);
    }
    /**
     * Destroys this `GeoJsonDataProvider`.
     */
    dispose() {
        this.m_tiler.dispose();
    }
}
exports.GeoJsonDataProvider = GeoJsonDataProvider;


/***/ }),

/***/ "../harp-vectortile-datasource/lib/OmvDataFilter.ts":
/*!**********************************************************!*\
  !*** ../harp-vectortile-datasource/lib/OmvDataFilter.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmvGenericFeatureModifier = exports.ComposedDataFilter = exports.OmvGenericFeatureFilter = exports.OmvFeatureFilterDescriptionBuilder = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-vectortile-datasource/lib/OmvDecoderDefs.ts");
/**
 * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well
 * as an [[OmvFeatureModifier]].
 *
 */
class OmvFeatureFilterDescriptionBuilder {
    /**
     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as
     * well as an [[OmvFeatureModifier]].
     *
     * @param processLayersDefault - If `true`, all unspecified layers will be processed.
     * If `false`, all unspecified layers will be ignored.
     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If
     * `false`, all unspecified point features will be ignored.
     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If
     * `false`, all unspecified line features will be ignored.
     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be
     * processed. If `false`, all unspecified polygon features will be ignored.
     */
    constructor(options) {
        this.m_processLayersDefault = true;
        this.m_processPointsDefault = true;
        this.m_processLinesDefault = true;
        this.m_processPolygonsDefault = true;
        this.m_layersToProcess = new Array();
        this.m_layersToIgnore = new Array();
        this.m_pointsToProcess = new Array();
        this.m_ignoredPoints = new Array();
        this.m_linesToProcess = new Array();
        this.m_linesToIgnore = new Array();
        this.m_polygonsToProcess = new Array();
        this.m_polygonsToIgnore = new Array();
        this.m_kindsToProcess = [];
        this.m_kindsToIgnore = [];
        if (options) {
            this.m_processLayersDefault =
                options.processLayersDefault !== undefined ? options.processLayersDefault : true;
            this.m_processPointsDefault =
                options.processPointsDefault !== undefined ? options.processPointsDefault : true;
            this.m_processLinesDefault =
                options.processLinesDefault !== undefined ? options.processLinesDefault : true;
            this.m_processPolygonsDefault =
                options.processPolygonsDefault !== undefined
                    ? options.processPolygonsDefault
                    : true;
        }
    }
    /**
     * Add a layer that should be processed.
     *
     * @param layer - Layer name to be matched.
     * @param match - Match condition.
     */
    processLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToProcess.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a layer that should be ignored.
     *
     * @param layer - Layer name to be matched.
     * @param match - Match condition.
     */
    ignoreLayer(layer, match = OmvDecoderDefs_1.OmvFilterString.StringMatch.Match, minLevel = 0, maxLevel = Infinity) {
        this.m_layersToIgnore.push({
            name: { value: layer, match },
            minLevel,
            maxLevel
        });
    }
    /**
     * Add a valid point feature.
     *
     * @param options - Feature options.
     */
    processPoint(options) {
        this.addItem(this.m_pointsToProcess, options);
    }
    /**
     * Add valid point features.
     *
     * @param options - Multi feature options.
     */
    processPoints(options) {
        this.addItems(this.m_pointsToProcess, options);
    }
    /**
     * Add a point feature that should be ignored.
     *
     * @param options - Feature options.
     */
    ignorePoint(options) {
        this.addItem(this.m_ignoredPoints, options);
    }
    /**
     * Add point features that should be ignored.
     *
     * @param options - Multi feature options.
     */
    ignorePoints(options) {
        this.addItems(this.m_ignoredPoints, options);
    }
    /**
     * Add a valid line feature.
     *
     * @param options - Feature options.
     */
    processLine(options) {
        this.addItem(this.m_linesToProcess, options);
    }
    /**
     * Add valid line features.
     *
     * @param options - Multi feature options.
     */
    processLines(options) {
        this.addItems(this.m_linesToProcess, options);
    }
    /**
     * Ignore a line feature.
     *
     * @param options - Feature options.
     */
    ignoreLine(options) {
        this.addItem(this.m_linesToIgnore, options);
    }
    /**
     * Ignore line features.
     *
     * @param options - Multi feature options.
     */
    ignoreLines(options) {
        this.addItems(this.m_linesToIgnore, options);
    }
    /**
     * Add a valid polygon feature.
     *
     * @param options - Feature options.
     */
    processPolygon(options) {
        this.addItem(this.m_polygonsToProcess, options);
    }
    /**
     * Add valid polygon features.
     *
     * @param options - Multi feature options.
     */
    processPolygons(options) {
        this.addItems(this.m_polygonsToProcess, options);
    }
    /**
     * Ignore a valid polygon feature.
     *
     * @param options - Feature options.
     */
    ignorePolygon(options) {
        this.addItem(this.m_polygonsToIgnore, options);
    }
    /**
     * Ignore polygon features.
     *
     * @param options - Multi feature options.
     */
    ignorePolygons(options) {
        this.addItems(this.m_polygonsToIgnore, options);
    }
    /**
     * Add all the specified strings as "enabledKinds".
     *
     * @param {string[]} enabledKinds List of kinds that should be generated.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    processKinds(enabledKinds) {
        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);
    }
    /**
     * Add all the specified strings as "disabledKinds".
     *
     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    ignoreKinds(disabledKinds) {
        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);
    }
    /**
     * Create a filter description that can be passed as an option to the [[OmvDataSource]].
     */
    createDescription() {
        return {
            processLayersDefault: this.m_processLayersDefault,
            processPointsDefault: this.m_processPointsDefault,
            processLinesDefault: this.m_processLinesDefault,
            processPolygonsDefault: this.m_processPolygonsDefault,
            layersToProcess: this.m_layersToProcess,
            layersToIgnore: this.m_layersToIgnore,
            pointsToProcess: this.m_pointsToProcess,
            pointsToIgnore: this.m_ignoredPoints,
            linesToProcess: this.m_linesToProcess,
            linesToIgnore: this.m_linesToIgnore,
            polygonsToProcess: this.m_polygonsToProcess,
            polygonsToIgnore: this.m_polygonsToIgnore,
            kindsToProcess: this.m_kindsToProcess,
            kindsToIgnore: this.m_kindsToIgnore
        };
    }
    addItem(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomType !== undefined
                ? Array.isArray(options.geomType)
                    ? options.geomType
                    : [options.geomType]
                : undefined,
            classes: [
                {
                    value: options.featureClass,
                    match: options.matchClass === undefined
                        ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                        : options.matchClass
                }
            ],
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
    addItems(items, options) {
        if (options.minLevel === undefined || isNaN(options.minLevel)) {
            options.minLevel = 0;
        }
        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {
            options.maxLevel = Infinity;
        }
        const item = {
            layerName: {
                value: options.layer,
                match: options.matchLayer === undefined
                    ? OmvDecoderDefs_1.OmvFilterString.StringMatch.Match
                    : options.matchLayer
            },
            geometryTypes: options.geomTypes !== undefined
                ? Array.isArray(options.geomTypes)
                    ? options.geomTypes
                    : [options.geomTypes]
                : undefined,
            classes: options.featureClasses,
            minLevel: options.minLevel,
            maxLevel: options.maxLevel,
            featureAttribute: options.featureAttribute
        };
        items.push(item);
    }
}
exports.OmvFeatureFilterDescriptionBuilder = OmvFeatureFilterDescriptionBuilder;
/**
 * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`
 * features before they are completely decoded.
 *
 * @internal
 */
class OmvGenericFeatureFilter {
    constructor(description) {
        this.description = description;
        if (this.description.kindsToProcess.length > 0) {
            this.enabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToProcess);
        }
        if (this.description.kindsToIgnore.length > 0) {
            this.disabledKinds = new harp_datasource_protocol_1.GeometryKindSet(this.description.kindsToIgnore);
        }
    }
    static matchLayer(layer, layerItems, level) {
        for (const layerItem of layerItems) {
            if (level < layerItem.minLevel || level > layerItem.maxLevel) {
                continue;
            }
            if (OmvDecoderDefs_1.OmvFilterString.matchString(layer, layerItem.name)) {
                return true;
            }
        }
        return false;
    }
    wantsLayer(layer, level) {
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {
            return true;
        }
        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {
            return false;
        }
        return this.description.processLayersDefault;
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, geometryType, level, this.description.processPointsDefault);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, geometryType, level, this.description.processLinesDefault);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.wantsFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, geometryType, level, this.description.processPolygonsDefault);
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    wantsKind(kind) {
        // undefined -> no way to filter
        if (kind === undefined) {
            return true;
        }
        return (!(this.disabledKinds !== undefined &&
            this.disabledKinds.hasOrIntersects(kind)) ||
            (this.enabledKinds !== undefined &&
                this.enabledKinds.hasOrIntersects(kind)));
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    get hasKindFilter() {
        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;
    }
    wantsFeature(itemsToProcess, itemsToIgnore, layer, geometryType, level, defaultResult) {
        for (const item of itemsToProcess) {
            if (level < item.minLevel || level > item.maxLevel) {
                continue;
            }
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {
                return true;
            }
        }
        for (const item of itemsToIgnore) {
            if (!OmvDecoderDefs_1.OmvFilterString.matchString(layer, item.layerName)) {
                // this rule is not for this layer
                continue;
            }
            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {
                return false;
            }
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureFilter = OmvGenericFeatureFilter;
/**
 * An [[OmvFeatureFilter]] implementation that delegates all filter decision
 * returning `true` for any predicate if all delegates return `true`.
 *
 * @internal
 */
class ComposedDataFilter {
    constructor(filters) {
        this.filters = filters;
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    get hasKindFilter() {
        return this.filters.reduce((result, filter) => result || filter.hasKindFilter, true);
    }
    wantsLayer(layer, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLayer(layer, level), true);
    }
    wantsPointFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPointFeature(layer, geometryType, level), true);
    }
    wantsLineFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsLineFeature(layer, geometryType, level), true);
    }
    wantsPolygonFeature(layer, geometryType, level) {
        return this.filters.reduce((result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level), true);
    }
    /**
     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.
     */
    wantsKind(kind) {
        return this.filters.reduce((result, filter) => result && filter.wantsKind(kind), true);
    }
}
exports.ComposedDataFilter = ComposedDataFilter;
/**
 * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter
 * `TileData` features before they are completely decoded.
 *
 * @internal
 */
class OmvGenericFeatureModifier {
    constructor(description) {
        this.description = description;
    }
    static matchItems(layerName, featureClass, items) {
        for (const item of items) {
            if (item.classes !== undefined) {
                if (!OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName)) {
                    continue;
                }
                for (const matchClass of item.classes) {
                    if (OmvDecoderDefs_1.OmvFilterString.matchString(featureClass, matchClass)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    static matchAttribute(layerName, env, items) {
        for (const item of items) {
            if (item.featureAttribute !== undefined) {
                if (OmvDecoderDefs_1.OmvFilterString.matchString(layerName, item.layerName) &&
                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value) {
                    return true;
                }
            }
        }
        return false;
    }
    doProcessPointFeature(layer, env) {
        return this.doProcessFeature(this.description.pointsToProcess, this.description.pointsToIgnore, layer, env, this.description.processPointsDefault);
    }
    doProcessLineFeature(layer, env) {
        return this.doProcessFeature(this.description.linesToProcess, this.description.linesToIgnore, layer, env, this.description.processLinesDefault);
    }
    doProcessPolygonFeature(layer, env) {
        return this.doProcessFeature(this.description.polygonsToProcess, this.description.polygonsToIgnore, layer, env, this.description.processPolygonsDefault);
    }
    doProcessFeature(itemsToProcess, itemsToIgnore, layer, env, defaultResult) {
        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {
            return defaultResult;
        }
        let featureClass;
        const featureClassThing = env.lookup("class");
        if (featureClassThing !== undefined && featureClassThing !== null) {
            featureClass = featureClassThing.toString();
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)) {
            return true;
        }
        if (featureClass &&
            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)) {
            return false;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {
            return true;
        }
        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {
            return false;
        }
        return defaultResult;
    }
}
exports.OmvGenericFeatureModifier = OmvGenericFeatureModifier;


/***/ }),

/***/ "../harp-vectortile-datasource/lib/OmvDebugLabelsTile.ts":
/*!***************************************************************!*\
  !*** ../harp-vectortile-datasource/lib/OmvDebugLabelsTile.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmvDebugLabelsTile = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const DebugContext_1 = __webpack_require__(/*! @here/harp-mapview/lib/DebugContext */ "../harp-mapview/lib/DebugContext.ts");
const TileGeometryCreator_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/TileGeometryCreator */ "../harp-mapview/lib/geometry/TileGeometryCreator.ts");
const TextElementType_1 = __webpack_require__(/*! @here/harp-mapview/lib/text/TextElementType */ "../harp-mapview/lib/text/TextElementType.ts");
const harp_text_canvas_1 = __webpack_require__(/*! @here/harp-text-canvas */ "../harp-text-canvas/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
const debugMaterial = new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 1,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugCircleMaterialWF = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterialWF.wireframe = true;
const debugCircleMaterial2WF = new THREE.MeshBasicMaterial({
    color: 0x8080ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
debugCircleMaterial2WF.wireframe = true;
const debugBlackCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    depthTest: false,
    depthFunc: THREE.NeverDepth
});
const debugBlueCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0x0000ff,
    depthTest: false,
    depthFunc: THREE.NeverDepth,
    opacity: 0.75,
    transparent: true
});
const debugOrangeCircleMaterial = new THREE.MeshBasicMaterial({
    color: 0xa07000,
    depthTest: false,
    depthFunc: THREE.NeverDepth,
    opacity: 0.75,
    transparent: true
});
const textRenderStyle = new harp_text_canvas_1.TextRenderStyle();
const textLayoutStyle = new harp_text_canvas_1.TextLayoutStyle();
textRenderStyle.fontSize = {
    unit: harp_text_canvas_1.FontUnit.Point,
    size: 9,
    backgroundSize: 0
};
textRenderStyle.opacity = 0.75;
textRenderStyle.backgroundOpacity = 0.75;
textRenderStyle.color = new THREE.Color(0.8, 0.2, 0.2);
// Set maximum priority.
const PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;
class DebugGeometry {
    constructor() {
        this.geometry = new THREE.BufferGeometry();
        this.indices = new Array();
        this.positions = new Array();
    }
}
function addPoint(xPos, yPos, zPos, size, debugGeometry) {
    debugGeometry.positions.push(xPos, yPos - size, zPos);
    debugGeometry.positions.push(xPos + size, yPos, zPos);
    debugGeometry.positions.push(xPos, yPos + size, zPos);
    debugGeometry.positions.push(xPos - size, yPos, zPos);
    const index = debugGeometry.positions.length / 3;
    debugGeometry.indices.push(index - 4);
    debugGeometry.indices.push(index - 3);
    debugGeometry.indices.push(index - 2);
    debugGeometry.indices.push(index - 4);
    debugGeometry.indices.push(index - 2);
    debugGeometry.indices.push(index - 1);
}
function addObject(objects, debugGeometry, priorityOffset = 0, factory) {
    if (debugGeometry.indices.length > 0) {
        debugGeometry.geometry.addGroup(0, debugGeometry.indices.length, 0);
        debugGeometry.geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(debugGeometry.positions), 3));
        debugGeometry.geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(debugGeometry.indices), 1));
        const mesh = factory(debugGeometry.geometry);
        mesh.renderOrder = PRIORITY_ALWAYS - priorityOffset;
        objects.push(mesh);
    }
}
class OmvDebugLabelsTile extends harp_mapview_1.Tile {
    constructor(dataSource, tileKey) {
        super(dataSource, tileKey);
    }
    /**
     * @override
     * Create [[TextElement]] objects for label debugging.
     */
    loadingFinished() {
        var _a, _b, _c;
        // activate in the browser with:
        // window.__debugContext.setValue("DEBUG_TEXT_PATHS", true)
        const debugTextPaths = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS");
        const debugTextPathsFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS_FULL");
        const debugTextPoisFull = DebugContext_1.debugContext.getValue("DEBUG_TEXT_POIS_FULL");
        const debugLineMarkers = DebugContext_1.debugContext.getValue("DEBUG_TEXT_LINE_MARKER");
        if (!(debugTextPaths || debugTextPathsFull || debugLineMarkers) ||
            this.decodedTile === undefined) {
            return;
        }
        const tileGeometryCreator = TileGeometryCreator_1.TileGeometryCreator.instance;
        const decodedTile = this.decodedTile;
        const colorMap = new Map();
        // allow limiting to specific names and/or index. There can be many paths with the
        // same text
        const textFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.TEXT");
        const indexFilter = DebugContext_1.debugContext.getValue("DEBUG_TEXT_PATHS.FILTER.INDEX");
        const env = this.mapView.env;
        if (decodedTile.textPathGeometries !== undefined) {
            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(decodedTile.textPathGeometries, decodedTile);
        }
        const centerX = this.center.x;
        const centerY = this.center.y;
        const centerZ = this.center.z;
        const pointScale = this.mapView.pixelToWorld;
        const worldOffsetX = this.computeWorldOffsetX();
        const zHeight = 10;
        let pointLabelIndex = 0;
        if (this.textElementGroups.count() > 0) {
            const bluePoints = new DebugGeometry();
            const orangePoints = new DebugGeometry();
            const addedTextElements = [];
            this.textElementGroups.forEach((textElement) => {
                if (textElement.type !== TextElementType_1.TextElementType.LineMarker &&
                    textElement.type !== TextElementType_1.TextElementType.PoiLabel) {
                    return;
                }
                const isLineMarker = textElement.type === TextElementType_1.TextElementType.LineMarker;
                const geometry = isLineMarker ? orangePoints : bluePoints;
                const pointSize = pointScale * 5;
                const addLabel = (x, y, z) => {
                    addPoint(x, y, z, pointSize, geometry);
                    if (debugTextPoisFull || debugLineMarkers) {
                        const offsetXY = pointSize * 0.5;
                        const label = `${textElement.text} [${pointLabelIndex}]`;
                        const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX + offsetXY, y + centerY + offsetXY, z + centerZ), textRenderStyle, textLayoutStyle, PRIORITY_ALWAYS, 0.0, 0.0);
                        labelElement.minZoomLevel = 0;
                        labelElement.mayOverlap = true;
                        labelElement.reserveSpace = false;
                        labelElement.alwaysOnTop = true;
                        labelElement.ignoreDistance = true;
                        labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;
                        labelElement._isDebug = true;
                        addedTextElements.push(labelElement);
                    }
                    pointLabelIndex++;
                };
                if (textElement.path !== undefined && Array.isArray(textElement.path)) {
                    for (let i = 0; i < textElement.path.length; i++) {
                        const pos = textElement.path[i];
                        const x = pos.x - centerX;
                        const y = pos.y - centerY;
                        const z = zHeight + pos.z + i * 5 - centerZ;
                        addLabel(x, y, z);
                    }
                }
                else if (debugTextPoisFull) {
                    const x = textElement.position.x - centerX;
                    const y = textElement.position.y - centerY;
                    const z = 5 - centerZ;
                    addLabel(x, y, z);
                }
            });
            for (const labelElement of addedTextElements) {
                this.addTextElement(labelElement);
            }
            addObject(this.objects, bluePoints, 0, (geometry) => {
                return new THREE.Mesh(geometry, debugBlueCircleMaterial);
            });
            addObject(this.objects, orangePoints, 0, (geometry) => {
                return new THREE.Mesh(geometry, debugOrangeCircleMaterial);
            });
        }
        if (this.preparedTextPaths !== undefined) {
            const lines = new DebugGeometry();
            const redPoints = new DebugGeometry();
            const blackPoints = new DebugGeometry();
            let baseVertex = 0;
            for (const textPath of this.preparedTextPaths) {
                const technique = decodedTile.techniques[textPath.technique];
                if (!harp_datasource_protocol_1.isTextTechnique(technique) || textPath._isDebug !== undefined) {
                    continue;
                }
                if (technique.color !== undefined) {
                    colorMap.set(textPath.technique, new THREE.Color(harp_datasource_protocol_1.getPropertyValue(technique.color, env)));
                }
                baseVertex = lines.positions.length / 3;
                const text = textPath.text;
                const elementIndex = this.preparedTextPaths.indexOf(textPath);
                const createDebugInfo = (!textFilter || (text && text.includes(textFilter))) &&
                    (indexFilter === undefined || indexFilter === elementIndex);
                if (createDebugInfo) {
                    for (let i = 0; i < textPath.path.length; i += 3) {
                        const pathIndex = i / 3;
                        const x = textPath.path[i] - centerX;
                        const y = textPath.path[i + 1] - centerY;
                        // raise it a bit, so we get identify connectivity visually by tilting
                        const z = zHeight + textPath.path[i + 2] + i / 3 - centerZ;
                        if (debugTextPaths) {
                            lines.positions.push(x, y, z);
                        }
                        const isRedPoint = i === 0 && debugTextPaths;
                        if (debugTextPathsFull || isRedPoint) {
                            const pointSize = pointScale * (isRedPoint ? 6 : 4);
                            const geometry = isRedPoint ? redPoints : blackPoints;
                            addPoint(x, y, z, pointSize, geometry);
                            if (debugTextPathsFull) {
                                const xOffset = (_a = technique.xOffset) !== null && _a !== void 0 ? _a : 0.0;
                                const yOffset = (_b = technique.yOffset) !== null && _b !== void 0 ? _b : 0.0;
                                const minZoomLevel = technique.minZoomLevel;
                                // give point index a label
                                const label = pathIndex % 5 === 0
                                    ? text + ":" + pathIndex
                                    : Number(pathIndex).toString();
                                const labelElement = new harp_mapview_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x + worldOffsetX + centerX, y + centerY, z + centerZ), textRenderStyle, textLayoutStyle, harp_datasource_protocol_1.getPropertyValue((_c = technique.priority) !== null && _c !== void 0 ? _c : 0, env), xOffset, yOffset);
                                labelElement.minZoomLevel = harp_datasource_protocol_1.getPropertyValue(minZoomLevel, env);
                                labelElement.mayOverlap = true;
                                labelElement.reserveSpace = false;
                                labelElement.alwaysOnTop = true;
                                labelElement.ignoreDistance = true;
                                labelElement.priority = harp_mapview_1.TextElement.HIGHEST_PRIORITY;
                                this.addTextElement(labelElement);
                            }
                        }
                    }
                    // the lines of a path share a common geometry
                    const N = textPath.path.length / 3;
                    for (let i = 0; i < N; ++i) {
                        if (i > 0) {
                            lines.indices.push(baseVertex + i);
                        }
                        if (i + 1 < N) {
                            lines.indices.push(baseVertex + i);
                        }
                    }
                }
            }
            addObject(this.objects, lines, -2, (geometry) => {
                return new THREE.LineSegments(geometry, debugMaterial);
            });
            addObject(this.objects, redPoints, 0, (geometry) => {
                return new THREE.Mesh(geometry, debugCircleMaterial);
            });
            addObject(this.objects, blackPoints, -1, (geometry) => {
                return new THREE.Mesh(geometry, debugBlackCircleMaterial);
            });
        }
    }
}
exports.OmvDebugLabelsTile = OmvDebugLabelsTile;


/***/ }),

/***/ "../harp-vectortile-datasource/lib/OmvDecoderDefs.ts":
/*!***********************************************************!*\
  !*** ../harp-vectortile-datasource/lib/OmvDecoderDefs.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GEOJSON_TILER_SERVICE_TYPE = exports.VECTOR_TILE_DECODER_SERVICE_TYPE = exports.OmvGeometryType = exports.OmvFilterString = exports.FeatureModifierId = void 0;
/**
 * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.
 */
var FeatureModifierId;
(function (FeatureModifierId) {
    /**
     * Generic feature modifier used when no other modifiers are defined.
     *
     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default
     * if no other feature modifier is used.
     */
    FeatureModifierId[FeatureModifierId["default"] = 0] = "default";
})(FeatureModifierId = exports.FeatureModifierId || (exports.FeatureModifierId = {}));
/**
 * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.
 */
var OmvFilterString;
(function (OmvFilterString) {
    /**
     * Match condition.
     */
    let StringMatch;
    (function (StringMatch) {
        /** Matches any. */
        StringMatch[StringMatch["Any"] = 0] = "Any";
        /** Exact match. */
        StringMatch[StringMatch["Match"] = 1] = "Match";
        /** Matches if a test string starts with a filter string. */
        StringMatch[StringMatch["StartsWith"] = 2] = "StartsWith";
        /** Matches if a test string contains a filter string. */
        StringMatch[StringMatch["Contains"] = 3] = "Contains";
        /** Matches if a test string ends with a filter string. */
        StringMatch[StringMatch["EndsWith"] = 4] = "EndsWith";
    })(StringMatch = OmvFilterString.StringMatch || (OmvFilterString.StringMatch = {}));
    /**
     * Check for a string against a filter.
     *
     * @param str - The string to check against a filter.
     * @param filterString - The filter containing the match condition.
     * @returns `true` if the match condition is satisfied.
     *
     * @internal
     */
    function matchString(str, filterString) {
        switch (filterString.match) {
            case OmvFilterString.StringMatch.Any:
                return true;
            case OmvFilterString.StringMatch.Match:
                return str === filterString.value;
            case OmvFilterString.StringMatch.StartsWith:
                return filterString.value.startsWith(str);
            case OmvFilterString.StringMatch.EndsWith:
                return filterString.value.endsWith(str);
            default:
                return str.includes(filterString.value);
        }
    }
    OmvFilterString.matchString = matchString;
})(OmvFilterString = exports.OmvFilterString || (exports.OmvFilterString = {}));
var OmvGeometryType;
(function (OmvGeometryType) {
    OmvGeometryType[OmvGeometryType["UNKNOWN"] = 0] = "UNKNOWN";
    OmvGeometryType[OmvGeometryType["POINT"] = 1] = "POINT";
    OmvGeometryType[OmvGeometryType["LINESTRING"] = 2] = "LINESTRING";
    OmvGeometryType[OmvGeometryType["POLYGON"] = 3] = "POLYGON";
})(OmvGeometryType = exports.OmvGeometryType || (exports.OmvGeometryType = {}));
/**
 * Vector tile decoder service type id.
 *
 * @remarks
 * Used for requesting decoder services using `WorkerServiceManager`.
 *
 * @internal
 */
exports.VECTOR_TILE_DECODER_SERVICE_TYPE = "vector-tile-decoder";
/**
 * GeoJson tiler service type id.
 *
 * @remarks
 * Used for requesting tiler services using `WorkerServiceManager`.
 *
 * @internal
 */
exports.GEOJSON_TILER_SERVICE_TYPE = "geojson-tiler";


/***/ }),

/***/ "../harp-vectortile-datasource/lib/OmvRestClient.ts":
/*!**********************************************************!*\
  !*** ../harp-vectortile-datasource/lib/OmvRestClient.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmvRestClient = exports.AuthenticationTypeAccessToken = exports.AuthenticationTypeTomTomV1 = exports.AuthenticationTypeBearer = exports.AuthenticationMethod = exports.APIFormat = void 0;
__webpack_require__(/*! @here/harp-fetch */ "../harp-fetch/index.web.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const harp_transfer_manager_1 = __webpack_require__(/*! @here/harp-transfer-manager */ "../harp-transfer-manager/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const logger = harp_utils_1.LoggerManager.instance.create("OmvRestClient");
var APIFormat;
(function (APIFormat) {
    /**
     * Use the REST API format of HERE Vector Tiles Server component version 1.
     *
     * @remarks
     * Documentation:
     *  https://developer.here.com/documentation/vector-tiles-api/dev_guide/index.html
     *
     * Usage:
     *
     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv
     *
     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:
     *
     *     Authorization: Bearer $authenticationToken
     *
     * Format definition:
     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`
     *
     * Default authentication method used: [[AuthenticationTypeBearer]].
     */
    APIFormat[APIFormat["HereV1"] = 0] = "HereV1";
    /**
     * Use the REST API format of Mapbox Vector Tile API v4.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`
     *
     * Sample URL:
     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["MapboxV4"] = 1] = "MapboxV4";
    /**
     * Use the REST API format of XYZ Vector Tile API in MVT format.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZMVT"] = 2] = "XYZMVT";
    /**
     * Use the REST API format of XYZ Vector Tile API in JSON format.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZJson"] = 3] = "XYZJson";
    /**
     * Use the REST API format of XYZ Vector Tile API in OMV format.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZOMV"] = 4] = "XYZOMV";
    /**
     * Use the REST API format of Tomtoms Vector Tile API v1.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`
     *
     * Sample URL:
     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`
     *
     * Default authentication method used: [[AuthenticationTypeTomTomV1]].
     */
    APIFormat[APIFormat["TomtomV1"] = 5] = "TomtomV1";
    /**
     * Use the REST API format of XYZ Space Vector Tile API in OMV format.
     *
     * @remarks
     * Usage:
     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`
     *
     * Format definition:
     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`
     *
     * Sample URL:
     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`
     *
     * Default authentication method used: [[AuthenticationTypeAccessToken]].
     */
    APIFormat[APIFormat["XYZSpace"] = 6] = "XYZSpace";
})(APIFormat = exports.APIFormat || (exports.APIFormat = {}));
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod[AuthenticationMethod["QueryString"] = 0] = "QueryString";
    AuthenticationMethod[AuthenticationMethod["AuthorizationHeader"] = 1] = "AuthorizationHeader";
})(AuthenticationMethod = exports.AuthenticationMethod || (exports.AuthenticationMethod = {}));
/**
 * Authentication method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeBearer = {
    method: AuthenticationMethod.AuthorizationHeader,
    name: "Bearer"
};
/**
 * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:
 *
 *    Authorization: Bearer $authenticationToken
 */
exports.AuthenticationTypeTomTomV1 = {
    method: AuthenticationMethod.QueryString,
    name: "key"
};
exports.AuthenticationTypeAccessToken = {
    method: AuthenticationMethod.QueryString,
    name: "access_token"
};
/**
 * REST client supporting getting protobuf OMV Tile from REST-based servers.
 */
class OmvRestClient extends harp_mapview_decoder_1.DataProvider {
    constructor(params) {
        super();
        this.params = params;
        this.downloadManager =
            params.downloadManager === undefined
                ? harp_transfer_manager_1.TransferManager.instance()
                : params.downloadManager;
        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;
    }
    /** Overriding abstract method, in this case doing nothing. */
    async connect() {
        // not needed
    }
    /** Overriding abstract method, in this case always returning `true`. */
    ready() {
        return true;
    }
    /**
     * Asynchronously fetches a tile from this restful server.
     *
     * @remarks
     * **Note:** In case of an HTTP Error, rejected promise is returned
     * with an error.
     *
     * @example
     * ```typescript
     * const response = layer.getTile(tileKey);
     * if (!response.ok) {
     *     // a network error happened
     *     console.error("Unable to download tile", response.statusText);
     *     return;
     * }
     *
     * // the response is ok and contains data, access it e.g. as arrayBuffer:
     * const payload = await response.arrayBuffer();
     * ```
     *
     * @param tileKey - The tile key of the tile.
     * @param tileRequestInit - Optional request options to be passed to fetch when downloading a
     * tile.
     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.
     */
    async getTile(tileKey, abortSignal) {
        const init = { signal: abortSignal };
        let tileUrl = this.dataUrl(tileKey);
        const authenticationCode = await this.getActualAuthenticationCode();
        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);
        tileUrl = this.addQueryParams(tileUrl, this.urlParams);
        if (this.params.apiFormat === APIFormat.XYZJson) {
            return await this.downloadManager.downloadJson(tileUrl, init);
        }
        return await this.downloadManager.downloadArrayBuffer(tileUrl, init);
    }
    /**
     * Destroys this `OmvRestClient`.
     */
    dispose() {
        // to be overloaded by subclasses
    }
    /**
     * Get actual authentication code/token for this request according to configuration.
     */
    async getActualAuthenticationCode() {
        if (typeof this.params.authenticationCode === "string") {
            return this.params.authenticationCode;
        }
        else if (this.params.authenticationCode !== undefined) {
            return await this.params.authenticationCode();
        }
        else if (this.params.getBearerToken !== undefined) {
            return await this.params.getBearerToken();
        }
        else {
            return undefined;
        }
    }
    /**
     * Get default authentication method basing on apiFormat and other params.
     */
    getDefaultAuthMethod() {
        if (this.params.getBearerToken !== undefined) {
            return exports.AuthenticationTypeBearer;
        }
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
                return exports.AuthenticationTypeBearer;
            case APIFormat.MapboxV4:
            case APIFormat.XYZOMV:
            case APIFormat.XYZMVT:
            case APIFormat.XYZSpace:
            case APIFormat.XYZJson:
                return exports.AuthenticationTypeAccessToken;
            case APIFormat.TomtomV1:
                return exports.AuthenticationTypeTomTomV1;
            default:
                logger.warn(`#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`);
                return undefined;
        }
    }
    /**
     * Apply authentication code/token using configured (or default) authentication method.
     *
     * @param url -
     * @param init - request extra data
     * @param authenticationCode - authentication/token to be applied
     * @return new url to be used
     */
    applyAuthCode(url, init, authenticationCode) {
        var _a, _b, _c;
        if (authenticationCode === undefined) {
            return url;
        }
        const authMethod = (_a = this.params.authenticationMethod) !== null && _a !== void 0 ? _a : this.getDefaultAuthMethod();
        if (authMethod === undefined) {
            return url;
        }
        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {
            if (init.headers === undefined) {
                init.headers = new Headers();
            }
            const authType = (_b = authMethod.name) !== null && _b !== void 0 ? _b : "Bearer";
            init.headers.append("Authorization", `${authType} ${authenticationCode}`);
        }
        else if (authMethod.method === AuthenticationMethod.QueryString) {
            const attrName = (_c = authMethod.name) !== null && _c !== void 0 ? _c : "access_token";
            const authParams = {};
            authParams[attrName] = authenticationCode;
            url = this.addQueryParams(url, authParams);
        }
        return url;
    }
    /**
     * Get actual tile URL depending on configured API format.
     */
    dataUrl(tileKey) {
        if (this.params.url !== undefined) {
            return this.params.url
                .replace("{x}", String(tileKey.column))
                .replace("{y}", String(tileKey.row))
                .replace("{z}", String(tileKey.level));
        }
        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(this.params.apiFormat === APIFormat.XYZSpace ||
            this.params.apiFormat === APIFormat.XYZJson
            ? "_"
            : "/");
        switch (this.params.apiFormat) {
            case APIFormat.HereV1:
            case APIFormat.XYZOMV:
                path += "/omv";
                break;
            case APIFormat.MapboxV4:
                path += ".mvt";
                break;
            case APIFormat.XYZMVT:
                path += ".mvt";
                break;
            case APIFormat.XYZJson:
                break;
            case APIFormat.XYZSpace:
                path += ".mvt";
                break;
            case APIFormat.TomtomV1:
                path += ".pbf";
                break;
            default:
                logger.warn(`Not supported API format: ${this.params.apiFormat}`);
                break;
        }
        return this.params.baseUrl + path;
    }
    addQueryParams(url, queryParams) {
        let queryString = "";
        let sep = url.includes("?") ? "&" : "?";
        for (const prop in queryParams) {
            if (!queryParams.hasOwnProperty(prop)) {
                continue;
            }
            queryString += `${sep}${encodeURIComponent(prop)}=${encodeURIComponent(queryParams[prop])}`;
            if (sep === "?") {
                sep = "&";
            }
        }
        return url + queryString;
    }
}
exports.OmvRestClient = OmvRestClient;


/***/ }),

/***/ "../harp-vectortile-datasource/lib/VectorTileDataSource.ts":
/*!*****************************************************************!*\
  !*** ../harp-vectortile-datasource/lib/VectorTileDataSource.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VectorTileDataSource = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = __webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts");
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_mapview_decoder_1 = __webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const OmvDecoderDefs_1 = __webpack_require__(/*! ./OmvDecoderDefs */ "../harp-vectortile-datasource/lib/OmvDecoderDefs.ts");
const OmvRestClient_1 = __webpack_require__(/*! ./OmvRestClient */ "../harp-vectortile-datasource/lib/OmvRestClient.ts");
const logger = harp_utils_1.LoggerManager.instance.create("VectorTileDataSource");
/**
 * A helper function to retrieve the [[DataProvider]] from the
 * {@link VectorTileDataSource}s parameters.
 *
 * @param params - The parameters passed into the OmvDataSource.
 */
function getDataProvider(params) {
    var _a;
    if (params.dataProvider) {
        return params.dataProvider;
    }
    else if ((_a = params.baseUrl) !== null && _a !== void 0 ? _a : params.url) {
        return new OmvRestClient_1.OmvRestClient(params);
    }
    else {
        throw new Error("OmvDataSource: missing url, baseUrl or dataProvider params");
    }
}
let missingOmvDecoderServiceInfoEmitted = false;
/**
 * The default vector tile service.
 */
const hereVectorTileBaseUrl = "https://vector.hereapi.com/v2/vectortiles/base/mc";
/**
 * Default options for the HERE Vector Tile service.
 */
const hereVectorTileDefaultOptions = {
    baseUrl: hereVectorTileBaseUrl,
    apiFormat: OmvRestClient_1.APIFormat.XYZOMV,
    styleSetName: "tilezen",
    authenticationMethod: {
        method: OmvRestClient_1.AuthenticationMethod.QueryString,
        name: "apikey"
    },
    copyrightInfo: [
        {
            id: "here.com",
            year: new Date().getFullYear(),
            label: "HERE",
            link: "https://legal.here.com/terms"
        }
    ]
};
const defaultOptions = new Map([
    [hereVectorTileBaseUrl, hereVectorTileDefaultOptions]
]);
/**
 * Tests if the given object has custom data provider.
 * @param object -
 */
function hasCustomDataProvider(object) {
    return object.dataProvider !== undefined;
}
/**
 * Add service specific default values.
 *
 * @param params - The configuration settings of the data source.
 */
function completeDataSourceParameters(params) {
    var _a;
    if (!hasCustomDataProvider(params) && params.url === undefined) {
        const baseUrl = (_a = params.baseUrl) !== null && _a !== void 0 ? _a : hereVectorTileBaseUrl;
        const completedParams = Object.assign(Object.assign({}, defaultOptions.get(baseUrl)), params);
        return Object.assign(Object.assign({}, completedParams), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: new OmvRestClient_1.OmvRestClient(completedParams) });
    }
    return Object.assign(Object.assign({}, params), { tilingScheme: harp_geoutils_1.webMercatorTilingScheme, dataProvider: getDataProvider(params) });
}
/**
 * `VectorTileDataSource` is used for the visualization of vector tiles.
 *
 * @example
 * ```typescript
 *    const dataSource = new VectorTileDataSource({
 *        baseUrl: "https://vector.hereapi.com/v2/vectortiles/base/mc",
 *        authenticationCode: apikey
 *    });
 *    mapView.addDataSource(dataSource);
 *   ```
 */
class VectorTileDataSource extends harp_mapview_decoder_1.TileDataSource {
    constructor(m_params) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super((_a = m_params.tileFactory) !== null && _a !== void 0 ? _a : new harp_mapview_decoder_1.TileFactory(harp_mapview_1.Tile), Object.assign({ styleSetName: (_b = m_params.styleSetName) !== null && _b !== void 0 ? _b : "omv", concurrentDecoderServiceName: (_c = m_params.concurrentDecoderServiceName) !== null && _c !== void 0 ? _c : OmvDecoderDefs_1.VECTOR_TILE_DECODER_SERVICE_TYPE, minDataLevel: (_d = m_params.minDataLevel) !== null && _d !== void 0 ? _d : 1, maxDataLevel: (_e = m_params.maxDataLevel) !== null && _e !== void 0 ? _e : 17, storageLevelOffset: (_f = m_params.storageLevelOffset) !== null && _f !== void 0 ? _f : -1 }, completeDataSourceParameters(m_params)));
        this.m_params = m_params;
        this.cacheable = true;
        this.addGroundPlane =
            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;
        let roundUpCoordinatesIfNeeded = m_params.roundUpCoordinatesIfNeeded;
        if (roundUpCoordinatesIfNeeded === undefined &&
            ((_g = m_params) === null || _g === void 0 ? void 0 : _g.baseUrl) === hereVectorTileBaseUrl) {
            roundUpCoordinatesIfNeeded = true;
        }
        this.m_decoderOptions = {
            showMissingTechniques: this.m_params.showMissingTechniques === true,
            filterDescription: this.m_params.filterDescr,
            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,
            featureModifiers: this.m_params.featureModifierId
                ? [this.m_params.featureModifierId]
                : undefined,
            politicalView: this.m_params.politicalView,
            skipShortLabels: this.m_params.skipShortLabels,
            storageLevelOffset: (_h = m_params.storageLevelOffset) !== null && _h !== void 0 ? _h : -1,
            enableElevationOverlay: this.m_params.enableElevationOverlay === true,
            roundUpCoordinatesIfNeeded
        };
        this.maxGeometryHeight = harp_utils_1.getOptionValue(m_params.maxGeometryHeight, harp_geoutils_1.EarthConstants.MAX_BUILDING_HEIGHT);
        this.minGeometryHeight = harp_utils_1.getOptionValue(m_params.minGeometryHeight, 0);
    }
    /** @override */
    async connect() {
        try {
            await super.connect();
        }
        catch (error) {
            // error is a string if the promise was rejected.
            if (error.message &&
                harp_datasource_protocol_1.WorkerServiceProtocol.isUnknownServiceError(error) &&
                !missingOmvDecoderServiceInfoEmitted) {
                logger.info("Unable to create decoder service in worker. Use " +
                    " 'OmvTileDecoderService.start();' in decoder script.");
                missingOmvDecoderServiceInfoEmitted = true;
            }
            throw typeof error === "string" ? new Error(error) : error;
        }
        this.configureDecoder(undefined, this.m_decoderOptions);
    }
    /**
     * Remove the current data filter.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     */
    removeDataFilter() {
        this.configureDecoder(undefined, {
            filterDescription: null
        });
    }
    /**
     * Set a new data filter. Can also be done during
     * the creation of an {@link VectorTileDataSource}.
     * Will be applied to the decoder, which might be shared with other omv datasources.
     *
     * @param filterDescription - Data filter description created with
     * [[OmvFeatureFilterDescriptionBuilder]].
     */
    setDataFilter(filterDescription) {
        this.m_decoderOptions.filterDescription =
            filterDescription !== null ? filterDescription : undefined;
        this.configureDecoder(undefined, {
            filterDescription,
            featureModifiers: this.m_decoderOptions.featureModifiers,
            politicalView: this.m_decoderOptions.politicalView
        });
    }
    /** @override */
    shouldPreloadTiles() {
        return true;
    }
    /** @override */
    setPoliticalView(politicalView) {
        // Just in case users mess with letters' casing.
        politicalView = politicalView === null || politicalView === void 0 ? void 0 : politicalView.toLowerCase();
        if (this.m_decoderOptions.politicalView !== politicalView) {
            this.m_decoderOptions.politicalView = politicalView;
            this.configureDecoder(undefined, {
                filterDescription: this.m_decoderOptions.filterDescription,
                featureModifiers: this.m_decoderOptions.featureModifiers,
                politicalView: politicalView !== undefined ? politicalView : ""
            });
        }
    }
    /** @override */
    get storageLevelOffset() {
        return super.storageLevelOffset;
    }
    /** @override */
    set storageLevelOffset(levelOffset) {
        super.storageLevelOffset = levelOffset;
        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;
        this.configureDecoder(undefined, {
            storageLevelOffset: this.storageLevelOffset
        });
    }
    /** @override */
    setEnableElevationOverlay(enable) {
        if (this.m_decoderOptions.enableElevationOverlay !== enable) {
            this.m_decoderOptions.enableElevationOverlay = enable;
            this.configureDecoder(undefined, {
                enableElevationOverlay: enable
            });
        }
    }
    configureDecoder(options, customOptions) {
        this.clearCache();
        this.decoder.configure(options, customOptions);
        this.mapView.markTilesDirty(this);
    }
}
exports.VectorTileDataSource = VectorTileDataSource;


/***/ }),

/***/ "../harp-webtile-datasource/index.ts":
/*!*******************************************!*\
  !*** ../harp-webtile-datasource/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * HERE WebTile Data source.
 *
 * @remarks
 *
 * @packageDocumentation
 */
__exportStar(__webpack_require__(/*! ./lib/WebTileDataSource */ "../harp-webtile-datasource/lib/WebTileDataSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./lib/HereWebTileDataSource */ "../harp-webtile-datasource/lib/HereWebTileDataSource.ts"), exports);


/***/ }),

/***/ "../harp-webtile-datasource/lib/HereWebTileDataSource.ts":
/*!***************************************************************!*\
  !*** ../harp-webtile-datasource/lib/HereWebTileDataSource.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HereWebTileDataSource = exports.HereTileProvider = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const WebTileDataSource_1 = __webpack_require__(/*! ./WebTileDataSource */ "../harp-webtile-datasource/lib/WebTileDataSource.ts");
const textureLoader = new harp_mapview_1.TextureLoader();
/**
 * Mapping from ISO-639-1 language codes to codes used by HERE Map Tile API (MARC)
 *
 * @see https://developer.here.com/documentation/map-tile/topics/resource-base-maptile.html
 * @see [MARC Code List for Languages](https://www.loc.gov/marc/languages/)
 */
const WEBTILE_LANGUAGE_DICTIONARY = {
    eu: "baq",
    ca: "cat",
    zh: "chi",
    cs: "cze",
    da: "dan",
    nl: "dut",
    en: "eng",
    fi: "fin",
    fr: "fre",
    de: "ger",
    ga: "gle",
    el: "gre",
    he: "heb",
    hi: "hin",
    id: "ind",
    it: "ita",
    no: "nor",
    fa: "per",
    pl: "pol",
    pt: "por",
    ru: "rus",
    si: "sin",
    es: "spa",
    sv: "swe",
    th: "tha",
    tr: "tur",
    uk: "ukr",
    ur: "urd",
    vi: "vie",
    cy: "wel"
};
class HereTileProvider {
    constructor(m_options) {
        var _a, _b;
        this.m_options = m_options;
        /** Predefined fixed HERE copyright info. */
        this.HERE_COPYRIGHT_INFO = {
            id: "here.com",
            year: new Date().getFullYear(),
            label: "HERE",
            link: "https://legal.here.com/terms"
        };
        this.m_ppi = harp_utils_1.getOptionValue(m_options.ppi, WebTileDataSource_1.WebTileDataSource.ppiValue.ppi72);
        this.m_resolution = harp_utils_1.getOptionValue(m_options.resolution, WebTileDataSource_1.WebTileDataSource.resolutionValue.resolution512);
        this.m_tileBaseAddress = (_a = m_options.tileBaseAddress) !== null && _a !== void 0 ? _a : HereTileProvider.TILE_BASE_NORMAL;
        if (this.m_tileBaseAddress === HereTileProvider.TILE_AERIAL_SATELLITE &&
            this.m_ppi !== WebTileDataSource_1.WebTileDataSource.ppiValue.ppi72) {
            throw new Error("Requested combination of scheme satellite.day and ppi is not valid");
        }
        const mapTileParams = this.parseBaseUrl(this.m_tileBaseAddress);
        const baseHostName = mapTileParams.baseUrl;
        const mapId = harp_utils_1.getOptionValue(mapTileParams.mapVersion, "newest");
        const scheme = (_b = mapTileParams.scheme) !== null && _b !== void 0 ? _b : "normal.day";
        const baseScheme = scheme.split(".")[0] || "normal";
        const url = `https://1.${baseHostName}/maptile/2.1/copyright/${mapId}` +
            `${this.getCopyrightRequestParams()}`;
        this.m_copyrightProvider = new harp_mapview_1.UrlCopyrightProvider(url, baseScheme);
    }
    /** @override */
    async getTexture(tile, abortSignal) {
        const column = tile.tileKey.column;
        const row = tile.tileKey.row;
        const level = tile.tileKey.level;
        const quadKey = tile.tileKey.toQuadKey();
        const server = parseInt(quadKey[quadKey.length - 1], 10) + 1;
        const url = `https://${server}.${this.m_tileBaseAddress}/` +
            `${level}/${column}/${row}/${this.m_resolution}/png8` +
            `${this.getImageRequestParams()}`;
        return await this.getRequestHeaders().then(headers => {
            return Promise.all([
                textureLoader.load(url, headers, abortSignal),
                this.getTileCopyright(tile, headers, abortSignal)
            ]);
        });
    }
    mapIsoLanguageToWebTile(languages) {
        this.m_languages = [];
        for (const language of languages) {
            if (WEBTILE_LANGUAGE_DICTIONARY[language] !== undefined) {
                this.m_languages.push(WEBTILE_LANGUAGE_DICTIONARY[language]);
            }
        }
    }
    async getRequestHeaders() {
        const { authenticationCode } = this.m_options;
        let token;
        if (typeof authenticationCode === "string") {
            token = authenticationCode;
        }
        else if (authenticationCode !== undefined) {
            token = await authenticationCode();
        }
        if (token !== undefined) {
            return {
                Authorization: `Bearer ${token}`
            };
        }
        return undefined;
    }
    async getTileCopyright(tile, requestHeaders, abortSignal) {
        if (this.m_options.gatherCopyrightInfo === false) {
            return [this.HERE_COPYRIGHT_INFO];
        }
        this.m_copyrightProvider.setRequestHeaders(requestHeaders);
        return await this.m_copyrightProvider.getCopyrights(tile.geoBox, tile.tileKey.level);
    }
    parseBaseUrl(url) {
        const parsed = new URL(url.startsWith("https:") ? url : `https://${url}`);
        const fullPath = parsed.pathname;
        const maptilePathRegexp = new RegExp("^(/maptile/2.1/)([^/]+)/([^/]+)/([^/]+)");
        const match = fullPath.match(maptilePathRegexp);
        if (!match) {
            throw new Error(`HereWebTileDataSource: invalid baseUrl: ${url}`);
        }
        return {
            baseUrl: parsed.host,
            path: match[1],
            tileType: match[2],
            mapVersion: match[3],
            scheme: match[4]
        };
    }
    getAuthParams() {
        const { apikey } = this.m_options;
        const { appId, appCode } = this.m_options;
        const { authenticationCode } = this.m_options;
        const useAuthenticationCode = authenticationCode !== undefined;
        const useApiKey = apikey !== undefined;
        const useAppId = appId !== undefined && appCode !== undefined;
        if (useAuthenticationCode) {
            return [];
        }
        else if (useApiKey) {
            return [`apikey=${apikey}`];
        }
        else if (useAppId) {
            return [`app_id=${appId}`, `app_code=${appCode}`];
        }
        throw new Error("Neither apiKey, appId/appCode nor authenticationCode are defined.");
    }
    getCopyrightRequestParams() {
        const requestParams = ["output=json", ...this.getAuthParams()];
        return `?${requestParams.join("&")}`;
    }
    getImageRequestParams() {
        const requestParams = this.getAuthParams();
        if (this.m_options.additionalRequestParameters !== undefined) {
            requestParams.push(this.m_options.additionalRequestParameters);
        }
        if (this.m_ppi !== WebTileDataSource_1.WebTileDataSource.ppiValue.ppi72) {
            // because ppi=72 is default, we do not include it in the request
            requestParams.push(`ppi=${this.m_ppi}`);
        }
        if (this.m_languages !== undefined && this.m_languages[0] !== undefined) {
            requestParams.push(`lg=${this.m_languages[0]}`);
        }
        if (this.m_languages !== undefined && this.m_languages[1] !== undefined) {
            requestParams.push(`lg2=${this.m_languages[1]}`);
        }
        if (requestParams.length > 0) {
            return `?${requestParams.join("&")}`;
        }
        return "";
    }
}
exports.HereTileProvider = HereTileProvider;
/**
 * Base address for Base Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-normal-day-view.html
 */
HereTileProvider.TILE_BASE_NORMAL = "base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day";
/**
 * Base address for Aerial Map rendered using `hybrid.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-hybrid-map.html
 */
HereTileProvider.TILE_AERIAL_HYBRID = "aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/hybrid.day";
/**
 * Base address for Aerial Map rendered using `satellite.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-satellite-map.html
 */
HereTileProvider.TILE_AERIAL_SATELLITE = "aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day";
/**
 * Base address for Traffic Map rendered using `normal.day` scheme.
 * @see https://developer.here.com/documentation/map-tile/topics/example-traffic.html
 */
HereTileProvider.TILE_TRAFFIC_NORMAL = "traffic.maps.ls.hereapi.com/maptile/2.1/traffictile/newest/normal.day";
/**
 * Instances of `HereWebTileDataSource` can be used to add Web Tile to [[MapView]].
 *
 * Example:
 *
 * ```typescript
 * const hereWebTileDataSource = new HereWebTileDataSource({
 *     authenticationCode: <authenticationCode>
 * });
 * ```
 * @see [[DataSource]], [[OmvDataSource]].
 */
class HereWebTileDataSource extends WebTileDataSource_1.WebTileDataSource {
    /**
     * Constructs a new `HereWebTileDataSource`.
     *
     * @param m_options - Represents the [[HereWebTileDataSourceParameters]].
     */
    constructor(m_options) {
        var _a;
        super(Object.assign(Object.assign({}, m_options), { minDataLevel: 1, maxDataLevel: 20, resolution: m_options.resolution, dataProvider: new HereTileProvider(m_options), storageLevelOffset: (_a = m_options.storageLevelOffset) !== null && _a !== void 0 ? _a : -1 }));
        this.cacheable = true;
        if (this.resolution === WebTileDataSource_1.WebTileDataSource.resolutionValue.resolution512) {
            this.maxDataLevel = 19; // 512x512 tiles do not have z19
        }
    }
    /** @override */
    setLanguages(languages) {
        if (languages !== undefined) {
            this.dataProvider.mapIsoLanguageToWebTile(languages);
            this.mapView.markTilesDirty(this);
        }
    }
}
exports.HereWebTileDataSource = HereWebTileDataSource;


/***/ }),

/***/ "../harp-webtile-datasource/lib/WebTileDataSource.ts":
/*!***********************************************************!*\
  !*** ../harp-webtile-datasource/lib/WebTileDataSource.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebTileDataSource = void 0;
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = __webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts");
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
const WebTileLoader_1 = __webpack_require__(/*! ./WebTileLoader */ "../harp-webtile-datasource/lib/WebTileLoader.ts");
/**
 * Instances of `WebTileDataSource` can be used to add Web Tile to [[MapView]].
 *
 * Example:
 *
 * ```typescript
 * const webTileDataSource = new WebTileDataSource({
 *     dataProvider: {
 *         getTexture: <your custom implementation>
 *     }
 * });
 * ```
 * @see {@links DataSource}
 */
class WebTileDataSource extends harp_mapview_1.DataSource {
    /**
     * Constructs a new `WebTileDataSource`.
     *
     * @param m_options - Represents the [[WebTileDataSourceParameters]].
     */
    constructor(m_options) {
        var _a, _b, _c, _d, _e;
        super(m_options);
        this.m_options = m_options;
        this.m_opacity = 1;
        this.m_renderOrder = 0;
        this.m_transparent = false;
        this.dataProvider = this.m_options.dataProvider;
        this.cacheable = true;
        this.m_opacity = (_b = (_a = this.m_options.renderingOptions) === null || _a === void 0 ? void 0 : _a.opacity) !== null && _b !== void 0 ? _b : 1;
        this.m_transparent =
            ((_c = this.m_options.renderingOptions) === null || _c === void 0 ? void 0 : _c.transparent) === true || this.m_opacity < 1;
        this.m_renderOrder = (_e = (_d = this.m_options.renderingOptions) === null || _d === void 0 ? void 0 : _d.renderOrder) !== null && _e !== void 0 ? _e : 0;
        this.m_resolution = harp_utils_1.getOptionValue(m_options.resolution, WebTileDataSource.resolutionValue.resolution512);
    }
    /**
     * Sets the opacity for the WebTileDataSource, will only affect not yet loaded or not cached
     * tiles.
     *
     * Use WebTileDataSource:clearCache and MapView:markTilesDirty to reload all tiles with the
     * new opacity setting.
     */
    set opacity(value) {
        var _a;
        this.m_opacity = value;
        if (this.m_opacity < 1) {
            this.m_transparent = true;
        }
        else if (((_a = this.m_options.renderingOptions) === null || _a === void 0 ? void 0 : _a.transparent) !== true) {
            this.m_transparent = false;
        }
    }
    /**
     * Gets the opacity of the WebTileDataSource.
     */
    get opacity() {
        return this.m_opacity;
    }
    get resolution() {
        return this.m_resolution;
    }
    /**
     * Gets the renderOrder of the WebTileDataSource.
     *
     * @deprecated Use instead the `dataSourceOrder` on {@link DataSource}
     */
    get renderOrder() {
        return this.m_renderOrder;
    }
    /**
     * Gets whether tiles of this WebTileDataSource are transparent.
     */
    get transparent() {
        return this.m_transparent;
    }
    /** @override */
    shouldPreloadTiles() {
        return true;
    }
    /** @override */
    getTilingScheme() {
        return harp_geoutils_1.webMercatorTilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new harp_mapview_1.Tile(this, tileKey);
        tile.tileLoader = new WebTileLoader_1.WebTileLoader(this, tile, this.dataProvider);
        return tile;
    }
    /** @override */
    isFullyCovering() {
        return true;
    }
}
exports.WebTileDataSource = WebTileDataSource;
/**
 * Definitions of variable values to be used with `WebTileDataSource`
 */
(function (WebTileDataSource) {
    let ppiValue;
    (function (ppiValue) {
        ppiValue[ppiValue["ppi72"] = 72] = "ppi72";
        ppiValue[ppiValue["ppi250"] = 250] = "ppi250";
        ppiValue[ppiValue["ppi320"] = 320] = "ppi320";
        ppiValue[ppiValue["ppi500"] = 500] = "ppi500";
    })(ppiValue = WebTileDataSource.ppiValue || (WebTileDataSource.ppiValue = {}));
    let resolutionValue;
    (function (resolutionValue) {
        resolutionValue[resolutionValue["resolution256"] = 256] = "resolution256";
        resolutionValue[resolutionValue["resolution512"] = 512] = "resolution512";
    })(resolutionValue = WebTileDataSource.resolutionValue || (WebTileDataSource.resolutionValue = {}));
})(WebTileDataSource = exports.WebTileDataSource || (exports.WebTileDataSource = {}));


/***/ }),

/***/ "../harp-webtile-datasource/lib/WebTileLoader.ts":
/*!*******************************************************!*\
  !*** ../harp-webtile-datasource/lib/WebTileLoader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebTileLoader = void 0;
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const AddGroundPlane_1 = __webpack_require__(/*! @here/harp-mapview/lib/geometry/AddGroundPlane */ "../harp-mapview/lib/geometry/AddGroundPlane.ts");
const harp_materials_1 = __webpack_require__(/*! @here/harp-materials */ "../harp-materials/index.ts");
const THREE = __webpack_require__(/*! three */ "three");
/**
 * TileLoader used by `WebTileDataSource`.
 */
class WebTileLoader extends harp_mapview_1.BaseTileLoader {
    /**
     * Set up loading of a single [[Tile]].
     *
     * @param dataSource - The [[DataSource]] the tile belongs to.
     * @param tileKey - The quadtree address of a [[Tile]].
     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.
     */
    constructor(dataSource, tile, dataProvider) {
        super(dataSource, tile.tileKey);
        this.dataSource = dataSource;
        this.tile = tile;
        this.dataProvider = dataProvider;
    }
    /**
     * @override
     */
    loadImpl(abortSignal, onDone, onError) {
        this.dataProvider
            .getTexture(this.tile, abortSignal)
            .then(value => {
            if (value === undefined || value[0] === undefined) {
                this.tile.forceHasGeometry(true);
                onDone(harp_mapview_1.TileLoaderState.Ready);
                return;
            }
            const [texture, copyrightInfo] = value;
            if (copyrightInfo !== undefined) {
                this.tile.copyrightInfo = copyrightInfo;
            }
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            // This is required because the WebTileDataSource uses the default setting of
            // useGeometryLoader on the DataSource, so it has to clear the tile's objects
            // manually.
            this.tile.clear();
            this.tile.addOwnedTexture(texture);
            const planeMesh = AddGroundPlane_1.addGroundPlane(this.tile, this.dataSource.renderOrder, 0xffffff, this.dataSource.opacity, true);
            const planeMaterial = planeMesh.material;
            planeMaterial.map = texture;
            if (this.dataSource.transparent) {
                harp_materials_1.enableBlending(planeMaterial);
            }
            planeMaterial.depthTest = false;
            this.tile.invalidateResourceInfo();
            this.dataSource.requestUpdate();
            onDone(harp_mapview_1.TileLoaderState.Ready);
        }, onError)
            .catch(onError);
    }
}
exports.WebTileLoader = WebTileLoader;


/***/ }),

/***/ "./lib/BundleMain.ts":
/*!***************************!*\
  !*** ./lib/BundleMain.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapBundleMain = exports.BundledUriResolver = exports.getScriptUrl = exports.getBundleScriptUrl = exports.BUNDLE_SCRIPT_BASENAME = exports.DEFAULT_DECODER_SCRIPT_URL = void 0;
const harp_mapview_1 = __webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts");
const WorkerLoader_1 = __webpack_require__(/*! @here/harp-mapview/lib/workers/WorkerLoader */ "../harp-mapview/lib/workers/WorkerLoader.ts");
const harp_utils_1 = __webpack_require__(/*! @here/harp-utils */ "../harp-utils/index.ts");
/**
 * Default decoder url for bundled map component.
 */
exports.DEFAULT_DECODER_SCRIPT_URL = "harp.js-bundle://harp-decoders.js";
/**
 * Basename of map bundle script - used by [[getBundleScriptUrl]] as fallback, when
 * `document.currentScript` is not present.
 *
 * @hidden
 */
exports.BUNDLE_SCRIPT_BASENAME = "harp";
/**
 * Guess `harp(.min).js` script URL.
 *
 * Required to find default URLs `harp-decoders.js` which are hosted together, not necessarily with
 * base URL of current page.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript
 * @hidden
 */
function getBundleScriptUrl() {
    if (bundleScriptUrl !== undefined) {
        return bundleScriptUrl;
    }
    const currentScript = document.currentScript;
    const baseScriptUrl = currentScript !== null &&
        typeof currentScript.src === "string" &&
        (currentScript.src.endsWith(exports.BUNDLE_SCRIPT_BASENAME + ".js") ||
            currentScript.src.endsWith(exports.BUNDLE_SCRIPT_BASENAME + ".min.js"))
        ? currentScript.src
        : getScriptUrl(exports.BUNDLE_SCRIPT_BASENAME);
    if (baseScriptUrl) {
        bundleScriptUrl = baseScriptUrl;
        return bundleScriptUrl;
    }
    else {
        bundleScriptUrl = null;
        return undefined;
    }
}
exports.getBundleScriptUrl = getBundleScriptUrl;
/**
 * Memoizes result of [[getBundleScriptUrl]].
 * @hidden
 */
let bundleScriptUrl;
/**
 * Get script URL assumet it's already loaded in DOM.
 *
 * Required to find default URLs `harp.(min.)js` and `three().min).js` which are required to
 * properly start decoder bundle.
 *
 * @see https://stackoverflow.com/questions/2976651
 * @hidden
 */
function getScriptUrl(name) {
    var _a, _b, _c;
    const scriptElement = (_c = (_b = (_a = document.querySelector(`script[src*='/${name}.min.js']`)) !== null && _a !== void 0 ? _a : document.querySelector(`script[src='${name}.min.js']`)) !== null && _b !== void 0 ? _b : document.querySelector(`script[src*='/${name}.js']`)) !== null && _c !== void 0 ? _c : document.querySelector(`script[src='${name}.js']`);
    if (scriptElement) {
        return scriptElement.src;
    }
    else {
        return undefined;
    }
}
exports.getScriptUrl = getScriptUrl;
const HARP_GL_BUNDLED_ASSETS_PREFIX = "harp.js-bundle://";
/**
 * Resolve URLs with support for `harp.gl` bundle specific URLs.
 *
 * URLs with prefix `harp.gl:` are resolved relatively to `harp.js` bundle's base URL.
 *
 * @hidden
 */
class BundledUriResolver {
    resolveUri(uri) {
        if (uri.startsWith(HARP_GL_BUNDLED_ASSETS_PREFIX)) {
            const bundleSriptUrl = getBundleScriptUrl();
            if (bundleSriptUrl === null || bundleSriptUrl === undefined) {
                throw new Error(`harp.js: cannot resolve ${uri} because 'harp.gl' base url is not set.`);
            }
            else {
                uri = uri.substring(HARP_GL_BUNDLED_ASSETS_PREFIX.length);
                if (uri.startsWith("/")) {
                    uri = uri.substring(1);
                }
                return harp_utils_1.baseUrl(bundleSriptUrl) + uri;
            }
        }
        return uri;
    }
}
exports.BundledUriResolver = BundledUriResolver;
const bundledUriResolver = new BundledUriResolver();
const getActualDecoderScriptUrl = () => {
    const baseScriptUrl = getBundleScriptUrl();
    if (!baseScriptUrl) {
        // eslint-disable-next-line no-console
        console.error(`harp.js: Unable to determine default location of 'harp-decoders(min).js'. ` +
            `See https://github.com/heremaps/harp.gl/@here/harp.gl.`);
    }
    if (!WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three) {
        // eslint-disable-next-line no-console
        console.error(`harp.js: Unable to determine location of 'three(.min).js'. ` +
            "`See https://github.com/heremaps/harp.gl/@here/harp.gl.`");
    }
    const isMinified = baseScriptUrl && baseScriptUrl.endsWith(".min.js");
    const decoderScriptName = !isMinified
        ? exports.DEFAULT_DECODER_SCRIPT_URL
        : exports.DEFAULT_DECODER_SCRIPT_URL.replace(/\.js$/, ".min.js");
    return bundledUriResolver.resolveUri(decoderScriptName);
};
/**
 * Guess decoder script URL.
 *
 * Assumes that decoder script - `harp-decoders.js` is in same place as main bundle and calculates
 * it's URL.
 *
 * Minified version of `harp.js` bundle loads minified version of decoder.
 * Hooks in [[ConcurrentDecoderFacade]] to use this URL as default `defaultScriptUrl`.
 *
 * @hidden
 */
function installDefaultDecoderUrlHook() {
    harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = "";
    harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = "";
    const threeUrl = getScriptUrl("three");
    WorkerLoader_1.WorkerLoader.dependencyUrlMapping.three = threeUrl;
    const oldDecoderGetWorkerSet = harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet;
    harp_mapview_1.ConcurrentDecoderFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentDecoderFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldDecoderGetWorkerSet.apply(harp_mapview_1.ConcurrentDecoderFacade, [scriptUrl]);
    };
    const oldTilerGetWorkerSet = harp_mapview_1.ConcurrentTilerFacade.getWorkerSet;
    harp_mapview_1.ConcurrentTilerFacade.getWorkerSet = (scriptUrl) => {
        if (scriptUrl === undefined && harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl === "") {
            const newScriptUrl = getActualDecoderScriptUrl();
            harp_mapview_1.ConcurrentTilerFacade.defaultScriptUrl = newScriptUrl;
        }
        return oldTilerGetWorkerSet.apply(harp_mapview_1.ConcurrentTilerFacade, [scriptUrl]);
    };
}
/**
 * Initialize `harp.gl` bundle.
 *
 * Install specific default decoder urls into [[ConcurrentDecoderFacade]].
 * @hidden
 */
function mapBundleMain() {
    getBundleScriptUrl();
    installDefaultDecoderUrlHook();
}
exports.mapBundleMain = mapBundleMain;


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const BundleMain_1 = __webpack_require__(/*! ./BundleMain */ "./lib/BundleMain.ts");
if (!window.THREE) {
    // eslint-disable-next-line no-console
    console.warn("harp.js: It looks like 'three.js' is not loaded. This script requires 'THREE' object to " +
        "be defined. See https://github.com/heremaps/harp.gl/@here/harp.gl.");
}
__exportStar(__webpack_require__(/*! @here/harp-mapview */ "../harp-mapview/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-vectortile-datasource */ "../harp-vectortile-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-omv-datasource */ "../harp-omv-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-debug-datasource */ "../harp-debug-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-geojson-datasource */ "../harp-geojson-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-features-datasource */ "../harp-features-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-webtile-datasource */ "../harp-webtile-datasource/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-map-controls/lib/MapControls */ "../harp-map-controls/lib/MapControls.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-map-controls/lib/MapControlsUI */ "../harp-map-controls/lib/MapControlsUI.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-datasource-protocol */ "../harp-datasource-protocol/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-geoutils */ "../harp-geoutils/index.ts"), exports);
__exportStar(__webpack_require__(/*! @here/harp-mapview-decoder */ "../harp-mapview-decoder/index.ts"), exports);
BundleMain_1.mapBundleMain();


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = THREE;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./lib/index.ts");
/******/ })()
;
//# sourceMappingURL=harp.js.map